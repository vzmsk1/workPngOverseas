/*! For license information please see main3d0a7a2df2b3e40babbd.js.LICENSE.txt */
(() => {
    var t = {
            "./src/js/planet.js": (t, e, n) => {
                "use strict";
                n.r(e);
                var r = n("./node_modules/three/build/three.module.js"),
                    i = n("./node_modules/three-globe/dist/three-globe.mjs"),
                    a = n("./node_modules/three/examples/jsm/controls/TrackballControls.js"),
                    o = n("./node_modules/three/examples/jsm/controls/OrbitControls.js"),
                    s = n("./node_modules/three/examples/jsm/renderers/CSS2DRenderer.js");
                const l = ["Russia", "Belarus"];
                document.addEventListener("DOMContentLoaded", (function() {
                    document.getElementById("globeViz") && fetch("./ne_110m_admin_0_countries.geojson").then((t => t.json())).then((t => {
                        const e = new i.default({
                                waitForGlobeReady: !0,
                                animateIn: !0
                            }).showAtmosphere(!0).ringColor((() => u)).ringMaxRadius("maxR").ringPropagationSpeed("propagationSpeed").ringAltitude(.004).polygonAltitude(.0035).ringRepeatPeriod("repeatPeriod").polygonsData(t.features.filter((t => "AQ" !== t.properties.ISO_A2))).polygonCapColor((() => "#422f7e")).polygonSideColor((() => "#6f6295")).polygonStrokeColor((() => "#7f77ce")),
                            n = [];
                        fetch("./capitals.geojson").then((t => t.json())).then((t => {
                            t.features.forEach((t => {
                                l.includes(t.properties.country) || n.push({
                                    country: t.properties.country,
                                    lat: t.geometry.coordinates[0],
                                    lng: t.geometry.coordinates[1]
                                })
                            }));
                            let r = n.map((t => ({
                                ...t,
                                maxR: 3,
                                propagationSpeed: 3,
                                repeatPeriod: 300
                            }))) || [];
                            e.ringsData(r)
                        }));
                        const s = new r.WebGLRenderer;
                        s.setSize(A, c), document.getElementById("globeViz").appendChild(s.domElement);
                        const h = new r.Scene;
                        h.add(e), h.add(new r.AmbientLight(13421772, Math.PI)), h.add(new r.DirectionalLight(16777215, .6 * Math.PI));
                        const d = new r.PerspectiveCamera;
                        d.aspect = A / c, d.updateProjectionMatrix(), d.position.z = 500;
                        const f = new a.TrackballControls(d, s.domElement);
                        f.minDistance = 201, f.rotateSpeed = 5, f.zoomSpeed = .8;
                        const p = new o.OrbitControls(d, s.domElement);
                        p.enableDamping = !0, p.dynamicDampingFactor = .01, p.enablePan = !1, p.minDistance = 275, p.maxDistance = 275, p.rotateSpeed = .8, p.zoomSpeed = 1, p.autoRotate = !1, p.minPolarAngle = Math.PI / 3.3, p.maxPolarAngle = Math.PI - Math.PI / 1.5,
                            function t() {
                                e.rotation.y += .008, p.update(), f.update(), s.render(h, d), requestAnimationFrame(t)
                            }()
                    }))
                }));
                const A = 930,
                    c = 770;
                Object.assign(r, {
                    TrackballControls: a.TrackballControls,
                    CSS2DRenderer: s.CSS2DRenderer
                });
                const u = t => `rgba(173,255,0,${1-t+.5})`
            },
            "./node_modules/earcut/src/earcut.js": t => {
                "use strict";

                function e(t, e, r) {
                    r = r || 2;
                    var a, o, s, l, u, h, f, p = e && e.length,
                        m = p ? e[0] * r : t.length,
                        g = n(t, 0, m, r, !0),
                        v = [];
                    if (!g || g.next === g.prev) return v;
                    if (p && (g = function(t, e, r, i) {
                            var a, o, s, l = [];
                            for (a = 0, o = e.length; a < o; a++)(s = n(t, e[a] * i, a < o - 1 ? e[a + 1] * i : t.length, i, !1)) === s.next && (s.steiner = !0), l.push(d(s));
                            for (l.sort(A), a = 0; a < l.length; a++) r = c(l[a], r);
                            return r
                        }(t, e, g, r)), t.length > 80 * r) {
                        a = s = t[0], o = l = t[1];
                        for (var _ = r; _ < m; _ += r)(u = t[_]) < a && (a = u), (h = t[_ + 1]) < o && (o = h), u > s && (s = u), h > l && (l = h);
                        f = 0 !== (f = Math.max(s - a, l - o)) ? 32767 / f : 0
                    }
                    return i(g, v, r, a, o, f, 0), v
                }

                function n(t, e, n, r, i) {
                    var a, o;
                    if (i === E(t, e, n, r) > 0)
                        for (a = e; a < n; a += r) o = M(a, t[a], t[a + 1], o);
                    else
                        for (a = n - r; a >= e; a -= r) o = M(a, t[a], t[a + 1], o);
                    return o && g(o, o.next) && (w(o), o = o.next), o
                }

                function r(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    var n, r = t;
                    do {
                        if (n = !1, r.steiner || !g(r, r.next) && 0 !== m(r.prev, r, r.next)) r = r.next;
                        else {
                            if (w(r), (r = e = r.prev) === r.next) break;
                            n = !0
                        }
                    } while (n || r !== e);
                    return e
                }

                function i(t, e, n, A, c, u, d) {
                    if (t) {
                        !d && u && function(t, e, n, r) {
                            var i = t;
                            do {
                                0 === i.z && (i.z = h(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                            } while (i !== t);
                            i.prevZ.nextZ = null, i.prevZ = null,
                                function(t) {
                                    var e, n, r, i, a, o, s, l, A = 1;
                                    do {
                                        for (n = t, t = null, a = null, o = 0; n;) {
                                            for (o++, r = n, s = 0, e = 0; e < A && (s++, r = r.nextZ); e++);
                                            for (l = A; s > 0 || l > 0 && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;
                                            n = r
                                        }
                                        a.nextZ = null, A *= 2
                                    } while (o > 1)
                                }(i)
                        }(t, A, c, u);
                        for (var f, p, m = t; t.prev !== t.next;)
                            if (f = t.prev, p = t.next, u ? o(t, A, c, u) : a(t)) e.push(f.i / n | 0), e.push(t.i / n | 0), e.push(p.i / n | 0), w(t), t = p.next, m = p.next;
                            else if ((t = p) === m) {
                            d ? 1 === d ? i(t = s(r(t), e, n), e, n, A, c, u, 2) : 2 === d && l(t, e, n, A, c, u) : i(r(t), e, n, A, c, u, 1);
                            break
                        }
                    }
                }

                function a(t) {
                    var e = t.prev,
                        n = t,
                        r = t.next;
                    if (m(e, n, r) >= 0) return !1;
                    for (var i = e.x, a = n.x, o = r.x, s = e.y, l = n.y, A = r.y, c = i < a ? i < o ? i : o : a < o ? a : o, u = s < l ? s < A ? s : A : l < A ? l : A, h = i > a ? i > o ? i : o : a > o ? a : o, d = s > l ? s > A ? s : A : l > A ? l : A, p = r.next; p !== e;) {
                        if (p.x >= c && p.x <= h && p.y >= u && p.y <= d && f(i, s, a, l, o, A, p.x, p.y) && m(p.prev, p, p.next) >= 0) return !1;
                        p = p.next
                    }
                    return !0
                }

                function o(t, e, n, r) {
                    var i = t.prev,
                        a = t,
                        o = t.next;
                    if (m(i, a, o) >= 0) return !1;
                    for (var s = i.x, l = a.x, A = o.x, c = i.y, u = a.y, d = o.y, p = s < l ? s < A ? s : A : l < A ? l : A, g = c < u ? c < d ? c : d : u < d ? u : d, v = s > l ? s > A ? s : A : l > A ? l : A, _ = c > u ? c > d ? c : d : u > d ? u : d, y = h(p, g, e, n, r), x = h(v, _, e, n, r), b = t.prevZ, M = t.nextZ; b && b.z >= y && M && M.z <= x;) {
                        if (b.x >= p && b.x <= v && b.y >= g && b.y <= _ && b !== i && b !== o && f(s, c, l, u, A, d, b.x, b.y) && m(b.prev, b, b.next) >= 0) return !1;
                        if (b = b.prevZ, M.x >= p && M.x <= v && M.y >= g && M.y <= _ && M !== i && M !== o && f(s, c, l, u, A, d, M.x, M.y) && m(M.prev, M, M.next) >= 0) return !1;
                        M = M.nextZ
                    }
                    for (; b && b.z >= y;) {
                        if (b.x >= p && b.x <= v && b.y >= g && b.y <= _ && b !== i && b !== o && f(s, c, l, u, A, d, b.x, b.y) && m(b.prev, b, b.next) >= 0) return !1;
                        b = b.prevZ
                    }
                    for (; M && M.z <= x;) {
                        if (M.x >= p && M.x <= v && M.y >= g && M.y <= _ && M !== i && M !== o && f(s, c, l, u, A, d, M.x, M.y) && m(M.prev, M, M.next) >= 0) return !1;
                        M = M.nextZ
                    }
                    return !0
                }

                function s(t, e, n) {
                    var i = t;
                    do {
                        var a = i.prev,
                            o = i.next.next;
                        !g(a, o) && v(a, i, i.next, o) && x(a, o) && x(o, a) && (e.push(a.i / n | 0), e.push(i.i / n | 0), e.push(o.i / n | 0), w(i), w(i.next), i = t = o), i = i.next
                    } while (i !== t);
                    return r(i)
                }

                function l(t, e, n, a, o, s) {
                    var l = t;
                    do {
                        for (var A = l.next.next; A !== l.prev;) {
                            if (l.i !== A.i && p(l, A)) {
                                var c = b(l, A);
                                return l = r(l, l.next), c = r(c, c.next), i(l, e, n, a, o, s, 0), void i(c, e, n, a, o, s, 0)
                            }
                            A = A.next
                        }
                        l = l.next
                    } while (l !== t)
                }

                function A(t, e) {
                    return t.x - e.x
                }

                function c(t, e) {
                    var n = function(t, e) {
                        var n, r = e,
                            i = t.x,
                            a = t.y,
                            o = -1 / 0;
                        do {
                            if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                                var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                if (s <= i && s > o && (o = s, n = r.x < r.next.x ? r : r.next, s === i)) return n
                            }
                            r = r.next
                        } while (r !== e);
                        if (!n) return null;
                        var l, A = n,
                            c = n.x,
                            h = n.y,
                            d = 1 / 0;
                        r = n;
                        do {
                            i >= r.x && r.x >= c && i !== r.x && f(a < h ? i : o, a, c, h, a < h ? o : i, a, r.x, r.y) && (l = Math.abs(a - r.y) / (i - r.x), x(r, t) && (l < d || l === d && (r.x > n.x || r.x === n.x && u(n, r))) && (n = r, d = l)), r = r.next
                        } while (r !== A);
                        return n
                    }(t, e);
                    if (!n) return e;
                    var i = b(n, t);
                    return r(i, i.next), r(n, n.next)
                }

                function u(t, e) {
                    return m(t.prev, t, e.prev) < 0 && m(e.next, t, t.next) < 0
                }

                function h(t, e, n, r, i) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }

                function d(t) {
                    var e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function f(t, e, n, r, i, a, o, s) {
                    return (i - o) * (e - s) >= (t - o) * (a - s) && (t - o) * (r - s) >= (n - o) * (e - s) && (n - o) * (a - s) >= (i - o) * (r - s)
                }

                function p(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        var n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && v(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (x(t, e) && x(e, t) && function(t, e) {
                        var n = t,
                            r = !1,
                            i = (t.x + e.x) / 2,
                            a = (t.y + e.y) / 2;
                        do {
                            n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                        } while (n !== t);
                        return r
                    }(t, e) && (m(t.prev, t, e.prev) || m(t, e.prev, e)) || g(t, e) && m(t.prev, t, t.next) > 0 && m(e.prev, e, e.next) > 0)
                }

                function m(t, e, n) {
                    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                }

                function g(t, e) {
                    return t.x === e.x && t.y === e.y
                }

                function v(t, e, n, r) {
                    var i = y(m(t, e, n)),
                        a = y(m(t, e, r)),
                        o = y(m(n, r, t)),
                        s = y(m(n, r, e));
                    return i !== a && o !== s || !(0 !== i || !_(t, n, e)) || !(0 !== a || !_(t, r, e)) || !(0 !== o || !_(n, t, r)) || !(0 !== s || !_(n, e, r))
                }

                function _(t, e, n) {
                    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                }

                function y(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }

                function x(t, e) {
                    return m(t.prev, t, t.next) < 0 ? m(t, e, t.next) >= 0 && m(t, t.prev, e) >= 0 : m(t, e, t.prev) < 0 || m(t, t.next, e) < 0
                }

                function b(t, e) {
                    var n = new S(t.i, t.x, t.y),
                        r = new S(e.i, e.x, e.y),
                        i = t.next,
                        a = e.prev;
                    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r
                }

                function M(t, e, n, r) {
                    var i = new S(t, e, n);
                    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
                }

                function w(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }

                function S(t, e, n) {
                    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }

                function E(t, e, n, r) {
                    for (var i = 0, a = e, o = n - r; a < n; a += r) i += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
                    return i
                }
                t.exports = e, t.exports.default = e, e.deviation = function(t, e, n, r) {
                    var i = e && e.length,
                        a = i ? e[0] * n : t.length,
                        o = Math.abs(E(t, 0, a, n));
                    if (i)
                        for (var s = 0, l = e.length; s < l; s++) {
                            var A = e[s] * n,
                                c = s < l - 1 ? e[s + 1] * n : t.length;
                            o -= Math.abs(E(t, A, c, n))
                        }
                    var u = 0;
                    for (s = 0; s < r.length; s += 3) {
                        var h = r[s] * n,
                            d = r[s + 1] * n,
                            f = r[s + 2] * n;
                        u += Math.abs((t[h] - t[f]) * (t[d + 1] - t[h + 1]) - (t[h] - t[d]) * (t[f + 1] - t[h + 1]))
                    }
                    return 0 === o && 0 === u ? 0 : Math.abs((u - o) / o)
                }, e.flatten = function(t) {
                    for (var e = t[0][0].length, n = {
                            vertices: [],
                            holes: [],
                            dimensions: e
                        }, r = 0, i = 0; i < t.length; i++) {
                        for (var a = 0; a < t[i].length; a++)
                            for (var o = 0; o < e; o++) n.vertices.push(t[i][a][o]);
                        i > 0 && (r += t[i - 1].length, n.holes.push(r))
                    }
                    return n
                }
            },
            "./node_modules/frame-ticker/dist/FrameTicker.js": function(t) {
                t.exports = function(t) {
                    function e(r) {
                        if (n[r]) return n[r].exports;
                        var i = n[r] = {
                            exports: {},
                            id: r,
                            loaded: !1
                        };
                        return t[r].call(i.exports, i, i.exports, e), i.loaded = !0, i.exports
                    }
                    var n = {};
                    return e.m = t, e.c = n, e.p = "", e(0)
                }([function(t, e, n) {
                    "use strict";
                    var r = n(1),
                        i = function() {
                            function t(t, e, n) {
                                void 0 === t && (t = NaN), void 0 === e && (e = NaN), void 0 === n && (n = !1), this._minFPS = e, this._maxFPS = t, this._timeScale = 1, this._currentTick = 0, this._currentTime = 0, this._tickDeltaTime = 0, this._isRunning = !1, this._maxInterval = isNaN(this._minFPS) ? NaN : 1e3 / this._minFPS, this._minInterval = isNaN(this._maxFPS) ? NaN : 1e3 / this._maxFPS, this._onResume = new r.default, this._onPause = new r.default, this._onTick = new r.default, this._onTickOncePerFrame = new r.default, n || this.resume()
                            }
                            return t.prototype.updateOnce = function(t) {
                                t(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick)
                            }, t.prototype.resume = function() {
                                this._isRunning || (this._isRunning = !0, this._lastTimeUpdated = this.getTimer(), this._onResume.dispatch(), this.animateOnce())
                            }, t.prototype.pause = function() {
                                this._isRunning && (this._isRunning = !1, this._onPause.dispatch(), window.cancelAnimationFrame(this._animationFrameHandle))
                            }, t.prototype.dispose = function() {
                                this.pause(), this._onResume.removeAll(), this._onPause.removeAll(), this._onTick.removeAll()
                            }, Object.defineProperty(t.prototype, "currentTick", {
                                get: function() {
                                    return this._currentTick
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "currentTimeSeconds", {
                                get: function() {
                                    return this._currentTime / 1e3
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "tickDeltaTimeSeconds", {
                                get: function() {
                                    return this._tickDeltaTime / 1e3
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "timeScale", {
                                get: function() {
                                    return this._timeScale
                                },
                                set: function(t) {
                                    this._timeScale !== t && (this._timeScale = t)
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "onResume", {
                                get: function() {
                                    return this._onResume
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "onPause", {
                                get: function() {
                                    return this._onPause
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "onTick", {
                                get: function() {
                                    return this._onTick
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "onTickOncePerFrame", {
                                get: function() {
                                    return this._onTickOncePerFrame
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "isRunning", {
                                get: function() {
                                    return this._isRunning
                                },
                                enumerable: !0,
                                configurable: !0
                            }), t.prototype.animateOnce = function() {
                                var t = this;
                                this._animationFrameHandle = window.requestAnimationFrame((function() {
                                    return t.onFrame()
                                }))
                            }, t.prototype.onFrame = function() {
                                if (this._now = this.getTimer(), this._frameDeltaTime = this._now - this._lastTimeUpdated, isNaN(this._minInterval) || this._frameDeltaTime >= this._minInterval)
                                    if (isNaN(this._maxInterval)) this.update(this._frameDeltaTime * this._timeScale, !0), this._lastTimeUpdated = this._now;
                                    else
                                        for (this._interval = Math.min(this._frameDeltaTime, this._maxInterval); this._now >= this._lastTimeUpdated + this._interval;) this.update(this._interval * this._timeScale, this._now <= this._lastTimeUpdated + 2 * this._maxInterval), this._lastTimeUpdated += this._interval;
                                this._isRunning && this.animateOnce()
                            }, t.prototype.update = function(t, e) {
                                void 0 === e && (e = !0), this._currentTick++, this._currentTime += t, this._tickDeltaTime = t, this._onTick.dispatch(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick), e && this._onTickOncePerFrame.dispatch(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick)
                            }, t.prototype.getTimer = function() {
                                return Date.now()
                            }, t
                        }();
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e.default = i
                }, function(t, e, n) {
                    t.exports = function(t) {
                        function e(r) {
                            if (n[r]) return n[r].exports;
                            var i = n[r] = {
                                exports: {},
                                id: r,
                                loaded: !1
                            };
                            return t[r].call(i.exports, i, i.exports, e), i.loaded = !0, i.exports
                        }
                        var n = {};
                        return e.m = t, e.c = n, e.p = "", e(0)
                    }([function(t, e) {
                        "use strict";
                        var n = function() {
                            function t() {
                                this.functions = []
                            }
                            return t.prototype.add = function(t) {
                                return -1 === this.functions.indexOf(t) && (this.functions.push(t), !0)
                            }, t.prototype.remove = function(t) {
                                var e = this.functions.indexOf(t);
                                return e > -1 && (this.functions.splice(e, 1), !0)
                            }, t.prototype.removeAll = function() {
                                return this.functions.length > 0 && (this.functions.length = 0, !0)
                            }, t.prototype.dispatch = function() {
                                for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                                this.functions.concat().forEach((function(e) {
                                    e.apply(void 0, t)
                                }))
                            }, Object.defineProperty(t.prototype, "numItems", {
                                get: function() {
                                    return this.functions.length
                                },
                                enumerable: !0,
                                configurable: !0
                            }), t
                        }();
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }), e.default = n
                    }])
                }])
            },
            "./node_modules/h3-js/dist/browser/h3-js.es.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    UNITS: () => D,
                    areNeighborCells: () => Mt,
                    cellArea: () => Ut,
                    cellToBoundary: () => At,
                    cellToCenterChild: () => dt,
                    cellToChildPos: () => ft,
                    cellToChildren: () => ut,
                    cellToChildrenSize: () => ht,
                    cellToLatLng: () => lt,
                    cellToLocalIj: () => Ot,
                    cellToParent: () => ct,
                    cellToVertex: () => zt,
                    cellToVertexes: () => Gt,
                    cellsToDirectedEdge: () => wt,
                    cellsToMultiPolygon: () => yt,
                    childPosToCell: () => pt,
                    compactCells: () => xt,
                    degsToRads: () => Yt,
                    directedEdgeToBoundary: () => Pt,
                    directedEdgeToCells: () => Ct,
                    edgeLength: () => Nt,
                    getBaseCellNumber: () => it,
                    getDirectedEdgeDestination: () => Et,
                    getDirectedEdgeOrigin: () => St,
                    getHexagonAreaAvg: () => kt,
                    getHexagonEdgeLengthAvg: () => Ft,
                    getIcosahedronFaces: () => at,
                    getNumCells: () => Ht,
                    getPentagons: () => Xt,
                    getRes0Cells: () => Wt,
                    getResolution: () => ot,
                    greatCircleDistance: () => qt,
                    gridDisk: () => mt,
                    gridDiskDistances: () => gt,
                    gridDistance: () => Lt,
                    gridPathCells: () => Dt,
                    gridRingUnsafe: () => vt,
                    h3IndexToSplitLong: () => N,
                    isPentagon: () => nt,
                    isResClassIII: () => rt,
                    isValidCell: () => et,
                    isValidDirectedEdge: () => Tt,
                    isValidVertex: () => Vt,
                    latLngToCell: () => st,
                    localIjToCell: () => Bt,
                    originToDirectedEdges: () => Rt,
                    polygonToCells: () => _t,
                    radsToDegs: () => Qt,
                    splitLongToH3Index: () => F,
                    uncompactCells: () => bt,
                    vertexToLatLng: () => jt
                });
                var r = function(t) {
                        var e, n = void 0 !== (t = t || {}) ? t : {},
                            r = {};
                        for (e in n) n.hasOwnProperty(e) && (r[e] = n[e]);
                        var i, a = [],
                            o = "";
                        "undefined" != typeof document && document.currentScript && (o = document.currentScript.src), o = 0 !== o.indexOf("blob:") ? o.substr(0, o.lastIndexOf("/") + 1) : "", i = function(t, e, n) {
                            var r = new XMLHttpRequest;
                            r.open("GET", t, !0), r.responseType = "arraybuffer", r.onload = function() {
                                if (200 == r.status || 0 == r.status && r.response) e(r.response);
                                else {
                                    var i = W(t);
                                    i ? e(i.buffer) : n()
                                }
                            }, r.onerror = n, r.send(null)
                        };
                        var s = n.print || console.log.bind(console),
                            l = n.printErr || console.warn.bind(console);
                        for (e in r) r.hasOwnProperty(e) && (n[e] = r[e]);
                        r = null, n.arguments && (a = n.arguments);
                        var A = 0,
                            c = !1;

                        function u(t) {
                            var e = n["_" + t];
                            return e || at("Assertion failed: " + ("Cannot call unknown function " + t + ", make sure it is exported")), e
                        }
                        var h, d, f, p, m, g, v, _ = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

                        function y(t, e) {
                            return t ? function(t, e, n) {
                                for (var r = e + n, i = e; t[i] && !(i >= r);) ++i;
                                if (i - e > 16 && t.subarray && _) return _.decode(t.subarray(e, i));
                                for (var a = ""; e < i;) {
                                    var o = t[e++];
                                    if (128 & o) {
                                        var s = 63 & t[e++];
                                        if (192 != (224 & o)) {
                                            var l = 63 & t[e++];
                                            if ((o = 224 == (240 & o) ? (15 & o) << 12 | s << 6 | l : (7 & o) << 18 | s << 12 | l << 6 | 63 & t[e++]) < 65536) a += String.fromCharCode(o);
                                            else {
                                                var A = o - 65536;
                                                a += String.fromCharCode(55296 | A >> 10, 56320 | 1023 & A)
                                            }
                                        } else a += String.fromCharCode((31 & o) << 6 | s)
                                    } else a += String.fromCharCode(o)
                                }
                                return a
                            }(f, t, e) : ""
                        }

                        function x(t, e) {
                            return t % e > 0 && (t += e - t % e), t
                        }

                        function b(t) {
                            h = t, n.HEAP8 = d = new Int8Array(t), n.HEAP16 = p = new Int16Array(t), n.HEAP32 = m = new Int32Array(t), n.HEAPU8 = f = new Uint8Array(t), n.HEAPU16 = new Uint16Array(t), n.HEAPU32 = new Uint32Array(t), n.HEAPF32 = g = new Float32Array(t), n.HEAPF64 = v = new Float64Array(t)
                        }
                        "undefined" != typeof TextDecoder && new TextDecoder("utf-16le");
                        var M = n.TOTAL_MEMORY || 33554432;

                        function w(t) {
                            for (; t.length > 0;) {
                                var e = t.shift();
                                if ("function" != typeof e) {
                                    var r = e.func;
                                    "number" == typeof r ? void 0 === e.arg ? n.dynCall_v(r) : n.dynCall_vi(r, e.arg) : r(void 0 === e.arg ? null : e.arg)
                                } else e()
                            }
                        }
                        M = (h = n.buffer ? n.buffer : new ArrayBuffer(M)).byteLength, b(h), m[6032] = 5267040;
                        var S = [],
                            E = [],
                            T = [],
                            C = [],
                            R = Math.abs,
                            P = Math.ceil,
                            L = Math.floor,
                            D = Math.min,
                            I = 0,
                            O = null,
                            B = null;
                        n.preloadedImages = {}, n.preloadedAudios = {};
                        var q, U, N = null,
                            k = "data:application/octet-stream;base64,";

                        function F(t) {
                            return String.prototype.startsWith ? t.startsWith(k) : 0 === t.indexOf(k)
                        }

                        function z(t) {
                            return t.replace(/\b__Z[\w\d_]+/g, (function(t) {
                                return t == t ? t : t + " [" + t + "]"
                            }))
                        }

                        function G() {
                            var t = new Error;
                            if (!t.stack) {
                                try {
                                    throw new Error(0)
                                } catch (e) {
                                    t = e
                                }
                                if (!t.stack) return "(no stack trace available)"
                            }
                            return t.stack.toString()
                        }

                        function j() {
                            return d.length
                        }

                        function V(t) {
                            try {
                                var e = new ArrayBuffer(t);
                                if (e.byteLength != t) return;
                                return new Int8Array(e).set(d), Z(e), b(e), 1
                            } catch (t) {}
                        }
                        N = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAOgehWlKfUEEz1zLi+JsiQa2og3wcMfVAWCbHorc0yEDi+Yn/Y6mbQJ11/mfsnG9At6bnG4UQQkBvMCQWKqUUQJVmwwswmOc/3hVgVBL3uj//qqOEOdGOPw/WDN4gnGE/H3ANkCUgND+AA8btKgAHPwTXBqJVSdo+XfRQAqsKrj4fc+zLYbSPQklEmCZHv2FCUP+uDso1NEKYtPhwphUHQptxnyFXYdpB7CddZAMmrkGAt1AxSTqBQUibBVdTsFNBSuX3MV+AJkFocv82SLf5QAqmgj7AY81A23VDSEnLoEDGEJVSeDFzQDYrqvBk70VA8U157pcRGUBWfEF+ZKbsP7KBdLHZTpFAqKYk69AqekDbeGY41MdjQD8AZzHK501A1vcrrjubNkD5LnquvBYhQCbiRRD71QlAqt72EbOH8z8Eu+jL1YbdP4uaox/xUcY/abedg1XfsD+BsUdzJ4KZP5wE9YFySIM/rW1kAKMpbT+rZFthVRhWPy4PKlXIs0A/qMZLlwDnMEHByqEF0I0ZQQYSFD8lUQNBPpY+dFs07UAH8BZImBPWQN9RY0I0sMBA2T7kLfc6qUByFYvfhBKTQMq+0Mis1XxA0XQbeQXMZUBJJ5aEGXpQQP7/SY0a6ThAaMD92b/UIkAs8s8yqXoMQNIegOvCk/U/aOi7NZJP4D8AAAAA/////wAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAD/////AAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAA/////wAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAP////8AAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////BQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAUAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAEAAQAAAQEAAAAAAAEAAAABAAAAAQABAAAAAAAAAAAAAAAAAAAAAAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAAGFsZ29zLmMAaDNOZWlnaGJvclJvdGF0aW9ucwBjb29yZGlqay5jAF91cEFwN0NoZWNrZWQAX3VwQXA3ckNoZWNrZWQAZGlyZWN0ZWRFZGdlLmMAZGlyZWN0ZWRFZGdlVG9Cb3VuZGFyeQBhZGphY2VudEZhY2VEaXJbdG1wRmlqay5mYWNlXVtmaWprLmZhY2VdID09IEtJAGZhY2VpamsuYwBfZmFjZUlqa1BlbnRUb0NlbGxCb3VuZGFyeQBhZGphY2VudEZhY2VEaXJbY2VudGVySUpLLmZhY2VdW2ZhY2UyXSA9PSBLSQBfZmFjZUlqa1RvQ2VsbEJvdW5kYXJ5AGgzSW5kZXguYwBjb21wYWN0Q2VsbHMAbGF0TG5nVG9DZWxsAGNlbGxUb0NoaWxkUG9zAHZhbGlkYXRlQ2hpbGRQb3MAbGF0TG5nLmMAY2VsbEFyZWFSYWRzMgBwb2x5Z29uLT5uZXh0ID09IE5VTEwAbGlua2VkR2VvLmMAYWRkTmV3TGlua2VkUG9seWdvbgBuZXh0ICE9IE5VTEwAbG9vcCAhPSBOVUxMAGFkZE5ld0xpbmtlZExvb3AAcG9seWdvbi0+Zmlyc3QgPT0gTlVMTABhZGRMaW5rZWRMb29wAGNvb3JkICE9IE5VTEwAYWRkTGlua2VkQ29vcmQAbG9vcC0+Zmlyc3QgPT0gTlVMTABpbm5lckxvb3BzICE9IE5VTEwAbm9ybWFsaXplTXVsdGlQb2x5Z29uAGJib3hlcyAhPSBOVUxMAGNhbmRpZGF0ZXMgIT0gTlVMTABmaW5kUG9seWdvbkZvckhvbGUAY2FuZGlkYXRlQkJveGVzICE9IE5VTEwAcmV2RGlyICE9IElOVkFMSURfRElHSVQAbG9jYWxpai5jAGNlbGxUb0xvY2FsSWprAGJhc2VDZWxsICE9IG9yaWdpbkJhc2VDZWxsACEob3JpZ2luT25QZW50ICYmIGluZGV4T25QZW50KQBiYXNlQ2VsbCA9PSBvcmlnaW5CYXNlQ2VsbABiYXNlQ2VsbCAhPSBJTlZBTElEX0JBU0VfQ0VMTABsb2NhbElqa1RvQ2VsbAAhX2lzQmFzZUNlbGxQZW50YWdvbihiYXNlQ2VsbCkAYmFzZUNlbGxSb3RhdGlvbnMgPj0gMABncmlkUGF0aENlbGxzADAAdmVydGV4LmMAY2VsbFRvVmVydGV4AGdyYXBoLT5idWNrZXRzICE9IE5VTEwAdmVydGV4R3JhcGguYwBpbml0VmVydGV4R3JhcGgAbm9kZSAhPSBOVUxMAGFkZFZlcnRleE5vZGU=";
                        var H = "function" == typeof atob ? atob : function(t) {
                            var e, n, r, i, a, o, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                                l = "",
                                A = 0;
                            t = t.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                            do {
                                e = s.indexOf(t.charAt(A++)) << 2 | (i = s.indexOf(t.charAt(A++))) >> 4, n = (15 & i) << 4 | (a = s.indexOf(t.charAt(A++))) >> 2, r = (3 & a) << 6 | (o = s.indexOf(t.charAt(A++))), l += String.fromCharCode(e), 64 !== a && (l += String.fromCharCode(n)), 64 !== o && (l += String.fromCharCode(r))
                            } while (A < t.length);
                            return l
                        };

                        function W(t) {
                            if (F(t)) return function(t) {
                                try {
                                    for (var e = H(t), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);
                                    return n
                                } catch (t) {
                                    throw new Error("Converting base64 string to bytes failed.")
                                }
                            }(t.slice(k.length))
                        }
                        var X, Y, Q = function(t, e, n) {
                                var r = new t.Int8Array(n),
                                    i = new t.Int32Array(n),
                                    a = (new t.Uint8Array(n), new t.Float32Array(n), new t.Float64Array(n)),
                                    o = 0 | e.o,
                                    s = 0 | e.p,
                                    l = t.Math.floor,
                                    A = t.Math.abs,
                                    c = t.Math.sqrt,
                                    u = t.Math.pow,
                                    h = t.Math.cos,
                                    d = t.Math.sin,
                                    f = t.Math.tan,
                                    p = t.Math.acos,
                                    m = t.Math.asin,
                                    g = t.Math.atan,
                                    v = t.Math.atan2,
                                    _ = t.Math.ceil,
                                    y = t.Math.imul,
                                    x = t.Math.min,
                                    b = t.Math.max,
                                    M = t.Math.clz32,
                                    w = e.b,
                                    S = e.c,
                                    E = e.d,
                                    T = e.e,
                                    C = e.f,
                                    R = e.g,
                                    P = e.h,
                                    L = e.i,
                                    D = 24160;

                                function I(t, e, n, r) {
                                    return 0 | O(t |= 0, e |= 0, n |= 0, r |= 0, 0)
                                }

                                function O(t, e, n, r, a) {
                                    var o, s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0;
                                    if (o = D, D = D + 16 | 0, l = o, !(0 | B(t |= 0, e |= 0, n |= 0, r |= 0, a |= 0))) return D = o, 0;
                                    do {
                                        if ((0 | n) >= 0) {
                                            if ((0 | n) > 13780509) {
                                                if (0 | (s = 0 | ee(15, l))) break;
                                                l = 0 | i[(A = l) >> 2], A = 0 | i[A + 4 >> 2]
                                            } else c = 0 | Ue(0 | n, 0 | (s = ((0 | n) < 0) << 31 >> 31), 3, 0), A = 0 | S(), s = 0 | De(0 | n, 0 | s, 1, 0), s = 0 | De(0 | (s = 0 | Ue(0 | c, 0 | A, 0 | s, 0 | S())), 0 | S(), 1, 0), A = 0 | S(), i[l >> 2] = s, i[l + 4 >> 2] = A, l = s;
                                            if (Xe(0 | r, 0, l << 3 | 0), 0 | a) {
                                                Xe(0 | a, 0, l << 2 | 0), s = 0 | q(t, e, n, r, a, l, A, 0);
                                                break
                                            }(s = 0 | Le(l, 4)) ? (c = 0 | q(t, e, n, r, s, l, A, 0), Pe(s), s = c) : s = 13
                                        } else s = 2
                                    } while (0);
                                    return D = o, 0 | s
                                }

                                function B(t, e, n, r, a) {
                                    t |= 0, e |= 0, n |= 0, r |= 0, a |= 0;
                                    var o, s, l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0;
                                    if (s = D, D = D + 16 | 0, m = s + 8 | 0, i[(p = o = s) >> 2] = t, i[p + 4 >> 2] = e, (0 | n) < 0) return D = s, 2;
                                    if (i[(l = r) >> 2] = t, i[l + 4 >> 2] = e, (l = 0 != (0 | a)) && (i[a >> 2] = 0), 0 | Ut(t, e)) return D = s, 9;
                                    i[m >> 2] = 0;
                                    t: do {
                                        if ((0 | n) >= 1)
                                            if (l)
                                                for (d = 1, h = 0, f = 0, p = 1, l = t;;) {
                                                    if (!(h | f)) {
                                                        if (0 | (l = 0 | U(l, e, 4, m, o))) break t;
                                                        if (0 | Ut(l = 0 | i[(e = o) >> 2], e = 0 | i[e + 4 >> 2])) {
                                                            l = 9;
                                                            break t
                                                        }
                                                    }
                                                    if (0 | (l = 0 | U(l, e, 0 | i[22384 + (f << 2) >> 2], m, o))) break t;
                                                    if (l = 0 | i[(e = o) >> 2], e = 0 | i[e + 4 >> 2], i[(t = r + (d << 3) | 0) >> 2] = l, i[t + 4 >> 2] = e, i[a + (d << 2) >> 2] = p, A = (0 | (t = h + 1 | 0)) == (0 | p), u = 6 == (0 | (c = f + 1 | 0)), 0 | Ut(l, e)) {
                                                        l = 9;
                                                        break t
                                                    }
                                                    if ((0 | (p = p + (u & A & 1) | 0)) > (0 | n)) {
                                                        l = 0;
                                                        break
                                                    }
                                                    d = d + 1 | 0, h = A ? 0 : t, f = A ? u ? 0 : c : f
                                                } else
                                                    for (d = 1, h = 0, f = 0, p = 1, l = t;;) {
                                                        if (!(h | f)) {
                                                            if (0 | (l = 0 | U(l, e, 4, m, o))) break t;
                                                            if (0 | Ut(l = 0 | i[(e = o) >> 2], e = 0 | i[e + 4 >> 2])) {
                                                                l = 9;
                                                                break t
                                                            }
                                                        }
                                                        if (0 | (l = 0 | U(l, e, 0 | i[22384 + (f << 2) >> 2], m, o))) break t;
                                                        if (l = 0 | i[(e = o) >> 2], e = 0 | i[e + 4 >> 2], i[(t = r + (d << 3) | 0) >> 2] = l, i[t + 4 >> 2] = e, A = (0 | (t = h + 1 | 0)) == (0 | p), u = 6 == (0 | (c = f + 1 | 0)), 0 | Ut(l, e)) {
                                                            l = 9;
                                                            break t
                                                        }
                                                        if ((0 | (p = p + (u & A & 1) | 0)) > (0 | n)) {
                                                            l = 0;
                                                            break
                                                        }
                                                        d = d + 1 | 0, h = A ? 0 : t, f = A ? u ? 0 : c : f
                                                    } else l = 0
                                    } while (0);
                                    return D = s, 0 | l
                                }

                                function q(t, e, n, r, a, o, s, l) {
                                    n |= 0, r |= 0, a |= 0, l |= 0;
                                    var A, c, u, h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0;
                                    if (u = D, D = D + 16 | 0, A = u + 8 | 0, c = u, h = 0 | ke(0 | (t |= 0), 0 | (e |= 0), 0 | (o |= 0), 0 | (s |= 0)), f = 0 | S(), !(0 == (0 | (v = 0 | i[(g = p = r + (h << 3) | 0) >> 2])) & 0 == (0 | (g = 0 | i[g + 4 >> 2])) | (d = (0 | v) == (0 | t) & (0 | g) == (0 | e))))
                                        do {
                                            h = 0 | Ne(0 | (h = 0 | De(0 | h, 0 | f, 1, 0)), 0 | S(), 0 | o, 0 | s), f = 0 | S(), d = (0 | (g = 0 | i[(v = p = r + (h << 3) | 0) >> 2])) == (0 | t) & (0 | (v = 0 | i[v + 4 >> 2])) == (0 | e)
                                        } while (!(0 == (0 | g) & 0 == (0 | v) | d));
                                    if (h = a + (h << 2) | 0, d && (0 | i[h >> 2]) <= (0 | l)) return D = u, 0;
                                    if (i[(v = p) >> 2] = t, i[v + 4 >> 2] = e, i[h >> 2] = l, (0 | l) >= (0 | n)) return D = u, 0;
                                    switch (d = l + 1 | 0, i[A >> 2] = 0, 0 | (h = 0 | U(t, e, 2, A, c))) {
                                        case 9:
                                            m = 9;
                                            break;
                                        case 0:
                                            (h = 0 | q(0 | i[(h = c) >> 2], 0 | i[h + 4 >> 2], n, r, a, o, s, d)) || (m = 9)
                                    }
                                    t: do {
                                        if (9 == (0 | m)) {
                                            switch (i[A >> 2] = 0, 0 | (h = 0 | U(t, e, 3, A, c))) {
                                                case 9:
                                                    break;
                                                case 0:
                                                    if (0 | (h = 0 | q(0 | i[(h = c) >> 2], 0 | i[h + 4 >> 2], n, r, a, o, s, d))) break t;
                                                    break;
                                                default:
                                                    break t
                                            }
                                            switch (i[A >> 2] = 0, 0 | (h = 0 | U(t, e, 1, A, c))) {
                                                case 9:
                                                    break;
                                                case 0:
                                                    if (0 | (h = 0 | q(0 | i[(h = c) >> 2], 0 | i[h + 4 >> 2], n, r, a, o, s, d))) break t;
                                                    break;
                                                default:
                                                    break t
                                            }
                                            switch (i[A >> 2] = 0, 0 | (h = 0 | U(t, e, 5, A, c))) {
                                                case 9:
                                                    break;
                                                case 0:
                                                    if (0 | (h = 0 | q(0 | i[(h = c) >> 2], 0 | i[h + 4 >> 2], n, r, a, o, s, d))) break t;
                                                    break;
                                                default:
                                                    break t
                                            }
                                            switch (i[A >> 2] = 0, 0 | (h = 0 | U(t, e, 4, A, c))) {
                                                case 9:
                                                    break;
                                                case 0:
                                                    if (0 | (h = 0 | q(0 | i[(h = c) >> 2], 0 | i[h + 4 >> 2], n, r, a, o, s, d))) break t;
                                                    break;
                                                default:
                                                    break t
                                            }
                                            switch (i[A >> 2] = 0, 0 | (h = 0 | U(t, e, 6, A, c))) {
                                                case 9:
                                                    break;
                                                case 0:
                                                    if (0 | (h = 0 | q(0 | i[(h = c) >> 2], 0 | i[h + 4 >> 2], n, r, a, o, s, d))) break t;
                                                    break;
                                                default:
                                                    break t
                                            }
                                            return D = u, 0
                                        }
                                    } while (0);
                                    return D = u, 0 | h
                                }

                                function U(t, e, n, r, a) {
                                    t |= 0, e |= 0, a |= 0;
                                    var o, s, l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0;
                                    if ((n |= 0) >>> 0 > 6) return 1;
                                    if (h = (0 | i[(r |= 0) >> 2]) % 6 | 0, i[r >> 2] = h, (0 | h) > 0) {
                                        l = 0;
                                        do {
                                            n = 0 | ft(n), l = l + 1 | 0
                                        } while ((0 | l) < (0 | i[r >> 2]))
                                    }
                                    if (h = 0 | ze(0 | t, 0 | e, 45), S(), (s = 127 & h) >>> 0 > 121) return 5;
                                    o = 0 | Nt(t, e), l = 0 | ze(0 | t, 0 | e, 52), S(), l &= 15;
                                    t: do {
                                        if (l) {
                                            for (;;) {
                                                if (c = 0 | ze(0 | t, 0 | e, 0 | (A = 3 * (15 - l | 0) | 0)), S(), 7 == (0 | (c &= 7))) {
                                                    e = 5;
                                                    break
                                                }
                                                if (f = 0 == (0 | jt(l)), l = l + -1 | 0, d = 0 | Ge(7, 0, 0 | A), e &= ~(0 | S()), t = 0 | Ge(0 | i[(f ? 432 : 16) + (28 * c | 0) + (n << 2) >> 2], 0, 0 | A) | t & ~d, e |= A = 0 | S(), !(n = 0 | i[(f ? 640 : 224) + (28 * c | 0) + (n << 2) >> 2])) {
                                                    n = 0;
                                                    break t
                                                }
                                                if (!l) {
                                                    u = 8;
                                                    break t
                                                }
                                            }
                                            return 0 | e
                                        }
                                        u = 8
                                    } while (0);
                                    8 == (0 | u) && (t |= 0 | Ge(0 | (f = 0 | i[848 + (28 * s | 0) + (n << 2) >> 2]), 0, 45), e = 0 | S() | -1040385 & e, n = 0 | i[4272 + (28 * s | 0) + (n << 2) >> 2], 127 == (127 & f | 0) && (f = 0 | Ge(0 | i[848 + (28 * s | 0) + 20 >> 2], 0, 45), e = 0 | S() | -1040385 & e, n = 0 | i[4272 + (28 * s | 0) + 20 >> 2], t = 0 | Ft(f | t, e), e = 0 | S(), i[r >> 2] = 1 + (0 | i[r >> 2]))), c = 0 | ze(0 | t, 0 | e, 45), S(), c &= 127;
                                    t: do {
                                        if (0 | F(c)) {
                                            e: do {
                                                if (1 == (0 | Nt(t, e))) {
                                                    if ((0 | s) != (0 | c)) {
                                                        if (0 | V(c, 0 | i[7696 + (28 * s | 0) >> 2])) {
                                                            t = 0 | Gt(t, e), A = 1, e = 0 | S();
                                                            break
                                                        }
                                                        E(23313, 22416, 436, 22424)
                                                    }
                                                    switch (0 | o) {
                                                        case 3:
                                                            t = 0 | Ft(t, e), e = 0 | S(), i[r >> 2] = 1 + (0 | i[r >> 2]), A = 0;
                                                            break e;
                                                        case 5:
                                                            t = 0 | Gt(t, e), e = 0 | S(), i[r >> 2] = 5 + (0 | i[r >> 2]), A = 0;
                                                            break e;
                                                        case 0:
                                                            return 9;
                                                        default:
                                                            return 1
                                                    }
                                                } else A = 0
                                            } while (0);
                                            if ((0 | n) > 0) {
                                                l = 0;
                                                do {
                                                    t = 0 | kt(t, e), e = 0 | S(), l = l + 1 | 0
                                                } while ((0 | l) != (0 | n))
                                            }
                                            if ((0 | s) != (0 | c)) {
                                                if (!(0 | z(c))) {
                                                    if (0 != (0 | A) | 5 != (0 | Nt(t, e))) break;
                                                    i[r >> 2] = 1 + (0 | i[r >> 2]);
                                                    break
                                                }
                                                switch (127 & h) {
                                                    case 8:
                                                    case 118:
                                                        break t
                                                }
                                                3 != (0 | Nt(t, e)) && (i[r >> 2] = 1 + (0 | i[r >> 2]))
                                            }
                                        }
                                        else if ((0 | n) > 0) {
                                            l = 0;
                                            do {
                                                t = 0 | Ft(t, e), e = 0 | S(), l = l + 1 | 0
                                            } while ((0 | l) != (0 | n))
                                        }
                                    } while (0);
                                    return i[r >> 2] = ((0 | i[r >> 2]) + n | 0) % 6 | 0, i[(f = a) >> 2] = t, i[f + 4 >> 2] = e, 0
                                }

                                function N(t, e, n, r) {
                                    n |= 0, r |= 0;
                                    var a, o, s, l = 0,
                                        A = 0;
                                    for (s = D, D = D + 16 | 0, a = s, o = s + 8 | 0, l = (l = 0 == (0 | Ut(t |= 0, e |= 0))) ? 1 : 2;;) {
                                        if (i[o >> 2] = 0, 0 == (0 | U(t, e, l, o, a)) & ((0 | i[(A = a) >> 2]) == (0 | n) ? (0 | i[A + 4 >> 2]) == (0 | r) : 0)) {
                                            t = 4;
                                            break
                                        }
                                        if ((l = l + 1 | 0) >>> 0 >= 7) {
                                            l = 7, t = 4;
                                            break
                                        }
                                    }
                                    return 4 == (0 | t) ? (D = s, 0 | l) : 0
                                }

                                function k(t, e, n, r, o, s, l) {
                                    e |= 0, n |= 0, r |= 0, o |= 0, s |= 0, l |= 0;
                                    var A, c, u, h, d, f, p, m, g, v, _ = 0,
                                        y = 0,
                                        x = 0,
                                        b = 0,
                                        M = 0,
                                        w = 0,
                                        E = 0,
                                        T = 0,
                                        C = 0,
                                        R = 0,
                                        P = 0,
                                        L = 0,
                                        I = 0,
                                        O = 0,
                                        B = 0,
                                        q = 0,
                                        U = 0,
                                        N = 0,
                                        k = 0;
                                    if (v = D, D = D + 64 | 0, p = v + 48 | 0, m = v + 32 | 0, g = v + 24 | 0, A = v + 8 | 0, c = v, (0 | (y = 0 | i[(t |= 0) >> 2])) <= 0) return D = v, 0;
                                    for (u = t + 4 | 0, h = p + 8 | 0, d = m + 8 | 0, f = A + 8 | 0, _ = 0, I = 0;;) {
                                        L = (x = 0 | i[u >> 2]) + (I << 4) | 0, i[p >> 2] = i[L >> 2], i[p + 4 >> 2] = i[L + 4 >> 2], i[p + 8 >> 2] = i[L + 8 >> 2], i[p + 12 >> 2] = i[L + 12 >> 2], (0 | I) == (y + -1 | 0) ? (i[m >> 2] = i[x >> 2], i[m + 4 >> 2] = i[x + 4 >> 2], i[m + 8 >> 2] = i[x + 8 >> 2], i[m + 12 >> 2] = i[x + 12 >> 2]) : (L = x + (I + 1 << 4) | 0, i[m >> 2] = i[L >> 2], i[m + 4 >> 2] = i[L + 4 >> 2], i[m + 8 >> 2] = i[L + 8 >> 2], i[m + 12 >> 2] = i[L + 12 >> 2]), y = 0 | Z(p, m, r, g);
                                        t: do {
                                            if (y) x = 0, _ = y;
                                            else if (y = 0 | i[(x = g) >> 2], (0 | (x = 0 | i[x + 4 >> 2])) > 0 | 0 == (0 | x) & y >>> 0 > 0) {
                                                P = 0, L = 0;
                                                e: for (;;) {
                                                    if (k = +a[p >> 3], N = +((R = 0 | Ie(0 | y, 0 | x, 0 | P, 0 | L)) >>> 0) + 4294967296 * +(0 | S()), q = +(y >>> 0) + 4294967296 * +(0 | x), U = +(P >>> 0) + 4294967296 * +(0 | L), a[A >> 3] = k * N / q + +a[m >> 3] * U / q, a[f >> 3] = +a[h >> 3] * N / q + +a[d >> 3] * U / q, 0 | (y = 0 | Vt(A, r, c))) {
                                                        _ = y;
                                                        break
                                                    }
                                                    w = 0 | ke(0 | (C = 0 | i[(R = c) >> 2]), 0 | (R = 0 | i[R + 4 >> 2]), 0 | e, 0 | n), b = 0 | S(), x = 0 | i[(M = y = l + (w << 3) | 0) >> 2], M = 0 | i[M + 4 >> 2];
                                                    n: do {
                                                        if (0 == (0 | x) & 0 == (0 | M)) O = y, B = 16;
                                                        else
                                                            for (E = 0, T = 0;;) {
                                                                if ((0 | E) > (0 | n) | (0 | E) == (0 | n) & T >>> 0 > e >>> 0) {
                                                                    _ = 1;
                                                                    break e
                                                                }
                                                                if ((0 | x) == (0 | C) & (0 | M) == (0 | R)) break n;
                                                                if (w = 0 | Ne(0 | (y = 0 | De(0 | w, 0 | b, 1, 0)), 0 | S(), 0 | e, 0 | n), b = 0 | S(), T = 0 | De(0 | T, 0 | E, 1, 0), E = 0 | S(), 0 == (0 | (x = 0 | i[(M = y = l + (w << 3) | 0) >> 2])) & 0 == (0 | (M = 0 | i[M + 4 >> 2]))) {
                                                                    O = y, B = 16;
                                                                    break
                                                                }
                                                            }
                                                    } while (0);
                                                    if (16 != (0 | B) || (B = 0, 0 == (0 | C) & 0 == (0 | R)) || (i[(T = O) >> 2] = C, i[T + 4 >> 2] = R, T = s + (i[o >> 2] << 3) | 0, i[T >> 2] = C, i[T + 4 >> 2] = R, T = 0 | De(0 | i[(T = o) >> 2], 0 | i[T + 4 >> 2], 1, 0), C = 0 | S(), i[(R = o) >> 2] = T, i[R + 4 >> 2] = C), P = 0 | De(0 | P, 0 | L, 1, 0), L = 0 | S(), y = 0 | i[(x = g) >> 2], !((0 | (x = 0 | i[x + 4 >> 2])) > (0 | L) | (0 | x) == (0 | L) & y >>> 0 > P >>> 0)) {
                                                        x = 1;
                                                        break t
                                                    }
                                                }
                                                x = 0
                                            } else x = 1
                                        } while (0);
                                        if (I = I + 1 | 0, !x) {
                                            B = 21;
                                            break
                                        }
                                        if ((0 | I) >= (0 | (y = 0 | i[t >> 2]))) {
                                            _ = 0, B = 21;
                                            break
                                        }
                                    }
                                    return 21 == (0 | B) ? (D = v, 0 | _) : 0
                                }

                                function F(t) {
                                    return (t |= 0) >>> 0 > 121 ? 0 | (t = 0) : 0 | (t = 0 | i[7696 + (28 * t | 0) + 16 >> 2])
                                }

                                function z(t) {
                                    return 4 == (0 | (t |= 0)) | 117 == (0 | t) | 0
                                }

                                function G(t) {
                                    return 0 | i[11120 + (216 * (0 | i[(t |= 0) >> 2]) | 0) + (72 * (0 | i[t + 4 >> 2]) | 0) + (24 * (0 | i[t + 8 >> 2]) | 0) + (i[t + 12 >> 2] << 3) >> 2]
                                }

                                function j(t) {
                                    return 0 | i[11120 + (216 * (0 | i[(t |= 0) >> 2]) | 0) + (72 * (0 | i[t + 4 >> 2]) | 0) + (24 * (0 | i[t + 8 >> 2]) | 0) + (i[t + 12 >> 2] << 3) + 4 >> 2]
                                }

                                function V(t, e) {
                                    return e |= 0, (0 | i[7696 + (28 * (t |= 0) | 0) + 20 >> 2]) == (0 | e) ? 0 | (e = 1) : 0 | (e = (0 | i[7696 + (28 * t | 0) + 24 >> 2]) == (0 | e))
                                }

                                function H(t, e) {
                                    return 0 | i[848 + (28 * (t |= 0) | 0) + ((e |= 0) << 2) >> 2]
                                }

                                function W(t, e) {
                                    return e |= 0, (0 | i[848 + (28 * (t |= 0) | 0) >> 2]) == (0 | e) ? 0 | (e = 0) : (0 | i[848 + (28 * t | 0) + 4 >> 2]) == (0 | e) ? 0 | (e = 1) : (0 | i[848 + (28 * t | 0) + 8 >> 2]) == (0 | e) ? 0 | (e = 2) : (0 | i[848 + (28 * t | 0) + 12 >> 2]) == (0 | e) ? 0 | (e = 3) : (0 | i[848 + (28 * t | 0) + 16 >> 2]) == (0 | e) ? 0 | (e = 4) : (0 | i[848 + (28 * t | 0) + 20 >> 2]) == (0 | e) ? 0 | (e = 5) : 0 | ((0 | i[848 + (28 * t | 0) + 24 >> 2]) == (0 | e) ? 6 : 7)
                                }

                                function X(t) {
                                    return +a[16 + (t |= 0) >> 3] < +a[t + 24 >> 3] | 0
                                }

                                function Y(t, e) {
                                    t |= 0;
                                    var n, r, i = 0;
                                    return (i = +a[(e |= 0) >> 3]) >= +a[t + 8 >> 3] && i <= +a[t >> 3] ? (n = +a[t + 16 >> 3], i = +a[t + 24 >> 3], e = (r = +a[e + 8 >> 3]) >= i, t = r <= n & 1, n < i ? e && (t = 1) : e || (t = 0), 0 | (e = 0 != (0 | t))) : 0 | (e = 0)
                                }

                                function Q(t, e, n) {
                                    t |= 0, e |= 0, n |= 0;
                                    var r, s, c, u, h, d, f, p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        y = 0,
                                        b = 0,
                                        M = 0;
                                    d = D, D = D + 288 | 0, h = d + 264 | 0, v = d + 96 | 0, m = (p = g = d) + 96 | 0;
                                    do {
                                        i[p >> 2] = 0, p = p + 4 | 0
                                    } while ((0 | p) < (0 | m));
                                    return 0 | (e = 0 | Qt(e, g)) ? (D = d, 0 | (b = e)) : (Xt(g = 0 | i[(m = g) >> 2], m = 0 | i[m + 4 >> 2], h), Yt(g, m, v), u = +te(h, v + 8 | 0), a[h >> 3] = +a[t >> 3], a[(m = h + 8 | 0) >> 3] = +a[t + 16 >> 3], a[v >> 3] = +a[t + 8 >> 3], a[(g = v + 8 | 0) >> 3] = +a[t + 24 >> 3], s = +te(h, v), M = +a[m >> 3] - +a[g >> 3], c = +A(+M), f = +a[h >> 3] - +a[v >> 3], r = +A(+f), 0 == M | 0 == f || (M = +je(+c, +r), M = +_(+s * s / +Ve(+M / +Ve(+c, +r), 3) / (u * (2.59807621135 * u) * .8)), a[o >> 3] = M, y = ~~M >>> 0, b = +A(M) >= 1 ? M > 0 ? ~~+x(+l(M / 4294967296), 4294967295) >>> 0 : ~~+_((M - +(~~M >>> 0)) / 4294967296) >>> 0 : 0, 2146435072 == (2146435072 & i[o + 4 >> 2] | 0)) ? e = 1 : (v = 0 == (0 | y) & 0 == (0 | b), i[(e = n) >> 2] = v ? 1 : y, i[e + 4 >> 2] = v ? 0 : b, e = 0), D = d, 0 | (b = e))
                                }

                                function Z(t, e, n, r) {
                                    t |= 0, e |= 0, n |= 0, r |= 0;
                                    var s, c, u, h, d = 0,
                                        f = 0,
                                        p = 0;
                                    h = D, D = D + 288 | 0, c = h + 264 | 0, u = h + 96 | 0, s = (d = f = h) + 96 | 0;
                                    do {
                                        i[d >> 2] = 0, d = d + 4 | 0
                                    } while ((0 | d) < (0 | s));
                                    return 0 | (n = 0 | Qt(n, f)) ? (D = h, 0 | (r = n)) : (Xt(d = 0 | i[(n = f) >> 2], n = 0 | i[n + 4 >> 2], c), Yt(d, n, u), p = +te(c, u + 8 | 0), p = +_(+ +te(t, e) / (2 * p)), a[o >> 3] = p, n = ~~p >>> 0, d = +A(p) >= 1 ? p > 0 ? ~~+x(+l(p / 4294967296), 4294967295) >>> 0 : ~~+_((p - +(~~p >>> 0)) / 4294967296) >>> 0 : 0, 2146435072 == (2146435072 & i[o + 4 >> 2] | 0) ? (D = h, 0 | (r = 1)) : (f = 0 == (0 | n) & 0 == (0 | d), i[r >> 2] = f ? 1 : n, i[r + 4 >> 2] = f ? 0 : d, D = h, 0 | (r = 0)))
                                }

                                function J(t, e, n, r) {
                                    e |= 0, n |= 0, r |= 0, i[(t |= 0) >> 2] = e, i[t + 4 >> 2] = n, i[t + 8 >> 2] = r
                                }

                                function K(t, e) {
                                    t |= 0;
                                    var n, r, o, s, l = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0;
                                    i[(s = 8 + (e |= 0) | 0) >> 2] = 0, r = +a[t >> 3], h = +A(+r), o = +a[t + 8 >> 3], h += .5 * (d = +A(+o) / .8660254037844386), h -= +(0 | (l = ~~h)), d -= +(0 | (t = ~~d));
                                    do {
                                        if (h < .5) {
                                            if (h < .3333333333333333) {
                                                if (i[e >> 2] = l, d < .5 * (h + 1)) {
                                                    i[e + 4 >> 2] = t;
                                                    break
                                                }
                                                t = t + 1 | 0, i[e + 4 >> 2] = t;
                                                break
                                            }
                                            if (t = (1 & !(d < (p = 1 - h))) + t | 0, i[e + 4 >> 2] = t, p <= d & d < 2 * h) {
                                                l = l + 1 | 0, i[e >> 2] = l;
                                                break
                                            }
                                            i[e >> 2] = l;
                                            break
                                        }
                                        if (!(h < .6666666666666666)) {
                                            if (l = l + 1 | 0, i[e >> 2] = l, d < .5 * h) {
                                                i[e + 4 >> 2] = t;
                                                break
                                            }
                                            t = t + 1 | 0, i[e + 4 >> 2] = t;
                                            break
                                        }
                                        if (d < 1 - h) {
                                            if (i[e + 4 >> 2] = t, 2 * h - 1 < d) {
                                                i[e >> 2] = l;
                                                break
                                            }
                                        } else t = t + 1 | 0, i[e + 4 >> 2] = t;
                                        l = l + 1 | 0, i[e >> 2] = l
                                    } while (0);
                                    do {
                                        if (r < 0) {
                                            if (1 & t) {
                                                l = ~~(+(0 | l) - (2 * (+((f = 0 | Ie(0 | l, ((0 | l) < 0) << 31 >> 31 | 0, 0 | (f = (t + 1 | 0) / 2 | 0), ((0 | f) < 0) << 31 >> 31 | 0)) >>> 0) + 4294967296 * +(0 | S())) + 1)), i[e >> 2] = l;
                                                break
                                            }
                                            l = ~~(+(0 | l) - 2 * (+((f = 0 | Ie(0 | l, ((0 | l) < 0) << 31 >> 31 | 0, 0 | (f = (0 | t) / 2 | 0), ((0 | f) < 0) << 31 >> 31 | 0)) >>> 0) + 4294967296 * +(0 | S()))), i[e >> 2] = l;
                                            break
                                        }
                                    } while (0);
                                    f = e + 4 | 0, o < 0 && (l = l - ((1 | t << 1) / 2 | 0) | 0, i[e >> 2] = l, t = 0 - t | 0, i[f >> 2] = t), c = t - l | 0, (0 | l) < 0 ? (u = 0 - l | 0, i[f >> 2] = c, i[s >> 2] = u, i[e >> 2] = 0, t = c, l = 0) : u = 0, (0 | t) < 0 && (l = l - t | 0, i[e >> 2] = l, u = u - t | 0, i[s >> 2] = u, i[f >> 2] = 0, t = 0), n = l - u | 0, c = t - u | 0, (0 | u) < 0 && (i[e >> 2] = n, i[f >> 2] = c, i[s >> 2] = 0, t = c, l = n, u = 0), (0 | (c = (0 | u) < (0 | (c = (0 | t) < (0 | l) ? t : l)) ? u : c)) <= 0 || (i[e >> 2] = l - c, i[f >> 2] = t - c, i[s >> 2] = u - c)
                                }

                                function $(t) {
                                    var e, n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0;
                                    n = 0 | i[(t |= 0) >> 2], r = 0 | i[(e = t + 4 | 0) >> 2], (0 | n) < 0 && (r = r - n | 0, i[e >> 2] = r, i[(s = t + 8 | 0) >> 2] = (0 | i[s >> 2]) - n, i[t >> 2] = 0, n = 0), (0 | r) < 0 ? (n = n - r | 0, i[t >> 2] = n, o = (0 | i[(s = t + 8 | 0) >> 2]) - r | 0, i[s >> 2] = o, i[e >> 2] = 0, r = 0) : (s = o = t + 8 | 0, o = 0 | i[o >> 2]), (0 | o) < 0 && (n = n - o | 0, i[t >> 2] = n, r = r - o | 0, i[e >> 2] = r, i[s >> 2] = 0, o = 0), (0 | (a = (0 | o) < (0 | (a = (0 | r) < (0 | n) ? r : n)) ? o : a)) <= 0 || (i[t >> 2] = n - a, i[e >> 2] = r - a, i[s >> 2] = o - a)
                                }

                                function tt(t, e) {
                                    var n, r;
                                    e |= 0, r = 0 | i[8 + (t |= 0) >> 2], n = +((0 | i[t + 4 >> 2]) - r | 0), a[e >> 3] = +((0 | i[t >> 2]) - r | 0) - .5 * n, a[e + 8 >> 3] = .8660254037844386 * n
                                }

                                function et(t, e, n) {
                                    t |= 0, e |= 0, i[(n |= 0) >> 2] = (0 | i[e >> 2]) + (0 | i[t >> 2]), i[n + 4 >> 2] = (0 | i[e + 4 >> 2]) + (0 | i[t + 4 >> 2]), i[n + 8 >> 2] = (0 | i[e + 8 >> 2]) + (0 | i[t + 8 >> 2])
                                }

                                function nt(t, e, n) {
                                    t |= 0, e |= 0, i[(n |= 0) >> 2] = (0 | i[t >> 2]) - (0 | i[e >> 2]), i[n + 4 >> 2] = (0 | i[t + 4 >> 2]) - (0 | i[e + 4 >> 2]), i[n + 8 >> 2] = (0 | i[t + 8 >> 2]) - (0 | i[e + 8 >> 2])
                                }

                                function rt(t, e) {
                                    e |= 0;
                                    var n, r = 0;
                                    r = 0 | y(0 | i[(t |= 0) >> 2], e), i[t >> 2] = r, n = 0 | y(0 | i[(r = t + 4 | 0) >> 2], e), i[r >> 2] = n, e = 0 | y(0 | i[(t = t + 8 | 0) >> 2], e), i[t >> 2] = e
                                }

                                function it(t) {
                                    var e, n, r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    l = (0 | (n = 0 | i[(t |= 0) >> 2])) < 0, t = (t = (a = (0 | (s = ((e = (0 | (o = (0 | i[t + 4 >> 2]) - (l ? n : 0) | 0)) < 0) ? 0 - o | 0 : 0) + ((0 | i[t + 8 >> 2]) - (l ? n : 0)) | 0)) < 0) ? 0 : s) - ((o = (0 | (a = (0 | t) < (0 | (a = (0 | (r = (e ? 0 : o) - (a ? s : 0) | 0)) < (0 | (s = (l ? 0 : n) - (e ? o : 0) - (a ? s : 0) | 0)) ? r : s)) ? t : a)) > 0) ? a : 0) | 0, r = r - (o ? a : 0) | 0;
                                    t: do {
                                        switch (s - (o ? a : 0) | 0) {
                                            case 0:
                                                switch (0 | r) {
                                                    case 0:
                                                        return 0 | (0 == (0 | t) ? 0 : 1 == (0 | t) ? 1 : 7);
                                                    case 1:
                                                        return 0 | (0 == (0 | t) ? 2 : 1 == (0 | t) ? 3 : 7);
                                                    default:
                                                        break t
                                                }
                                            case 1:
                                                switch (0 | r) {
                                                    case 0:
                                                        return 0 | (0 == (0 | t) ? 4 : 1 == (0 | t) ? 5 : 7);
                                                    case 1:
                                                        if (t) break t;
                                                        return 6;
                                                    default:
                                                        break t
                                                }
                                        }
                                    } while (0);
                                    return 7
                                }

                                function at(t) {
                                    var e, n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    o = 0 | i[(e = 8 + (t |= 0) | 0) >> 2], s = (0 | i[t >> 2]) - o | 0, o = (0 | i[(l = t + 4 | 0) >> 2]) - o | 0;
                                    do {
                                        if (s >>> 0 > 715827881 | o >>> 0 > 715827881) {
                                            if (r = (0 | s) > 0) {
                                                if ((2147483647 - s | 0) < (0 | s)) return 1;
                                                if ((2147483647 - (s << 1) | 0) < (0 | s)) return 1
                                            } else {
                                                if ((-2147483648 - s | 0) > (0 | s)) return 1;
                                                if ((-2147483648 - (s << 1) | 0) > (0 | s)) return 1
                                            }
                                            if (n = 3 * s | 0, (0 | o) > 0) {
                                                if ((2147483647 - o | 0) < (0 | o)) return 1
                                            } else if ((-2147483648 - o | 0) > (0 | o)) return 1;
                                            if (a = o << 1, (0 | s) > -1) {
                                                if ((-2147483648 | n | 0) >= (0 | o)) return 1
                                            } else if ((-2147483648 ^ n | 0) < (0 | o)) return 1;
                                            if (r) {
                                                if (!((2147483647 - s | 0) < (0 | a))) {
                                                    r = a;
                                                    break
                                                }
                                                return 1
                                            }
                                            if (!((-2147483648 - s | 0) > (0 | a))) {
                                                r = a;
                                                break
                                            }
                                            return 1
                                        }
                                        r = o << 1, n = 3 * s | 0
                                    } while (0);
                                    a = 0 | Ce(+(n - o | 0) / 7), i[t >> 2] = a, o = 0 | Ce(+(r + s | 0) / 7), i[l >> 2] = o, i[e >> 2] = 0, n = (r = (0 | o) < (0 | a)) ? a : o, r = r ? o : a;
                                    do {
                                        if ((0 | r) < 0) {
                                            if ((0 | n) > 0) {
                                                if ((-2147483648 | n | 0) < (0 | r) & -2147483648 != (0 | r) & (2147483647 - n | 0) >= (0 | r)) break;
                                                E(23313, 22444, 355, 22455)
                                            }
                                            if (-2147483648 == (0 | r) | (-2147483648 - n | 0) > (0 | r) && E(23313, 22444, 355, 22455), (0 | n) > -1) {
                                                if ((-2147483648 | n | 0) < (0 | r)) break;
                                                E(23313, 22444, 355, 22455)
                                            } else {
                                                if ((-2147483648 ^ n | 0) >= (0 | r)) break;
                                                E(23313, 22444, 355, 22455)
                                            }
                                        }
                                    } while (0);
                                    return n = o - a | 0, (0 | a) < 0 ? (r = 0 - a | 0, i[l >> 2] = n, i[e >> 2] = r, i[t >> 2] = 0, a = 0) : (n = o, r = 0), (0 | n) < 0 && (a = a - n | 0, i[t >> 2] = a, r = r - n | 0, i[e >> 2] = r, i[l >> 2] = 0, n = 0), s = a - r | 0, o = n - r | 0, (0 | r) < 0 ? (i[t >> 2] = s, i[l >> 2] = o, i[e >> 2] = 0, n = o, o = s, r = 0) : o = a, (0 | (a = (0 | r) < (0 | (a = (0 | n) < (0 | o) ? n : o)) ? r : a)) <= 0 || (i[t >> 2] = o - a, i[l >> 2] = n - a, i[e >> 2] = r - a), 0
                                }

                                function ot(t) {
                                    var e, n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    o = 0 | i[(e = 8 + (t |= 0) | 0) >> 2], s = (0 | i[t >> 2]) - o | 0, o = (0 | i[(l = t + 4 | 0) >> 2]) - o | 0;
                                    do {
                                        if (s >>> 0 > 715827881 | o >>> 0 > 715827881) {
                                            if (r = (0 | s) > 0) {
                                                if ((2147483647 - s | 0) < (0 | s)) return 1
                                            } else if ((-2147483648 - s | 0) > (0 | s)) return 1;
                                            if (n = s << 1, (0 | o) > 0) {
                                                if ((2147483647 - o | 0) < (0 | o)) return 1;
                                                if ((2147483647 - (o << 1) | 0) < (0 | o)) return 1
                                            } else {
                                                if ((-2147483648 - o | 0) > (0 | o)) return 1;
                                                if ((-2147483648 - (o << 1) | 0) > (0 | o)) return 1
                                            }
                                            if (a = 3 * o | 0, r) {
                                                if ((2147483647 - n | 0) < (0 | o)) return 1
                                            } else if ((-2147483648 - n | 0) > (0 | o)) return 1;
                                            if ((0 | o) > -1) {
                                                if ((-2147483648 | a | 0) < (0 | s)) {
                                                    r = a;
                                                    break
                                                }
                                                return 1
                                            }
                                            if (!((-2147483648 ^ a | 0) < (0 | s))) {
                                                r = a;
                                                break
                                            }
                                            return 1
                                        }
                                        r = 3 * o | 0, n = s << 1
                                    } while (0);
                                    a = 0 | Ce(+(n + o | 0) / 7), i[t >> 2] = a, o = 0 | Ce(+(r - s | 0) / 7), i[l >> 2] = o, i[e >> 2] = 0, n = (r = (0 | o) < (0 | a)) ? a : o, r = r ? o : a;
                                    do {
                                        if ((0 | r) < 0) {
                                            if ((0 | n) > 0) {
                                                if ((-2147483648 | n | 0) < (0 | r) & -2147483648 != (0 | r) & (2147483647 - n | 0) >= (0 | r)) break;
                                                E(23313, 22444, 404, 22469)
                                            }
                                            if (-2147483648 == (0 | r) | (-2147483648 - n | 0) > (0 | r) && E(23313, 22444, 404, 22469), (0 | n) > -1) {
                                                if ((-2147483648 | n | 0) < (0 | r)) break;
                                                E(23313, 22444, 404, 22469)
                                            } else {
                                                if ((-2147483648 ^ n | 0) >= (0 | r)) break;
                                                E(23313, 22444, 404, 22469)
                                            }
                                        }
                                    } while (0);
                                    return n = o - a | 0, (0 | a) < 0 ? (r = 0 - a | 0, i[l >> 2] = n, i[e >> 2] = r, i[t >> 2] = 0, a = 0) : (n = o, r = 0), (0 | n) < 0 && (a = a - n | 0, i[t >> 2] = a, r = r - n | 0, i[e >> 2] = r, i[l >> 2] = 0, n = 0), s = a - r | 0, o = n - r | 0, (0 | r) < 0 ? (i[t >> 2] = s, i[l >> 2] = o, i[e >> 2] = 0, n = o, o = s, r = 0) : o = a, (0 | (a = (0 | r) < (0 | (a = (0 | n) < (0 | o) ? n : o)) ? r : a)) <= 0 || (i[t >> 2] = o - a, i[l >> 2] = n - a, i[e >> 2] = r - a), 0
                                }

                                function st(t) {
                                    var e, n, r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    a = 0 | i[(e = 8 + (t |= 0) | 0) >> 2], o = 0 | Ce(+((3 * (r = (0 | i[t >> 2]) - a | 0) | 0) - (a = (0 | i[(n = t + 4 | 0) >> 2]) - a | 0) | 0) / 7), i[t >> 2] = o, r = 0 | Ce(+((a << 1) + r | 0) / 7), i[n >> 2] = r, i[e >> 2] = 0, a = r - o | 0, (0 | o) < 0 ? (l = 0 - o | 0, i[n >> 2] = a, i[e >> 2] = l, i[t >> 2] = 0, r = a, o = 0, a = l) : a = 0, (0 | r) < 0 && (o = o - r | 0, i[t >> 2] = o, a = a - r | 0, i[e >> 2] = a, i[n >> 2] = 0, r = 0), l = o - a | 0, s = r - a | 0, (0 | a) < 0 ? (i[t >> 2] = l, i[n >> 2] = s, i[e >> 2] = 0, r = s, s = l, a = 0) : s = o, (0 | (o = (0 | a) < (0 | (o = (0 | r) < (0 | s) ? r : s)) ? a : o)) <= 0 || (i[t >> 2] = s - o, i[n >> 2] = r - o, i[e >> 2] = a - o)
                                }

                                function lt(t) {
                                    var e, n, r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    a = 0 | i[(e = 8 + (t |= 0) | 0) >> 2], o = 0 | Ce(+(((r = (0 | i[t >> 2]) - a | 0) << 1) + (a = (0 | i[(n = t + 4 | 0) >> 2]) - a | 0) | 0) / 7), i[t >> 2] = o, r = 0 | Ce(+((3 * a | 0) - r | 0) / 7), i[n >> 2] = r, i[e >> 2] = 0, a = r - o | 0, (0 | o) < 0 ? (l = 0 - o | 0, i[n >> 2] = a, i[e >> 2] = l, i[t >> 2] = 0, r = a, o = 0, a = l) : a = 0, (0 | r) < 0 && (o = o - r | 0, i[t >> 2] = o, a = a - r | 0, i[e >> 2] = a, i[n >> 2] = 0, r = 0), l = o - a | 0, s = r - a | 0, (0 | a) < 0 ? (i[t >> 2] = l, i[n >> 2] = s, i[e >> 2] = 0, r = s, s = l, a = 0) : s = o, (0 | (o = (0 | a) < (0 | (o = (0 | r) < (0 | s) ? r : s)) ? a : o)) <= 0 || (i[t >> 2] = s - o, i[n >> 2] = r - o, i[e >> 2] = a - o)
                                }

                                function At(t) {
                                    var e, n, r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    a = 0 | i[(t |= 0) >> 2], o = 0 | i[(n = t + 4 | 0) >> 2], s = 0 | i[(r = t + 8 | 0) >> 2], l = o + (3 * a | 0) | 0, i[t >> 2] = l, o = s + (3 * o | 0) | 0, i[n >> 2] = o, a = (3 * s | 0) + a | 0, i[r >> 2] = a, s = o - l | 0, (0 | l) < 0 ? (a = a - l | 0, i[n >> 2] = s, i[r >> 2] = a, i[t >> 2] = 0, o = s, s = 0) : s = l, (0 | o) < 0 && (s = s - o | 0, i[t >> 2] = s, a = a - o | 0, i[r >> 2] = a, i[n >> 2] = 0, o = 0), e = s - a | 0, l = o - a | 0, (0 | a) < 0 ? (i[t >> 2] = e, i[n >> 2] = l, i[r >> 2] = 0, s = e, a = 0) : l = o, (0 | (o = (0 | a) < (0 | (o = (0 | l) < (0 | s) ? l : s)) ? a : o)) <= 0 || (i[t >> 2] = s - o, i[n >> 2] = l - o, i[r >> 2] = a - o)
                                }

                                function ct(t) {
                                    var e, n, r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    l = 0 | i[(t |= 0) >> 2], s = (3 * (a = 0 | i[(n = t + 4 | 0) >> 2]) | 0) + l | 0, l = (o = 0 | i[(r = t + 8 | 0) >> 2]) + (3 * l | 0) | 0, i[t >> 2] = l, i[n >> 2] = s, a = (3 * o | 0) + a | 0, i[r >> 2] = a, o = s - l | 0, (0 | l) < 0 ? (a = a - l | 0, i[n >> 2] = o, i[r >> 2] = a, i[t >> 2] = 0, l = 0) : o = s, (0 | o) < 0 && (l = l - o | 0, i[t >> 2] = l, a = a - o | 0, i[r >> 2] = a, i[n >> 2] = 0, o = 0), e = l - a | 0, s = o - a | 0, (0 | a) < 0 ? (i[t >> 2] = e, i[n >> 2] = s, i[r >> 2] = 0, l = e, a = 0) : s = o, (0 | (o = (0 | a) < (0 | (o = (0 | s) < (0 | l) ? s : l)) ? a : o)) <= 0 || (i[t >> 2] = l - o, i[n >> 2] = s - o, i[r >> 2] = a - o)
                                }

                                function ut(t, e) {
                                    t |= 0;
                                    var n, r, a, o = 0,
                                        s = 0,
                                        l = 0;
                                    ((e |= 0) - 1 | 0) >>> 0 >= 6 || (l = (0 | i[15440 + (12 * e | 0) >> 2]) + (0 | i[t >> 2]) | 0, i[t >> 2] = l, a = t + 4 | 0, s = (0 | i[15440 + (12 * e | 0) + 4 >> 2]) + (0 | i[a >> 2]) | 0, i[a >> 2] = s, r = t + 8 | 0, e = (0 | i[15440 + (12 * e | 0) + 8 >> 2]) + (0 | i[r >> 2]) | 0, i[r >> 2] = e, o = s - l | 0, (0 | l) < 0 ? (e = e - l | 0, i[a >> 2] = o, i[r >> 2] = e, i[t >> 2] = 0, s = 0) : (o = s, s = l), (0 | o) < 0 && (s = s - o | 0, i[t >> 2] = s, e = e - o | 0, i[r >> 2] = e, i[a >> 2] = 0, o = 0), n = s - e | 0, l = o - e | 0, (0 | e) < 0 ? (i[t >> 2] = n, i[a >> 2] = l, i[r >> 2] = 0, s = n, e = 0) : l = o, (0 | (o = (0 | e) < (0 | (o = (0 | l) < (0 | s) ? l : s)) ? e : o)) <= 0 || (i[t >> 2] = s - o, i[a >> 2] = l - o, i[r >> 2] = e - o))
                                }

                                function ht(t) {
                                    var e, n, r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    l = 0 | i[(t |= 0) >> 2], s = (a = 0 | i[(n = t + 4 | 0) >> 2]) + l | 0, l = (o = 0 | i[(r = t + 8 | 0) >> 2]) + l | 0, i[t >> 2] = l, i[n >> 2] = s, a = o + a | 0, i[r >> 2] = a, o = s - l | 0, (0 | l) < 0 ? (a = a - l | 0, i[n >> 2] = o, i[r >> 2] = a, i[t >> 2] = 0, s = 0) : (o = s, s = l), (0 | o) < 0 && (s = s - o | 0, i[t >> 2] = s, a = a - o | 0, i[r >> 2] = a, i[n >> 2] = 0, o = 0), e = s - a | 0, l = o - a | 0, (0 | a) < 0 ? (i[t >> 2] = e, i[n >> 2] = l, i[r >> 2] = 0, s = e, a = 0) : l = o, (0 | (o = (0 | a) < (0 | (o = (0 | l) < (0 | s) ? l : s)) ? a : o)) <= 0 || (i[t >> 2] = s - o, i[n >> 2] = l - o, i[r >> 2] = a - o)
                                }

                                function dt(t) {
                                    var e, n, r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    a = 0 | i[(t |= 0) >> 2], s = 0 | i[(n = t + 4 | 0) >> 2], o = 0 | i[(r = t + 8 | 0) >> 2], l = s + a | 0, i[t >> 2] = l, s = o + s | 0, i[n >> 2] = s, a = o + a | 0, i[r >> 2] = a, o = s - l | 0, (0 | l) < 0 ? (a = a - l | 0, i[n >> 2] = o, i[r >> 2] = a, i[t >> 2] = 0, s = 0) : (o = s, s = l), (0 | o) < 0 && (s = s - o | 0, i[t >> 2] = s, a = a - o | 0, i[r >> 2] = a, i[n >> 2] = 0, o = 0), e = s - a | 0, l = o - a | 0, (0 | a) < 0 ? (i[t >> 2] = e, i[n >> 2] = l, i[r >> 2] = 0, s = e, a = 0) : l = o, (0 | (o = (0 | a) < (0 | (o = (0 | l) < (0 | s) ? l : s)) ? a : o)) <= 0 || (i[t >> 2] = s - o, i[n >> 2] = l - o, i[r >> 2] = a - o)
                                }

                                function ft(t) {
                                    switch (0 | (t |= 0)) {
                                        case 1:
                                            t = 5;
                                            break;
                                        case 5:
                                            t = 4;
                                            break;
                                        case 4:
                                            t = 6;
                                            break;
                                        case 6:
                                            t = 2;
                                            break;
                                        case 2:
                                            t = 3;
                                            break;
                                        case 3:
                                            t = 1
                                    }
                                    return 0 | t
                                }

                                function pt(t) {
                                    switch (0 | (t |= 0)) {
                                        case 1:
                                            t = 3;
                                            break;
                                        case 3:
                                            t = 2;
                                            break;
                                        case 2:
                                            t = 6;
                                            break;
                                        case 6:
                                            t = 4;
                                            break;
                                        case 4:
                                            t = 5;
                                            break;
                                        case 5:
                                            t = 1
                                    }
                                    return 0 | t
                                }

                                function mt(t) {
                                    var e, n, r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    a = 0 | i[(t |= 0) >> 2], o = 0 | i[(n = t + 4 | 0) >> 2], s = 0 | i[(r = t + 8 | 0) >> 2], l = o + (a << 1) | 0, i[t >> 2] = l, o = s + (o << 1) | 0, i[n >> 2] = o, a = (s << 1) + a | 0, i[r >> 2] = a, s = o - l | 0, (0 | l) < 0 ? (a = a - l | 0, i[n >> 2] = s, i[r >> 2] = a, i[t >> 2] = 0, o = s, s = 0) : s = l, (0 | o) < 0 && (s = s - o | 0, i[t >> 2] = s, a = a - o | 0, i[r >> 2] = a, i[n >> 2] = 0, o = 0), e = s - a | 0, l = o - a | 0, (0 | a) < 0 ? (i[t >> 2] = e, i[n >> 2] = l, i[r >> 2] = 0, s = e, a = 0) : l = o, (0 | (o = (0 | a) < (0 | (o = (0 | l) < (0 | s) ? l : s)) ? a : o)) <= 0 || (i[t >> 2] = s - o, i[n >> 2] = l - o, i[r >> 2] = a - o)
                                }

                                function gt(t) {
                                    var e, n, r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    l = 0 | i[(t |= 0) >> 2], s = ((a = 0 | i[(n = t + 4 | 0) >> 2]) << 1) + l | 0, l = (o = 0 | i[(r = t + 8 | 0) >> 2]) + (l << 1) | 0, i[t >> 2] = l, i[n >> 2] = s, a = (o << 1) + a | 0, i[r >> 2] = a, o = s - l | 0, (0 | l) < 0 ? (a = a - l | 0, i[n >> 2] = o, i[r >> 2] = a, i[t >> 2] = 0, l = 0) : o = s, (0 | o) < 0 && (l = l - o | 0, i[t >> 2] = l, a = a - o | 0, i[r >> 2] = a, i[n >> 2] = 0, o = 0), e = l - a | 0, s = o - a | 0, (0 | a) < 0 ? (i[t >> 2] = e, i[n >> 2] = s, i[r >> 2] = 0, l = e, a = 0) : s = o, (0 | (o = (0 | a) < (0 | (o = (0 | s) < (0 | l) ? s : l)) ? a : o)) <= 0 || (i[t >> 2] = l - o, i[n >> 2] = s - o, i[r >> 2] = a - o)
                                }

                                function vt(t, e) {
                                    e |= 0;
                                    var n, r, a, o = 0,
                                        s = 0,
                                        l = 0;
                                    return a = (0 | (r = (0 | i[(t |= 0) >> 2]) - (0 | i[e >> 2]) | 0)) < 0, n = (0 | (s = (0 | i[t + 4 >> 2]) - (0 | i[e + 4 >> 2]) - (a ? r : 0) | 0)) < 0, e = (e = (t = (0 | (l = (a ? 0 - r | 0 : 0) + (0 | i[t + 8 >> 2]) - (0 | i[e + 8 >> 2]) + (n ? 0 - s | 0 : 0) | 0)) < 0) ? 0 : l) - ((s = (0 | (t = (0 | e) < (0 | (t = (0 | (o = (n ? 0 : s) - (t ? l : 0) | 0)) < (0 | (l = (a ? 0 : r) - (n ? s : 0) - (t ? l : 0) | 0)) ? o : l)) ? e : t)) > 0) ? t : 0) | 0, o = o - (s ? t : 0) | 0, 0 | ((0 | (t = (0 | (t = l - (s ? t : 0) | 0)) > -1 ? t : 0 - t | 0)) > (0 | (e = (0 | (o = (0 | o) > -1 ? o : 0 - o | 0)) > (0 | (e = (0 | e) > -1 ? e : 0 - e | 0)) ? o : e)) ? t : e)
                                }

                                function _t(t, e) {
                                    var n;
                                    e |= 0, n = 0 | i[8 + (t |= 0) >> 2], i[e >> 2] = (0 | i[t >> 2]) - n, i[e + 4 >> 2] = (0 | i[t + 4 >> 2]) - n
                                }

                                function yt(t, e) {
                                    e |= 0;
                                    var n, r, a, o = 0,
                                        s = 0,
                                        l = 0;
                                    s = 0 | i[(t |= 0) >> 2], i[e >> 2] = s, l = 0 | i[t + 4 >> 2], i[(r = e + 4 | 0) >> 2] = l, i[(a = e + 8 | 0) >> 2] = 0, t = (o = (0 | l) < (0 | s)) ? s : l, o = o ? l : s;
                                    do {
                                        if ((0 | o) < 0) {
                                            if ((0 | t) > 0) {
                                                if ((-2147483648 | t | 0) < (0 | o) & -2147483648 != (0 | o) & (2147483647 - t | 0) >= (0 | o)) break;
                                                return 1
                                            }
                                            if (-2147483648 == (0 | o) | (-2147483648 - t | 0) > (0 | o)) return 1;
                                            if ((0 | t) > -1) {
                                                if ((-2147483648 | t | 0) < (0 | o)) break;
                                                return 1
                                            }
                                            if (!((-2147483648 ^ t | 0) < (0 | o))) break;
                                            return 1
                                        }
                                    } while (0);
                                    return t = l - s | 0, (0 | s) < 0 ? (o = 0 - s | 0, i[r >> 2] = t, i[a >> 2] = o, i[e >> 2] = 0, s = 0) : (t = l, o = 0), (0 | t) < 0 && (s = s - t | 0, i[e >> 2] = s, o = o - t | 0, i[a >> 2] = o, i[r >> 2] = 0, t = 0), n = s - o | 0, l = t - o | 0, (0 | o) < 0 ? (i[e >> 2] = n, i[r >> 2] = l, i[a >> 2] = 0, t = l, l = n, o = 0) : l = s, (0 | (s = (0 | o) < (0 | (s = (0 | t) < (0 | l) ? t : l)) ? o : s)) <= 0 || (i[e >> 2] = l - s, i[r >> 2] = t - s, i[a >> 2] = o - s), 0
                                }

                                function xt(t) {
                                    var e, n, r, a;
                                    n = (a = 0 | i[(e = 8 + (t |= 0) | 0) >> 2]) - (0 | i[t >> 2]) | 0, i[t >> 2] = n, t = (0 | i[(r = t + 4 | 0) >> 2]) - a | 0, i[r >> 2] = t, i[e >> 2] = 0 - (t + n)
                                }

                                function bt(t) {
                                    var e, n, r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    r = 0 - (a = 0 | i[(t |= 0) >> 2]) | 0, i[t >> 2] = r, i[(e = t + 8 | 0) >> 2] = 0, s = (o = 0 | i[(n = t + 4 | 0) >> 2]) + a | 0, (0 | a) > 0 ? (i[n >> 2] = s, i[e >> 2] = a, i[t >> 2] = 0, r = 0, o = s) : a = 0, (0 | o) < 0 ? (l = r - o | 0, i[t >> 2] = l, a = a - o | 0, i[e >> 2] = a, i[n >> 2] = 0, s = l - a | 0, r = 0 - a | 0, (0 | a) < 0 ? (i[t >> 2] = s, i[n >> 2] = r, i[e >> 2] = 0, o = r, a = 0) : (o = 0, s = l)) : s = r, (0 | (r = (0 | a) < (0 | (r = (0 | o) < (0 | s) ? o : s)) ? a : r)) <= 0 || (i[t >> 2] = s - r, i[n >> 2] = o - r, i[e >> 2] = a - r)
                                }

                                function Mt(t, e, n) {
                                    n |= 0;
                                    var r, a, o = 0,
                                        s = 0;
                                    return a = D, D = D + 16 | 0, r = a, s = -2130706433 & (e |= 0) | 134217728, !0 & 268435456 == (2013265920 & e | 0) ? (o = 0 | ze(0 | (t |= 0), 0 | e, 56), S(), o = 0 | function(t, e, n) {
                                        n |= 0;
                                        var r, a = 0,
                                            o = 0;
                                        if (r = D, D = D + 16 | 0, o = r, a = 0 | Ut(t |= 0, e |= 0), (n + -1 | 0) >>> 0 > 5) return D = r, -1;
                                        if (1 == (0 | n) & (a = 0 != (0 | a))) return D = r, -1;
                                        do {
                                            if (!(0 | _e(t, e, o))) {
                                                if (a) {
                                                    a = (5 + (0 | i[21936 + (n << 2) >> 2]) - (0 | i[o >> 2]) | 0) % 5 | 0;
                                                    break
                                                }
                                                a = (6 + (0 | i[21968 + (n << 2) >> 2]) - (0 | i[o >> 2]) | 0) % 6 | 0;
                                                break
                                            }
                                            a = -1
                                        } while (0);
                                        return D = r, 0 | (o = a)
                                    }(t, s, 7 & o), -1 == (0 | o) ? (i[n >> 2] = 0, D = a, 0 | (s = 6)) : (0 | Wt(t, s, r) && E(23313, 22484, 282, 22499), e = 0 | ze(0 | t, 0 | e, 52), S(), e &= 15, 0 | Ut(t, s) ? Tt(r, e, o, 2, n) : Lt(r, e, o, 2, n), D = a, 0 | (s = 0))) : (D = a, 0 | (s = 6))
                                }

                                function wt(t, e, n, r) {
                                    e |= 0, r |= 0;
                                    var o, s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0;
                                    if (o = D, D = D + 16 | 0, function(t, e, n) {
                                            e |= 0, n |= 0;
                                            var r, o, s = 0;
                                            o = D, D = D + 32 | 0,
                                                function(t, e) {
                                                    e |= 0;
                                                    var n, r, i = 0;
                                                    i = +a[(t |= 0) >> 3], n = +h(+i), i = +d(+i), a[e + 16 >> 3] = i, i = +a[t + 8 >> 3], r = n * +h(+i), a[e >> 3] = r, i = n * +d(+i), a[e + 8 >> 3] = i
                                                }(t |= 0, r = o), i[e >> 2] = 0, a[n >> 3] = 5, (s = +ve(16400, r)) < +a[n >> 3] && (i[e >> 2] = 0, a[n >> 3] = s), (s = +ve(16424, r)) < +a[n >> 3] && (i[e >> 2] = 1, a[n >> 3] = s), (s = +ve(16448, r)) < +a[n >> 3] && (i[e >> 2] = 2, a[n >> 3] = s), (s = +ve(16472, r)) < +a[n >> 3] && (i[e >> 2] = 3, a[n >> 3] = s), (s = +ve(16496, r)) < +a[n >> 3] && (i[e >> 2] = 4, a[n >> 3] = s), (s = +ve(16520, r)) < +a[n >> 3] && (i[e >> 2] = 5, a[n >> 3] = s), (s = +ve(16544, r)) < +a[n >> 3] && (i[e >> 2] = 6, a[n >> 3] = s), (s = +ve(16568, r)) < +a[n >> 3] && (i[e >> 2] = 7, a[n >> 3] = s), (s = +ve(16592, r)) < +a[n >> 3] && (i[e >> 2] = 8, a[n >> 3] = s), (s = +ve(16616, r)) < +a[n >> 3] && (i[e >> 2] = 9, a[n >> 3] = s), (s = +ve(16640, r)) < +a[n >> 3] && (i[e >> 2] = 10, a[n >> 3] = s), (s = +ve(16664, r)) < +a[n >> 3] && (i[e >> 2] = 11, a[n >> 3] = s), (s = +ve(16688, r)) < +a[n >> 3] && (i[e >> 2] = 12, a[n >> 3] = s), (s = +ve(16712, r)) < +a[n >> 3] && (i[e >> 2] = 13, a[n >> 3] = s), (s = +ve(16736, r)) < +a[n >> 3] && (i[e >> 2] = 14, a[n >> 3] = s), (s = +ve(16760, r)) < +a[n >> 3] && (i[e >> 2] = 15, a[n >> 3] = s), (s = +ve(16784, r)) < +a[n >> 3] && (i[e >> 2] = 16, a[n >> 3] = s), (s = +ve(16808, r)) < +a[n >> 3] && (i[e >> 2] = 17, a[n >> 3] = s), (s = +ve(16832, r)) < +a[n >> 3] && (i[e >> 2] = 18, a[n >> 3] = s), (s = +ve(16856, r)) < +a[n >> 3] ? (i[e >> 2] = 19, a[n >> 3] = s, D = o) : D = o
                                        }(t |= 0, n |= 0, c = o), (l = +p(+(1 - .5 * +a[c >> 3]))) < 1e-16) return i[r >> 2] = 0, i[r + 4 >> 2] = 0, i[r + 8 >> 2] = 0, i[r + 12 >> 2] = 0, void(D = o);
                                    if (c = 0 | i[n >> 2], s = +Kt((s = +a[15920 + (24 * c | 0) >> 3]) - +Kt(+ function(t, e) {
                                            t |= 0;
                                            var n, r, i, o, s;
                                            return o = +a[(e |= 0) >> 3], r = +h(+o), i = +a[e + 8 >> 3] - +a[t + 8 >> 3], s = r * +d(+i), n = +a[t >> 3], + +v(+s, +(+d(+o) * +h(+n) - +h(+i) * (r * +d(+n))))
                                        }(15600 + (c << 4) | 0, t))), A = 0 | jt(e) ? +Kt(s + -.3334731722518321) : s, s = +f(+l) / .381966011250105, (0 | e) > 0) {
                                        t = 0;
                                        do {
                                            s *= 2.6457513110645907, t = t + 1 | 0
                                        } while ((0 | t) != (0 | e))
                                    }
                                    l = +h(+A) * s, a[r >> 3] = l, A = +d(+A) * s, a[r + 8 >> 3] = A, D = o
                                }

                                function St(t, e, n, r, o) {
                                    e |= 0, n |= 0, r |= 0, o |= 0;
                                    var s = 0,
                                        l = 0;
                                    if (s = + function(t) {
                                            var e, n;
                                            return n = +a[(t |= 0) >> 3], e = +a[t + 8 >> 3], + +c(+(n * n + e * e))
                                        }(t |= 0), s < 1e-16) return e = 15600 + (e << 4) | 0, i[o >> 2] = i[e >> 2], i[o + 4 >> 2] = i[e + 4 >> 2], i[o + 8 >> 2] = i[e + 8 >> 2], void(i[o + 12 >> 2] = i[e + 12 >> 2]);
                                    if (l = +v(+ +a[t + 8 >> 3], + +a[t >> 3]), (0 | n) > 0) {
                                        t = 0;
                                        do {
                                            s /= 2.6457513110645907, t = t + 1 | 0
                                        } while ((0 | t) != (0 | n))
                                    }
                                    r ? (s /= 3, n = 0 == (0 | jt(n)), s = +g(.381966011250105 * (n ? s : s / 2.6457513110645907))) : (s = +g(.381966011250105 * s), 0 | jt(n) && (l = +Kt(l + .3334731722518321))),
                                        function(t, e, n, r) {
                                            t |= 0, e = +e, r |= 0;
                                            var o = 0,
                                                s = 0,
                                                l = 0,
                                                c = 0;
                                            if ((n = +n) < 1e-16) return i[r >> 2] = i[t >> 2], i[r + 4 >> 2] = i[t + 4 >> 2], i[r + 8 >> 2] = i[t + 8 >> 2], void(i[r + 12 >> 2] = i[t + 12 >> 2]);
                                            s = e < 0 ? e + 6.283185307179586 : e, s = e >= 6.283185307179586 ? s + -6.283185307179586 : s;
                                            do {
                                                if (!(s < 1e-16)) {
                                                    if (o = +A(+(s + -3.141592653589793)) < 1e-16, e = +a[t >> 3], o) {
                                                        e -= n, a[r >> 3] = e, o = r;
                                                        break
                                                    }
                                                    if (l = +h(+n), n = +d(+n), e = l * +d(+e) + +h(+s) * (n * +h(+e)), e = +m(+((e = e > 1 ? 1 : e) < -1 ? -1 : e)), a[r >> 3] = e, +A(+(e + -1.5707963267948966)) < 1e-16) return a[r >> 3] = 1.5707963267948966, void(a[r + 8 >> 3] = 0);
                                                    if (+A(+(e + 1.5707963267948966)) < 1e-16) return a[r >> 3] = -1.5707963267948966, void(a[r + 8 >> 3] = 0);
                                                    if (c = +h(+e), s = n * +d(+s) / c, n = +a[t >> 3], e = (l - +d(+e) * +d(+n)) / +h(+n) / c, l = s > 1 ? 1 : s, e = e > 1 ? 1 : e, (e = +a[t + 8 >> 3] + +v(+(l < -1 ? -1 : l), +(e < -1 ? -1 : e))) > 3.141592653589793)
                                                        do {
                                                            e += -6.283185307179586
                                                        } while (e > 3.141592653589793);
                                                    if (e < -3.141592653589793)
                                                        do {
                                                            e += 6.283185307179586
                                                        } while (e < -3.141592653589793);
                                                    return void(a[r + 8 >> 3] = e)
                                                }
                                                e = +a[t >> 3] + n, a[r >> 3] = e, o = r
                                            } while (0);
                                            if (+A(+(e + -1.5707963267948966)) < 1e-16) return a[o >> 3] = 1.5707963267948966, void(a[r + 8 >> 3] = 0);
                                            if (+A(+(e + 1.5707963267948966)) < 1e-16) return a[o >> 3] = -1.5707963267948966, void(a[r + 8 >> 3] = 0);
                                            if ((e = +a[t + 8 >> 3]) > 3.141592653589793)
                                                do {
                                                    e += -6.283185307179586
                                                } while (e > 3.141592653589793);
                                            if (e < -3.141592653589793)
                                                do {
                                                    e += 6.283185307179586
                                                } while (e < -3.141592653589793);
                                            a[r + 8 >> 3] = e
                                        }(15600 + (e << 4) | 0, +Kt(+a[15920 + (24 * e | 0) >> 3] - l), s, o)
                                }

                                function Et(t, e, n) {
                                    var r, a;
                                    e |= 0, n |= 0, r = D, D = D + 16 | 0, tt(4 + (t |= 0) | 0, a = r), St(a, 0 | i[t >> 2], e, 0, n), D = r
                                }

                                function Tt(t, e, n, r, o) {
                                    t |= 0, e |= 0, n |= 0, r |= 0, o |= 0;
                                    var s, l, A, c, u, h, d, f, p, m, g, v, _, y, x, b, M, w, S, T, C, R, P = 0,
                                        L = 0,
                                        I = 0,
                                        O = 0,
                                        B = 0,
                                        q = 0;
                                    if (R = D, D = D + 272 | 0, O = R + 240 | 0, S = R, T = R + 224 | 0, C = R + 208 | 0, g = R + 176 | 0, v = R + 160 | 0, _ = R + 192 | 0, y = R + 144 | 0, x = R + 128 | 0, b = R + 112 | 0, M = R + 96 | 0, w = R + 80 | 0, i[(P = R + 256 | 0) >> 2] = e, i[O >> 2] = i[t >> 2], i[O + 4 >> 2] = i[t + 4 >> 2], i[O + 8 >> 2] = i[t + 8 >> 2], i[O + 12 >> 2] = i[t + 12 >> 2], Ct(O, P, S), i[o >> 2] = 0, (0 | (O = r + n + (5 == (0 | r) & 1) | 0)) <= (0 | n)) D = R;
                                    else {
                                        l = T + 4 | 0, A = g + 4 | 0, c = n + 5 | 0, u = 16880 + ((s = 0 | i[P >> 2]) << 2) | 0, h = 16960 + (s << 2) | 0, d = x + 8 | 0, f = b + 8 | 0, p = M + 8 | 0, m = C + 4 | 0, I = n;
                                        t: for (;;) {
                                            L = S + (((0 | I) % 5 | 0) << 4) | 0, i[C >> 2] = i[L >> 2], i[C + 4 >> 2] = i[L + 4 >> 2], i[C + 8 >> 2] = i[L + 8 >> 2], i[C + 12 >> 2] = i[L + 12 >> 2];
                                            do {} while (2 == (0 | Rt(C, s, 0, 1)));
                                            if ((0 | I) > (0 | n) & 0 != (0 | jt(e))) {
                                                if (i[g >> 2] = i[C >> 2], i[g + 4 >> 2] = i[C + 4 >> 2], i[g + 8 >> 2] = i[C + 8 >> 2], i[g + 12 >> 2] = i[C + 12 >> 2], tt(l, v), r = 0 | i[g >> 2], P = 0 | i[17040 + (80 * r | 0) + (i[T >> 2] << 2) >> 2], i[g >> 2] = i[18640 + (80 * r | 0) + (20 * P | 0) >> 2], (0 | (L = 0 | i[18640 + (80 * r | 0) + (20 * P | 0) + 16 >> 2])) > 0) {
                                                    t = 0;
                                                    do {
                                                        ht(A), t = t + 1 | 0
                                                    } while ((0 | t) < (0 | L))
                                                }
                                                switch (L = 18640 + (80 * r | 0) + (20 * P | 0) + 4 | 0, i[_ >> 2] = i[L >> 2], i[_ + 4 >> 2] = i[L + 4 >> 2], i[_ + 8 >> 2] = i[L + 8 >> 2], rt(_, 3 * (0 | i[u >> 2]) | 0), et(A, _, A), $(A), tt(A, y), B = +(0 | i[h >> 2]), a[x >> 3] = 3 * B, a[d >> 3] = 0, q = -1.5 * B, a[b >> 3] = q, a[f >> 3] = 2.598076211353316 * B, a[M >> 3] = q, a[p >> 3] = -2.598076211353316 * B, 0 | i[17040 + (80 * (0 | i[g >> 2]) | 0) + (i[C >> 2] << 2) >> 2]) {
                                                    case 1:
                                                        t = b, r = x;
                                                        break;
                                                    case 3:
                                                        t = M, r = b;
                                                        break;
                                                    case 2:
                                                        t = x, r = M;
                                                        break;
                                                    default:
                                                        t = 12;
                                                        break t
                                                }
                                                me(v, y, r, t, w), St(w, 0 | i[g >> 2], s, 1, o + 8 + (i[o >> 2] << 4) | 0), i[o >> 2] = 1 + (0 | i[o >> 2])
                                            }
                                            if ((0 | I) < (0 | c) && (tt(m, g), St(g, 0 | i[C >> 2], s, 1, o + 8 + (i[o >> 2] << 4) | 0), i[o >> 2] = 1 + (0 | i[o >> 2])), i[T >> 2] = i[C >> 2], i[T + 4 >> 2] = i[C + 4 >> 2], i[T + 8 >> 2] = i[C + 8 >> 2], i[T + 12 >> 2] = i[C + 12 >> 2], (0 | (I = I + 1 | 0)) >= (0 | O)) {
                                                t = 3;
                                                break
                                            }
                                        }
                                        3 != (0 | t) ? 12 == (0 | t) && E(22522, 22569, 571, 22579) : D = R
                                    }
                                }

                                function Ct(t, e, n) {
                                    t |= 0, e |= 0, n |= 0;
                                    var r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0;
                                    r = D, D = D + 128 | 0, o = r, l = 20240, A = 60 + (s = a = r + 64 | 0) | 0;
                                    do {
                                        i[s >> 2] = i[l >> 2], s = s + 4 | 0, l = l + 4 | 0
                                    } while ((0 | s) < (0 | A));
                                    l = 20304, A = (s = o) + 60 | 0;
                                    do {
                                        i[s >> 2] = i[l >> 2], s = s + 4 | 0, l = l + 4 | 0
                                    } while ((0 | s) < (0 | A));
                                    a = (A = 0 == (0 | jt(0 | i[e >> 2]))) ? a : o, mt(o = t + 4 | 0), gt(o), 0 | jt(0 | i[e >> 2]) && (ct(o), i[e >> 2] = 1 + (0 | i[e >> 2])), i[n >> 2] = i[t >> 2], et(o, a, e = n + 4 | 0), $(e), i[n + 16 >> 2] = i[t >> 2], et(o, a + 12 | 0, e = n + 20 | 0), $(e), i[n + 32 >> 2] = i[t >> 2], et(o, a + 24 | 0, e = n + 36 | 0), $(e), i[n + 48 >> 2] = i[t >> 2], et(o, a + 36 | 0, e = n + 52 | 0), $(e), i[n + 64 >> 2] = i[t >> 2], et(o, a + 48 | 0, n = n + 68 | 0), $(n), D = r
                                }

                                function Rt(t, e, n, r) {
                                    n |= 0, r |= 0;
                                    var a, o, s, l, A, c, u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0;
                                    if (c = D, D = D + 32 | 0, A = c + 12 | 0, o = c, p = 4 + (t |= 0) | 0, f = 0 | i[16960 + ((e |= 0) << 2) >> 2], f = (l = 0 != (0 | r)) ? 3 * f | 0 : f, u = 0 | i[p >> 2], a = 0 | i[(s = t + 8 | 0) >> 2], l) {
                                        if ((0 | (u = a + u + (r = 0 | i[(h = t + 12 | 0) >> 2]) | 0)) == (0 | f)) return D = c, 1;
                                        d = h
                                    } else u = a + u + (r = 0 | i[(d = t + 12 | 0) >> 2]) | 0;
                                    if ((0 | u) <= (0 | f)) return D = c, 0;
                                    do {
                                        if ((0 | r) > 0) {
                                            if (r = 0 | i[t >> 2], (0 | a) > 0) {
                                                h = 18640 + (80 * r | 0) + 60 | 0, r = t;
                                                break
                                            }
                                            r = 18640 + (80 * r | 0) + 40 | 0, n ? (J(A, f, 0, 0), nt(p, A, o), dt(o), et(o, A, p), h = r, r = t) : (h = r, r = t)
                                        } else h = 18640 + (80 * (0 | i[t >> 2]) | 0) + 20 | 0, r = t
                                    } while (0);
                                    if (i[r >> 2] = i[h >> 2], (0 | i[(u = h + 16 | 0) >> 2]) > 0) {
                                        r = 0;
                                        do {
                                            ht(p), r = r + 1 | 0
                                        } while ((0 | r) < (0 | i[u >> 2]))
                                    }
                                    return t = h + 4 | 0, i[A >> 2] = i[t >> 2], i[A + 4 >> 2] = i[t + 4 >> 2], i[A + 8 >> 2] = i[t + 8 >> 2], e = 0 | i[16880 + (e << 2) >> 2], rt(A, l ? 3 * e | 0 : e), et(p, A, p), $(p), r = l && ((0 | i[s >> 2]) + (0 | i[p >> 2]) + (0 | i[d >> 2]) | 0) == (0 | f) ? 1 : 2, D = c, 0 | r
                                }

                                function Pt(t, e) {
                                    t |= 0, e |= 0;
                                    var n = 0;
                                    do {
                                        n = 0 | Rt(t, e, 0, 1)
                                    } while (2 == (0 | n));
                                    return 0 | n
                                }

                                function Lt(t, e, n, r, o) {
                                    t |= 0, e |= 0, n |= 0, r |= 0, o |= 0;
                                    var s, l, A, c, u, h, d, f, p, m, g, v, _, y, x, b, M, w, S = 0,
                                        T = 0,
                                        C = 0,
                                        R = 0,
                                        P = 0;
                                    if (w = D, D = D + 240 | 0, y = w + 208 | 0, x = w, b = w + 192 | 0, M = w + 176 | 0, p = w + 160 | 0, m = w + 144 | 0, g = w + 128 | 0, v = w + 112 | 0, _ = w + 96 | 0, i[(S = w + 224 | 0) >> 2] = e, i[y >> 2] = i[t >> 2], i[y + 4 >> 2] = i[t + 4 >> 2], i[y + 8 >> 2] = i[t + 8 >> 2], i[y + 12 >> 2] = i[t + 12 >> 2], Dt(y, S, x), i[o >> 2] = 0, (0 | (f = r + n + (6 == (0 | r) & 1) | 0)) <= (0 | n)) D = w;
                                    else {
                                        l = n + 6 | 0, A = 16960 + ((s = 0 | i[S >> 2]) << 2) | 0, c = m + 8 | 0, u = g + 8 | 0, h = v + 8 | 0, d = b + 4 | 0, T = 0, C = n, r = -1;
                                        t: for (;;) {
                                            if (t = x + ((S = (0 | C) % 6 | 0) << 4) | 0, i[b >> 2] = i[t >> 2], i[b + 4 >> 2] = i[t + 4 >> 2], i[b + 8 >> 2] = i[t + 8 >> 2], i[b + 12 >> 2] = i[t + 12 >> 2], t = T, T = 0 | Rt(b, s, 0, 1), (0 | C) > (0 | n) & 0 != (0 | jt(e)) && 1 != (0 | t) && (0 | i[b >> 2]) != (0 | r)) {
                                                switch (tt(x + (((S + 5 | 0) % 6 | 0) << 4) + 4 | 0, M), tt(x + (S << 4) + 4 | 0, p), R = +(0 | i[A >> 2]), a[m >> 3] = 3 * R, a[c >> 3] = 0, P = -1.5 * R, a[g >> 3] = P, a[u >> 3] = 2.598076211353316 * R, a[v >> 3] = P, a[h >> 3] = -2.598076211353316 * R, S = 0 | i[y >> 2], 0 | i[17040 + (80 * S | 0) + (((0 | r) == (0 | S) ? 0 | i[b >> 2] : r) << 2) >> 2]) {
                                                    case 1:
                                                        t = g, r = m;
                                                        break;
                                                    case 3:
                                                        t = v, r = g;
                                                        break;
                                                    case 2:
                                                        t = m, r = v;
                                                        break;
                                                    default:
                                                        t = 8;
                                                        break t
                                                }
                                                me(M, p, r, t, _), 0 | ge(M, _) || 0 | ge(p, _) || (St(_, 0 | i[y >> 2], s, 1, o + 8 + (i[o >> 2] << 4) | 0), i[o >> 2] = 1 + (0 | i[o >> 2]))
                                            }
                                            if ((0 | C) < (0 | l) && (tt(d, M), St(M, 0 | i[b >> 2], s, 1, o + 8 + (i[o >> 2] << 4) | 0), i[o >> 2] = 1 + (0 | i[o >> 2])), (0 | (C = C + 1 | 0)) >= (0 | f)) {
                                                t = 3;
                                                break
                                            }
                                            r = 0 | i[b >> 2]
                                        }
                                        3 != (0 | t) ? 8 == (0 | t) && E(22606, 22569, 736, 22651) : D = w
                                    }
                                }

                                function Dt(t, e, n) {
                                    t |= 0, e |= 0, n |= 0;
                                    var r, a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0;
                                    r = D, D = D + 160 | 0, o = r, l = 20368, A = 72 + (s = a = r + 80 | 0) | 0;
                                    do {
                                        i[s >> 2] = i[l >> 2], s = s + 4 | 0, l = l + 4 | 0
                                    } while ((0 | s) < (0 | A));
                                    l = 20448, A = (s = o) + 72 | 0;
                                    do {
                                        i[s >> 2] = i[l >> 2], s = s + 4 | 0, l = l + 4 | 0
                                    } while ((0 | s) < (0 | A));
                                    a = (A = 0 == (0 | jt(0 | i[e >> 2]))) ? a : o, mt(o = t + 4 | 0), gt(o), 0 | jt(0 | i[e >> 2]) && (ct(o), i[e >> 2] = 1 + (0 | i[e >> 2])), i[n >> 2] = i[t >> 2], et(o, a, e = n + 4 | 0), $(e), i[n + 16 >> 2] = i[t >> 2], et(o, a + 12 | 0, e = n + 20 | 0), $(e), i[n + 32 >> 2] = i[t >> 2], et(o, a + 24 | 0, e = n + 36 | 0), $(e), i[n + 48 >> 2] = i[t >> 2], et(o, a + 36 | 0, e = n + 52 | 0), $(e), i[n + 64 >> 2] = i[t >> 2], et(o, a + 48 | 0, e = n + 68 | 0), $(e), i[n + 80 >> 2] = i[t >> 2], et(o, a + 60 | 0, n = n + 84 | 0), $(n), D = r
                                }

                                function It(t, e) {
                                    return e = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 45), S(), 127 & e | 0
                                }

                                function Ot(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0;
                                    if (!(!0 & 134217728 == (-16777216 & (e |= 0) | 0))) return 0;
                                    if (o = 0 | ze(0 | (t |= 0), 0 | e, 45), S(), (o &= 127) >>> 0 > 121) return 0;
                                    n = 0 | ze(0 | t, 0 | e, 52), S(), n &= 15;
                                    do {
                                        if (0 | n) {
                                            for (i = 1, r = 0;;) {
                                                if (a = 0 | ze(0 | t, 0 | e, 3 * (15 - i | 0) | 0), S(), 0 != (0 | (a &= 7)) & (1 ^ r)) {
                                                    if (1 == (0 | a) & 0 != (0 | F(o))) {
                                                        s = 0, r = 13;
                                                        break
                                                    }
                                                    r = 1
                                                }
                                                if (7 == (0 | a)) {
                                                    s = 0, r = 13;
                                                    break
                                                }
                                                if (!(i >>> 0 < n >>> 0)) {
                                                    r = 9;
                                                    break
                                                }
                                                i = i + 1 | 0
                                            }
                                            if (9 == (0 | r)) {
                                                if (15 != (0 | n)) break;
                                                return 1
                                            }
                                            if (13 == (0 | r)) return 0 | s
                                        }
                                    } while (0);
                                    for (;;) {
                                        if (s = 0 | ze(0 | t, 0 | e, 3 * (14 - n | 0) | 0), S(), !(7 == (7 & s | 0) & !0)) {
                                            s = 0, r = 13;
                                            break
                                        }
                                        if (!(n >>> 0 < 14)) {
                                            s = 1, r = 13;
                                            break
                                        }
                                        n = n + 1 | 0
                                    }
                                    return 13 == (0 | r) ? 0 | s : 0
                                }

                                function Bt(t, e, n, r) {
                                    n |= 0, r |= 0;
                                    var a = 0,
                                        o = 0;
                                    if (o = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), n >>> 0 > 15) return 4;
                                    if ((0 | (o &= 15)) < (0 | n)) return 12;
                                    if ((0 | o) == (0 | n)) return i[r >> 2] = t, i[r + 4 >> 2] = e, 0;
                                    if (a = 0 | Ge(0 | n, 0, 52), a |= t, t = 0 | S() | -15728641 & e, (0 | o) > (0 | n))
                                        do {
                                            e = 0 | Ge(7, 0, 3 * (14 - n | 0) | 0), n = n + 1 | 0, a |= e, t = 0 | S() | t
                                        } while ((0 | n) < (0 | o));
                                    return i[r >> 2] = a, i[r + 4 >> 2] = t, 0
                                }

                                function qt(t, e, n, r) {
                                    n |= 0, r |= 0;
                                    var a = 0,
                                        o = 0,
                                        s = 0;
                                    if (o = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), !((0 | n) < 16 & (0 | (o &= 15)) <= (0 | n))) return 4;
                                    a = n - o | 0, n = 0 | ze(0 | t, 0 | e, 45), S();
                                    t: do {
                                        if (0 | F(127 & n)) {
                                            e: do {
                                                if (0 | o) {
                                                    for (n = 1; 0 == ((s = 0 | Ge(7, 0, 3 * (15 - n | 0) | 0)) & t | 0) & 0 == ((0 | S()) & e | 0);) {
                                                        if (!(n >>> 0 < o >>> 0)) break e;
                                                        n = n + 1 | 0
                                                    }
                                                    n = 0 | ue(7, 0, a, ((0 | a) < 0) << 31 >> 31), a = 0 | S();
                                                    break t
                                                }
                                            } while (0);n = 0 | De(0 | (n = 0 | Ue(0 | (n = 0 | ue(7, 0, a, ((0 | a) < 0) << 31 >> 31)), 0 | S(), 5, 0)), 0 | S(), -5, -1),
                                            n = 0 | De(0 | (n = 0 | qe(0 | n, 0 | S(), 6, 0)), 0 | S(), 1, 0),
                                            a = 0 | S()
                                        }
                                        else n = 0 | ue(7, 0, a, ((0 | a) < 0) << 31 >> 31), a = 0 | S()
                                    } while (0);
                                    return i[(s = r) >> 2] = n, i[s + 4 >> 2] = a, 0
                                }

                                function Ut(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0;
                                    if (i = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 45), S(), !(0 | F(127 & i))) return 0;
                                    i = 0 | ze(0 | t, 0 | e, 52), S(), i &= 15;
                                    t: do {
                                        if (i)
                                            for (r = 1;;) {
                                                if (n = 0 | ze(0 | t, 0 | e, 3 * (15 - r | 0) | 0), S(), 0 | (n &= 7)) break t;
                                                if (!(r >>> 0 < i >>> 0)) {
                                                    n = 0;
                                                    break
                                                }
                                                r = r + 1 | 0
                                            } else n = 0
                                    } while (0);
                                    return 0 | 0 == (0 | n) & 1
                                }

                                function Nt(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0;
                                    if (i = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), !(i &= 15)) return 0;
                                    for (r = 1;;) {
                                        if (n = 0 | ze(0 | t, 0 | e, 3 * (15 - r | 0) | 0), S(), 0 | (n &= 7)) {
                                            r = 5;
                                            break
                                        }
                                        if (!(r >>> 0 < i >>> 0)) {
                                            n = 0, r = 5;
                                            break
                                        }
                                        r = r + 1 | 0
                                    }
                                    return 5 == (0 | r) ? 0 | n : 0
                                }

                                function kt(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    if (l = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), !(l &= 15)) return l = t, w(0 | (s = e)), 0 | l;
                                    for (s = 1, n = 0;;) {
                                        r = 0 | Ge(7, 0, 0 | (a = 3 * (15 - s | 0) | 0)), i = 0 | S(), o = 0 | ze(0 | t, 0 | e, 0 | a), S(), t = (a = 0 | Ge(0 | ft(7 & o), 0, 0 | a)) | t & ~r, e = (o = 0 | S()) | e & ~i;
                                        t: do {
                                            if (!n)
                                                if (0 == (a & r | 0) & 0 == (o & i | 0)) n = 0;
                                                else if (r = 0 | ze(0 | t, 0 | e, 52), S(), r &= 15) {
                                                n = 1;
                                                e: for (;;) {
                                                    switch (o = 0 | ze(0 | t, 0 | e, 3 * (15 - n | 0) | 0), S(), 7 & o) {
                                                        case 1:
                                                            break e;
                                                        case 0:
                                                            break;
                                                        default:
                                                            n = 1;
                                                            break t
                                                    }
                                                    if (!(n >>> 0 < r >>> 0)) {
                                                        n = 1;
                                                        break t
                                                    }
                                                    n = n + 1 | 0
                                                }
                                                for (n = 1;;) {
                                                    if (i = 0 | ze(0 | t, 0 | e, 0 | (o = 3 * (15 - n | 0) | 0)), S(), a = 0 | Ge(7, 0, 0 | o), e &= ~(0 | S()), t = t & ~a | (o = 0 | Ge(0 | ft(7 & i), 0, 0 | o)), e = 0 | e | S(), !(n >>> 0 < r >>> 0)) {
                                                        n = 1;
                                                        break
                                                    }
                                                    n = n + 1 | 0
                                                }
                                            } else n = 1
                                        } while (0);
                                        if (!(s >>> 0 < l >>> 0)) break;
                                        s = s + 1 | 0
                                    }
                                    return w(0 | e), 0 | t
                                }

                                function Ft(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0,
                                        a = 0,
                                        o = 0;
                                    if (r = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), !(r &= 15)) return r = t, w(0 | (n = e)), 0 | r;
                                    for (n = 1; o = 0 | ze(0 | t, 0 | e, 0 | (a = 3 * (15 - n | 0) | 0)), S(), i = 0 | Ge(7, 0, 0 | a), e &= ~(0 | S()), t = (a = 0 | Ge(0 | ft(7 & o), 0, 0 | a)) | t & ~i, e = 0 | S() | e, n >>> 0 < r >>> 0;) n = n + 1 | 0;
                                    return w(0 | e), 0 | t
                                }

                                function zt(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0;
                                    if (l = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), !(l &= 15)) return l = t, w(0 | (s = e)), 0 | l;
                                    for (s = 1, n = 0;;) {
                                        r = 0 | Ge(7, 0, 0 | (a = 3 * (15 - s | 0) | 0)), i = 0 | S(), o = 0 | ze(0 | t, 0 | e, 0 | a), S(), t = (a = 0 | Ge(0 | pt(7 & o), 0, 0 | a)) | t & ~r, e = (o = 0 | S()) | e & ~i;
                                        t: do {
                                            if (!n)
                                                if (0 == (a & r | 0) & 0 == (o & i | 0)) n = 0;
                                                else if (r = 0 | ze(0 | t, 0 | e, 52), S(), r &= 15) {
                                                n = 1;
                                                e: for (;;) {
                                                    switch (o = 0 | ze(0 | t, 0 | e, 3 * (15 - n | 0) | 0), S(), 7 & o) {
                                                        case 1:
                                                            break e;
                                                        case 0:
                                                            break;
                                                        default:
                                                            n = 1;
                                                            break t
                                                    }
                                                    if (!(n >>> 0 < r >>> 0)) {
                                                        n = 1;
                                                        break t
                                                    }
                                                    n = n + 1 | 0
                                                }
                                                for (n = 1;;) {
                                                    if (a = 0 | Ge(7, 0, 0 | (i = 3 * (15 - n | 0) | 0)), o = e & ~(0 | S()), e = 0 | ze(0 | t, 0 | e, 0 | i), S(), t = t & ~a | (e = 0 | Ge(0 | pt(7 & e), 0, 0 | i)), e = 0 | o | S(), !(n >>> 0 < r >>> 0)) {
                                                        n = 1;
                                                        break
                                                    }
                                                    n = n + 1 | 0
                                                }
                                            } else n = 1
                                        } while (0);
                                        if (!(s >>> 0 < l >>> 0)) break;
                                        s = s + 1 | 0
                                    }
                                    return w(0 | e), 0 | t
                                }

                                function Gt(t, e) {
                                    var n = 0,
                                        r = 0,
                                        i = 0,
                                        a = 0,
                                        o = 0;
                                    if (r = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), !(r &= 15)) return r = t, w(0 | (n = e)), 0 | r;
                                    for (n = 1; a = 0 | Ge(7, 0, 0 | (o = 3 * (15 - n | 0) | 0)), i = e & ~(0 | S()), e = 0 | ze(0 | t, 0 | e, 0 | o), S(), t = (e = 0 | Ge(0 | pt(7 & e), 0, 0 | o)) | t & ~a, e = 0 | S() | i, n >>> 0 < r >>> 0;) n = n + 1 | 0;
                                    return w(0 | e), 0 | t
                                }

                                function jt(t) {
                                    return 0 | (0 | (t |= 0)) % 2
                                }

                                function Vt(t, e, n) {
                                    n |= 0;
                                    var r, a = 0;
                                    return r = D, D = D + 16 | 0, a = r, (e |= 0) >>> 0 > 15 ? (D = r, 0 | (a = 4)) : 2146435072 == (2146435072 & i[4 + (t |= 0) >> 2] | 0) || 2146435072 == (2146435072 & i[t + 8 + 4 >> 2] | 0) ? (D = r, 0 | (a = 3)) : (function(t, e, n) {
                                        var r, i;
                                        r = D, D = D + 16 | 0, wt(t |= 0, e |= 0, n |= 0, i = r), K(i, n + 4 | 0), D = r
                                    }(t, e, a), e = 0 | function(t, e) {
                                        t |= 0;
                                        var n, r = 0,
                                            a = 0,
                                            o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0;
                                        if (n = D, D = D + 64 | 0, A = n + 40 | 0, a = n + 24 | 0, o = n + 12 | 0, s = n, Ge(0 | (e |= 0), 0, 52), r = 134225919 | S(), !e) return (0 | i[t + 4 >> 2]) > 2 || (0 | i[t + 8 >> 2]) > 2 || (0 | i[t + 12 >> 2]) > 2 ? (A = 0, w(0 | (l = 0)), D = n, 0 | A) : (Ge(0 | G(t), 0, 45), l = 0 | S() | r, A = -1, w(0 | l), D = n, 0 | A);
                                        if (i[A >> 2] = i[t >> 2], i[A + 4 >> 2] = i[t + 4 >> 2], i[A + 8 >> 2] = i[t + 8 >> 2], i[A + 12 >> 2] = i[t + 12 >> 2], l = A + 4 | 0, (0 | e) > 0)
                                            for (t = -1; i[a >> 2] = i[l >> 2], i[a + 4 >> 2] = i[l + 4 >> 2], i[a + 8 >> 2] = i[l + 8 >> 2], 1 & e ? (st(l), i[o >> 2] = i[l >> 2], i[o + 4 >> 2] = i[l + 4 >> 2], i[o + 8 >> 2] = i[l + 8 >> 2], At(o)) : (lt(l), i[o >> 2] = i[l >> 2], i[o + 4 >> 2] = i[l + 4 >> 2], i[o + 8 >> 2] = i[l + 8 >> 2], ct(o)), nt(a, o, s), $(s), c = 0 | Ge(7, 0, 0 | (u = 3 * (15 - e | 0) | 0)), r &= ~(0 | S()), t = (u = 0 | Ge(0 | it(s), 0, 0 | u)) | t & ~c, r = 0 | S() | r, (0 | e) > 1;) e = e + -1 | 0;
                                        else t = -1;
                                        t: do {
                                            if ((0 | i[l >> 2]) <= 2 && (0 | i[A + 8 >> 2]) <= 2 && (0 | i[A + 12 >> 2]) <= 2) {
                                                if (e = 0 | Ge(0 | (a = 0 | G(A)), 0, 45), e |= t, t = 0 | S() | -1040385 & r, s = 0 | j(A), !(0 | F(a))) {
                                                    if ((0 | s) <= 0) break;
                                                    for (o = 0;;) {
                                                        if (a = 0 | ze(0 | e, 0 | t, 52), S(), a &= 15)
                                                            for (r = 1; A = 0 | ze(0 | e, 0 | t, 0 | (u = 3 * (15 - r | 0) | 0)), S(), c = 0 | Ge(7, 0, 0 | u), t &= ~(0 | S()), e = e & ~c | (u = 0 | Ge(0 | ft(7 & A), 0, 0 | u)), t = 0 | t | S(), r >>> 0 < a >>> 0;) r = r + 1 | 0;
                                                        if ((0 | (o = o + 1 | 0)) == (0 | s)) break t
                                                    }
                                                }
                                                o = 0 | ze(0 | e, 0 | t, 52), S(), o &= 15;
                                                e: do {
                                                    if (o) {
                                                        r = 1;
                                                        n: for (;;) {
                                                            switch (u = 0 | ze(0 | e, 0 | t, 3 * (15 - r | 0) | 0), S(), 7 & u) {
                                                                case 1:
                                                                    break n;
                                                                case 0:
                                                                    break;
                                                                default:
                                                                    break e
                                                            }
                                                            if (!(r >>> 0 < o >>> 0)) break e;
                                                            r = r + 1 | 0
                                                        }
                                                        if (0 | V(a, 0 | i[A >> 2]))
                                                            for (r = 1; c = 0 | Ge(7, 0, 0 | (A = 3 * (15 - r | 0) | 0)), u = t & ~(0 | S()), t = 0 | ze(0 | e, 0 | t, 0 | A), S(), e = e & ~c | (t = 0 | Ge(0 | pt(7 & t), 0, 0 | A)), t = 0 | u | S(), r >>> 0 < o >>> 0;) r = r + 1 | 0;
                                                        else
                                                            for (r = 1; A = 0 | ze(0 | e, 0 | t, 0 | (u = 3 * (15 - r | 0) | 0)), S(), c = 0 | Ge(7, 0, 0 | u), t &= ~(0 | S()), e = e & ~c | (u = 0 | Ge(0 | ft(7 & A), 0, 0 | u)), t = 0 | t | S(), r >>> 0 < o >>> 0;) r = r + 1 | 0
                                                    }
                                                } while (0);
                                                if ((0 | s) > 0) {
                                                    r = 0;
                                                    do {
                                                        e = 0 | kt(e, t), t = 0 | S(), r = r + 1 | 0
                                                    } while ((0 | r) != (0 | s))
                                                }
                                            } else e = 0, t = 0
                                        } while (0);
                                        return u = e, w(0 | (c = t)), D = n, 0 | u
                                    }(a, e), a = 0 | S(), i[n >> 2] = e, i[n + 4 >> 2] = a, 0 == (0 | e) & 0 == (0 | a) && E(23313, 22674, 786, 22697), D = r, 0 | (a = 0))
                                }

                                function Ht(t, e, n) {
                                    var r, a = 0,
                                        o = 0,
                                        s = 0;
                                    if (r = 4 + (n |= 0) | 0, o = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), o &= 15, s = 0 | ze(0 | t, 0 | e, 45), S(), a = 0 == (0 | o), 0 | F(127 & s)) {
                                        if (a) return 1;
                                        a = 1
                                    } else {
                                        if (a) return 0;
                                        a = 0 == (0 | i[r >> 2]) && 0 == (0 | i[n + 8 >> 2]) ? 0 != (0 | i[n + 12 >> 2]) & 1 : 1
                                    }
                                    for (n = 1; 1 & n ? At(r) : ct(r), s = 0 | ze(0 | t, 0 | e, 3 * (15 - n | 0) | 0), S(), ut(r, 7 & s), n >>> 0 < o >>> 0;) n = n + 1 | 0;
                                    return 0 | a
                                }

                                function Wt(t, e, n) {
                                    n |= 0;
                                    var r, a, o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0;
                                    if (a = D, D = D + 16 | 0, r = a, u = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 45), S(), (u &= 127) >>> 0 > 121) return i[n >> 2] = 0, i[n + 4 >> 2] = 0, i[n + 8 >> 2] = 0, i[n + 12 >> 2] = 0, D = a, 5;
                                    t: do {
                                        if (0 != (0 | F(u)) && (l = 0 | ze(0 | t, 0 | e, 52), S(), 0 != (0 | (l &= 15)))) {
                                            o = 1;
                                            e: for (;;) {
                                                switch (c = 0 | ze(0 | t, 0 | e, 3 * (15 - o | 0) | 0), S(), 7 & c) {
                                                    case 5:
                                                        break e;
                                                    case 0:
                                                        break;
                                                    default:
                                                        o = e;
                                                        break t
                                                }
                                                if (!(o >>> 0 < l >>> 0)) {
                                                    o = e;
                                                    break t
                                                }
                                                o = o + 1 | 0
                                            }
                                            for (s = 1, o = e; A = 0 | Ge(7, 0, 0 | (e = 3 * (15 - s | 0) | 0)), c = o & ~(0 | S()), o = 0 | ze(0 | t, 0 | o, 0 | e), S(), t = t & ~A | (o = 0 | Ge(0 | pt(7 & o), 0, 0 | e)), o = 0 | c | S(), s >>> 0 < l >>> 0;) s = s + 1 | 0
                                        } else o = e
                                    } while (0);
                                    if (c = 7696 + (28 * u | 0) | 0, i[n >> 2] = i[c >> 2], i[n + 4 >> 2] = i[c + 4 >> 2], i[n + 8 >> 2] = i[c + 8 >> 2], i[n + 12 >> 2] = i[c + 12 >> 2], !(0 | Ht(t, o, n))) return D = a, 0;
                                    if (A = n + 4 | 0, i[r >> 2] = i[A >> 2], i[r + 4 >> 2] = i[A + 4 >> 2], i[r + 8 >> 2] = i[A + 8 >> 2], l = 0 | ze(0 | t, 0 | o, 52), S(), c = 15 & l, 1 & l ? (ct(A), l = c + 1 | 0) : l = c, 0 | F(u)) {
                                        t: do {
                                            if (c)
                                                for (e = 1;;) {
                                                    if (s = 0 | ze(0 | t, 0 | o, 3 * (15 - e | 0) | 0), S(), 0 | (s &= 7)) {
                                                        o = s;
                                                        break t
                                                    }
                                                    if (!(e >>> 0 < c >>> 0)) {
                                                        o = 0;
                                                        break
                                                    }
                                                    e = e + 1 | 0
                                                } else o = 0
                                        } while (0);o = 4 == (0 | o) & 1
                                    }
                                    else o = 0;
                                    if (0 | Rt(n, l, o, 0)) {
                                        if (0 | F(u))
                                            do {} while (0 != (0 | Rt(n, l, 0, 0)));
                                        (0 | l) != (0 | c) && lt(A)
                                    } else(0 | l) != (0 | c) && (i[A >> 2] = i[r >> 2], i[A + 4 >> 2] = i[r + 4 >> 2], i[A + 8 >> 2] = i[r + 8 >> 2]);
                                    return D = a, 0
                                }

                                function Xt(t, e, n) {
                                    n |= 0;
                                    var r, i, a = 0;
                                    return i = D, D = D + 16 | 0, 0 | (a = 0 | Wt(t |= 0, e |= 0, r = i)) ? (D = i, 0 | a) : (a = 0 | ze(0 | t, 0 | e, 52), S(), Et(r, 15 & a, n), D = i, 0 | (a = 0))
                                }

                                function Yt(t, e, n) {
                                    n |= 0;
                                    var r, i = 0,
                                        a = 0,
                                        o = 0;
                                    if (r = D, D = D + 16 | 0, 0 | (i = 0 | Wt(t |= 0, e |= 0, o = r))) return D = r, 0 | i;
                                    i = 0 | ze(0 | t, 0 | e, 45), S(), i = 0 == (0 | F(127 & i)), a = 0 | ze(0 | t, 0 | e, 52), S(), a &= 15;
                                    t: do {
                                        if (!i) {
                                            if (0 | a)
                                                for (i = 1;;) {
                                                    if (!(0 == ((0 | Ge(7, 0, 3 * (15 - i | 0) | 0)) & t | 0) & 0 == ((0 | S()) & e | 0))) break t;
                                                    if (!(i >>> 0 < a >>> 0)) break;
                                                    i = i + 1 | 0
                                                }
                                            return Tt(o, a, 0, 5, n), D = r, 0
                                        }
                                    } while (0);
                                    return Lt(o, a, 0, 6, n), D = r, 0
                                }

                                function Qt(t, e) {
                                    e |= 0;
                                    var n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0;
                                    if ((t |= 0) >>> 0 > 15) return 4;
                                    if (Ge(0 | t, 0, 52), l = 134225919 | S(), !t) {
                                        n = 0, r = 0;
                                        do {
                                            0 | F(r) && (Ge(0 | r, 0, 45), s = 0 | l | S(), i[(t = e + (n << 3) | 0) >> 2] = -1, i[t + 4 >> 2] = s, n = n + 1 | 0), r = r + 1 | 0
                                        } while (122 != (0 | r));
                                        return 0
                                    }
                                    n = 0, s = 0;
                                    do {
                                        if (0 | F(s)) {
                                            for (Ge(0 | s, 0, 45), r = 1, a = -1, o = 0 | l | S(); a &= ~(A = 0 | Ge(7, 0, 3 * (15 - r | 0) | 0)), o &= ~(0 | S()), (0 | r) != (0 | t);) r = r + 1 | 0;
                                            i[(A = e + (n << 3) | 0) >> 2] = a, i[A + 4 >> 2] = o, n = n + 1 | 0
                                        }
                                        s = s + 1 | 0
                                    } while (122 != (0 | s));
                                    return 0
                                }

                                function Zt(t, e, n, r) {
                                    t |= 0, r |= 0;
                                    var a = 0,
                                        o = 0;
                                    a = 0 | ze(0 | (e |= 0), 0 | (n |= 0), 52), S(), 0 == (0 | e) & 0 == (0 | n) | (0 | r) > 15 | (0 | (a &= 15)) > (0 | r) ? (r = -1, a = -1, e = 0, n = 0) : (o = 0 | function(t, e, n, r) {
                                        return t |= 0, e |= 0, (0 | (r |= 0)) < (0 | (n |= 0)) ? (r = t, w(0 | (n = e)), 0 | r) : (n = 0 | Ge(-1, -1, 3 + (3 * (r - n | 0) | 0) | 0), r = 0 | Ge(0 | ~n, 0 | ~(0 | S()), 3 * (15 - r | 0) | 0), n = ~(0 | S()) & e, r = ~r & t, w(0 | n), 0 | r)
                                    }(e, n, a + 1 | 0, r), n = -15728641 & (0 | S()), e = 0 | Ge(0 | r, 0, 52), r = (o = 0 == (0 | Ut(e |= o, n = 0 | n | S()))) ? -1 : r), i[(o = t) >> 2] = e, i[o + 4 >> 2] = n, i[t + 8 >> 2] = a, i[t + 12 >> 2] = r
                                }

                                function Jt(t) {
                                    var e, n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0;
                                    if (!(0 == (0 | (n = 0 | i[(r = t |= 0) >> 2])) & 0 == (0 | (r = 0 | i[r + 4 >> 2])) || (a = 0 | ze(0 | n, 0 | r, 52), S(), n = 0 | De(0 | (A = 0 | Ge(1, 0, 3 * (15 ^ (a &= 15)) | 0)), 0 | S(), 0 | n, 0 | r), r = 0 | S(), i[(A = t) >> 2] = n, i[A + 4 >> 2] = r, (0 | a) < (0 | (l = 0 | i[(A = t + 8 | 0) >> 2]))))) {
                                        for (e = t + 12 | 0, s = a;;) {
                                            if ((0 | s) == (0 | l)) {
                                                a = 5;
                                                break
                                            }
                                            if (c = (0 | s) == (0 | i[e >> 2]), a = 0 | ze(0 | n, 0 | r, 0 | (o = 3 * (15 - s | 0) | 0)), S(), c & 1 == (0 | (a &= 7)) & !0) {
                                                a = 7;
                                                break
                                            }
                                            if (!(7 == (0 | a) & !0)) {
                                                a = 10;
                                                break
                                            }
                                            if (n = 0 | De(0 | n, 0 | r, 0 | (c = 0 | Ge(1, 0, 0 | o)), 0 | S()), r = 0 | S(), i[(c = t) >> 2] = n, i[c + 4 >> 2] = r, !((0 | s) > (0 | l))) {
                                                a = 10;
                                                break
                                            }
                                            s = s + -1 | 0
                                        }
                                        if (5 == (0 | a)) return i[(c = t) >> 2] = 0, i[c + 4 >> 2] = 0, i[A >> 2] = -1, void(i[e >> 2] = -1);
                                        if (7 == (0 | a)) return l = 0 | De(0 | n, 0 | r, 0 | (l = 0 | Ge(1, 0, 0 | o)), 0 | S()), A = 0 | S(), i[(c = t) >> 2] = l, i[c + 4 >> 2] = A, void(i[e >> 2] = s + -1)
                                    }
                                }

                                function Kt(t) {
                                    var e;
                                    return e = (t = +t) < 0 ? t + 6.283185307179586 : t, +(t >= 6.283185307179586 ? e + -6.283185307179586 : e)
                                }

                                function $t(t, e) {
                                    return e |= 0, +A(+(+a[(t |= 0) >> 3] - +a[e >> 3])) < 17453292519943298e-27 ? 0 | (e = +A(+(+a[t + 8 >> 3] - +a[e + 8 >> 3])) < 17453292519943298e-27) : 0 | (e = 0)
                                }

                                function te(t, e) {
                                    t |= 0;
                                    var n, r, i, o = 0;
                                    return r = +a[(e |= 0) >> 3], n = +a[t >> 3], o = (i = +d(.5 * (r - n))) * i + (o = +d(.5 * (+a[e + 8 >> 3] - +a[t + 8 >> 3]))) * (+h(+r) * +h(+n) * o), 2 * +v(+ +c(+o), + +c(+(1 - o))) * 6371.007180918475
                                }

                                function ee(t, e) {
                                    e |= 0;
                                    var n = 0;
                                    return (t |= 0) >>> 0 > 15 ? 0 | (e = 4) : (n = 0 | Ue(0 | (n = 0 | ue(7, 0, t, ((0 | t) < 0) << 31 >> 31)), 0 | S(), 120, 0), t = 0 | S(), i[e >> 2] = 2 | n, i[e + 4 >> 2] = t, 0 | (e = 0))
                                }

                                function ne(t, e, n) {
                                    t |= 0, n |= 0;
                                    var r, i, o, s, l = 0,
                                        A = 0,
                                        u = 0,
                                        p = 0,
                                        m = 0,
                                        _ = 0;
                                    return _ = +a[(e |= 0) >> 3], o = +a[t >> 3], m = +d(.5 * (_ - o)), u = +a[e + 8 >> 3], i = +a[t + 8 >> 3], p = +d(.5 * (u - i)), r = +h(+o), s = +h(+_), p = 2 * +v(+ +c(+(p = m * m + p * (s * r * p))), + +c(+(1 - p))), m = +a[n >> 3], _ = +d(.5 * (m - _)), l = +a[n + 8 >> 3], u = +d(.5 * (l - u)), A = +h(+m), u = 2 * +v(+ +c(+(u = _ * _ + u * (s * A * u))), + +c(+(1 - u))), m = +d(.5 * (o - m)), l = +d(.5 * (i - l)), l = 2 * +v(+ +c(+(l = m * m + l * (r * A * l))), + +c(+(1 - l))), 4 * +g(+ +c(+ +f(.5 * (A = .5 * (p + u + l))) * +f(.5 * (A - p)) * +f(.5 * (A - u)) * +f(.5 * (A - l))))
                                }

                                function re(t, e, n) {
                                    n |= 0;
                                    var r, o, s, l = 0,
                                        A = 0;
                                    if (s = D, D = D + 192 | 0, o = s, 0 | (A = 0 | Xt(t |= 0, e |= 0, r = s + 168 | 0))) return D = s, 0 | A;
                                    if (0 | Yt(t, e, o) && E(23313, 22742, 386, 22751), (0 | (e = 0 | i[o >> 2])) > 0) {
                                        if (l = +ne(o + 8 | 0, o + 8 + ((1 != (0 | e) & 1) << 4) | 0, r) + 0, 1 != (0 | e)) {
                                            t = 1;
                                            do {
                                                l += +ne(o + 8 + ((A = t) << 4) | 0, o + 8 + (((0 | (t = t + 1 | 0)) % (0 | e) | 0) << 4) | 0, r)
                                            } while ((0 | t) < (0 | e))
                                        }
                                    } else l = 0;
                                    return a[n >> 3] = l, D = s, 0
                                }

                                function ie(t) {
                                    t |= 0;
                                    var e, n, r = 0;
                                    return (e = 0 | Le(1, 12)) || E(22832, 22787, 49, 22845), 0 | (r = 0 | i[(n = t + 4 | 0) >> 2]) ? (i[(r = r + 8 | 0) >> 2] = e, i[n >> 2] = e, 0 | e) : (0 | i[t >> 2] && E(22862, 22787, 61, 22885), i[(r = t) >> 2] = e, i[n >> 2] = e, 0 | e)
                                }

                                function ae(t, e) {
                                    var n, r;
                                    return t |= 0, e |= 0, (r = 0 | Re(24)) || E(22899, 22787, 78, 22913), i[r >> 2] = i[e >> 2], i[r + 4 >> 2] = i[e + 4 >> 2], i[r + 8 >> 2] = i[e + 8 >> 2], i[r + 12 >> 2] = i[e + 12 >> 2], i[r + 16 >> 2] = 0, 0 | (n = 0 | i[(e = t + 4 | 0) >> 2]) ? (i[n + 16 >> 2] = r, i[e >> 2] = r, 0 | r) : (0 | i[t >> 2] && E(22928, 22787, 82, 22913), i[t >> 2] = r, i[e >> 2] = r, 0 | r)
                                }

                                function oe(t) {
                                    var e = 0,
                                        n = 0,
                                        r = 0,
                                        a = 0;
                                    if (t |= 0)
                                        for (r = 1;;) {
                                            if (0 | (e = 0 | i[t >> 2]))
                                                do {
                                                    if (0 | (n = 0 | i[e >> 2]))
                                                        do {
                                                            a = n, n = 0 | i[n + 16 >> 2], Pe(a)
                                                        } while (0 != (0 | n));
                                                    a = e, e = 0 | i[e + 8 >> 2], Pe(a)
                                                } while (0 != (0 | e));
                                            if (e = t, t = 0 | i[t + 8 >> 2], r || Pe(e), !t) break;
                                            r = 0
                                        }
                                }

                                function se(t) {
                                    var e, n, r = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0,
                                        x = 0,
                                        b = 0,
                                        M = 0,
                                        w = 0,
                                        S = 0,
                                        T = 0,
                                        C = 0,
                                        R = 0,
                                        P = 0,
                                        L = 0,
                                        D = 0,
                                        I = 0,
                                        O = 0,
                                        B = 0,
                                        q = 0;
                                    if (0 | i[(l = 8 + (t |= 0) | 0) >> 2]) return 1;
                                    if (!(s = 0 | i[t >> 2])) return 0;
                                    r = s, o = 0;
                                    do {
                                        o = o + 1 | 0, r = 0 | i[r + 8 >> 2]
                                    } while (0 != (0 | r));
                                    if (o >>> 0 < 2) return 0;
                                    (n = 0 | Re(o << 2)) || E(22948, 22787, 317, 22967), (e = 0 | Re(o << 5)) || E(22989, 22787, 321, 22967), i[t >> 2] = 0, i[(C = t + 4 | 0) >> 2] = 0, i[l >> 2] = 0, o = 0, O = 0, T = 0, m = 0;
                                    t: for (;;) {
                                        if (p = 0 | i[s >> 2]) {
                                            c = 0, u = p;
                                            do {
                                                if (d = +a[u + 8 >> 3], r = u, u = 0 | i[u + 16 >> 2], h = +a[(l = (f = 0 == (0 | u)) ? p : u) + 8 >> 3], +A(+(d - h)) > 3.141592653589793) {
                                                    q = 14;
                                                    break
                                                }
                                                c += (h - d) * (+a[r >> 3] + +a[l >> 3])
                                            } while (!f);
                                            if (14 == (0 | q)) {
                                                q = 0, c = 0, r = p;
                                                do {
                                                    S = +a[r + 8 >> 3], D = 0 | i[(I = r + 16 | 0) >> 2], w = +a[(D = 0 == (0 | D) ? p : D) + 8 >> 3], c += (+a[r >> 3] + +a[D >> 3]) * ((w < 0 ? w + 6.283185307179586 : w) - (S < 0 ? S + 6.283185307179586 : S)), r = 0 | i[(0 == (0 | r) ? s : I) >> 2]
                                                } while (0 != (0 | r))
                                            }
                                            c > 0 ? (i[n + (O << 2) >> 2] = s, O = O + 1 | 0, l = T, r = m) : q = 19
                                        } else q = 19;
                                        if (19 == (0 | q)) {
                                            q = 0;
                                            do {
                                                if (!o) {
                                                    if (m) {
                                                        l = C, u = m + 8 | 0, r = s, o = t;
                                                        break
                                                    }
                                                    if (0 | i[t >> 2]) {
                                                        q = 27;
                                                        break t
                                                    }
                                                    l = C, u = t, r = s, o = t;
                                                    break
                                                }
                                                if (0 | i[(r = o + 8 | 0) >> 2]) {
                                                    q = 21;
                                                    break t
                                                }
                                                if (!(o = 0 | Le(1, 12))) {
                                                    q = 23;
                                                    break t
                                                }
                                                i[r >> 2] = o, l = o + 4 | 0, u = o, r = m
                                            } while (0);
                                            if (i[u >> 2] = s, i[l >> 2] = s, u = e + (T << 5) | 0, f = 0 | i[s >> 2]) {
                                                for (a[(p = e + (T << 5) + 8 | 0) >> 3] = 17976931348623157e292, a[(m = e + (T << 5) + 24 | 0) >> 3] = 17976931348623157e292, a[u >> 3] = -17976931348623157e292, a[(g = e + (T << 5) + 16 | 0) >> 3] = -17976931348623157e292, b = 17976931348623157e292, M = -17976931348623157e292, l = 0, v = f, d = 17976931348623157e292, y = 17976931348623157e292, x = -17976931348623157e292, h = -17976931348623157e292; c = +a[v >> 3], S = +a[v + 8 >> 3], v = 0 | i[v + 16 >> 2], w = +a[((_ = 0 == (0 | v)) ? f : v) + 8 >> 3], c < d && (a[p >> 3] = c, d = c), S < y && (a[m >> 3] = S, y = S), c > x ? a[u >> 3] = c : c = x, S > h && (a[g >> 3] = S, h = S), b = S > 0 & S < b ? S : b, M = S < 0 & S > M ? S : M, l |= +A(+(S - w)) > 3.141592653589793, !_;) x = c;
                                                l && (a[g >> 3] = M, a[m >> 3] = b)
                                            } else i[u >> 2] = 0, i[u + 4 >> 2] = 0, i[u + 8 >> 2] = 0, i[u + 12 >> 2] = 0, i[u + 16 >> 2] = 0, i[u + 20 >> 2] = 0, i[u + 24 >> 2] = 0, i[u + 28 >> 2] = 0;
                                            l = T + 1 | 0
                                        }
                                        if (s = 0 | i[(I = s + 8 | 0) >> 2], i[I >> 2] = 0, !s) {
                                            q = 45;
                                            break
                                        }
                                        T = l, m = r
                                    }
                                    if (21 == (0 | q)) E(22765, 22787, 35, 22799);
                                    else if (23 == (0 | q)) E(22819, 22787, 37, 22799);
                                    else if (27 == (0 | q)) E(22862, 22787, 61, 22885);
                                    else if (45 == (0 | q)) {
                                        t: do {
                                            if ((0 | O) > 0) {
                                                for (I = 0 == (0 | l), L = l << 2, D = 0 == (0 | t), P = 0, r = 0;;) {
                                                    if (R = 0 | i[n + (P << 2) >> 2], I) q = 73;
                                                    else {
                                                        if (!(T = 0 | Re(L))) {
                                                            q = 50;
                                                            break
                                                        }
                                                        if (!(C = 0 | Re(L))) {
                                                            q = 52;
                                                            break
                                                        }
                                                        e: do {
                                                            if (D) o = 0;
                                                            else {
                                                                for (l = 0, o = 0, u = t; s = e + (l << 5) | 0, 0 | le(0 | i[u >> 2], s, 0 | i[R >> 2]) ? (i[T + (o << 2) >> 2] = u, i[C + (o << 2) >> 2] = s, _ = o + 1 | 0) : _ = o, u = 0 | i[u + 8 >> 2];) l = l + 1 | 0, o = _;
                                                                if ((0 | _) > 0)
                                                                    if (s = 0 | i[T >> 2], 1 == (0 | _)) o = s;
                                                                    else
                                                                        for (g = 0, v = -1, o = s, m = s;;) {
                                                                            for (f = 0 | i[m >> 2], s = 0, u = 0; p = (0 | (l = 0 | i[i[T + (u << 2) >> 2] >> 2])) == (0 | f) ? s : s + (1 & (0 | le(l, 0 | i[C + (u << 2) >> 2], 0 | i[f >> 2]))) | 0, (0 | (u = u + 1 | 0)) != (0 | _);) s = p;
                                                                            if (o = (l = (0 | p) > (0 | v)) ? m : o, (0 | (s = g + 1 | 0)) == (0 | _)) break e;
                                                                            g = s, v = l ? p : v, m = 0 | i[T + (s << 2) >> 2]
                                                                        } else o = 0
                                                            }
                                                        } while (0);
                                                        if (Pe(T), Pe(C), o) {
                                                            if (s = 0 | i[(l = o + 4 | 0) >> 2]) o = s + 8 | 0;
                                                            else if (0 | i[o >> 2]) {
                                                                q = 70;
                                                                break
                                                            }
                                                            i[o >> 2] = R, i[l >> 2] = R
                                                        } else q = 73
                                                    }
                                                    if (73 == (0 | q)) {
                                                        if (q = 0, 0 | (r = 0 | i[R >> 2]))
                                                            do {
                                                                C = r, r = 0 | i[r + 16 >> 2], Pe(C)
                                                            } while (0 != (0 | r));
                                                        Pe(R), r = 1
                                                    }
                                                    if ((0 | (P = P + 1 | 0)) >= (0 | O)) {
                                                        B = r;
                                                        break t
                                                    }
                                                }
                                                50 == (0 | q) ? E(23004, 22787, 249, 23023) : 52 == (0 | q) ? E(23042, 22787, 252, 23023) : 70 == (0 | q) && E(22862, 22787, 61, 22885)
                                            } else B = 0
                                        } while (0);
                                        return Pe(n),
                                        Pe(e),
                                        0 | B
                                    }
                                    return 0
                                }

                                function le(t, e, n) {
                                    t |= 0;
                                    var r = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0;
                                    if (!(0 | Y(e |= 0, n |= 0))) return 0;
                                    if (e = 0 | X(e), r = +a[n >> 3], o = e & (o = +a[n + 8 >> 3]) < 0 ? o + 6.283185307179586 : o, !(t = 0 | i[t >> 2])) return 0;
                                    if (e) {
                                        e = 0, u = o, n = t;
                                        t: for (;;) {
                                            for (; l = +a[n >> 3], o = +a[n + 8 >> 3], h = 0 | i[(n = n + 16 | 0) >> 2], s = +a[(h = 0 == (0 | h) ? t : h) >> 3], A = +a[h + 8 >> 3], l > s ? (c = l, l = A) : (c = s, s = l, l = o, o = A), (r = r == s | r == c ? r + 2220446049250313e-31 : r) < s | r > c;)
                                                if (!(n = 0 | i[n >> 2])) {
                                                    n = 22;
                                                    break t
                                                } if (((c = (A = l < 0 ? l + 6.283185307179586 : l) + (r - s) / (c - s) * ((l = o < 0 ? o + 6.283185307179586 : o) - A)) < 0 ? c + 6.283185307179586 : c) > (u = A == u | l == u ? u + -2220446049250313e-31 : u) && (e ^= 1), !(n = 0 | i[n >> 2])) {
                                                n = 22;
                                                break
                                            }
                                        }
                                        if (22 == (0 | n)) return 0 | e
                                    } else {
                                        e = 0, u = o, n = t;
                                        t: for (;;) {
                                            for (; l = +a[n >> 3], o = +a[n + 8 >> 3], h = 0 | i[(n = n + 16 | 0) >> 2], s = +a[(h = 0 == (0 | h) ? t : h) >> 3], A = +a[h + 8 >> 3], l > s ? (c = l, l = A) : (c = s, s = l, l = o, o = A), (r = r == s | r == c ? r + 2220446049250313e-31 : r) < s | r > c;)
                                                if (!(n = 0 | i[n >> 2])) {
                                                    n = 22;
                                                    break t
                                                } if (l + (r - s) / (c - s) * (o - l) > (u = l == u | o == u ? u + -2220446049250313e-31 : u) && (e ^= 1), !(n = 0 | i[n >> 2])) {
                                                n = 22;
                                                break
                                            }
                                        }
                                        if (22 == (0 | n)) return 0 | e
                                    }
                                    return 0
                                }

                                function Ae(t, e, n, a, o) {
                                    n |= 0, a |= 0, o |= 0;
                                    var s, l, A, c, u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0;
                                    if (c = D, D = D + 32 | 0, y = c + 16 | 0, A = c, u = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), u &= 15, g = 0 | ze(0 | n, 0 | a, 52), S(), (0 | u) != (15 & g | 0)) return D = c, 12;
                                    if (p = 0 | ze(0 | t, 0 | e, 45), S(), p &= 127, m = 0 | ze(0 | n, 0 | a, 45), S(), p >>> 0 > 121 | (m &= 127) >>> 0 > 121) return D = c, 5;
                                    if (g = (0 | p) != (0 | m)) {
                                        if (7 == (0 | (d = 0 | W(p, m)))) return D = c, 1;
                                        7 == (0 | (f = 0 | W(m, p))) ? E(23066, 23090, 161, 23100) : (v = d, h = f)
                                    } else v = 0, h = 0;
                                    s = 0 | F(p), l = 0 | F(m), i[y >> 2] = 0, i[y + 4 >> 2] = 0, i[y + 8 >> 2] = 0, i[y + 12 >> 2] = 0;
                                    do {
                                        if (v) {
                                            if (d = (0 | (m = 0 | i[4272 + (28 * p | 0) + (v << 2) >> 2])) > 0, l)
                                                if (d) {
                                                    p = 0, f = n, d = a;
                                                    do {
                                                        f = 0 | zt(f, d), d = 0 | S(), 1 == (0 | (h = 0 | pt(h))) && (h = 0 | pt(1)), p = p + 1 | 0
                                                    } while ((0 | p) != (0 | m));
                                                    m = h, p = f, f = d
                                                } else m = h, p = n, f = a;
                                            else if (d) {
                                                p = 0, f = n, d = a;
                                                do {
                                                    f = 0 | Gt(f, d), d = 0 | S(), h = 0 | pt(h), p = p + 1 | 0
                                                } while ((0 | p) != (0 | m));
                                                m = h, p = f, f = d
                                            } else m = h, p = n, f = a;
                                            if (Ht(p, f, y), g || E(23115, 23090, 191, 23100), (d = 0 != (0 | s)) & (h = 0 != (0 | l)) && E(23142, 23090, 192, 23100), d) {
                                                if (7 == (0 | (h = 0 | Nt(t, e)))) {
                                                    u = 5;
                                                    break
                                                }
                                                if (0 | r[21872 + (7 * h | 0) + v >> 0]) {
                                                    u = 1;
                                                    break
                                                }
                                                p = f = 0 | i[21040 + (28 * h | 0) + (v << 2) >> 2]
                                            } else if (h) {
                                                if (7 == (0 | (h = 0 | Nt(p, f)))) {
                                                    u = 5;
                                                    break
                                                }
                                                if (0 | r[21872 + (7 * h | 0) + m >> 0]) {
                                                    u = 1;
                                                    break
                                                }
                                                p = 0, f = 0 | i[21040 + (28 * m | 0) + (h << 2) >> 2]
                                            } else p = 0, f = 0;
                                            if ((p | f | 0) < 0) u = 5;
                                            else {
                                                if ((0 | f) > 0) {
                                                    d = y + 4 | 0, h = 0;
                                                    do {
                                                        dt(d), h = h + 1 | 0
                                                    } while ((0 | h) != (0 | f))
                                                }
                                                if (i[A >> 2] = 0, i[A + 4 >> 2] = 0, i[A + 8 >> 2] = 0, ut(A, v), 0 | u)
                                                    for (; 0 | jt(u) ? At(A) : ct(A), (0 | u) > 1;) u = u + -1 | 0;
                                                if ((0 | p) > 0) {
                                                    u = 0;
                                                    do {
                                                        dt(A), u = u + 1 | 0
                                                    } while ((0 | u) != (0 | p))
                                                }
                                                et(_ = y + 4 | 0, A, _), $(_), _ = 51
                                            }
                                        } else if (Ht(n, a, y), 0 != (0 | s) & 0 != (0 | l))
                                            if ((0 | m) != (0 | p) && E(23173, 23090, 261, 23100), 7 == (0 | (h = 0 | Nt(t, e))) | 7 == (0 | (u = 0 | Nt(n, a)))) u = 5;
                                            else if (0 | r[21872 + (7 * h | 0) + u >> 0]) u = 1;
                                        else if ((0 | (h = 0 | i[21040 + (28 * h | 0) + (u << 2) >> 2])) > 0) {
                                            d = y + 4 | 0, u = 0;
                                            do {
                                                dt(d), u = u + 1 | 0
                                            } while ((0 | u) != (0 | h));
                                            _ = 51
                                        } else _ = 51;
                                        else _ = 51
                                    } while (0);
                                    return 51 == (0 | _) && (u = y + 4 | 0, i[o >> 2] = i[u >> 2], i[o + 4 >> 2] = i[u + 4 >> 2], i[o + 8 >> 2] = i[u + 8 >> 2], u = 0), D = c, 0 | u
                                }

                                function ce(t, e, n, r) {
                                    n |= 0, r |= 0;
                                    var a, o, s, l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0;
                                    if (s = D, D = D + 48 | 0, a = s + 36 | 0, c = s + 24 | 0, u = s + 12 | 0, h = s, l = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), l &= 15, f = 0 | ze(0 | t, 0 | e, 45), S(), (f &= 127) >>> 0 > 121) return D = s, 5;
                                    if (o = 0 | F(f), Ge(0 | l, 0, 52), g = 134225919 | S(), i[(A = r) >> 2] = -1, i[A + 4 >> 2] = g, !l) return 7 == (0 | (l = 0 | it(n))) || 127 == (0 | (l = 0 | H(f, l))) ? (D = s, 0 | (g = 1)) : (p = 0 | Ge(0 | l, 0, 45), m = 0 | S(), m = -1040385 & i[(f = r) + 4 >> 2] | m, i[(g = r) >> 2] = i[f >> 2] | p, i[g + 4 >> 2] = m, D = s, 0 | (g = 0));
                                    for (i[a >> 2] = i[n >> 2], i[a + 4 >> 2] = i[n + 4 >> 2], i[a + 8 >> 2] = i[n + 8 >> 2], n = l;;) {
                                        if (A = n, n = n + -1 | 0, i[c >> 2] = i[a >> 2], i[c + 4 >> 2] = i[a + 4 >> 2], i[c + 8 >> 2] = i[a + 8 >> 2], 0 | jt(A)) {
                                            if (0 | (l = 0 | at(a))) {
                                                n = 13;
                                                break
                                            }
                                            i[u >> 2] = i[a >> 2], i[u + 4 >> 2] = i[a + 4 >> 2], i[u + 8 >> 2] = i[a + 8 >> 2], At(u)
                                        } else {
                                            if (0 | (l = 0 | ot(a))) {
                                                n = 13;
                                                break
                                            }
                                            i[u >> 2] = i[a >> 2], i[u + 4 >> 2] = i[a + 4 >> 2], i[u + 8 >> 2] = i[a + 8 >> 2], ct(u)
                                        }
                                        if (nt(c, u, h), $(h), _ = 0 | i[(l = r) >> 2], l = 0 | i[l + 4 >> 2], v = 0 | Ge(7, 0, 0 | (y = 3 * (15 - A | 0) | 0)), l &= ~(0 | S()), y = 0 | Ge(0 | it(h), 0, 0 | y), l = 0 | S() | l, i[(g = r) >> 2] = y | _ & ~v, i[g + 4 >> 2] = l, (0 | A) <= 1) {
                                            n = 14;
                                            break
                                        }
                                    }
                                    t: do {
                                        if (13 != (0 | n) && 14 == (0 | n))
                                            if ((0 | i[a >> 2]) <= 1 && (0 | i[a + 4 >> 2]) <= 1 && (0 | i[a + 8 >> 2]) <= 1) {
                                                h = 127 == (0 | (l = 0 | H(f, n = 0 | it(a)))) ? 0 : 0 | F(l);
                                                e: do {
                                                    if (n) {
                                                        if (o) {
                                                            if (7 == (0 | (l = 0 | Nt(t, e)))) {
                                                                l = 5;
                                                                break t
                                                            }
                                                            if ((0 | (A = 0 | i[21248 + (28 * l | 0) + (n << 2) >> 2])) > 0) {
                                                                l = n, n = 0;
                                                                do {
                                                                    l = 0 | ft(l), n = n + 1 | 0
                                                                } while ((0 | n) != (0 | A))
                                                            } else l = n;
                                                            if (1 == (0 | l)) {
                                                                l = 9;
                                                                break t
                                                            }
                                                            127 == (0 | (n = 0 | H(f, l))) && E(23200, 23090, 411, 23230), 0 | F(n) ? E(23245, 23090, 412, 23230) : (m = n, p = A, d = l)
                                                        } else m = l, p = 0, d = n;
                                                        if ((0 | (u = 0 | i[4272 + (28 * f | 0) + (d << 2) >> 2])) <= -1 && E(23276, 23090, 419, 23230), !h) {
                                                            if ((0 | p) < 0) {
                                                                l = 5;
                                                                break t
                                                            }
                                                            if (0 | p) {
                                                                l = 0, n = 0 | i[(A = r) >> 2], A = 0 | i[A + 4 >> 2];
                                                                do {
                                                                    n = 0 | Ft(n, A), A = 0 | S(), i[(y = r) >> 2] = n, i[y + 4 >> 2] = A, l = l + 1 | 0
                                                                } while ((0 | l) < (0 | p))
                                                            }
                                                            if ((0 | u) <= 0) {
                                                                l = m, n = 58;
                                                                break
                                                            }
                                                            for (l = 0, n = 0 | i[(A = r) >> 2], A = 0 | i[A + 4 >> 2];;)
                                                                if (n = 0 | Ft(n, A), A = 0 | S(), i[(y = r) >> 2] = n, i[y + 4 >> 2] = A, (0 | (l = l + 1 | 0)) == (0 | u)) {
                                                                    l = m, n = 58;
                                                                    break e
                                                                }
                                                        }
                                                        if (7 == (0 | (c = 0 | W(m, f))) && E(23066, 23090, 428, 23230), n = 0 | i[(l = r) >> 2], l = 0 | i[l + 4 >> 2], (0 | u) > 0) {
                                                            A = 0;
                                                            do {
                                                                n = 0 | Ft(n, l), l = 0 | S(), i[(y = r) >> 2] = n, i[y + 4 >> 2] = l, A = A + 1 | 0
                                                            } while ((0 | A) != (0 | u))
                                                        }
                                                        if (7 == (0 | (l = 0 | Nt(n, l))) && E(23313, 23090, 440, 23230), n = 0 | z(m), (0 | (n = 0 | i[(n ? 21664 : 21456) + (28 * c | 0) + (l << 2) >> 2])) < 0 && E(23313, 23090, 454, 23230), n) {
                                                            l = 0, A = 0 | i[(c = r) >> 2], c = 0 | i[c + 4 >> 2];
                                                            do {
                                                                A = 0 | kt(A, c), c = 0 | S(), i[(y = r) >> 2] = A, i[y + 4 >> 2] = c, l = l + 1 | 0
                                                            } while ((0 | l) < (0 | n));
                                                            l = m, n = 58
                                                        } else l = m, n = 58
                                                    } else if (0 != (0 | o) & 0 != (0 | h)) {
                                                        if (7 == (0 | (n = 0 | Nt(t, e))) | 7 == (0 | (A = 0 | Nt(0 | i[(A = r) >> 2], 0 | i[A + 4 >> 2])))) {
                                                            l = 5;
                                                            break t
                                                        }
                                                        if ((0 | (A = 0 | i[21248 + (28 * n | 0) + (A << 2) >> 2])) < 0) {
                                                            l = 5;
                                                            break t
                                                        }
                                                        if (A) {
                                                            n = 0, c = 0 | i[(u = r) >> 2], u = 0 | i[u + 4 >> 2];
                                                            do {
                                                                c = 0 | Ft(c, u), u = 0 | S(), i[(y = r) >> 2] = c, i[y + 4 >> 2] = u, n = n + 1 | 0
                                                            } while ((0 | n) < (0 | A));
                                                            n = 58
                                                        } else n = 59
                                                    } else n = 58
                                                } while (0);
                                                if (58 == (0 | n) && h && (n = 59), 59 == (0 | n) && 1 == (0 | Nt(0 | i[(y = r) >> 2], 0 | i[y + 4 >> 2]))) {
                                                    l = 9;
                                                    break
                                                }
                                                v = 0 | i[(y = r) >> 2], y = -1040385 & i[y + 4 >> 2], _ = 0 | Ge(0 | l, 0, 45), y = 0 | y | S(), i[(l = r) >> 2] = v | _, i[l + 4 >> 2] = y, l = 0
                                            } else l = 1
                                    } while (0);
                                    return D = s, 0 | l
                                }

                                function ue(t, e, n, r) {
                                    t |= 0, e |= 0;
                                    var i = 0,
                                        a = 0,
                                        o = 0;
                                    if (0 == (0 | (n |= 0)) & 0 == (0 | (r |= 0))) return a = 1, w(0 | (i = 0)), 0 | a;
                                    a = t, i = e, t = 1, e = 0;
                                    do {
                                        t = 0 | Ue(0 | ((o = 0 == (1 & n | 0) & !0) ? 1 : a), 0 | (o ? 0 : i), 0 | t, 0 | e), e = 0 | S(), n = 0 | Fe(0 | n, 0 | r, 1), r = 0 | S(), a = 0 | Ue(0 | a, 0 | i, 0 | a, 0 | i), i = 0 | S()
                                    } while (!(0 == (0 | n) & 0 == (0 | r)));
                                    return w(0 | e), 0 | t
                                }

                                function he(t, e, n) {
                                    t |= 0;
                                    var r, o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0;
                                    if (!(0 | Y(e |= 0, n |= 0))) return 0;
                                    if (e = 0 | X(e), o = +a[n >> 3], s = e & (s = +a[n + 8 >> 3]) < 0 ? s + 6.283185307179586 : s, (0 | (f = 0 | i[t >> 2])) <= 0) return 0;
                                    if (r = 0 | i[t + 4 >> 2], e) {
                                        e = 0, d = s, n = -1, t = 0;
                                        t: for (;;) {
                                            for (h = t; A = +a[r + (h << 4) >> 3], s = +a[r + (h << 4) + 8 >> 3], l = +a[r + ((t = (n + 2 | 0) % (0 | f) | 0) << 4) >> 3], c = +a[r + (t << 4) + 8 >> 3], A > l ? (u = A, A = c) : (u = l, l = A, A = s, s = c), (o = o == l | o == u ? o + 2220446049250313e-31 : o) < l | o > u;) {
                                                if ((0 | (n = h + 1 | 0)) >= (0 | f)) {
                                                    n = 22;
                                                    break t
                                                }
                                                t = h, h = n, n = t
                                            }
                                            if (((u = (c = A < 0 ? A + 6.283185307179586 : A) + (o - l) / (u - l) * ((A = s < 0 ? s + 6.283185307179586 : s) - c)) < 0 ? u + 6.283185307179586 : u) > (d = c == d | A == d ? d + -2220446049250313e-31 : d) && (e ^= 1), (0 | (t = h + 1 | 0)) >= (0 | f)) {
                                                n = 22;
                                                break
                                            }
                                            n = h
                                        }
                                        if (22 == (0 | n)) return 0 | e
                                    } else {
                                        e = 0, d = s, n = -1, t = 0;
                                        t: for (;;) {
                                            for (h = t; A = +a[r + (h << 4) >> 3], s = +a[r + (h << 4) + 8 >> 3], l = +a[r + ((t = (n + 2 | 0) % (0 | f) | 0) << 4) >> 3], c = +a[r + (t << 4) + 8 >> 3], A > l ? (u = A, A = c) : (u = l, l = A, A = s, s = c), (o = o == l | o == u ? o + 2220446049250313e-31 : o) < l | o > u;) {
                                                if ((0 | (n = h + 1 | 0)) >= (0 | f)) {
                                                    n = 22;
                                                    break t
                                                }
                                                t = h, h = n, n = t
                                            }
                                            if (A + (o - l) / (u - l) * (s - A) > (d = A == d | s == d ? d + -2220446049250313e-31 : d) && (e ^= 1), (0 | (t = h + 1 | 0)) >= (0 | f)) {
                                                n = 22;
                                                break
                                            }
                                            n = h
                                        }
                                        if (22 == (0 | n)) return 0 | e
                                    }
                                    return 0
                                }

                                function de(t, e) {
                                    e |= 0;
                                    var n, r, o, s, l, c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0,
                                        x = 0;
                                    if (!(r = 0 | i[(t |= 0) >> 2])) return i[e >> 2] = 0, i[e + 4 >> 2] = 0, i[e + 8 >> 2] = 0, i[e + 12 >> 2] = 0, i[e + 16 >> 2] = 0, i[e + 20 >> 2] = 0, i[e + 24 >> 2] = 0, void(i[e + 28 >> 2] = 0);
                                    if (a[(o = e + 8 | 0) >> 3] = 17976931348623157e292, a[(s = e + 24 | 0) >> 3] = 17976931348623157e292, a[e >> 3] = -17976931348623157e292, a[(l = e + 16 | 0) >> 3] = -17976931348623157e292, !((0 | r) <= 0)) {
                                        for (n = 0 | i[t + 4 >> 2], g = 17976931348623157e292, v = -17976931348623157e292, _ = 0, t = -1, d = 17976931348623157e292, f = 17976931348623157e292, m = -17976931348623157e292, u = -17976931348623157e292, y = 0; c = +a[n + (y << 4) >> 3], p = +a[n + (y << 4) + 8 >> 3], h = +a[n + (((0 | (t = t + 2 | 0)) == (0 | r) ? 0 : t) << 4) + 8 >> 3], c < d && (a[o >> 3] = c, d = c), p < f && (a[s >> 3] = p, f = p), c > m ? a[e >> 3] = c : c = m, p > u && (a[l >> 3] = p, u = p), g = p > 0 & p < g ? p : g, v = p < 0 & p > v ? p : v, _ |= +A(+(p - h)) > 3.141592653589793, (0 | (t = y + 1 | 0)) != (0 | r);) x = y, m = c, y = t, t = x;
                                        _ && (a[l >> 3] = v, a[s >> 3] = g)
                                    }
                                }

                                function fe(t, e) {
                                    e |= 0;
                                    var n, r = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0,
                                        x = 0,
                                        b = 0,
                                        M = 0,
                                        w = 0,
                                        S = 0,
                                        E = 0;
                                    if (v = 0 | i[(t |= 0) >> 2]) {
                                        if (a[(_ = e + 8 | 0) >> 3] = 17976931348623157e292, a[(y = e + 24 | 0) >> 3] = 17976931348623157e292, a[e >> 3] = -17976931348623157e292, a[(x = e + 16 | 0) >> 3] = -17976931348623157e292, (0 | v) > 0) {
                                            for (s = 0 | i[t + 4 >> 2], m = 17976931348623157e292, g = -17976931348623157e292, o = 0, r = -1, h = 17976931348623157e292, d = 17976931348623157e292, p = -17976931348623157e292, c = -17976931348623157e292, b = 0; l = +a[s + (b << 4) >> 3], f = +a[s + (b << 4) + 8 >> 3], u = +a[s + (((0 | (S = r + 2 | 0)) == (0 | v) ? 0 : S) << 4) + 8 >> 3], l < h && (a[_ >> 3] = l, h = l), f < d && (a[y >> 3] = f, d = f), l > p ? a[e >> 3] = l : l = p, f > c && (a[x >> 3] = f, c = f), m = f > 0 & f < m ? f : m, g = f < 0 & f > g ? f : g, o |= +A(+(f - u)) > 3.141592653589793, (0 | (r = b + 1 | 0)) != (0 | v);) S = b, p = l, b = r, r = S;
                                            o && (a[x >> 3] = g, a[y >> 3] = m)
                                        }
                                    } else i[e >> 2] = 0, i[e + 4 >> 2] = 0, i[e + 8 >> 2] = 0, i[e + 12 >> 2] = 0, i[e + 16 >> 2] = 0, i[e + 20 >> 2] = 0, i[e + 24 >> 2] = 0, i[e + 28 >> 2] = 0;
                                    if (!((0 | (r = 0 | i[(S = t + 8 | 0) >> 2])) <= 0)) {
                                        n = t + 12 | 0, w = 0;
                                        do {
                                            if (s = 0 | i[n >> 2], o = w, y = e + ((w = w + 1 | 0) << 5) | 0, x = 0 | i[s + (o << 3) >> 2]) {
                                                if (a[(b = e + (w << 5) + 8 | 0) >> 3] = 17976931348623157e292, a[(t = e + (w << 5) + 24 | 0) >> 3] = 17976931348623157e292, a[y >> 3] = -17976931348623157e292, a[(M = e + (w << 5) + 16 | 0) >> 3] = -17976931348623157e292, (0 | x) > 0) {
                                                    for (v = 0 | i[s + (o << 3) + 4 >> 2], m = 17976931348623157e292, g = -17976931348623157e292, s = 0, o = -1, _ = 0, h = 17976931348623157e292, d = 17976931348623157e292, f = -17976931348623157e292, c = -17976931348623157e292; l = +a[v + (_ << 4) >> 3], p = +a[v + (_ << 4) + 8 >> 3], u = +a[v + (((0 | (o = o + 2 | 0)) == (0 | x) ? 0 : o) << 4) + 8 >> 3], l < h && (a[b >> 3] = l, h = l), p < d && (a[t >> 3] = p, d = p), l > f ? a[y >> 3] = l : l = f, p > c && (a[M >> 3] = p, c = p), m = p > 0 & p < m ? p : m, g = p < 0 & p > g ? p : g, s |= +A(+(p - u)) > 3.141592653589793, (0 | (o = _ + 1 | 0)) != (0 | x);) E = _, _ = o, f = l, o = E;
                                                    s && (a[M >> 3] = g, a[t >> 3] = m)
                                                }
                                            } else i[y >> 2] = 0, i[y + 4 >> 2] = 0, i[y + 8 >> 2] = 0, i[y + 12 >> 2] = 0, i[y + 16 >> 2] = 0, i[y + 20 >> 2] = 0, i[y + 24 >> 2] = 0, i[y + 28 >> 2] = 0, r = 0 | i[S >> 2]
                                        } while ((0 | w) < (0 | r))
                                    }
                                }

                                function pe(t, e, n) {
                                    var r = 0,
                                        a = 0,
                                        o = 0;
                                    if (!(0 | he(t |= 0, e |= 0, n |= 0))) return 0;
                                    if ((0 | i[(a = t + 8 | 0) >> 2]) <= 0) return 1;
                                    for (r = t + 12 | 0, t = 0;;) {
                                        if (o = t, t = t + 1 | 0, 0 | he((0 | i[r >> 2]) + (o << 3) | 0, e + (t << 5) | 0, n)) {
                                            t = 0, r = 6;
                                            break
                                        }
                                        if ((0 | t) >= (0 | i[a >> 2])) {
                                            t = 1, r = 6;
                                            break
                                        }
                                    }
                                    return 6 == (0 | r) ? 0 | t : 0
                                }

                                function me(t, e, n, r, i) {
                                    e |= 0, n |= 0, r |= 0, i |= 0;
                                    var o, s, l, A, c, u, h, d = 0;
                                    A = +a[(t |= 0) >> 3], l = +a[e >> 3] - A, s = +a[t + 8 >> 3], o = +a[e + 8 >> 3] - s, u = +a[n >> 3], d = ((d = +a[r >> 3] - u) * (s - (h = +a[n + 8 >> 3])) - (A - u) * (c = +a[r + 8 >> 3] - h)) / (l * c - o * d), a[i >> 3] = A + l * d, a[i + 8 >> 3] = s + o * d
                                }

                                function ge(t, e) {
                                    return e |= 0, +A(+(+a[(t |= 0) >> 3] - +a[e >> 3])) < 1.1920928955078125e-7 ? 0 | (e = +A(+(+a[t + 8 >> 3] - +a[e + 8 >> 3])) < 1.1920928955078125e-7) : 0 | (e = 0)
                                }

                                function ve(t, e) {
                                    var n, r, i;
                                    return e |= 0, +((i = +a[(t |= 0) >> 3] - +a[e >> 3]) * i + (r = +a[t + 8 >> 3] - +a[e + 8 >> 3]) * r + (n = +a[t + 16 >> 3] - +a[e + 16 >> 3]) * n)
                                }

                                function _e(t, e, n) {
                                    n |= 0;
                                    var r, a, o, s, l = 0,
                                        A = 0,
                                        c = 0;
                                    if (s = D, D = D + 32 | 0, c = s, 0 | (l = 0 | Wt(t |= 0, e |= 0, a = s + 16 | 0))) return D = s, 0 | l;
                                    r = 0 | It(t, e), o = 0 | Nt(t, e),
                                        function(t, e) {
                                            t = 7696 + (28 * (t |= 0) | 0) | 0, i[(e |= 0) >> 2] = i[t >> 2], i[e + 4 >> 2] = i[t + 4 >> 2], i[e + 8 >> 2] = i[t + 8 >> 2], i[e + 12 >> 2] = i[t + 12 >> 2]
                                        }(r, c), l = 0 | function(t, e) {
                                            t |= 0;
                                            var n = 0,
                                                r = 0;
                                            if ((e |= 0) >>> 0 > 20) return -1;
                                            do {
                                                if ((0 | i[11120 + (216 * e | 0) >> 2]) != (0 | t))
                                                    if ((0 | i[11120 + (216 * e | 0) + 8 >> 2]) != (0 | t))
                                                        if ((0 | i[11120 + (216 * e | 0) + 16 >> 2]) != (0 | t))
                                                            if ((0 | i[11120 + (216 * e | 0) + 24 >> 2]) != (0 | t))
                                                                if ((0 | i[11120 + (216 * e | 0) + 32 >> 2]) != (0 | t))
                                                                    if ((0 | i[11120 + (216 * e | 0) + 40 >> 2]) != (0 | t))
                                                                        if ((0 | i[11120 + (216 * e | 0) + 48 >> 2]) != (0 | t))
                                                                            if ((0 | i[11120 + (216 * e | 0) + 56 >> 2]) != (0 | t))
                                                                                if ((0 | i[11120 + (216 * e | 0) + 64 >> 2]) != (0 | t))
                                                                                    if ((0 | i[11120 + (216 * e | 0) + 72 >> 2]) != (0 | t))
                                                                                        if ((0 | i[11120 + (216 * e | 0) + 80 >> 2]) != (0 | t))
                                                                                            if ((0 | i[11120 + (216 * e | 0) + 88 >> 2]) != (0 | t))
                                                                                                if ((0 | i[11120 + (216 * e | 0) + 96 >> 2]) != (0 | t))
                                                                                                    if ((0 | i[11120 + (216 * e | 0) + 104 >> 2]) != (0 | t))
                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 112 >> 2]) != (0 | t))
                                                                                                            if ((0 | i[11120 + (216 * e | 0) + 120 >> 2]) != (0 | t))
                                                                                                                if ((0 | i[11120 + (216 * e | 0) + 128 >> 2]) != (0 | t)) {
                                                                                                                    if ((0 | i[11120 + (216 * e | 0) + 136 >> 2]) != (0 | t)) {
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 144 >> 2]) == (0 | t)) {
                                                                                                                            t = 0, n = 2, r = 0;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 152 >> 2]) == (0 | t)) {
                                                                                                                            t = 0, n = 2, r = 1;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 160 >> 2]) == (0 | t)) {
                                                                                                                            t = 0, n = 2, r = 2;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 168 >> 2]) == (0 | t)) {
                                                                                                                            t = 1, n = 2, r = 0;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 176 >> 2]) == (0 | t)) {
                                                                                                                            t = 1, n = 2, r = 1;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 184 >> 2]) == (0 | t)) {
                                                                                                                            t = 1, n = 2, r = 2;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 192 >> 2]) == (0 | t)) {
                                                                                                                            t = 2, n = 2, r = 0;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 200 >> 2]) == (0 | t)) {
                                                                                                                            t = 2, n = 2, r = 1;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        if ((0 | i[11120 + (216 * e | 0) + 208 >> 2]) == (0 | t)) {
                                                                                                                            t = 2, n = 2, r = 2;
                                                                                                                            break
                                                                                                                        }
                                                                                                                        return -1
                                                                                                                    }
                                                                                                                    t = 2, n = 1, r = 2
                                                                                                                } else t = 2, n = 1, r = 1;
                                                else t = 2, n = 1, r = 0;
                                                else t = 1, n = 1, r = 2;
                                                else t = 1, n = 1, r = 1;
                                                else t = 1, n = 1, r = 0;
                                                else t = 0, n = 1, r = 2;
                                                else t = 0, n = 1, r = 1;
                                                else t = 0, n = 1, r = 0;
                                                else t = 2, n = 0, r = 2;
                                                else t = 2, n = 0, r = 1;
                                                else t = 2, n = 0, r = 0;
                                                else t = 1, n = 0, r = 2;
                                                else t = 1, n = 0, r = 1;
                                                else t = 1, n = 0, r = 0;
                                                else t = 0, n = 0, r = 2;
                                                else t = 0, n = 0, r = 1;
                                                else t = 0, n = 0, r = 0
                                            } while (0);
                                            return 0 | i[11120 + (216 * e | 0) + (72 * n | 0) + (24 * t | 0) + (r << 3) + 4 >> 2]
                                        }(r, 0 | i[a >> 2]);
                                    t: do {
                                        if (0 | F(r)) {
                                            switch (0 | r) {
                                                case 4:
                                                    t = 0;
                                                    break;
                                                case 14:
                                                    t = 1;
                                                    break;
                                                case 24:
                                                    t = 2;
                                                    break;
                                                case 38:
                                                    t = 3;
                                                    break;
                                                case 49:
                                                    t = 4;
                                                    break;
                                                case 58:
                                                    t = 5;
                                                    break;
                                                case 63:
                                                    t = 6;
                                                    break;
                                                case 72:
                                                    t = 7;
                                                    break;
                                                case 83:
                                                    t = 8;
                                                    break;
                                                case 97:
                                                    t = 9;
                                                    break;
                                                case 107:
                                                    t = 10;
                                                    break;
                                                case 117:
                                                    t = 11;
                                                    break;
                                                default:
                                                    l = 1;
                                                    break t
                                            }
                                            if (A = 0 | i[22e3 + (24 * t | 0) + 8 >> 2], e = 0 | i[22e3 + (24 * t | 0) + 16 >> 2], (0 | (t = 0 | i[a >> 2])) != (0 | i[c >> 2]) && (c = 0 | z(r)) | (0 | (t = 0 | i[a >> 2])) == (0 | e) && (l = (l + 1 | 0) % 6 | 0), 3 == (0 | o) & (0 | t) == (0 | e)) {
                                                l = (l + 5 | 0) % 6 | 0, A = 22;
                                                break
                                            }
                                            5 == (0 | o) & (0 | t) == (0 | A) ? (l = (l + 1 | 0) % 6 | 0, A = 22) : A = 22
                                        } else A = 22
                                    } while (0);
                                    return 22 == (0 | A) && (i[n >> 2] = l, l = 0), D = s, 0 | l
                                }

                                function ye(t, e, n, r) {
                                    n |= 0, r |= 0;
                                    var a, o, s, l, A, c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0;
                                    if (A = D, D = D + 32 | 0, y = A + 24 | 0, l = A + 20 | 0, s = A + 8 | 0, o = A + 16 | 0, a = A, f = (f = 0 == (0 | Ut(t |= 0, e |= 0))) ? 6 : 5, m = 0 | ze(0 | t, 0 | e, 52), S(), f >>> 0 <= n >>> 0) return D = A, 2;
                                    !(g = 0 == (0 | (m &= 15))) && 0 == ((v = 0 | Ge(7, 0, 3 * (15 ^ m) | 0)) & t | 0) & 0 == ((0 | S()) & e | 0) ? c = n : u = 4;
                                    t: do {
                                        if (4 == (0 | u)) {
                                            if ((0 | ((c = 0 != (0 | Ut(t, e))) ? 4 : 5)) < (0 | n)) return D = A, 1;
                                            if (0 | _e(t, e, y)) return D = A, 1;
                                            if (u = (0 | i[y >> 2]) + n | 0, 7 == (0 | (v = 0 | i[(c = c ? 22288 + (((0 | u) % 5 | 0) << 2) | 0 : 22320 + (((0 | u) % 6 | 0) << 2) | 0) >> 2]))) return D = A, 1;
                                            i[l >> 2] = 0, c = 0 | U(t, e, v, l, s);
                                            do {
                                                if (!c) {
                                                    if (p = 0 | i[(d = s) >> 2], u = (h = (d = 0 | i[d + 4 >> 2]) >>> 0 < e >>> 0 | (0 | d) == (0 | e) & p >>> 0 < t >>> 0) ? p : t, h = h ? d : e, !g && 0 == (p & (g = 0 | Ge(7, 0, 3 * (15 ^ m) | 0)) | 0) & 0 == (d & (0 | S()) | 0)) c = n;
                                                    else {
                                                        if (d = (n + -1 + f | 0) % (0 | f) | 0, c = 0 | Ut(t, e), (0 | d) < 0 && E(23313, 23315, 245, 23324), (0 | ((f = 0 != (0 | c)) ? 4 : 5)) < (0 | d) && E(23313, 23315, 245, 23324), 0 | _e(t, e, y) && E(23313, 23315, 245, 23324), c = (0 | i[y >> 2]) + d | 0, 7 == (0 | (d = 0 | i[(c = f ? 22288 + (((0 | c) % 5 | 0) << 2) | 0 : 22320 + (((0 | c) % 6 | 0) << 2) | 0) >> 2])) && E(23313, 23315, 245, 23324), i[o >> 2] = 0, 0 | (c = 0 | U(t, e, d, o, a))) break;
                                                        f = 0 | i[(p = a) >> 2], p = 0 | i[p + 4 >> 2];
                                                        do {
                                                            if (p >>> 0 < h >>> 0 | (0 | p) == (0 | h) & f >>> 0 < u >>> 0) {
                                                                if (u = 0 | Ut(f, p) ? 0 | N(f, p, t, e) : 0 | i[22384 + ((((0 | i[o >> 2]) + (0 | i[22352 + (d << 2) >> 2]) | 0) % 6 | 0) << 2) >> 2], c = 0 | Ut(f, p), (u + -1 | 0) >>> 0 > 5) {
                                                                    c = -1, u = f, h = p;
                                                                    break
                                                                }
                                                                if (1 == (0 | u) & (c = 0 != (0 | c))) {
                                                                    c = -1, u = f, h = p;
                                                                    break
                                                                }
                                                                do {
                                                                    if (!(0 | _e(f, p, y))) {
                                                                        if (c) {
                                                                            c = (5 + (0 | i[21936 + (u << 2) >> 2]) - (0 | i[y >> 2]) | 0) % 5 | 0;
                                                                            break
                                                                        }
                                                                        c = (6 + (0 | i[21968 + (u << 2) >> 2]) - (0 | i[y >> 2]) | 0) % 6 | 0;
                                                                        break
                                                                    }
                                                                    c = -1
                                                                } while (0);
                                                                u = f, h = p
                                                            } else c = n
                                                        } while (0);
                                                        p = 0 | i[(d = s) >> 2], d = 0 | i[d + 4 >> 2]
                                                    }
                                                    if ((0 | u) == (0 | p) & (0 | h) == (0 | d)) {
                                                        if (t = (f = 0 != (0 | Ut(p, d))) ? 0 | N(p, d, t, e) : 0 | i[22384 + ((((0 | i[l >> 2]) + (0 | i[22352 + (v << 2) >> 2]) | 0) % 6 | 0) << 2) >> 2], c = 0 | Ut(p, d), (t + -1 | 0) >>> 0 <= 5 && !(1 == (0 | t) & (_ = 0 != (0 | c))))
                                                            do {
                                                                if (!(0 | _e(p, d, y))) {
                                                                    if (_) {
                                                                        c = (5 + (0 | i[21936 + (t << 2) >> 2]) - (0 | i[y >> 2]) | 0) % 5 | 0;
                                                                        break
                                                                    }
                                                                    c = (6 + (0 | i[21968 + (t << 2) >> 2]) - (0 | i[y >> 2]) | 0) % 6 | 0;
                                                                    break
                                                                }
                                                                c = -1
                                                            } while (0);
                                                        else c = -1;
                                                        c = 6 == (0 | (c = c + 1 | 0)) | f & 5 == (0 | c) ? 0 : c
                                                    }
                                                    e = h, t = u;
                                                    break t
                                                }
                                            } while (0);
                                            return D = A, 0 | c
                                        }
                                    } while (0);
                                    return _ = 0 | Ge(0 | c, 0, 56), y = 0 | S() | -2130706433 & e | 536870912, i[r >> 2] = _ | t, i[r + 4 >> 2] = y, D = A, 0
                                }

                                function xe(t, e, n) {
                                    t |= 0, n |= 0;
                                    var r = 0;
                                    (0 | (e |= 0)) > 0 ? (r = 0 | Le(e, 4), i[t >> 2] = r, r || E(23337, 23360, 40, 23374)) : i[t >> 2] = 0, i[t + 4 >> 2] = e, i[t + 8 >> 2] = 0, i[t + 12 >> 2] = n
                                }

                                function be(t) {
                                    var e, n, r, o = 0,
                                        s = 0,
                                        l = 0,
                                        c = 0;
                                    e = 4 + (t |= 0) | 0, n = t + 12 | 0, r = t + 8 | 0;
                                    t: for (;;) {
                                        for (s = 0 | i[e >> 2], o = 0;;) {
                                            if ((0 | o) >= (0 | s)) break t;
                                            if (l = 0 | i[t >> 2], c = 0 | i[l + (o << 2) >> 2]) break;
                                            o = o + 1 | 0
                                        }
                                        o = l + (~~(+A(+ +u(10, + +(15 - (0 | i[n >> 2]) | 0)) * (+a[c >> 3] + +a[c + 8 >> 3])) % +(0 | s)) >>> 0 << 2) | 0, s = 0 | i[o >> 2];
                                        e: do {
                                            if (0 | s) {
                                                if (l = c + 32 | 0, (0 | s) == (0 | c)) i[o >> 2] = i[l >> 2];
                                                else {
                                                    if (!(o = 0 | i[(s = s + 32 | 0) >> 2])) break;
                                                    for (;
                                                        (0 | o) != (0 | c);)
                                                        if (!(o = 0 | i[(s = o + 32 | 0) >> 2])) break e;
                                                    i[s >> 2] = i[l >> 2]
                                                }
                                                Pe(c), i[r >> 2] = (0 | i[r >> 2]) - 1
                                            }
                                        } while (0)
                                    }
                                    Pe(0 | i[t >> 2])
                                }

                                function Me(t) {
                                    var e, n = 0,
                                        r = 0;
                                    for (e = 0 | i[4 + (t |= 0) >> 2], r = 0;;) {
                                        if ((0 | r) >= (0 | e)) {
                                            n = 0, r = 4;
                                            break
                                        }
                                        if (n = 0 | i[(0 | i[t >> 2]) + (r << 2) >> 2]) {
                                            r = 4;
                                            break
                                        }
                                        r = r + 1 | 0
                                    }
                                    return 4 == (0 | r) ? 0 | n : 0
                                }

                                function we(t, e) {
                                    e |= 0;
                                    var n = 0,
                                        r = 0,
                                        o = 0,
                                        s = 0;
                                    if (n = ~~(+A(+ +u(10, + +(15 - (0 | i[12 + (t |= 0) >> 2]) | 0)) * (+a[e >> 3] + +a[e + 8 >> 3])) % +(0 | i[t + 4 >> 2])) >>> 0, n = (0 | i[t >> 2]) + (n << 2) | 0, !(r = 0 | i[n >> 2])) return 1;
                                    s = e + 32 | 0;
                                    do {
                                        if ((0 | r) != (0 | e)) {
                                            if (!(n = 0 | i[r + 32 >> 2])) return 1;
                                            for (o = n;;) {
                                                if ((0 | o) == (0 | e)) {
                                                    o = 8;
                                                    break
                                                }
                                                if (!(n = 0 | i[o + 32 >> 2])) {
                                                    n = 1, o = 10;
                                                    break
                                                }
                                                r = o, o = n
                                            }
                                            if (8 == (0 | o)) {
                                                i[r + 32 >> 2] = i[s >> 2];
                                                break
                                            }
                                            if (10 == (0 | o)) return 0 | n
                                        } else i[n >> 2] = i[s >> 2]
                                    } while (0);
                                    return Pe(e), i[(s = t + 8 | 0) >> 2] = (0 | i[s >> 2]) - 1, 0
                                }

                                function Se(t, e, n) {
                                    t |= 0, e |= 0, n |= 0;
                                    var r, o = 0,
                                        s = 0,
                                        l = 0;
                                    (r = 0 | Re(40)) || E(23390, 23360, 98, 23403), i[r >> 2] = i[e >> 2], i[r + 4 >> 2] = i[e + 4 >> 2], i[r + 8 >> 2] = i[e + 8 >> 2], i[r + 12 >> 2] = i[e + 12 >> 2], i[(s = r + 16 | 0) >> 2] = i[n >> 2], i[s + 4 >> 2] = i[n + 4 >> 2], i[s + 8 >> 2] = i[n + 8 >> 2], i[s + 12 >> 2] = i[n + 12 >> 2], i[r + 32 >> 2] = 0, s = ~~(+A(+ +u(10, + +(15 - (0 | i[t + 12 >> 2]) | 0)) * (+a[e >> 3] + +a[e + 8 >> 3])) % +(0 | i[t + 4 >> 2])) >>> 0, s = (0 | i[t >> 2]) + (s << 2) | 0, o = 0 | i[s >> 2];
                                    do {
                                        if (o) {
                                            for (; !(0 | $t(o, e) && 0 | $t(o + 16 | 0, n));)
                                                if (s = 0 | i[o + 32 >> 2], !(0 | i[(o = 0 == (0 | s) ? o : s) + 32 >> 2])) {
                                                    l = 10;
                                                    break
                                                } if (10 == (0 | l)) {
                                                i[o + 32 >> 2] = r;
                                                break
                                            }
                                            return Pe(r), 0 | o
                                        }
                                        i[s >> 2] = r
                                    } while (0);
                                    return i[(l = t + 8 | 0) >> 2] = 1 + (0 | i[l >> 2]), 0 | r
                                }

                                function Ee(t, e, n) {
                                    e |= 0, n |= 0;
                                    var r = 0,
                                        o = 0;
                                    if (o = ~~(+A(+ +u(10, + +(15 - (0 | i[12 + (t |= 0) >> 2]) | 0)) * (+a[e >> 3] + +a[e + 8 >> 3])) % +(0 | i[t + 4 >> 2])) >>> 0, !(o = 0 | i[(0 | i[t >> 2]) + (o << 2) >> 2])) return 0;
                                    if (!n) {
                                        for (t = o;;) {
                                            if (0 | $t(t, e)) {
                                                r = 10;
                                                break
                                            }
                                            if (!(t = 0 | i[t + 32 >> 2])) {
                                                t = 0, r = 10;
                                                break
                                            }
                                        }
                                        if (10 == (0 | r)) return 0 | t
                                    }
                                    for (t = o;;) {
                                        if (0 | $t(t, e) && 0 | $t(t + 16 | 0, n)) {
                                            r = 10;
                                            break
                                        }
                                        if (!(t = 0 | i[t + 32 >> 2])) {
                                            t = 0, r = 10;
                                            break
                                        }
                                    }
                                    return 10 == (0 | r) ? 0 | t : 0
                                }

                                function Te(t, e) {
                                    e |= 0;
                                    var n = 0;
                                    if (n = ~~(+A(+ +u(10, + +(15 - (0 | i[12 + (t |= 0) >> 2]) | 0)) * (+a[e >> 3] + +a[e + 8 >> 3])) % +(0 | i[t + 4 >> 2])) >>> 0, !(t = 0 | i[(0 | i[t >> 2]) + (n << 2) >> 2])) return 0;
                                    for (;;) {
                                        if (0 | $t(t, e)) {
                                            e = 5;
                                            break
                                        }
                                        if (!(t = 0 | i[t + 32 >> 2])) {
                                            t = 0, e = 5;
                                            break
                                        }
                                    }
                                    return 5 == (0 | e) ? 0 | t : 0
                                }

                                function Ce(t) {
                                    return 0 | ~~+ function(t) {
                                        return + +Ye(+(t = +t))
                                    }(t = +t)
                                }

                                function Re(t) {
                                    t |= 0;
                                    var e, n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0,
                                        m = 0,
                                        g = 0,
                                        v = 0,
                                        _ = 0,
                                        y = 0,
                                        x = 0,
                                        b = 0;
                                    e = D, D = D + 16 | 0, f = e;
                                    do {
                                        if (t >>> 0 < 245) {
                                            if (t = (u = t >>> 0 < 11 ? 16 : t + 11 & -8) >>> 3, 3 & (r = (d = 0 | i[5857]) >>> t) | 0) return a = 0 | i[(r = 8 + (t = 23468 + ((n = (1 & r ^ 1) + t | 0) << 1 << 2) | 0) | 0) >> 2], (0 | (s = 0 | i[(o = a + 8 | 0) >> 2])) == (0 | t) ? i[5857] = d & ~(1 << n) : (i[s + 12 >> 2] = t, i[r >> 2] = s), b = n << 3, i[a + 4 >> 2] = 3 | b, i[(b = a + b + 4 | 0) >> 2] = 1 | i[b >> 2], D = e, 0 | o;
                                            if (u >>> 0 > (h = 0 | i[5859]) >>> 0) {
                                                if (0 | r) return n = ((n = r << t & ((n = 2 << t) | 0 - n)) & 0 - n) - 1 | 0, s = 0 | i[(t = 8 + (n = 23468 + ((a = ((r = (n >>>= A = n >>> 12 & 16) >>> 5 & 8) | A | (s = (n >>>= r) >>> 2 & 4) | (t = (n >>>= s) >>> 1 & 2) | (a = (n >>>= t) >>> 1 & 1)) + (n >>> a) | 0) << 1 << 2) | 0) | 0) >> 2], (0 | (r = 0 | i[(A = s + 8 | 0) >> 2])) == (0 | n) ? (t = d & ~(1 << a), i[5857] = t) : (i[r + 12 >> 2] = n, i[t >> 2] = r, t = d), l = (b = a << 3) - u | 0, i[s + 4 >> 2] = 3 | u, i[4 + (o = s + u | 0) >> 2] = 1 | l, i[s + b >> 2] = l, 0 | h && (a = 0 | i[5862], r = 23468 + ((n = h >>> 3) << 1 << 2) | 0, t & (n = 1 << n) ? n = 0 | i[(t = r + 8 | 0) >> 2] : (i[5857] = t | n, n = r, t = r + 8 | 0), i[t >> 2] = a, i[n + 12 >> 2] = a, i[a + 8 >> 2] = n, i[a + 12 >> 2] = r), i[5859] = l, i[5862] = o, D = e, 0 | A;
                                                if (s = 0 | i[5858]) {
                                                    for (r = (s & 0 - s) - 1 | 0, r = c = 0 | i[23732 + (((a = (r >>>= o = r >>> 12 & 16) >>> 5 & 8) | o | (l = (r >>>= a) >>> 2 & 4) | (A = (r >>>= l) >>> 1 & 2) | (c = (r >>>= A) >>> 1 & 1)) + (r >>> c) << 2) >> 2], A = c, c = (-8 & i[c + 4 >> 2]) - u | 0;
                                                        (t = 0 | i[r + 16 >> 2]) || (t = 0 | i[r + 20 >> 2]);) r = t, A = (o = (l = (-8 & i[t + 4 >> 2]) - u | 0) >>> 0 < c >>> 0) ? t : A, c = o ? l : c;
                                                    if ((l = A + u | 0) >>> 0 > A >>> 0) {
                                                        o = 0 | i[A + 24 >> 2], n = 0 | i[A + 12 >> 2];
                                                        do {
                                                            if ((0 | n) == (0 | A)) {
                                                                if (!(n = 0 | i[(t = A + 20 | 0) >> 2]) && !(n = 0 | i[(t = A + 16 | 0) >> 2])) {
                                                                    r = 0;
                                                                    break
                                                                }
                                                                for (;;)
                                                                    if (r = 0 | i[(a = n + 20 | 0) >> 2]) n = r, t = a;
                                                                    else {
                                                                        if (!(r = 0 | i[(a = n + 16 | 0) >> 2])) break;
                                                                        n = r, t = a
                                                                    } i[t >> 2] = 0, r = n
                                                            } else r = 0 | i[A + 8 >> 2], i[r + 12 >> 2] = n, i[n + 8 >> 2] = r, r = n
                                                        } while (0);
                                                        do {
                                                            if (0 | o) {
                                                                if (n = 0 | i[A + 28 >> 2], (0 | A) == (0 | i[(t = 23732 + (n << 2) | 0) >> 2])) {
                                                                    if (i[t >> 2] = r, !r) {
                                                                        i[5858] = s & ~(1 << n);
                                                                        break
                                                                    }
                                                                } else if (i[((0 | i[(b = o + 16 | 0) >> 2]) == (0 | A) ? b : o + 20 | 0) >> 2] = r, !r) break;
                                                                i[r + 24 >> 2] = o, 0 | (n = 0 | i[A + 16 >> 2]) && (i[r + 16 >> 2] = n, i[n + 24 >> 2] = r), 0 | (n = 0 | i[A + 20 >> 2]) && (i[r + 20 >> 2] = n, i[n + 24 >> 2] = r)
                                                            }
                                                        } while (0);
                                                        return c >>> 0 < 16 ? (b = c + u | 0, i[A + 4 >> 2] = 3 | b, i[(b = A + b + 4 | 0) >> 2] = 1 | i[b >> 2]) : (i[A + 4 >> 2] = 3 | u, i[l + 4 >> 2] = 1 | c, i[l + c >> 2] = c, 0 | h && (a = 0 | i[5862], r = 23468 + ((n = h >>> 3) << 1 << 2) | 0, (n = 1 << n) & d ? n = 0 | i[(t = r + 8 | 0) >> 2] : (i[5857] = n | d, n = r, t = r + 8 | 0), i[t >> 2] = a, i[n + 12 >> 2] = a, i[a + 8 >> 2] = n, i[a + 12 >> 2] = r), i[5859] = c, i[5862] = l), D = e, 0 | A + 8
                                                    }
                                                    d = u
                                                } else d = u
                                            } else d = u
                                        } else if (t >>> 0 <= 4294967231)
                                            if (u = -8 & (t = t + 11 | 0), a = 0 | i[5858]) {
                                                o = 0 - u | 0, c = (t >>>= 8) ? u >>> 0 > 16777215 ? 31 : u >>> (7 + (c = 14 - ((A = (520192 + (g = t << (d = (t + 1048320 | 0) >>> 16 & 8)) | 0) >>> 16 & 4) | d | (c = (245760 + (g <<= A) | 0) >>> 16 & 2)) + (g << c >>> 15) | 0) | 0) & 1 | c << 1 : 0, r = 0 | i[23732 + (c << 2) >> 2];
                                                t: do {
                                                    if (r)
                                                        for (t = 0, A = u << (31 == (0 | c) ? 0 : 25 - (c >>> 1) | 0), s = 0;;) {
                                                            if ((l = (-8 & i[r + 4 >> 2]) - u | 0) >>> 0 < o >>> 0) {
                                                                if (!l) {
                                                                    t = r, o = 0, g = 65;
                                                                    break t
                                                                }
                                                                t = r, o = l
                                                            }
                                                            if (s = 0 == (0 | (g = 0 | i[r + 20 >> 2])) | (0 | g) == (0 | (r = 0 | i[r + 16 + (A >>> 31 << 2) >> 2])) ? s : g, !r) {
                                                                r = s, g = 61;
                                                                break
                                                            }
                                                            A <<= 1
                                                        } else r = 0, t = 0, g = 61
                                                } while (0);
                                                if (61 == (0 | g)) {
                                                    if (0 == (0 | r) & 0 == (0 | t)) {
                                                        if (!(t = ((t = 2 << c) | 0 - t) & a)) {
                                                            d = u;
                                                            break
                                                        }
                                                        d = (t & 0 - t) - 1 | 0, t = 0, r = 0 | i[23732 + (((s = (d >>>= l = d >>> 12 & 16) >>> 5 & 8) | l | (A = (d >>>= s) >>> 2 & 4) | (c = (d >>>= A) >>> 1 & 2) | (r = (d >>>= c) >>> 1 & 1)) + (d >>> r) << 2) >> 2]
                                                    }
                                                    r ? g = 65 : (A = t, l = o)
                                                }
                                                if (65 == (0 | g))
                                                    for (s = r;;) {
                                                        if (o = (r = (d = (-8 & i[s + 4 >> 2]) - u | 0) >>> 0 < o >>> 0) ? d : o, t = r ? s : t, (r = 0 | i[s + 16 >> 2]) || (r = 0 | i[s + 20 >> 2]), !r) {
                                                            A = t, l = o;
                                                            break
                                                        }
                                                        s = r
                                                    }
                                                if (0 != (0 | A) && l >>> 0 < ((0 | i[5859]) - u | 0) >>> 0 && (h = A + u | 0) >>> 0 > A >>> 0) {
                                                    s = 0 | i[A + 24 >> 2], n = 0 | i[A + 12 >> 2];
                                                    do {
                                                        if ((0 | n) == (0 | A)) {
                                                            if (!(n = 0 | i[(t = A + 20 | 0) >> 2]) && !(n = 0 | i[(t = A + 16 | 0) >> 2])) {
                                                                n = 0;
                                                                break
                                                            }
                                                            for (;;)
                                                                if (r = 0 | i[(o = n + 20 | 0) >> 2]) n = r, t = o;
                                                                else {
                                                                    if (!(r = 0 | i[(o = n + 16 | 0) >> 2])) break;
                                                                    n = r, t = o
                                                                } i[t >> 2] = 0
                                                        } else b = 0 | i[A + 8 >> 2], i[b + 12 >> 2] = n, i[n + 8 >> 2] = b
                                                    } while (0);
                                                    do {
                                                        if (s) {
                                                            if (t = 0 | i[A + 28 >> 2], (0 | A) == (0 | i[(r = 23732 + (t << 2) | 0) >> 2])) {
                                                                if (i[r >> 2] = n, !n) {
                                                                    a &= ~(1 << t), i[5858] = a;
                                                                    break
                                                                }
                                                            } else if (i[((0 | i[(b = s + 16 | 0) >> 2]) == (0 | A) ? b : s + 20 | 0) >> 2] = n, !n) break;
                                                            i[n + 24 >> 2] = s, 0 | (t = 0 | i[A + 16 >> 2]) && (i[n + 16 >> 2] = t, i[t + 24 >> 2] = n), (t = 0 | i[A + 20 >> 2]) && (i[n + 20 >> 2] = t, i[t + 24 >> 2] = n)
                                                        }
                                                    } while (0);
                                                    t: do {
                                                        if (l >>> 0 < 16) b = l + u | 0, i[A + 4 >> 2] = 3 | b, i[(b = A + b + 4 | 0) >> 2] = 1 | i[b >> 2];
                                                        else {
                                                            if (i[A + 4 >> 2] = 3 | u, i[h + 4 >> 2] = 1 | l, i[h + l >> 2] = l, n = l >>> 3, l >>> 0 < 256) {
                                                                r = 23468 + (n << 1 << 2) | 0, (t = 0 | i[5857]) & (n = 1 << n) ? n = 0 | i[(t = r + 8 | 0) >> 2] : (i[5857] = t | n, n = r, t = r + 8 | 0), i[t >> 2] = h, i[n + 12 >> 2] = h, i[h + 8 >> 2] = n, i[h + 12 >> 2] = r;
                                                                break
                                                            }
                                                            if (n = 23732 + ((r = (n = l >>> 8) ? l >>> 0 > 16777215 ? 31 : l >>> (7 + (r = 14 - ((y = (520192 + (b = n << (x = (n + 1048320 | 0) >>> 16 & 8)) | 0) >>> 16 & 4) | x | (r = (245760 + (b <<= y) | 0) >>> 16 & 2)) + (b << r >>> 15) | 0) | 0) & 1 | r << 1 : 0) << 2) | 0, i[h + 28 >> 2] = r, i[4 + (t = h + 16 | 0) >> 2] = 0, i[t >> 2] = 0, !(a & (t = 1 << r))) {
                                                                i[5858] = a | t, i[n >> 2] = h, i[h + 24 >> 2] = n, i[h + 12 >> 2] = h, i[h + 8 >> 2] = h;
                                                                break
                                                            }
                                                            n = 0 | i[n >> 2];
                                                            e: do {
                                                                if ((-8 & i[n + 4 >> 2] | 0) != (0 | l)) {
                                                                    for (a = l << (31 == (0 | r) ? 0 : 25 - (r >>> 1) | 0); t = 0 | i[(r = n + 16 + (a >>> 31 << 2) | 0) >> 2];) {
                                                                        if ((-8 & i[t + 4 >> 2] | 0) == (0 | l)) {
                                                                            n = t;
                                                                            break e
                                                                        }
                                                                        a <<= 1, n = t
                                                                    }
                                                                    i[r >> 2] = h, i[h + 24 >> 2] = n, i[h + 12 >> 2] = h, i[h + 8 >> 2] = h;
                                                                    break t
                                                                }
                                                            } while (0);
                                                            b = 0 | i[(x = n + 8 | 0) >> 2], i[b + 12 >> 2] = h, i[x >> 2] = h, i[h + 8 >> 2] = b, i[h + 12 >> 2] = n, i[h + 24 >> 2] = 0
                                                        }
                                                    } while (0);
                                                    return D = e, 0 | A + 8
                                                }
                                                d = u
                                            } else d = u;
                                        else d = -1
                                    } while (0);
                                    if ((r = 0 | i[5859]) >>> 0 >= d >>> 0) return n = r - d | 0, t = 0 | i[5862], n >>> 0 > 15 ? (b = t + d | 0, i[5862] = b, i[5859] = n, i[b + 4 >> 2] = 1 | n, i[t + r >> 2] = n, i[t + 4 >> 2] = 3 | d) : (i[5859] = 0, i[5862] = 0, i[t + 4 >> 2] = 3 | r, i[(b = t + r + 4 | 0) >> 2] = 1 | i[b >> 2]), D = e, 0 | t + 8;
                                    if ((l = 0 | i[5860]) >>> 0 > d >>> 0) return y = l - d | 0, i[5860] = y, x = (b = 0 | i[5863]) + d | 0, i[5863] = x, i[x + 4 >> 2] = 1 | y, i[b + 4 >> 2] = 3 | d, D = e, 0 | b + 8;
                                    if (0 | i[5975] ? t = 0 | i[5977] : (i[5977] = 4096, i[5976] = 4096, i[5978] = -1, i[5979] = -1, i[5980] = 0, i[5968] = 0, i[5975] = -16 & f ^ 1431655768, t = 4096), A = d + 48 | 0, (u = (s = t + (c = d + 47 | 0) | 0) & (o = 0 - t | 0)) >>> 0 <= d >>> 0) return D = e, 0;
                                    if (0 | (t = 0 | i[5967]) && (f = (h = 0 | i[5965]) + u | 0) >>> 0 <= h >>> 0 | f >>> 0 > t >>> 0) return D = e, 0;
                                    t: do {
                                        if (4 & i[5968]) n = 0, g = 143;
                                        else {
                                            r = 0 | i[5863];
                                            e: do {
                                                if (r) {
                                                    for (a = 23876; !((f = 0 | i[a >> 2]) >>> 0 <= r >>> 0 && (f + (0 | i[a + 4 >> 2]) | 0) >>> 0 > r >>> 0);) {
                                                        if (!(t = 0 | i[a + 8 >> 2])) {
                                                            g = 128;
                                                            break e
                                                        }
                                                        a = t
                                                    }
                                                    if ((n = s - l & o) >>> 0 < 2147483647)
                                                        if ((0 | (t = 0 | Qe(0 | n))) == ((0 | i[a >> 2]) + (0 | i[a + 4 >> 2]) | 0)) {
                                                            if (-1 != (0 | t)) {
                                                                l = n, s = t, g = 145;
                                                                break t
                                                            }
                                                        } else a = t, g = 136;
                                                    else n = 0
                                                } else g = 128
                                            } while (0);
                                            do {
                                                if (128 == (0 | g))
                                                    if (-1 != (0 | (r = 0 | Qe(0))) && (n = r, m = (n = (0 == ((m = (p = 0 | i[5976]) - 1 | 0) & n | 0) ? 0 : (m + n & 0 - p) - n | 0) + u | 0) + (p = 0 | i[5965]) | 0, n >>> 0 > d >>> 0 & n >>> 0 < 2147483647)) {
                                                        if (0 | (f = 0 | i[5967]) && m >>> 0 <= p >>> 0 | m >>> 0 > f >>> 0) {
                                                            n = 0;
                                                            break
                                                        }
                                                        if ((0 | (t = 0 | Qe(0 | n))) == (0 | r)) {
                                                            l = n, s = r, g = 145;
                                                            break t
                                                        }
                                                        a = t, g = 136
                                                    } else n = 0
                                            } while (0);
                                            do {
                                                if (136 == (0 | g)) {
                                                    if (r = 0 - n | 0, !(A >>> 0 > n >>> 0 & n >>> 0 < 2147483647 & -1 != (0 | a))) {
                                                        if (-1 == (0 | a)) {
                                                            n = 0;
                                                            break
                                                        }
                                                        l = n, s = a, g = 145;
                                                        break t
                                                    }
                                                    if ((t = c - n + (t = 0 | i[5977]) & 0 - t) >>> 0 >= 2147483647) {
                                                        l = n, s = a, g = 145;
                                                        break t
                                                    }
                                                    if (-1 == (0 | Qe(0 | t))) {
                                                        Qe(0 | r), n = 0;
                                                        break
                                                    }
                                                    l = t + n | 0, s = a, g = 145;
                                                    break t
                                                }
                                            } while (0);
                                            i[5968] = 4 | i[5968], g = 143
                                        }
                                    } while (0);
                                    if (143 == (0 | g) && u >>> 0 < 2147483647 && !(-1 == (0 | (y = 0 | Qe(0 | u))) | 1 ^ (_ = (v = (m = 0 | Qe(0)) - y | 0) >>> 0 > (d + 40 | 0) >>> 0) | y >>> 0 < m >>> 0 & -1 != (0 | y) & -1 != (0 | m) ^ 1) && (l = _ ? v : n, s = y, g = 145), 145 == (0 | g)) {
                                        n = (0 | i[5965]) + l | 0, i[5965] = n, n >>> 0 > (0 | i[5966]) >>> 0 && (i[5966] = n), c = 0 | i[5863];
                                        t: do {
                                            if (c) {
                                                for (n = 23876;;) {
                                                    if ((0 | s) == ((t = 0 | i[n >> 2]) + (r = 0 | i[n + 4 >> 2]) | 0)) {
                                                        g = 154;
                                                        break
                                                    }
                                                    if (!(a = 0 | i[n + 8 >> 2])) break;
                                                    n = a
                                                }
                                                if (154 == (0 | g) && (x = n + 4 | 0, 0 == (8 & i[n + 12 >> 2] | 0)) && s >>> 0 > c >>> 0 & t >>> 0 <= c >>> 0) {
                                                    i[x >> 2] = r + l, x = c + (y = 0 == (7 & (y = c + 8 | 0) | 0) ? 0 : 0 - y & 7) | 0, y = (b = (0 | i[5860]) + l | 0) - y | 0, i[5863] = x, i[5860] = y, i[x + 4 >> 2] = 1 | y, i[c + b + 4 >> 2] = 40, i[5864] = i[5979];
                                                    break
                                                }
                                                for (s >>> 0 < (0 | i[5861]) >>> 0 && (i[5861] = s), r = s + l | 0, n = 23876;;) {
                                                    if ((0 | i[n >> 2]) == (0 | r)) {
                                                        g = 162;
                                                        break
                                                    }
                                                    if (!(t = 0 | i[n + 8 >> 2])) break;
                                                    n = t
                                                }
                                                if (162 == (0 | g) && 0 == (8 & i[n + 12 >> 2] | 0)) {
                                                    i[n >> 2] = s, i[(h = n + 4 | 0) >> 2] = (0 | i[h >> 2]) + l, u = (h = s + (0 == (7 & (h = s + 8 | 0) | 0) ? 0 : 0 - h & 7) | 0) + d | 0, A = (n = r + (0 == (7 & (n = r + 8 | 0) | 0) ? 0 : 0 - n & 7) | 0) - h - d | 0, i[h + 4 >> 2] = 3 | d;
                                                    e: do {
                                                        if ((0 | c) == (0 | n)) b = (0 | i[5860]) + A | 0, i[5860] = b, i[5863] = u, i[u + 4 >> 2] = 1 | b;
                                                        else {
                                                            if ((0 | i[5862]) == (0 | n)) {
                                                                b = (0 | i[5859]) + A | 0, i[5859] = b, i[5862] = u, i[u + 4 >> 2] = 1 | b, i[u + b >> 2] = b;
                                                                break
                                                            }
                                                            if (1 == (3 & (t = 0 | i[n + 4 >> 2]) | 0)) {
                                                                l = -8 & t, a = t >>> 3;
                                                                n: do {
                                                                    if (t >>> 0 < 256) {
                                                                        if (t = 0 | i[n + 8 >> 2], (0 | (r = 0 | i[n + 12 >> 2])) == (0 | t)) {
                                                                            i[5857] = i[5857] & ~(1 << a);
                                                                            break
                                                                        }
                                                                        i[t + 12 >> 2] = r, i[r + 8 >> 2] = t;
                                                                        break
                                                                    }
                                                                    s = 0 | i[n + 24 >> 2], t = 0 | i[n + 12 >> 2];
                                                                    do {
                                                                        if ((0 | t) == (0 | n)) {
                                                                            if (t = 0 | i[(a = 4 + (r = n + 16 | 0) | 0) >> 2]) r = a;
                                                                            else if (!(t = 0 | i[r >> 2])) {
                                                                                t = 0;
                                                                                break
                                                                            }
                                                                            for (;;)
                                                                                if (a = 0 | i[(o = t + 20 | 0) >> 2]) t = a, r = o;
                                                                                else {
                                                                                    if (!(a = 0 | i[(o = t + 16 | 0) >> 2])) break;
                                                                                    t = a, r = o
                                                                                } i[r >> 2] = 0
                                                                        } else b = 0 | i[n + 8 >> 2], i[b + 12 >> 2] = t, i[t + 8 >> 2] = b
                                                                    } while (0);
                                                                    if (!s) break;
                                                                    a = 23732 + ((r = 0 | i[n + 28 >> 2]) << 2) | 0;
                                                                    do {
                                                                        if ((0 | i[a >> 2]) == (0 | n)) {
                                                                            if (i[a >> 2] = t, 0 | t) break;
                                                                            i[5858] = i[5858] & ~(1 << r);
                                                                            break n
                                                                        }
                                                                        if (i[((0 | i[(b = s + 16 | 0) >> 2]) == (0 | n) ? b : s + 20 | 0) >> 2] = t, !t) break n
                                                                    } while (0);
                                                                    if (i[t + 24 >> 2] = s, 0 | (a = 0 | i[(r = n + 16 | 0) >> 2]) && (i[t + 16 >> 2] = a, i[a + 24 >> 2] = t), !(r = 0 | i[r + 4 >> 2])) break;
                                                                    i[t + 20 >> 2] = r, i[r + 24 >> 2] = t
                                                                } while (0);
                                                                n = n + l | 0, o = l + A | 0
                                                            } else o = A;
                                                            if (i[(n = n + 4 | 0) >> 2] = -2 & i[n >> 2], i[u + 4 >> 2] = 1 | o, i[u + o >> 2] = o, n = o >>> 3, o >>> 0 < 256) {
                                                                r = 23468 + (n << 1 << 2) | 0, (t = 0 | i[5857]) & (n = 1 << n) ? n = 0 | i[(t = r + 8 | 0) >> 2] : (i[5857] = t | n, n = r, t = r + 8 | 0), i[t >> 2] = u, i[n + 12 >> 2] = u, i[u + 8 >> 2] = n, i[u + 12 >> 2] = r;
                                                                break
                                                            }
                                                            n = o >>> 8;
                                                            do {
                                                                if (n) {
                                                                    if (o >>> 0 > 16777215) {
                                                                        a = 31;
                                                                        break
                                                                    }
                                                                    a = o >>> (7 + (a = 14 - ((y = (520192 + (b = n << (x = (n + 1048320 | 0) >>> 16 & 8)) | 0) >>> 16 & 4) | x | (a = (245760 + (b <<= y) | 0) >>> 16 & 2)) + (b << a >>> 15) | 0) | 0) & 1 | a << 1
                                                                } else a = 0
                                                            } while (0);
                                                            if (n = 23732 + (a << 2) | 0, i[u + 28 >> 2] = a, i[4 + (t = u + 16 | 0) >> 2] = 0, i[t >> 2] = 0, !((t = 0 | i[5858]) & (r = 1 << a))) {
                                                                i[5858] = t | r, i[n >> 2] = u, i[u + 24 >> 2] = n, i[u + 12 >> 2] = u, i[u + 8 >> 2] = u;
                                                                break
                                                            }
                                                            n = 0 | i[n >> 2];
                                                            n: do {
                                                                if ((-8 & i[n + 4 >> 2] | 0) != (0 | o)) {
                                                                    for (a = o << (31 == (0 | a) ? 0 : 25 - (a >>> 1) | 0); t = 0 | i[(r = n + 16 + (a >>> 31 << 2) | 0) >> 2];) {
                                                                        if ((-8 & i[t + 4 >> 2] | 0) == (0 | o)) {
                                                                            n = t;
                                                                            break n
                                                                        }
                                                                        a <<= 1, n = t
                                                                    }
                                                                    i[r >> 2] = u, i[u + 24 >> 2] = n, i[u + 12 >> 2] = u, i[u + 8 >> 2] = u;
                                                                    break e
                                                                }
                                                            } while (0);
                                                            b = 0 | i[(x = n + 8 | 0) >> 2], i[b + 12 >> 2] = u, i[x >> 2] = u, i[u + 8 >> 2] = b, i[u + 12 >> 2] = n, i[u + 24 >> 2] = 0
                                                        }
                                                    } while (0);
                                                    return D = e, 0 | h + 8
                                                }
                                                for (n = 23876; !((t = 0 | i[n >> 2]) >>> 0 <= c >>> 0 && (b = t + (0 | i[n + 4 >> 2]) | 0) >>> 0 > c >>> 0);) n = 0 | i[n + 8 >> 2];
                                                n = (t = (t = (o = b + -47 | 0) + (0 == (7 & (t = o + 8 | 0) | 0) ? 0 : 0 - t & 7) | 0) >>> 0 < (o = c + 16 | 0) >>> 0 ? c : t) + 8 | 0, x = s + (y = 0 == (7 & (y = s + 8 | 0) | 0) ? 0 : 0 - y & 7) | 0, y = (r = l + -40 | 0) - y | 0, i[5863] = x, i[5860] = y, i[x + 4 >> 2] = 1 | y, i[s + r + 4 >> 2] = 40, i[5864] = i[5979], i[(r = t + 4 | 0) >> 2] = 27, i[n >> 2] = i[5969], i[n + 4 >> 2] = i[5970], i[n + 8 >> 2] = i[5971], i[n + 12 >> 2] = i[5972], i[5969] = s, i[5970] = l, i[5972] = 0, i[5971] = n, n = t + 24 | 0;
                                                do {
                                                    x = n, i[(n = n + 4 | 0) >> 2] = 7
                                                } while ((x + 8 | 0) >>> 0 < b >>> 0);
                                                if ((0 | t) != (0 | c)) {
                                                    if (s = t - c | 0, i[r >> 2] = -2 & i[r >> 2], i[c + 4 >> 2] = 1 | s, i[t >> 2] = s, n = s >>> 3, s >>> 0 < 256) {
                                                        r = 23468 + (n << 1 << 2) | 0, (t = 0 | i[5857]) & (n = 1 << n) ? n = 0 | i[(t = r + 8 | 0) >> 2] : (i[5857] = t | n, n = r, t = r + 8 | 0), i[t >> 2] = c, i[n + 12 >> 2] = c, i[c + 8 >> 2] = n, i[c + 12 >> 2] = r;
                                                        break
                                                    }
                                                    if (r = 23732 + ((a = (n = s >>> 8) ? s >>> 0 > 16777215 ? 31 : s >>> (7 + (a = 14 - ((y = (520192 + (b = n << (x = (n + 1048320 | 0) >>> 16 & 8)) | 0) >>> 16 & 4) | x | (a = (245760 + (b <<= y) | 0) >>> 16 & 2)) + (b << a >>> 15) | 0) | 0) & 1 | a << 1 : 0) << 2) | 0, i[c + 28 >> 2] = a, i[c + 20 >> 2] = 0, i[o >> 2] = 0, !((n = 0 | i[5858]) & (t = 1 << a))) {
                                                        i[5858] = n | t, i[r >> 2] = c, i[c + 24 >> 2] = r, i[c + 12 >> 2] = c, i[c + 8 >> 2] = c;
                                                        break
                                                    }
                                                    n = 0 | i[r >> 2];
                                                    e: do {
                                                        if ((-8 & i[n + 4 >> 2] | 0) != (0 | s)) {
                                                            for (a = s << (31 == (0 | a) ? 0 : 25 - (a >>> 1) | 0); t = 0 | i[(r = n + 16 + (a >>> 31 << 2) | 0) >> 2];) {
                                                                if ((-8 & i[t + 4 >> 2] | 0) == (0 | s)) {
                                                                    n = t;
                                                                    break e
                                                                }
                                                                a <<= 1, n = t
                                                            }
                                                            i[r >> 2] = c, i[c + 24 >> 2] = n, i[c + 12 >> 2] = c, i[c + 8 >> 2] = c;
                                                            break t
                                                        }
                                                    } while (0);
                                                    b = 0 | i[(x = n + 8 | 0) >> 2], i[b + 12 >> 2] = c, i[x >> 2] = c, i[c + 8 >> 2] = b, i[c + 12 >> 2] = n, i[c + 24 >> 2] = 0
                                                }
                                            } else 0 == (0 | (b = 0 | i[5861])) | s >>> 0 < b >>> 0 && (i[5861] = s), i[5969] = s, i[5970] = l, i[5972] = 0, i[5866] = i[5975], i[5865] = -1, i[5870] = 23468, i[5869] = 23468, i[5872] = 23476, i[5871] = 23476, i[5874] = 23484, i[5873] = 23484, i[5876] = 23492, i[5875] = 23492, i[5878] = 23500, i[5877] = 23500, i[5880] = 23508, i[5879] = 23508, i[5882] = 23516, i[5881] = 23516, i[5884] = 23524, i[5883] = 23524, i[5886] = 23532, i[5885] = 23532, i[5888] = 23540, i[5887] = 23540, i[5890] = 23548, i[5889] = 23548, i[5892] = 23556, i[5891] = 23556, i[5894] = 23564, i[5893] = 23564, i[5896] = 23572, i[5895] = 23572, i[5898] = 23580, i[5897] = 23580, i[5900] = 23588, i[5899] = 23588, i[5902] = 23596, i[5901] = 23596, i[5904] = 23604, i[5903] = 23604, i[5906] = 23612, i[5905] = 23612, i[5908] = 23620, i[5907] = 23620, i[5910] = 23628, i[5909] = 23628, i[5912] = 23636, i[5911] = 23636, i[5914] = 23644, i[5913] = 23644, i[5916] = 23652, i[5915] = 23652, i[5918] = 23660, i[5917] = 23660, i[5920] = 23668, i[5919] = 23668, i[5922] = 23676, i[5921] = 23676, i[5924] = 23684, i[5923] = 23684, i[5926] = 23692, i[5925] = 23692, i[5928] = 23700, i[5927] = 23700, i[5930] = 23708, i[5929] = 23708, i[5932] = 23716, i[5931] = 23716, x = s + (y = 0 == (7 & (y = s + 8 | 0) | 0) ? 0 : 0 - y & 7) | 0, y = (b = l + -40 | 0) - y | 0, i[5863] = x, i[5860] = y, i[x + 4 >> 2] = 1 | y, i[s + b + 4 >> 2] = 40, i[5864] = i[5979]
                                        } while (0);
                                        if ((n = 0 | i[5860]) >>> 0 > d >>> 0) return y = n - d | 0, i[5860] = y, x = (b = 0 | i[5863]) + d | 0, i[5863] = x, i[x + 4 >> 2] = 1 | y, i[b + 4 >> 2] = 3 | d, D = e, 0 | b + 8
                                    }
                                    return i[(b = 23424) >> 2] = 12, D = e, 0
                                }

                                function Pe(t) {
                                    var e = 0,
                                        n = 0,
                                        r = 0,
                                        a = 0,
                                        o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0;
                                    if (t |= 0) {
                                        n = t + -8 | 0, a = 0 | i[5861], A = n + (e = -8 & (t = 0 | i[t + -4 >> 2])) | 0;
                                        do {
                                            if (1 & t) l = n, s = n;
                                            else {
                                                if (r = 0 | i[n >> 2], !(3 & t)) return;
                                                if (o = r + e | 0, (s = n + (0 - r) | 0) >>> 0 < a >>> 0) return;
                                                if ((0 | i[5862]) == (0 | s)) {
                                                    if (3 != (3 & (e = 0 | i[(t = A + 4 | 0) >> 2]) | 0)) {
                                                        l = s, e = o;
                                                        break
                                                    }
                                                    return i[5859] = o, i[t >> 2] = -2 & e, i[s + 4 >> 2] = 1 | o, void(i[s + o >> 2] = o)
                                                }
                                                if (n = r >>> 3, r >>> 0 < 256) {
                                                    if (t = 0 | i[s + 8 >> 2], (0 | (e = 0 | i[s + 12 >> 2])) == (0 | t)) {
                                                        i[5857] = i[5857] & ~(1 << n), l = s, e = o;
                                                        break
                                                    }
                                                    i[t + 12 >> 2] = e, i[e + 8 >> 2] = t, l = s, e = o;
                                                    break
                                                }
                                                a = 0 | i[s + 24 >> 2], t = 0 | i[s + 12 >> 2];
                                                do {
                                                    if ((0 | t) == (0 | s)) {
                                                        if (t = 0 | i[(n = 4 + (e = s + 16 | 0) | 0) >> 2]) e = n;
                                                        else if (!(t = 0 | i[e >> 2])) {
                                                            t = 0;
                                                            break
                                                        }
                                                        for (;;)
                                                            if (n = 0 | i[(r = t + 20 | 0) >> 2]) t = n, e = r;
                                                            else {
                                                                if (!(n = 0 | i[(r = t + 16 | 0) >> 2])) break;
                                                                t = n, e = r
                                                            } i[e >> 2] = 0
                                                    } else l = 0 | i[s + 8 >> 2], i[l + 12 >> 2] = t, i[t + 8 >> 2] = l
                                                } while (0);
                                                if (a) {
                                                    if (e = 0 | i[s + 28 >> 2], (0 | i[(n = 23732 + (e << 2) | 0) >> 2]) == (0 | s)) {
                                                        if (i[n >> 2] = t, !t) {
                                                            i[5858] = i[5858] & ~(1 << e), l = s, e = o;
                                                            break
                                                        }
                                                    } else if (i[((0 | i[(l = a + 16 | 0) >> 2]) == (0 | s) ? l : a + 20 | 0) >> 2] = t, !t) {
                                                        l = s, e = o;
                                                        break
                                                    }
                                                    i[t + 24 >> 2] = a, 0 | (n = 0 | i[(e = s + 16 | 0) >> 2]) && (i[t + 16 >> 2] = n, i[n + 24 >> 2] = t), (e = 0 | i[e + 4 >> 2]) ? (i[t + 20 >> 2] = e, i[e + 24 >> 2] = t, l = s, e = o) : (l = s, e = o)
                                                } else l = s, e = o
                                            }
                                        } while (0);
                                        if (!(s >>> 0 >= A >>> 0) && 1 & (r = 0 | i[(t = A + 4 | 0) >> 2])) {
                                            if (2 & r) i[t >> 2] = -2 & r, i[l + 4 >> 2] = 1 | e, i[s + e >> 2] = e, a = e;
                                            else {
                                                if ((0 | i[5863]) == (0 | A)) {
                                                    if (A = (0 | i[5860]) + e | 0, i[5860] = A, i[5863] = l, i[l + 4 >> 2] = 1 | A, (0 | l) != (0 | i[5862])) return;
                                                    return i[5862] = 0, void(i[5859] = 0)
                                                }
                                                if ((0 | i[5862]) == (0 | A)) return A = (0 | i[5859]) + e | 0, i[5859] = A, i[5862] = s, i[l + 4 >> 2] = 1 | A, void(i[s + A >> 2] = A);
                                                a = (-8 & r) + e | 0, n = r >>> 3;
                                                do {
                                                    if (r >>> 0 < 256) {
                                                        if (e = 0 | i[A + 8 >> 2], (0 | (t = 0 | i[A + 12 >> 2])) == (0 | e)) {
                                                            i[5857] = i[5857] & ~(1 << n);
                                                            break
                                                        }
                                                        i[e + 12 >> 2] = t, i[t + 8 >> 2] = e;
                                                        break
                                                    }
                                                    o = 0 | i[A + 24 >> 2], t = 0 | i[A + 12 >> 2];
                                                    do {
                                                        if ((0 | t) == (0 | A)) {
                                                            if (t = 0 | i[(n = 4 + (e = A + 16 | 0) | 0) >> 2]) e = n;
                                                            else if (!(t = 0 | i[e >> 2])) {
                                                                n = 0;
                                                                break
                                                            }
                                                            for (;;)
                                                                if (n = 0 | i[(r = t + 20 | 0) >> 2]) t = n, e = r;
                                                                else {
                                                                    if (!(n = 0 | i[(r = t + 16 | 0) >> 2])) break;
                                                                    t = n, e = r
                                                                } i[e >> 2] = 0, n = t
                                                        } else n = 0 | i[A + 8 >> 2], i[n + 12 >> 2] = t, i[t + 8 >> 2] = n, n = t
                                                    } while (0);
                                                    if (0 | o) {
                                                        if (t = 0 | i[A + 28 >> 2], (0 | i[(e = 23732 + (t << 2) | 0) >> 2]) == (0 | A)) {
                                                            if (i[e >> 2] = n, !n) {
                                                                i[5858] = i[5858] & ~(1 << t);
                                                                break
                                                            }
                                                        } else if (i[((0 | i[(r = o + 16 | 0) >> 2]) == (0 | A) ? r : o + 20 | 0) >> 2] = n, !n) break;
                                                        i[n + 24 >> 2] = o, 0 | (e = 0 | i[(t = A + 16 | 0) >> 2]) && (i[n + 16 >> 2] = e, i[e + 24 >> 2] = n), 0 | (t = 0 | i[t + 4 >> 2]) && (i[n + 20 >> 2] = t, i[t + 24 >> 2] = n)
                                                    }
                                                } while (0);
                                                if (i[l + 4 >> 2] = 1 | a, i[s + a >> 2] = a, (0 | l) == (0 | i[5862])) return void(i[5859] = a)
                                            }
                                            if (t = a >>> 3, a >>> 0 < 256) return n = 23468 + (t << 1 << 2) | 0, (e = 0 | i[5857]) & (t = 1 << t) ? t = 0 | i[(e = n + 8 | 0) >> 2] : (i[5857] = e | t, t = n, e = n + 8 | 0), i[e >> 2] = l, i[t + 12 >> 2] = l, i[l + 8 >> 2] = t, void(i[l + 12 >> 2] = n);
                                            t = 23732 + ((r = (t = a >>> 8) ? a >>> 0 > 16777215 ? 31 : a >>> (7 + (r = 14 - ((o = (520192 + (A = t << (s = (t + 1048320 | 0) >>> 16 & 8)) | 0) >>> 16 & 4) | s | (r = (245760 + (A <<= o) | 0) >>> 16 & 2)) + (A << r >>> 15) | 0) | 0) & 1 | r << 1 : 0) << 2) | 0, i[l + 28 >> 2] = r, i[l + 20 >> 2] = 0, i[l + 16 >> 2] = 0, e = 0 | i[5858], n = 1 << r;
                                            t: do {
                                                if (e & n) {
                                                    t = 0 | i[t >> 2];
                                                    e: do {
                                                        if ((-8 & i[t + 4 >> 2] | 0) != (0 | a)) {
                                                            for (r = a << (31 == (0 | r) ? 0 : 25 - (r >>> 1) | 0); e = 0 | i[(n = t + 16 + (r >>> 31 << 2) | 0) >> 2];) {
                                                                if ((-8 & i[e + 4 >> 2] | 0) == (0 | a)) {
                                                                    t = e;
                                                                    break e
                                                                }
                                                                r <<= 1, t = e
                                                            }
                                                            i[n >> 2] = l, i[l + 24 >> 2] = t, i[l + 12 >> 2] = l, i[l + 8 >> 2] = l;
                                                            break t
                                                        }
                                                    } while (0);
                                                    A = 0 | i[(s = t + 8 | 0) >> 2], i[A + 12 >> 2] = l, i[s >> 2] = l, i[l + 8 >> 2] = A, i[l + 12 >> 2] = t, i[l + 24 >> 2] = 0
                                                } else i[5858] = e | n, i[t >> 2] = l, i[l + 24 >> 2] = t, i[l + 12 >> 2] = l, i[l + 8 >> 2] = l
                                            } while (0);
                                            if (A = (0 | i[5865]) - 1 | 0, i[5865] = A, !(0 | A)) {
                                                for (t = 23884; t = 0 | i[t >> 2];) t = t + 8 | 0;
                                                i[5865] = -1
                                            }
                                        }
                                    }
                                }

                                function Le(t, e) {
                                    e |= 0;
                                    var n = 0;
                                    return (t |= 0) ? (n = 0 | y(e, t), (e | t) >>> 0 > 65535 && (n = (0 | (n >>> 0) / (t >>> 0)) == (0 | e) ? n : -1)) : n = 0, (t = 0 | Re(n)) && 3 & i[t + -4 >> 2] ? (Xe(0 | t, 0, 0 | n), 0 | t) : 0 | t
                                }

                                function De(t, e, n, r) {
                                    return 0 | (w((e |= 0) + (r |= 0) + ((n = (t |= 0) + (n |= 0) >>> 0) >>> 0 < t >>> 0 | 0) >>> 0 | 0), 0 | n)
                                }

                                function Ie(t, e, n, r) {
                                    return 0 | (w(0 | (r = (e |= 0) - (r |= 0) - ((n |= 0) >>> 0 > (t |= 0) >>> 0 | 0) >>> 0)), t - n >>> 0 | 0)
                                }

                                function Oe(t) {
                                    return 0 | ((t |= 0) ? 31 - (0 | M(t ^ t - 1)) | 0 : 32)
                                }

                                function Be(t, e, n, r, a) {
                                    a |= 0;
                                    var o = 0,
                                        s = 0,
                                        l = 0,
                                        A = 0,
                                        c = 0,
                                        u = 0,
                                        h = 0,
                                        d = 0,
                                        f = 0,
                                        p = 0;
                                    if (u = t |= 0, s = n |= 0, l = d = r |= 0, !(c = A = e |= 0)) return o = 0 != (0 | a), l ? o ? (i[a >> 2] = 0 | t, i[a + 4 >> 2] = 0 & e, a = 0, 0 | (w(0 | (d = 0)), a)) : (a = 0, 0 | (w(0 | (d = 0)), a)) : (o && (i[a >> 2] = (u >>> 0) % (s >>> 0), i[a + 4 >> 2] = 0), a = (u >>> 0) / (s >>> 0) >>> 0, 0 | (w(0 | (d = 0)), a));
                                    o = 0 == (0 | l);
                                    do {
                                        if (s) {
                                            if (!o) {
                                                if ((o = (0 | M(0 | l)) - (0 | M(0 | c)) | 0) >>> 0 <= 31) {
                                                    s = h = o + 1 | 0, t = u >>> (h >>> 0) & (e = o - 31 >> 31) | c << (l = 31 - o | 0), e &= c >>> (h >>> 0), o = 0, l = u << l;
                                                    break
                                                }
                                                return a ? (i[a >> 2] = 0 | t, i[a + 4 >> 2] = A | 0 & e, a = 0, 0 | (w(0 | (d = 0)), a)) : (a = 0, 0 | (w(0 | (d = 0)), a))
                                            }
                                            if ((o = s - 1 | 0) & s | 0) {
                                                s = l = 33 + (0 | M(0 | s)) - (0 | M(0 | c)) | 0, t = (h = 32 - l | 0) - 1 >> 31 & c >>> ((f = l - 32 | 0) >>> 0) | (c << h | u >>> (l >>> 0)) & (e = f >> 31), e &= c >>> (l >>> 0), o = u << (p = 64 - l | 0) & (A = h >> 31), l = (c << p | u >>> (f >>> 0)) & A | u << h & l - 33 >> 31;
                                                break
                                            }
                                            return 0 | a && (i[a >> 2] = o & u, i[a + 4 >> 2] = 0), 1 == (0 | s) ? (p = 0 | t, 0 | (w(0 | (f = A | 0 & e)), p)) : (f = c >>> ((p = 0 | Oe(0 | s)) >>> 0) | 0, p = c << 32 - p | u >>> (p >>> 0) | 0, 0 | (w(0 | f), p))
                                        }
                                        if (o) return 0 | a && (i[a >> 2] = (c >>> 0) % (s >>> 0), i[a + 4 >> 2] = 0), p = (c >>> 0) / (s >>> 0) >>> 0, 0 | (w(0 | (f = 0)), p);
                                        if (!u) return 0 | a && (i[a >> 2] = 0, i[a + 4 >> 2] = (c >>> 0) % (l >>> 0)), p = (c >>> 0) / (l >>> 0) >>> 0, 0 | (w(0 | (f = 0)), p);
                                        if (!((o = l - 1 | 0) & l)) return 0 | a && (i[a >> 2] = 0 | t, i[a + 4 >> 2] = o & c | 0 & e), f = 0, p = c >>> ((0 | Oe(0 | l)) >>> 0), 0 | (w(0 | f), p);
                                        if ((o = (0 | M(0 | l)) - (0 | M(0 | c)) | 0) >>> 0 <= 30) {
                                            s = e = o + 1 | 0, t = c << (l = 31 - o | 0) | u >>> (e >>> 0), e = c >>> (e >>> 0), o = 0, l = u << l;
                                            break
                                        }
                                        return a ? (i[a >> 2] = 0 | t, i[a + 4 >> 2] = A | 0 & e, p = 0, 0 | (w(0 | (f = 0)), p)) : (p = 0, 0 | (w(0 | (f = 0)), p))
                                    } while (0);
                                    if (s) {
                                        c = 0 | De(0 | (h = 0 | n), 0 | (u = d | 0 & r), -1, -1), n = 0 | S(), A = l, l = 0;
                                        do {
                                            r = A, A = o >>> 31 | A << 1, o = l | o << 1, Ie(0 | c, 0 | n, 0 | (r = t << 1 | r >>> 31 | 0), 0 | (d = t >>> 31 | e << 1 | 0)), l = 1 & (f = (p = 0 | S()) >> 31 | ((0 | p) < 0 ? -1 : 0) << 1), t = 0 | Ie(0 | r, 0 | d, f & h | 0, (((0 | p) < 0 ? -1 : 0) >> 31 | ((0 | p) < 0 ? -1 : 0) << 1) & u | 0), e = 0 | S(), s = s - 1 | 0
                                        } while (0 != (0 | s));
                                        c = A, A = 0
                                    } else c = l, A = 0, l = 0;
                                    return s = 0, 0 | a && (i[a >> 2] = t, i[a + 4 >> 2] = e), p = -2 & (o << 1 | 0) | l, 0 | (w(0 | (f = (0 | o) >>> 31 | (c | s) << 1 | 0 & (s << 1 | o >>> 31) | A)), p)
                                }

                                function qe(t, e, n, r) {
                                    var i, a, o, s, l;
                                    return n |= 0, a = (r |= 0) >> 31 | ((0 | r) < 0 ? -1 : 0) << 1, i = ((0 | r) < 0 ? -1 : 0) >> 31 | ((0 | r) < 0 ? -1 : 0) << 1, o = 0 | Ie((l = (e |= 0) >> 31 | ((0 | e) < 0 ? -1 : 0) << 1) ^ (t |= 0) | 0, (s = ((0 | e) < 0 ? -1 : 0) >> 31 | ((0 | e) < 0 ? -1 : 0) << 1) ^ e | 0, 0 | l, 0 | s), t = a ^ l, e = i ^ s, 0 | Ie((0 | Be(o, 0 | S(), 0 | Ie(a ^ n | 0, i ^ r | 0, 0 | a, 0 | i), 0 | S(), 0)) ^ t | 0, (0 | S()) ^ e | 0, 0 | t, 0 | e)
                                }

                                function Ue(t, e, n, r) {
                                    var i, a;
                                    return e |= 0, r |= 0, n = 0 | function(t, e) {
                                        var n, r, i, a = 0;
                                        return t = ((n = 0 | y(a = 65535 & (e |= 0), i = 65535 & (t |= 0))) >>> 16) + (0 | y(a, r = t >>> 16)) | 0, e = 0 | y(a = e >>> 16, i), 0 | (w((t >>> 16) + (0 | y(a, r)) + (((65535 & t) + e | 0) >>> 16) | 0), t + e << 16 | 65535 & n | 0)
                                    }(i = t |= 0, a = n |= 0), t = 0 | S(), 0 | (w((0 | y(e, a)) + (0 | y(r, i)) + t | 0 & t | 0), 0 | n)
                                }

                                function Ne(t, e, n, r) {
                                    var a, o, s, l, A, c;
                                    return n |= 0, a = D, D = D + 16 | 0, l = 0 | a, c = (r |= 0) >> 31 | ((0 | r) < 0 ? -1 : 0) << 1, A = ((0 | r) < 0 ? -1 : 0) >> 31 | ((0 | r) < 0 ? -1 : 0) << 1, Be(t = 0 | Ie((s = (e |= 0) >> 31 | ((0 | e) < 0 ? -1 : 0) << 1) ^ (t |= 0) | 0, (o = ((0 | e) < 0 ? -1 : 0) >> 31 | ((0 | e) < 0 ? -1 : 0) << 1) ^ e | 0, 0 | s, 0 | o), e = 0 | S(), 0 | Ie(c ^ n | 0, A ^ r | 0, 0 | c, 0 | A), 0 | S(), l), r = 0 | Ie(i[l >> 2] ^ s | 0, i[l + 4 >> 2] ^ o | 0, 0 | s, 0 | o), n = 0 | S(), D = a, 0 | (w(0 | n), r)
                                }

                                function ke(t, e, n, r) {
                                    var a, o;
                                    return o = D, D = D + 16 | 0, Be(t |= 0, e |= 0, n |= 0, r |= 0, a = 0 | o), D = o, 0 | (w(0 | i[a + 4 >> 2]), 0 | i[a >> 2])
                                }

                                function Fe(t, e, n) {
                                    return t |= 0, e |= 0, (0 | (n |= 0)) < 32 ? (w(e >> n | 0), t >>> n | (e & (1 << n) - 1) << 32 - n) : (w(0 | ((0 | e) < 0 ? -1 : 0)), e >> n - 32 | 0)
                                }

                                function ze(t, e, n) {
                                    return t |= 0, e |= 0, (0 | (n |= 0)) < 32 ? (w(e >>> n | 0), t >>> n | (e & (1 << n) - 1) << 32 - n) : (w(0), e >>> n - 32 | 0)
                                }

                                function Ge(t, e, n) {
                                    return t |= 0, (0 | (n |= 0)) < 32 ? (w((e |= 0) << n | (t & (1 << n) - 1 << 32 - n) >>> 32 - n | 0), t << n) : (w(t << n - 32 | 0), 0)
                                }

                                function je(t, e) {
                                    return e = +e, (t = +t) != t ? +e : e != e ? +t : +b(+t, +e)
                                }

                                function Ve(t, e) {
                                    return e = +e, (t = +t) != t ? +e : e != e ? +t : +x(+t, +e)
                                }

                                function He(t) {
                                    return (t = +t) >= 0 ? +l(t + .5) : +_(t - .5)
                                }

                                function We(t, e, n) {
                                    t |= 0, e |= 0;
                                    var a, o, s = 0;
                                    if ((0 | (n |= 0)) >= 8192) return R(0 | t, 0 | e, 0 | n), 0 | t;
                                    if (o = 0 | t, a = t + n | 0, (3 & t) == (3 & e)) {
                                        for (; 3 & t;) {
                                            if (!n) return 0 | o;
                                            r[t >> 0] = 0 | r[e >> 0], t = t + 1 | 0, e = e + 1 | 0, n = n - 1 | 0
                                        }
                                        for (s = (n = -4 & a | 0) - 64 | 0;
                                            (0 | t) <= (0 | s);) i[t >> 2] = i[e >> 2], i[t + 4 >> 2] = i[e + 4 >> 2], i[t + 8 >> 2] = i[e + 8 >> 2], i[t + 12 >> 2] = i[e + 12 >> 2], i[t + 16 >> 2] = i[e + 16 >> 2], i[t + 20 >> 2] = i[e + 20 >> 2], i[t + 24 >> 2] = i[e + 24 >> 2], i[t + 28 >> 2] = i[e + 28 >> 2], i[t + 32 >> 2] = i[e + 32 >> 2], i[t + 36 >> 2] = i[e + 36 >> 2], i[t + 40 >> 2] = i[e + 40 >> 2], i[t + 44 >> 2] = i[e + 44 >> 2], i[t + 48 >> 2] = i[e + 48 >> 2], i[t + 52 >> 2] = i[e + 52 >> 2], i[t + 56 >> 2] = i[e + 56 >> 2], i[t + 60 >> 2] = i[e + 60 >> 2], t = t + 64 | 0, e = e + 64 | 0;
                                        for (;
                                            (0 | t) < (0 | n);) i[t >> 2] = i[e >> 2], t = t + 4 | 0, e = e + 4 | 0
                                    } else
                                        for (n = a - 4 | 0;
                                            (0 | t) < (0 | n);) r[t >> 0] = 0 | r[e >> 0], r[t + 1 >> 0] = 0 | r[e + 1 >> 0], r[t + 2 >> 0] = 0 | r[e + 2 >> 0], r[t + 3 >> 0] = 0 | r[e + 3 >> 0], t = t + 4 | 0, e = e + 4 | 0;
                                    for (;
                                        (0 | t) < (0 | a);) r[t >> 0] = 0 | r[e >> 0], t = t + 1 | 0, e = e + 1 | 0;
                                    return 0 | o
                                }

                                function Xe(t, e, n) {
                                    e |= 0;
                                    var a, o = 0,
                                        s = 0,
                                        l = 0;
                                    if (a = (t |= 0) + (n |= 0) | 0, e &= 255, (0 | n) >= 67) {
                                        for (; 3 & t;) r[t >> 0] = e, t = t + 1 | 0;
                                        for (l = e | e << 8 | e << 16 | e << 24, s = (o = -4 & a | 0) - 64 | 0;
                                            (0 | t) <= (0 | s);) i[t >> 2] = l, i[t + 4 >> 2] = l, i[t + 8 >> 2] = l, i[t + 12 >> 2] = l, i[t + 16 >> 2] = l, i[t + 20 >> 2] = l, i[t + 24 >> 2] = l, i[t + 28 >> 2] = l, i[t + 32 >> 2] = l, i[t + 36 >> 2] = l, i[t + 40 >> 2] = l, i[t + 44 >> 2] = l, i[t + 48 >> 2] = l, i[t + 52 >> 2] = l, i[t + 56 >> 2] = l, i[t + 60 >> 2] = l, t = t + 64 | 0;
                                        for (;
                                            (0 | t) < (0 | o);) i[t >> 2] = l, t = t + 4 | 0
                                    }
                                    for (;
                                        (0 | t) < (0 | a);) r[t >> 0] = e, t = t + 1 | 0;
                                    return a - n | 0
                                }

                                function Ye(t) {
                                    return (t = +t) >= 0 ? +l(t + .5) : +_(t - .5)
                                }

                                function Qe(t) {
                                    var e, n, r;
                                    return t |= 0, r = 0 | C(), (0 | t) > 0 & (0 | (e = (n = 0 | i[s >> 2]) + t | 0)) < (0 | n) | (0 | e) < 0 ? (L(0 | e), T(12), -1) : (0 | e) > (0 | r) && !(0 | P(0 | e)) ? (T(12), -1) : (i[s >> 2] = e, 0 | n)
                                }
                                return {
                                    ___divdi3: qe,
                                    ___muldi3: Ue,
                                    ___remdi3: Ne,
                                    ___uremdi3: ke,
                                    _areNeighborCells: function(t, e, n, r, a) {
                                        a |= 0;
                                        var o, s, l, A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0;
                                        if (l = D, D = D + 64 | 0, s = l, o = l + 56 | 0, !(!0 & 134217728 == (2013265920 & (e |= 0) | 0) & !0 & 134217728 == (2013265920 & (r |= 0) | 0))) return D = l, 5;
                                        if ((0 | (t |= 0)) == (0 | (n |= 0)) & (0 | e) == (0 | r)) return i[a >> 2] = 0, D = l, 0;
                                        if (c = 0 | ze(0 | t, 0 | e, 52), S(), c &= 15, h = 0 | ze(0 | n, 0 | r, 52), S(), (0 | c) != (15 & h | 0)) return D = l, 12;
                                        if (A = c + -1 | 0, c >>> 0 > 1) {
                                            Bt(t, e, A, s), Bt(n, r, A, o), u = 0 | i[(h = s) >> 2], h = 0 | i[h + 4 >> 2];
                                            t: do {
                                                if ((0 | u) == (0 | i[o >> 2]) && (0 | h) == (0 | i[o + 4 >> 2])) {
                                                    A = 0 | ze(0 | t, 0 | e, 0 | (c = 3 * (15 ^ c) | 0)), S(), A &= 7, c = 0 | ze(0 | n, 0 | r, 0 | c), S(), c &= 7;
                                                    do {
                                                        if (0 == (0 | A) | 0 == (0 | c)) i[a >> 2] = 1, A = 0;
                                                        else if (7 == (0 | A)) A = 5;
                                                        else {
                                                            if (1 == (0 | A) | 1 == (0 | c) && 0 | Ut(u, h)) {
                                                                A = 5;
                                                                break
                                                            }
                                                            if ((0 | i[15536 + (A << 2) >> 2]) != (0 | c) && (0 | i[15568 + (A << 2) >> 2]) != (0 | c)) break t;
                                                            i[a >> 2] = 1, A = 0
                                                        }
                                                    } while (0);
                                                    return D = l, 0 | A
                                                }
                                            } while (0)
                                        }
                                        c = (A = s) + 56 | 0;
                                        do {
                                            i[A >> 2] = 0, A = A + 4 | 0
                                        } while ((0 | A) < (0 | c));
                                        return I(t, e, 1, s), A = (0 | i[(e = s) >> 2]) == (0 | n) && (0 | i[e + 4 >> 2]) == (0 | r) || (0 | i[(e = s + 8 | 0) >> 2]) == (0 | n) && (0 | i[e + 4 >> 2]) == (0 | r) || (0 | i[(e = s + 16 | 0) >> 2]) == (0 | n) && (0 | i[e + 4 >> 2]) == (0 | r) || (0 | i[(e = s + 24 | 0) >> 2]) == (0 | n) && (0 | i[e + 4 >> 2]) == (0 | r) || (0 | i[(e = s + 32 | 0) >> 2]) == (0 | n) && (0 | i[e + 4 >> 2]) == (0 | r) || (0 | i[(e = s + 40 | 0) >> 2]) == (0 | n) && (0 | i[e + 4 >> 2]) == (0 | r) ? 1 : 1 & ((0 | i[(A = s + 48 | 0) >> 2]) == (0 | n) ? (0 | i[A + 4 >> 2]) == (0 | r) : 0), i[a >> 2] = A, D = l, 0
                                    },
                                    _bitshift64Ashr: Fe,
                                    _bitshift64Lshr: ze,
                                    _bitshift64Shl: Ge,
                                    _calloc: Le,
                                    _cellAreaKm2: function(t, e, n) {
                                        return 0 | (t = 0 | re(t |= 0, e |= 0, n |= 0)) || (a[n >> 3] = 6371.007180918475 * +a[n >> 3] * 6371.007180918475), 0 | t
                                    },
                                    _cellAreaM2: function(t, e, n) {
                                        return 0 | (t = 0 | re(t |= 0, e |= 0, n |= 0)) || (a[n >> 3] = 6371.007180918475 * +a[n >> 3] * 6371.007180918475 * 1e3 * 1e3), 0 | t
                                    },
                                    _cellAreaRads2: re,
                                    _cellToBoundary: Yt,
                                    _cellToCenterChild: function(t, e, n, r) {
                                        n |= 0, r |= 0;
                                        var a = 0;
                                        return a = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), (0 | n) < 16 & (0 | (a &= 15)) <= (0 | n) ? ((0 | a) < (0 | n) && (a = 0 | Ge(-1, -1, 3 + (3 * (n + -1 - a | 0) | 0) | 0), a = 0 | Ge(0 | ~a, 0 | ~(0 | S()), 3 * (15 - n | 0) | 0), e = ~(0 | S()) & e, t &= ~a), a = 0 | Ge(0 | n, 0, 52), n = -15728641 & e | 0 | S(), i[r >> 2] = t | a, i[r + 4 >> 2] = n, 0 | (r = 0)) : 0 | (r = 4)
                                    },
                                    _cellToChildPos: function(t, e, n, r) {
                                        n |= 0, r |= 0;
                                        var a, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0,
                                            m = 0,
                                            g = 0,
                                            v = 0,
                                            _ = 0;
                                        if (a = D, D = D + 16 | 0, v = a, _ = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), n >>> 0 > 15) return D = a, 4;
                                        if ((0 | (_ &= 15)) < (0 | n)) return D = a, 12;
                                        if ((0 | _) != (0 | n))
                                            if (s = 0 | Ge(0 | n, 0, 52), s |= t, A = 0 | S() | -15728641 & e, (0 | _) > (0 | n)) {
                                                c = n;
                                                do {
                                                    g = 0 | Ge(7, 0, 3 * (14 - c | 0) | 0), c = c + 1 | 0, s |= g, A = 0 | S() | A
                                                } while ((0 | c) < (0 | _));
                                                g = s
                                            } else g = s;
                                        else g = t, A = e;
                                        m = 0 | ze(0 | g, 0 | A, 45), S();
                                        t: do {
                                            if (0 | F(127 & m)) {
                                                if (c = 0 | ze(0 | g, 0 | A, 52), S(), 0 | (c &= 15))
                                                    for (s = 1;;) {
                                                        if (!(0 == ((m = 0 | Ge(7, 0, 3 * (15 - s | 0) | 0)) & g | 0) & 0 == ((0 | S()) & A | 0))) {
                                                            u = 33;
                                                            break t
                                                        }
                                                        if (!(s >>> 0 < c >>> 0)) break;
                                                        s = s + 1 | 0
                                                    }
                                                if (i[(m = r) >> 2] = 0, i[m + 4 >> 2] = 0, (0 | _) > (0 | n)) {
                                                    for (m = -15728641 & e, p = _;;) {
                                                        if (f = p, (p = p + -1 | 0) >>> 0 > 15 | (0 | _) < (0 | p)) {
                                                            u = 19;
                                                            break
                                                        }
                                                        if ((0 | _) != (0 | p))
                                                            if (s = 0 | Ge(0 | p, 0, 52), s |= t, c = 0 | S() | m, (0 | _) < (0 | f)) d = s;
                                                            else {
                                                                u = p;
                                                                do {
                                                                    d = 0 | Ge(7, 0, 3 * (14 - u | 0) | 0), u = u + 1 | 0, s |= d, c = 0 | S() | c
                                                                } while ((0 | u) < (0 | _));
                                                                d = s
                                                            }
                                                        else d = t, c = e;
                                                        if (h = 0 | ze(0 | d, 0 | c, 45), S(), 0 | F(127 & h)) {
                                                            h = 0 | ze(0 | d, 0 | c, 52), S(), h &= 15;
                                                            e: do {
                                                                if (h)
                                                                    for (u = 1;;) {
                                                                        if (s = 0 | ze(0 | d, 0 | c, 3 * (15 - u | 0) | 0), S(), 0 | (s &= 7)) break e;
                                                                        if (!(u >>> 0 < h >>> 0)) {
                                                                            s = 0;
                                                                            break
                                                                        }
                                                                        u = u + 1 | 0
                                                                    } else s = 0
                                                            } while (0);
                                                            s = 0 == (0 | s) & 1
                                                        } else s = 0;
                                                        if (c = 0 | ze(0 | t, 0 | e, 3 * (15 - f | 0) | 0), S(), 7 == (0 | (c &= 7))) {
                                                            o = 5, u = 42;
                                                            break
                                                        }
                                                        if (1 == (0 | c) & (s = 0 != (0 | s))) {
                                                            o = 5, u = 42;
                                                            break
                                                        }
                                                        if (0 | (d = c + ((0 != (0 | c) & s) << 31 >> 31) | 0) && (u = 0 | ue(7, 0, u = _ - f | 0, ((0 | u) < 0) << 31 >> 31), h = 0 | S(), s ? (s = 0 | De(0 | (s = 0 | Ue(0 | u, 0 | h, 5, 0)), 0 | S(), -5, -1), s = 0 | De(0 | (s = 0 | qe(0 | s, 0 | S(), 6, 0)), 0 | S(), 1, 0), c = 0 | S()) : (s = u, c = h), f = 0 | De(0 | s, 0 | c, 0 | (f = 0 | Ue(0 | u, 0 | h, 0 | (f = d + -1 | 0), ((0 | f) < 0) << 31 >> 31 | 0)), 0 | S()), h = 0 | De(0 | f, 0 | (d = 0 | S()), 0 | i[(h = r) >> 2], 0 | i[h + 4 >> 2]), d = 0 | S(), i[(f = r) >> 2] = h, i[f + 4 >> 2] = d), (0 | p) <= (0 | n)) {
                                                            u = 37;
                                                            break
                                                        }
                                                    }
                                                    if (19 == (0 | u)) E(23313, 22674, 1099, 22710);
                                                    else {
                                                        if (37 == (0 | u)) {
                                                            o = 0 | i[(l = r) + 4 >> 2], l = 0 | i[l >> 2];
                                                            break
                                                        }
                                                        if (42 == (0 | u)) return D = a, 0 | o
                                                    }
                                                } else o = 0, l = 0
                                            } else u = 33
                                        } while (0);
                                        t: do {
                                            if (33 == (0 | u)) {
                                                if (i[(m = r) >> 2] = 0, i[m + 4 >> 2] = 0, (0 | _) > (0 | n)) {
                                                    for (s = _;;) {
                                                        if (o = 0 | ze(0 | t, 0 | e, 3 * (15 - s | 0) | 0), S(), 7 == (0 | (o &= 7))) {
                                                            o = 5;
                                                            break
                                                        }
                                                        if (o = 0 | Ue(0 | (l = 0 | ue(7, 0, l = _ - s | 0, ((0 | l) < 0) << 31 >> 31)), 0 | S(), 0 | o, 0), l = 0 | S(), l = 0 | De(0 | i[(m = r) >> 2], 0 | i[m + 4 >> 2], 0 | o, 0 | l), o = 0 | S(), i[(m = r) >> 2] = l, i[m + 4 >> 2] = o, (0 | (s = s + -1 | 0)) <= (0 | n)) break t
                                                    }
                                                    return D = a, 0 | o
                                                }
                                                o = 0, l = 0
                                            }
                                        } while (0);
                                        return 0 | qt(g, A, _, v) && E(23313, 22674, 1063, 22725), ((0 | o) > -1 | -1 == (0 | o) & l >>> 0 > 4294967295) & ((0 | (v = 0 | i[(_ = v) + 4 >> 2])) > (0 | o) | ((0 | v) == (0 | o) ? (0 | i[_ >> 2]) >>> 0 > l >>> 0 : 0)) ? (D = a, 0 | (_ = 0)) : (E(23313, 22674, 1139, 22710), 0)
                                    },
                                    _cellToChildren: function(t, e, n, r) {
                                        r |= 0;
                                        var a, o, s = 0,
                                            l = 0;
                                        if (o = D, D = D + 16 | 0, Zt(a = o, t |= 0, e |= 0, n |= 0), 0 == (0 | (t = 0 | i[(e = a) >> 2])) & 0 == (0 | (e = 0 | i[e + 4 >> 2]))) return D = o, 0;
                                        s = 0, n = 0;
                                        do {
                                            i[(l = r + (s << 3) | 0) >> 2] = t, i[l + 4 >> 2] = e, s = 0 | De(0 | s, 0 | n, 1, 0), n = 0 | S(), Jt(a), t = 0 | i[(l = a) >> 2], e = 0 | i[l + 4 >> 2]
                                        } while (!(0 == (0 | t) & 0 == (0 | e)));
                                        return D = o, 0
                                    },
                                    _cellToChildrenSize: qt,
                                    _cellToLatLng: Xt,
                                    _cellToLocalIj: function(t, e, n, r, i, a) {
                                        var o, s;
                                        return t |= 0, a |= 0, s = D, D = D + 16 | 0, o = s, (i |= 0) ? t = 15 : (t = 0 | Ae(t, e |= 0, n |= 0, r |= 0, o)) || (_t(o, a), t = 0), D = s, 0 | t
                                    },
                                    _cellToParent: Bt,
                                    _cellToVertex: ye,
                                    _cellToVertexes: function(t, e, n) {
                                        n |= 0;
                                        var r, a = 0,
                                            o = 0;
                                        return o = 0 == (0 | Ut(t |= 0, e |= 0)), r = 0 == (0 | (a = 0 | ye(t, e, 0, n))), o ? r ? 0 | (a = 0 | ye(t, e, 1, n + 8 | 0)) || 0 | (a = 0 | ye(t, e, 2, n + 16 | 0)) || 0 | (a = 0 | ye(t, e, 3, n + 24 | 0)) || (a = 0 | ye(t, e, 4, n + 32 | 0)) ? 0 | (o = a) : 0 | ye(t, e, 5, n + 40 | 0) : 0 | (o = a) : r ? 0 | (a = 0 | ye(t, e, 1, n + 8 | 0)) || 0 | (a = 0 | ye(t, e, 2, n + 16 | 0)) || 0 | (a = 0 | ye(t, e, 3, n + 24 | 0)) || 0 | (a = 0 | ye(t, e, 4, n + 32 | 0)) ? 0 | (o = a) : (i[(o = n + 40 | 0) >> 2] = 0, i[o + 4 >> 2] = 0, 0 | (o = 0)) : 0 | (o = a)
                                    },
                                    _cellsToDirectedEdge: function(t, e, n, r, a) {
                                        return a |= 0, 7 == (0 | (n = 0 | N(t |= 0, e |= 0, n |= 0, r |= 0))) ? 0 | (a = 11) : (r = 0 | Ge(0 | n, 0, 56), e = -2130706433 & e | 0 | S() | 268435456, i[a >> 2] = t | r, i[a + 4 >> 2] = e, 0 | (a = 0))
                                    },
                                    _cellsToLinkedMultiPolygon: function(t, e, n) {
                                        n |= 0;
                                        var r, a, o, s = 0;
                                        if (o = D, D = D + 32 | 0, r = o, t = 0 | function(t, e, n) {
                                                t |= 0, n |= 0;
                                                var r, a, o = 0,
                                                    s = 0,
                                                    l = 0,
                                                    A = 0,
                                                    c = 0,
                                                    u = 0;
                                                if (a = D, D = D + 176 | 0, r = a, (0 | (e |= 0)) < 1) return xe(n, 0, 0), D = a, 0;
                                                for (c = 0 | ze(0 | i[(c = t) >> 2], 0 | i[c + 4 >> 2], 52), S(), xe(n, (0 | e) > 6 ? e : 6, 15 & c), c = 0; !(0 | (o = 0 | Yt(0 | i[(o = t + (c << 3) | 0) >> 2], 0 | i[o + 4 >> 2], r)));) {
                                                    if ((0 | (o = 0 | i[r >> 2])) > 0) {
                                                        A = 0;
                                                        do {
                                                            l = r + 8 + (A << 4) | 0, (s = 0 | Ee(n, o = r + 8 + (((0 | (A = A + 1 | 0)) % (0 | o) | 0) << 4) | 0, l)) ? we(n, s) : Se(n, l, o), o = 0 | i[r >> 2]
                                                        } while ((0 | A) < (0 | o))
                                                    }
                                                    if ((0 | (c = c + 1 | 0)) >= (0 | e)) {
                                                        o = 0, u = 13;
                                                        break
                                                    }
                                                }
                                                return 13 == (0 | u) ? (D = a, 0 | o) : (be(n), D = a, 0 | (u = o))
                                            }(t |= 0, e |= 0, a = o + 16 | 0), 0 | t) return D = o, 0 | t;
                                        if (i[n >> 2] = 0, i[n + 4 >> 2] = 0, i[n + 8 >> 2] = 0, 0 | (t = 0 | Me(a)))
                                            do {
                                                e = 0 | ie(n);
                                                do {
                                                    ae(e, t), s = t + 16 | 0, i[r >> 2] = i[s >> 2], i[r + 4 >> 2] = i[s + 4 >> 2], i[r + 8 >> 2] = i[s + 8 >> 2], i[r + 12 >> 2] = i[s + 12 >> 2], we(a, t), t = 0 | Te(a, r)
                                                } while (0 != (0 | t));
                                                t = 0 | Me(a)
                                            } while (0 != (0 | t));
                                        return be(a), (t = 0 | se(n)) ? (oe(n), D = o, 0 | (s = t)) : (D = o, 0 | (s = 0))
                                    },
                                    _childPosToCell: function(t, e, n, r, a, o) {
                                        t |= 0, e |= 0, o |= 0;
                                        var s, l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0,
                                            m = 0;
                                        if (s = D, D = D + 16 | 0, l = s, (a |= 0) >>> 0 > 15) return D = s, 4;
                                        if (A = 0 | ze(0 | (n |= 0), 0 | (r |= 0), 52), S(), (0 | (A &= 15)) > (0 | a)) return D = s, 12;
                                        if (0 | qt(n, r, a, l) && E(23313, 22674, 1063, 22725), !(((0 | e) > -1 | -1 == (0 | e) & t >>> 0 > 4294967295) & ((0 | (u = 0 | i[(h = l) + 4 >> 2])) > (0 | e) | ((0 | u) == (0 | e) ? (0 | i[h >> 2]) >>> 0 > t >>> 0 : 0)))) return D = s, 2;
                                        h = a - A | 0, a = 0 | Ge(0 | a, 0, 52), c = 0 | S() | -15728641 & r, i[(u = o) >> 2] = a | n, i[u + 4 >> 2] = c, u = 0 | ze(0 | n, 0 | r, 45), S();
                                        t: do {
                                            if (0 | F(127 & u)) {
                                                if (0 | A)
                                                    for (l = 1;;) {
                                                        if (!(0 == ((u = 0 | Ge(7, 0, 3 * (15 - l | 0) | 0)) & n | 0) & 0 == ((0 | S()) & r | 0))) break t;
                                                        if (!(l >>> 0 < A >>> 0)) break;
                                                        l = l + 1 | 0
                                                    }
                                                if ((0 | h) < 1) return D = s, 0;
                                                for (u = 15 ^ A, r = -1, c = 1, l = 1;;) {
                                                    A = 0 | ue(7, 0, A = h - c | 0, ((0 | A) < 0) << 31 >> 31), n = 0 | S();
                                                    do {
                                                        if (l) {
                                                            if (l = 0 | qe(0 | (l = 0 | De(0 | (l = 0 | Ue(0 | A, 0 | n, 5, 0)), 0 | S(), -5, -1)), 0 | S(), 6, 0), (0 | e) > (0 | (a = 0 | S())) | (0 | e) == (0 | a) & t >>> 0 > l >>> 0) {
                                                                e = 0 | Ie(0 | (e = 0 | De(0 | t, 0 | e, -1, -1)), 0 | S(), 0 | l, 0 | a), l = 0 | S(), p = 0 | i[(d = o) >> 2], d = 0 | i[d + 4 >> 2], f = 0 | Ge(7, 0, 0 | (m = 3 * (u + r | 0) | 0)), d &= ~(0 | S()), m = 0 | Ge(0 | (a = 0 | De(0 | (r = 0 | qe(0 | e, 0 | l, 0 | A, 0 | n)), 0 | (t = 0 | S()), 2, 0)), 0 | S(), 0 | m), d = 0 | S() | d, i[(a = o) >> 2] = m | p & ~f, i[a + 4 >> 2] = d, t = 0 | Ie(0 | e, 0 | l, 0 | (t = 0 | Ue(0 | r, 0 | t, 0 | A, 0 | n)), 0 | S()), l = 0, e = 0 | S();
                                                                break
                                                            }
                                                            f = 0 | i[(m = o) >> 2], m = 0 | i[m + 4 >> 2], p = 0 | Ge(7, 0, 3 * (u + r | 0) | 0), m &= ~(0 | S()), i[(l = o) >> 2] = f & ~p, i[l + 4 >> 2] = m, l = 1;
                                                            break
                                                        }
                                                        a = 0 | i[(f = o) >> 2], f = 0 | i[f + 4 >> 2], d = 0 | Ge(7, 0, 0 | (r = 3 * (u + r | 0) | 0)), f &= ~(0 | S()), r = 0 | Ge(0 | (m = 0 | qe(0 | t, 0 | e, 0 | A, 0 | n)), 0 | (l = 0 | S()), 0 | r), f = 0 | S() | f, i[(p = o) >> 2] = r | a & ~d, i[p + 4 >> 2] = f, t = 0 | Ie(0 | t, 0 | e, 0 | (l = 0 | Ue(0 | m, 0 | l, 0 | A, 0 | n)), 0 | S()), l = 0, e = 0 | S()
                                                    } while (0);
                                                    if (!((0 | h) > (0 | c))) {
                                                        e = 0;
                                                        break
                                                    }
                                                    r = ~c, c = c + 1 | 0
                                                }
                                                return D = s, 0 | e
                                            }
                                        } while (0);
                                        if ((0 | h) < 1) return D = s, 0;
                                        for (a = 15 ^ A, l = 1;;) {
                                            if (p = 0 | ue(7, 0, p = h - l | 0, ((0 | p) < 0) << 31 >> 31), m = 0 | S(), n = 0 | i[(c = o) >> 2], c = 0 | i[c + 4 >> 2], r = 0 | Ge(7, 0, 0 | (A = 3 * (a - l | 0) | 0)), c &= ~(0 | S()), A = 0 | Ge(0 | (d = 0 | qe(0 | t, 0 | e, 0 | p, 0 | m)), 0 | (f = 0 | S()), 0 | A), c = 0 | S() | c, i[(u = o) >> 2] = A | n & ~r, i[u + 4 >> 2] = c, t = 0 | Ie(0 | t, 0 | e, 0 | (m = 0 | Ue(0 | d, 0 | f, 0 | p, 0 | m)), 0 | S()), e = 0 | S(), (0 | h) <= (0 | l)) {
                                                e = 0;
                                                break
                                            }
                                            l = l + 1 | 0
                                        }
                                        return D = s, 0 | e
                                    },
                                    _compactCells: function(t, e, n, r) {
                                        e |= 0;
                                        var a, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0,
                                            m = 0,
                                            g = 0,
                                            v = 0,
                                            _ = 0,
                                            y = 0,
                                            x = 0,
                                            b = 0,
                                            M = 0,
                                            w = 0,
                                            T = 0;
                                        if (0 == (0 | (n |= 0)) & 0 == (0 | (r |= 0))) return 0;
                                        if (s = 0 | i[(o = t |= 0) >> 2], !0 & 0 == (15728640 & (o = 0 | i[o + 4 >> 2]) | 0)) {
                                            if (!((0 | r) > 0 | 0 == (0 | r) & n >>> 0 > 0)) return 0;
                                            if (i[(w = e) >> 2] = s, i[w + 4 >> 2] = o, 1 == (0 | n) & 0 == (0 | r)) return 0;
                                            o = 1;
                                            do {
                                                M = 0 | i[4 + (b = t + (o << 3) | 0) >> 2], i[(w = e + (o << 3) | 0) >> 2] = i[b >> 2], i[w + 4 >> 2] = M, o = o + 1 | 0
                                            } while (0 < (0 | r) | 0 == (0 | r) & o >>> 0 < n >>> 0);
                                            return 0
                                        }
                                        if (!(M = 0 | Re(a = n << 3))) return 13;
                                        if (We(0 | M, 0 | t, 0 | a), !(b = 0 | Le(n, 8))) return Pe(M), 13;
                                        t: do {
                                            if (0 | n) {
                                                e: for (;;) {
                                                    y = 0 | ze(0 | (_ = 0 | i[(o = M) >> 2]), 0 | (o = 0 | i[o + 4 >> 2]), 52), S(), x = (y &= 15) - 1 | 0, v = (0 | n) > 0;
                                                    n: do {
                                                        if (0 != (0 | y) & v) {
                                                            if (p = ((0 | n) < 0) << 31 >> 31, m = 0 | Ge(0 | x, 0, 52), g = 0 | S(), x >>> 0 > 15) {
                                                                if (!(0 == (0 | _) & 0 == (0 | o))) {
                                                                    w = 17;
                                                                    break e
                                                                }
                                                                for (s = 0;;) {
                                                                    if ((0 | (s = s + 1 | 0)) >= (0 | n)) break n;
                                                                    if (!(0 == (0 | (g = 0 | i[(r = M + (s << 3) | 0) >> 2])) & 0 == (0 | (r = 0 | i[r + 4 >> 2])))) {
                                                                        o = r, w = 17;
                                                                        break e
                                                                    }
                                                                }
                                                            }
                                                            for (s = 0, t = _, r = o;;) {
                                                                if (!(0 == (0 | t) & 0 == (0 | r))) {
                                                                    if (!(!0 & 0 == (117440512 & r | 0))) {
                                                                        w = 22;
                                                                        break e
                                                                    }
                                                                    if (A = 0 | ze(0 | t, 0 | r, 52), S(), (0 | (A &= 15)) < (0 | x)) {
                                                                        o = 12, w = 28;
                                                                        break e
                                                                    }
                                                                    if ((0 | A) != (0 | x) && (t |= m, r = -15728641 & r | g, A >>> 0 >= y >>> 0)) {
                                                                        l = x;
                                                                        do {
                                                                            f = 0 | Ge(7, 0, 3 * (14 - l | 0) | 0), l = l + 1 | 0, t |= f, r = 0 | S() | r
                                                                        } while (l >>> 0 < A >>> 0)
                                                                    }
                                                                    if (l = 0 | ke(0 | t, 0 | r, 0 | n, 0 | p), S(), 0 == (0 | (c = 0 | i[(A = u = b + (l << 3) | 0) >> 2])) & 0 == (0 | (A = 0 | i[A + 4 >> 2]))) l = u;
                                                                    else
                                                                        for (f = 0;;) {
                                                                            if ((0 | f) > (0 | n)) {
                                                                                w = 32;
                                                                                break e
                                                                            }
                                                                            if ((0 | c) == (0 | t) & (-117440513 & A | 0) == (0 | r)) {
                                                                                h = 0 | ze(0 | c, 0 | A, 56), S(), d = 1 + (h &= 7) | 0, T = 0 | ze(0 | c, 0 | A, 45), S();
                                                                                r: do {
                                                                                    if (0 | F(127 & T)) {
                                                                                        if (c = 0 | ze(0 | c, 0 | A, 52), S(), !(c &= 15)) {
                                                                                            A = 6;
                                                                                            break
                                                                                        }
                                                                                        for (A = 1;;) {
                                                                                            if (!(0 == ((T = 0 | Ge(7, 0, 3 * (15 - A | 0) | 0)) & t | 0) & 0 == ((0 | S()) & r | 0))) {
                                                                                                A = 7;
                                                                                                break r
                                                                                            }
                                                                                            if (!(A >>> 0 < c >>> 0)) {
                                                                                                A = 6;
                                                                                                break
                                                                                            }
                                                                                            A = A + 1 | 0
                                                                                        }
                                                                                    } else A = 7
                                                                                } while (0);
                                                                                if ((h + 2 | 0) >>> 0 > A >>> 0) {
                                                                                    w = 42;
                                                                                    break e
                                                                                }
                                                                                T = 0 | Ge(0 | d, 0, 56), r = 0 | S() | -117440513 & r, i[(d = u) >> 2] = 0, i[d + 4 >> 2] = 0, t |= T
                                                                            } else l = (l + 1 | 0) % (0 | n) | 0;
                                                                            if (0 == (0 | (c = 0 | i[(A = u = b + (l << 3) | 0) >> 2])) & 0 == (0 | (A = 0 | i[A + 4 >> 2]))) {
                                                                                l = u;
                                                                                break
                                                                            }
                                                                            f = f + 1 | 0
                                                                        }
                                                                    i[(T = l) >> 2] = t, i[T + 4 >> 2] = r
                                                                }
                                                                if ((0 | (s = s + 1 | 0)) >= (0 | n)) break n;
                                                                t = 0 | i[(r = M + (s << 3) | 0) >> 2], r = 0 | i[r + 4 >> 2]
                                                            }
                                                        }
                                                    } while (0);
                                                    if ((n + 5 | 0) >>> 0 < 11) {
                                                        w = 85;
                                                        break
                                                    }
                                                    if (!(g = 0 | Le((0 | n) / 6 | 0, 8))) {
                                                        w = 49;
                                                        break
                                                    }
                                                    n: do {
                                                        if (v) {
                                                            f = 0, d = 0;
                                                            do {
                                                                if (!(0 == (0 | (s = 0 | i[(r = A = b + (f << 3) | 0) >> 2])) & 0 == (0 | (r = 0 | i[r + 4 >> 2])))) {
                                                                    c = 0 | ze(0 | s, 0 | r, 56), S(), t = 1 + (c &= 7) | 0, u = -117440513 & r, T = 0 | ze(0 | s, 0 | r, 45), S();
                                                                    r: do {
                                                                        if (0 | F(127 & T)) {
                                                                            if (h = 0 | ze(0 | s, 0 | r, 52), S(), 0 | (h &= 15))
                                                                                for (l = 1;;) {
                                                                                    if (!(0 == (s & (T = 0 | Ge(7, 0, 3 * (15 - l | 0) | 0)) | 0) & 0 == (u & (0 | S()) | 0))) break r;
                                                                                    if (!(l >>> 0 < h >>> 0)) break;
                                                                                    l = l + 1 | 0
                                                                                }
                                                                            s |= r = 0 | Ge(0 | t, 0, 56), r = 0 | S() | u, i[(t = A) >> 2] = s, i[t + 4 >> 2] = r, t = c + 2 | 0
                                                                        }
                                                                    } while (0);
                                                                    7 == (0 | t) && (i[(T = g + (d << 3) | 0) >> 2] = s, i[T + 4 >> 2] = -117440513 & r, d = d + 1 | 0)
                                                                }
                                                                f = f + 1 | 0
                                                            } while ((0 | f) != (0 | n));
                                                            if (v) {
                                                                if (f = ((0 | n) < 0) << 31 >> 31, p = 0 | Ge(0 | x, 0, 52), m = 0 | S(), x >>> 0 > 15) {
                                                                    if (!(0 == (0 | _) & 0 == (0 | o))) {
                                                                        o = 4, w = 84;
                                                                        break e
                                                                    }
                                                                    for (o = 0;;) {
                                                                        if ((0 | (o = o + 1 | 0)) >= (0 | n)) {
                                                                            s = 0, o = d;
                                                                            break n
                                                                        }
                                                                        if (!(0 == (0 | i[(T = M + (o << 3) | 0) >> 2]) & 0 == (0 | i[T + 4 >> 2]))) {
                                                                            o = 4, w = 84;
                                                                            break e
                                                                        }
                                                                    }
                                                                }
                                                                for (h = 0, s = 0, u = _;;) {
                                                                    do {
                                                                        if (!(0 == (0 | u) & 0 == (0 | o))) {
                                                                            if (A = 0 | ze(0 | u, 0 | o, 52), S(), (0 | (A &= 15)) < (0 | x)) {
                                                                                o = 12, w = 84;
                                                                                break e
                                                                            }
                                                                            do {
                                                                                if ((0 | A) == (0 | x)) r = u, A = o;
                                                                                else {
                                                                                    if (r = u | p, t = -15728641 & o | m, A >>> 0 < y >>> 0) {
                                                                                        A = t;
                                                                                        break
                                                                                    }
                                                                                    l = x;
                                                                                    do {
                                                                                        T = 0 | Ge(7, 0, 3 * (14 - l | 0) | 0), l = l + 1 | 0, r |= T, t = 0 | S() | t
                                                                                    } while (l >>> 0 < A >>> 0);
                                                                                    A = t
                                                                                }
                                                                            } while (0);
                                                                            for (l = 0 | ke(0 | r, 0 | A, 0 | n, 0 | f), S(), t = 0;;) {
                                                                                if ((0 | t) > (0 | n)) {
                                                                                    w = 77;
                                                                                    break e
                                                                                }
                                                                                if ((-117440513 & (c = 0 | i[4 + (T = b + (l << 3) | 0) >> 2]) | 0) == (0 | A) && (0 | i[T >> 2]) == (0 | r)) {
                                                                                    w = 79;
                                                                                    break
                                                                                }
                                                                                if ((0 | i[(T = b + ((l = (l + 1 | 0) % (0 | n) | 0) << 3) | 0) >> 2]) == (0 | r) && (0 | i[T + 4 >> 2]) == (0 | A)) break;
                                                                                t = t + 1 | 0
                                                                            }
                                                                            if (79 == (0 | w) && (w = 0, !0 & 100663296 == (117440512 & c | 0))) break;
                                                                            i[(T = e + (s << 3) | 0) >> 2] = u, i[T + 4 >> 2] = o, s = s + 1 | 0
                                                                        }
                                                                    } while (0);
                                                                    if ((0 | (o = h + 1 | 0)) >= (0 | n)) {
                                                                        o = d;
                                                                        break n
                                                                    }
                                                                    h = o, u = 0 | i[(T = M + (o << 3) | 0) >> 2], o = 0 | i[T + 4 >> 2]
                                                                }
                                                            } else s = 0, o = d
                                                        } else s = 0, o = 0
                                                    } while (0);
                                                    if (Xe(0 | b, 0, 0 | a), We(0 | M, 0 | g, o << 3 | 0), Pe(g), !o) break t;
                                                    e = e + (s << 3) | 0, n = o
                                                }
                                                if (17 == (0 | w)) !0 & 0 == (117440512 & o | 0) ? (o = 4, w = 28) : w = 22;
                                                else if (32 == (0 | w)) E(23313, 22674, 362, 22684);
                                                else {
                                                    if (42 == (0 | w)) return Pe(M), Pe(b), 10;
                                                    if (49 == (0 | w)) return Pe(M), Pe(b), 13;
                                                    if (77 == (0 | w)) E(23313, 22674, 462, 22684);
                                                    else {
                                                        if (84 == (0 | w)) return Pe(g), Pe(M), Pe(b), 0 | o;
                                                        if (85 == (0 | w)) {
                                                            We(0 | e, 0 | M, n << 3 | 0);
                                                            break
                                                        }
                                                    }
                                                }
                                                if (22 == (0 | w)) return Pe(M),
                                                Pe(b),
                                                5;
                                                if (28 == (0 | w)) return Pe(M),
                                                Pe(b),
                                                0 | o
                                            }
                                        } while (0);
                                        return Pe(M), Pe(b), 0
                                    },
                                    _destroyLinkedMultiPolygon: oe,
                                    _directedEdgeToBoundary: Mt,
                                    _directedEdgeToCells: function(t, e, n) {
                                        t |= 0;
                                        var r, a, o, s = 0;
                                        return r = D, D = D + 16 | 0, s = r, !0 & 268435456 == (2013265920 & (e |= 0) | 0) ? (a = -2130706433 & e | 134217728, i[(o = n |= 0) >> 2] = t, i[o + 4 >> 2] = a, i[s >> 2] = 0, e = 0 | ze(0 | t, 0 | e, 56), S(), s = 0 | U(t, a, 7 & e, s, n + 8 | 0), D = r, 0 | s) : (D = r, 0 | (s = 6))
                                    },
                                    _edgeLengthKm: function(t, e, n) {
                                        n |= 0;
                                        var r, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            u = 0,
                                            f = 0,
                                            p = 0;
                                        if (r = D, D = D + 176 | 0, 0 | (t = 0 | Mt(t |= 0, e |= 0, A = r))) return A = t, l = +a[n >> 3], l *= 6371.007180918475, a[n >> 3] = l, D = r, 0 | A;
                                        if (a[n >> 3] = 0, (0 | (t = 0 | i[A >> 2])) <= 1) return A = 0, l = 0, l *= 6371.007180918475, a[n >> 3] = l, D = r, 0 | A;
                                        e = t + -1 | 0, t = 0, o = +a[A + 8 >> 3], s = +a[A + 16 >> 3], l = 0;
                                        do {
                                            f = o, o = +a[A + 8 + ((t = t + 1 | 0) << 4) >> 3], p = +d(.5 * (o - f)), u = s, s = +a[A + 8 + (t << 4) + 8 >> 3], u = p * p + (u = +d(.5 * (s - u))) * (+h(+f) * +h(+o) * u), l += 2 * +v(+ +c(+u), + +c(+(1 - u)))
                                        } while ((0 | t) != (0 | e));
                                        return a[n >> 3] = l, A = 0, p = l, p *= 6371.007180918475, a[n >> 3] = p, D = r, 0 | A
                                    },
                                    _edgeLengthM: function(t, e, n) {
                                        n |= 0;
                                        var r, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            u = 0,
                                            f = 0,
                                            p = 0;
                                        if (r = D, D = D + 176 | 0, 0 | (t = 0 | Mt(t |= 0, e |= 0, A = r))) return A = t, l = +a[n >> 3], l *= 6371.007180918475, l *= 1e3, a[n >> 3] = l, D = r, 0 | A;
                                        if (a[n >> 3] = 0, (0 | (t = 0 | i[A >> 2])) <= 1) return A = 0, l = 0, l *= 6371.007180918475, l *= 1e3, a[n >> 3] = l, D = r, 0 | A;
                                        e = t + -1 | 0, t = 0, o = +a[A + 8 >> 3], s = +a[A + 16 >> 3], l = 0;
                                        do {
                                            f = o, o = +a[A + 8 + ((t = t + 1 | 0) << 4) >> 3], p = +d(.5 * (o - f)), u = s, s = +a[A + 8 + (t << 4) + 8 >> 3], u = p * p + (u = +d(.5 * (s - u))) * (+h(+f) * +h(+o) * u), l += 2 * +v(+ +c(+u), + +c(+(1 - u)))
                                        } while ((0 | t) != (0 | e));
                                        return a[n >> 3] = l, A = 0, p = l, p *= 6371.007180918475, p *= 1e3, a[n >> 3] = p, D = r, 0 | A
                                    },
                                    _edgeLengthRads: function(t, e, n) {
                                        n |= 0;
                                        var r, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            u = 0,
                                            f = 0,
                                            p = 0;
                                        if (r = D, D = D + 176 | 0, 0 | (t = 0 | Mt(t |= 0, e |= 0, A = r))) return D = r, 0 | t;
                                        if (a[n >> 3] = 0, (0 | (t = 0 | i[A >> 2])) <= 1) return D = r, 0;
                                        e = t + -1 | 0, t = 0, o = +a[A + 8 >> 3], s = +a[A + 16 >> 3], l = 0;
                                        do {
                                            f = o, o = +a[A + 8 + ((t = t + 1 | 0) << 4) >> 3], p = +d(.5 * (o - f)), u = s, s = +a[A + 8 + (t << 4) + 8 >> 3], u = p * p + (u = +d(.5 * (s - u))) * (+h(+o) * +h(+f) * u), l += 2 * +v(+ +c(+u), + +c(+(1 - u)))
                                        } while ((0 | t) < (0 | e));
                                        return a[n >> 3] = l, D = r, 0
                                    },
                                    _emscripten_replace_memory: function(t) {
                                        return r = new Int8Array(t), new Uint8Array(t), i = new Int32Array(t), new Float32Array(t), a = new Float64Array(t), n = t, !0
                                    },
                                    _free: Pe,
                                    _getBaseCellNumber: It,
                                    _getDirectedEdgeDestination: function(t, e, n) {
                                        t |= 0, e |= 0, n |= 0;
                                        var r, a, o = 0;
                                        return r = D, D = D + 16 | 0, i[(o = r) >> 2] = 0, !0 & 268435456 == (2013265920 & e | 0) ? (a = 0 | ze(0 | t, 0 | e, 56), S(), o = 0 | U(t, -2130706433 & e | 134217728, 7 & a, o, n), D = r, 0 | o) : (D = r, 0 | (o = 6))
                                    },
                                    _getDirectedEdgeOrigin: function(t, e, n) {
                                        return t |= 0, n |= 0, !0 & 268435456 == (2013265920 & (e |= 0) | 0) ? (i[n >> 2] = t, i[n + 4 >> 2] = -2130706433 & e | 134217728, 0 | (n = 0)) : 0 | (n = 6)
                                    },
                                    _getHexagonAreaAvgKm2: function(t, e) {
                                        return e |= 0, (t |= 0) >>> 0 > 15 ? 0 | (e = 4) : (a[e >> 3] = +a[20528 + (t << 3) >> 3], 0 | (e = 0))
                                    },
                                    _getHexagonAreaAvgM2: function(t, e) {
                                        return e |= 0, (t |= 0) >>> 0 > 15 ? 0 | (e = 4) : (a[e >> 3] = +a[20656 + (t << 3) >> 3], 0 | (e = 0))
                                    },
                                    _getHexagonEdgeLengthAvgKm: function(t, e) {
                                        return e |= 0, (t |= 0) >>> 0 > 15 ? 0 | (e = 4) : (a[e >> 3] = +a[20784 + (t << 3) >> 3], 0 | (e = 0))
                                    },
                                    _getHexagonEdgeLengthAvgM: function(t, e) {
                                        return e |= 0, (t |= 0) >>> 0 > 15 ? 0 | (e = 4) : (a[e >> 3] = +a[20912 + (t << 3) >> 3], 0 | (e = 0))
                                    },
                                    _getIcosahedronFaces: function t(e, n, r) {
                                        r |= 0;
                                        var a, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0;
                                        a = D, D = D + 128 | 0, h = a + 112 | 0, l = a + 96 | 0, d = a, s = 0 | ze(0 | (e |= 0), 0 | (n |= 0), 52), S(), c = 15 & s, i[h >> 2] = c, A = 0 | ze(0 | e, 0 | n, 45), S(), A &= 127;
                                        t: do {
                                            if (0 | F(A)) {
                                                if (0 | c)
                                                    for (o = 1;;) {
                                                        if (!(0 == ((u = 0 | Ge(7, 0, 3 * (15 - o | 0) | 0)) & e | 0) & 0 == ((0 | S()) & n | 0))) {
                                                            s = 0;
                                                            break t
                                                        }
                                                        if (!(o >>> 0 < c >>> 0)) break;
                                                        o = o + 1 | 0
                                                    }
                                                if (!(1 & s)) return u = 0 | Ge(c + 1 | 0, 0, 52), d = 0 | S() | -15728641 & n, d = 0 | t((u | e) & ~(h = 0 | Ge(7, 0, 3 * (14 - c | 0) | 0)), d & ~(0 | S()), r), D = a, 0 | d;
                                                s = 1
                                            } else s = 0
                                        } while (0);
                                        if (!(o = 0 | Wt(e, n, l))) {
                                            s ? (Ct(l, h, d), u = 5) : (Dt(l, h, d), u = 6);
                                            t: do {
                                                if (0 | F(A))
                                                    if (c)
                                                        for (o = 1;;) {
                                                            if (!(0 == ((A = 0 | Ge(7, 0, 3 * (15 - o | 0) | 0)) & e | 0) & 0 == ((0 | S()) & n | 0))) {
                                                                e = 2;
                                                                break t
                                                            }
                                                            if (!(o >>> 0 < c >>> 0)) {
                                                                e = 5;
                                                                break
                                                            }
                                                            o = o + 1 | 0
                                                        } else e = 5;
                                                    else e = 2
                                            } while (0);
                                            Xe(0 | r, -1, e << 2 | 0);
                                            t: do {
                                                if (s)
                                                    for (l = 0;;) {
                                                        if (Pt(A = d + (l << 4) | 0, 0 | i[h >> 2]), A = 0 | i[A >> 2], -1 == (0 | (c = 0 | i[r >> 2])) | (0 | c) == (0 | A)) o = r;
                                                        else {
                                                            s = 0;
                                                            do {
                                                                if ((s = s + 1 | 0) >>> 0 >= e >>> 0) {
                                                                    o = 1;
                                                                    break t
                                                                }
                                                                c = 0 | i[(o = r + (s << 2) | 0) >> 2]
                                                            } while (!(-1 == (0 | c) | (0 | c) == (0 | A)))
                                                        }
                                                        if (i[o >> 2] = A, (l = l + 1 | 0) >>> 0 >= u >>> 0) {
                                                            o = 0;
                                                            break
                                                        }
                                                    } else
                                                        for (l = 0;;) {
                                                            if (Rt(A = d + (l << 4) | 0, 0 | i[h >> 2], 0, 1), A = 0 | i[A >> 2], -1 == (0 | (c = 0 | i[r >> 2])) | (0 | c) == (0 | A)) o = r;
                                                            else {
                                                                s = 0;
                                                                do {
                                                                    if ((s = s + 1 | 0) >>> 0 >= e >>> 0) {
                                                                        o = 1;
                                                                        break t
                                                                    }
                                                                    c = 0 | i[(o = r + (s << 2) | 0) >> 2]
                                                                } while (!(-1 == (0 | c) | (0 | c) == (0 | A)))
                                                            }
                                                            if (i[o >> 2] = A, (l = l + 1 | 0) >>> 0 >= u >>> 0) {
                                                                o = 0;
                                                                break
                                                            }
                                                        }
                                            } while (0)
                                        }
                                        return D = a, 0 | o
                                    },
                                    _getNumCells: ee,
                                    _getPentagons: Qt,
                                    _getRes0Cells: function(t) {
                                        t |= 0;
                                        var e = 0,
                                            n = 0,
                                            r = 0;
                                        e = 0;
                                        do {
                                            Ge(0 | e, 0, 45), r = 134225919 | S(), i[(n = t + (e << 3) | 0) >> 2] = -1, i[n + 4 >> 2] = r, e = e + 1 | 0
                                        } while (122 != (0 | e));
                                        return 0
                                    },
                                    _getResolution: function(t, e) {
                                        return e = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), 15 & e | 0
                                    },
                                    _greatCircleDistanceKm: te,
                                    _greatCircleDistanceM: function(t, e) {
                                        t |= 0;
                                        var n, r, i, o = 0;
                                        return r = +a[(e |= 0) >> 3], n = +a[t >> 3], o = (i = +d(.5 * (r - n))) * i + (o = +d(.5 * (+a[e + 8 >> 3] - +a[t + 8 >> 3]))) * (+h(+r) * +h(+n) * o), 2 * +v(+ +c(+o), + +c(+(1 - o))) * 6371.007180918475 * 1e3
                                    },
                                    _greatCircleDistanceRads: function(t, e) {
                                        t |= 0;
                                        var n, r, i, o = 0;
                                        return r = +a[(e |= 0) >> 3], n = +a[t >> 3], o = (i = +d(.5 * (r - n))) * i + (o = +d(.5 * (+a[e + 8 >> 3] - +a[t + 8 >> 3]))) * (+h(+r) * +h(+n) * o), 2 * +v(+ +c(+o), + +c(+(1 - o)))
                                    },
                                    _gridDisk: I,
                                    _gridDiskDistances: O,
                                    _gridDistance: function(t, e, n, r, a) {
                                        n |= 0, r |= 0, a |= 0;
                                        var o, s, l = 0,
                                            A = 0;
                                        return s = D, D = D + 32 | 0, A = s, 0 | (o = 0 | Ae(t |= 0, e |= 0, t, e, l = s + 12 | 0)) ? (D = s, 0 | (A = o)) : 0 | (t = 0 | Ae(t, e, n, r, A)) ? (D = s, 0 | (A = t)) : (l = 0 | vt(l, A), i[(A = a) >> 2] = l, i[A + 4 >> 2] = ((0 | l) < 0) << 31 >> 31, D = s, 0 | (A = 0))
                                    },
                                    _gridPathCells: function(t, e, n, r, a) {
                                        n |= 0, r |= 0, a |= 0;
                                        var o, s = 0,
                                            l = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0,
                                            m = 0,
                                            g = 0,
                                            v = 0,
                                            _ = 0,
                                            y = 0,
                                            x = 0,
                                            b = 0,
                                            M = 0,
                                            w = 0,
                                            T = 0,
                                            C = 0;
                                        if (o = D, D = D + 48 | 0, c = o + 12 | 0, T = o, !(s = 0 | Ae(t |= 0, e |= 0, t, e, l = o + 24 | 0)) && !(s = 0 | Ae(t, e, n, r, c))) {
                                            w = ((0 | (M = 0 | vt(l, c))) < 0) << 31 >> 31, i[l >> 2] = 0, i[l + 4 >> 2] = 0, i[l + 8 >> 2] = 0, i[c >> 2] = 0, i[c + 4 >> 2] = 0, i[c + 8 >> 2] = 0, 0 | Ae(t, e, t, e, l) && E(23313, 23090, 691, 23299), 0 | Ae(t, e, n, r, c) && E(23313, 23090, 696, 23299), xt(l), xt(c), M ? (g = +(0 | M), b = l, r = f = 0 | i[l >> 2], s = p = 0 | i[(y = l + 4 | 0) >> 2], n = m = 0 | i[(x = l + 8 | 0) >> 2], v = +((0 | i[c >> 2]) - f | 0) / g, _ = +((0 | i[c + 4 >> 2]) - p | 0) / g, g = +((0 | i[c + 8 >> 2]) - m | 0) / g) : (y = s = l + 4 | 0, x = n = l + 8 | 0, b = l, r = 0 | i[l >> 2], s = 0 | i[s >> 2], n = 0 | i[n >> 2], v = 0, _ = 0, g = 0), i[T >> 2] = r, i[(m = T + 4 | 0) >> 2] = s, i[(p = T + 8 | 0) >> 2] = n;
                                            t: do {
                                                if ((0 | M) < 0) s = 0;
                                                else
                                                    for (d = 0, f = 0, s = r;;) {
                                                        C = v * (h = +(f >>> 0) + 4294967296 * +(0 | d)) + +(0 | s), u = _ * h + +(0 | i[y >> 2]), h = g * h + +(0 | i[x >> 2]), n = ~~+He(+C), l = ~~+He(+u), s = ~~+He(+h), C = +A(+(+(0 | n) - C)), u = +A(+(+(0 | l) - u)), h = +A(+(+(0 | s) - h));
                                                        do {
                                                            if (!(C > u & C > h)) {
                                                                if (c = 0 - n | 0, u > h) {
                                                                    r = c - s | 0;
                                                                    break
                                                                }
                                                                r = l, s = c - l | 0;
                                                                break
                                                            }
                                                            n = 0 - (l + s) | 0, r = l
                                                        } while (0);
                                                        if (i[T >> 2] = n, i[m >> 2] = r, i[p >> 2] = s, bt(T), 0 | (s = 0 | ce(t, e, T, a + (f << 3) | 0))) break t;
                                                        if (!((0 | d) < (0 | w) | (0 | d) == (0 | w) & f >>> 0 < M >>> 0)) {
                                                            s = 0;
                                                            break t
                                                        }
                                                        s = 0 | De(0 | f, 0 | d, 1, 0), d = c = 0 | S(), f = s, s = 0 | i[b >> 2]
                                                    }
                                            } while (0);
                                            return D = o, 0 | s
                                        }
                                        return D = o, 0 | s
                                    },
                                    _gridPathCellsSize: function(t, e, n, r, a) {
                                        n |= 0, r |= 0, a |= 0;
                                        var o, s = 0,
                                            l = 0,
                                            A = 0;
                                        return o = D, D = D + 32 | 0, A = o, (s = 0 | Ae(t |= 0, e |= 0, t, e, l = o + 12 | 0)) || (s = 0 | Ae(t, e, n, r, A)) ? (D = o, 0 | (A = s)) : (r = 0 | De(0 | (r = 0 | vt(l, A)), ((0 | r) < 0) << 31 >> 31 | 0, 1, 0), l = 0 | S(), i[(A = a) >> 2] = r, i[A + 4 >> 2] = l, D = o, 0 | (A = 0))
                                    },
                                    _gridRingUnsafe: function(t, e, n, r) {
                                        t |= 0, e |= 0, n |= 0, r |= 0;
                                        var a, o, s = 0,
                                            l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0;
                                        if (o = D, D = D + 16 | 0, p = o + 8 | 0, i[(f = a = o) >> 2] = t, i[f + 4 >> 2] = e, !n) return i[(p = r) >> 2] = t, i[p + 4 >> 2] = e, D = o, 0;
                                        i[p >> 2] = 0;
                                        t: do {
                                            if (0 | Ut(t, e)) t = 9;
                                            else {
                                                if (l = (0 | n) > 0) {
                                                    s = 0, f = t;
                                                    do {
                                                        if (0 | (t = 0 | U(f, e, 4, p, a))) break t;
                                                        if (s = s + 1 | 0, 0 | Ut(f = 0 | i[(e = a) >> 2], e = 0 | i[e + 4 >> 2])) {
                                                            t = 9;
                                                            break t
                                                        }
                                                    } while ((0 | s) < (0 | n));
                                                    if (i[(d = r) >> 2] = f, i[d + 4 >> 2] = e, d = n + -1 | 0, l) {
                                                        h = 0, t = 1;
                                                        do {
                                                            if (s = 22384 + (h << 2) | 0, 5 == (0 | h))
                                                                for (A = 0 | i[s >> 2], l = 0, s = t;;) {
                                                                    if (0 | (t = 0 | U(0 | i[(t = a) >> 2], 0 | i[t + 4 >> 2], A, p, a))) break t;
                                                                    if ((0 | l) != (0 | d)) {
                                                                        if (c = 0 | i[(u = a) >> 2], u = 0 | i[u + 4 >> 2], i[(t = r + (s << 3) | 0) >> 2] = c, i[t + 4 >> 2] = u, 0 | Ut(c, u)) {
                                                                            t = 9;
                                                                            break t
                                                                        }
                                                                        t = s + 1 | 0
                                                                    } else t = s;
                                                                    if ((0 | (l = l + 1 | 0)) >= (0 | n)) break;
                                                                    s = t
                                                                } else
                                                                    for (A = a, u = 0 | i[s >> 2], c = 0, s = t, l = 0 | i[A >> 2], A = 0 | i[A + 4 >> 2];;) {
                                                                        if (0 | (t = 0 | U(l, A, u, p, a))) break t;
                                                                        if (l = 0 | i[(A = a) >> 2], A = 0 | i[A + 4 >> 2], i[(t = r + (s << 3) | 0) >> 2] = l, i[t + 4 >> 2] = A, t = s + 1 | 0, 0 | Ut(l, A)) {
                                                                            t = 9;
                                                                            break t
                                                                        }
                                                                        if ((0 | (c = c + 1 | 0)) >= (0 | n)) break;
                                                                        s = t
                                                                    }
                                                            h = h + 1 | 0
                                                        } while (h >>> 0 < 6);
                                                        A = f, s = 0 | i[(t = a) >> 2], l = e, t = 0 | i[t + 4 >> 2]
                                                    } else A = f, s = f, l = e, t = e
                                                } else i[(A = r) >> 2] = t, i[A + 4 >> 2] = e, A = t, s = t, l = e, t = e;
                                                t = (0 | A) == (0 | s) & (0 | l) == (0 | t) ? 0 : 9
                                            }
                                        } while (0);
                                        return D = o, 0 | t
                                    },
                                    _i64Add: De,
                                    _i64Subtract: Ie,
                                    _isPentagon: Ut,
                                    _isResClassIII: function(t, e) {
                                        return e = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 52), S(), 1 & e | 0
                                    },
                                    _isValidCell: Ot,
                                    _isValidDirectedEdge: function(t, e) {
                                        var n = 0;
                                        switch (n = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 56), S(), 7 & n) {
                                            case 0:
                                            case 7:
                                                return 0
                                        }
                                        return n = -2130706433 & e | 134217728, !0 & 268435456 == (2013265920 & e | 0) ? !0 & 16777216 == (117440512 & e | 0) & 0 != (0 | Ut(t, n)) ? 0 | (n = 0) : 0 | (n = 0 | Ot(t, n)) : 0 | (n = 0)
                                    },
                                    _isValidVertex: function(t, e) {
                                        t |= 0;
                                        var n, r, a = 0,
                                            o = 0;
                                        return r = D, D = D + 16 | 0, n = r, !0 & 536870912 == (2013265920 & (e |= 0) | 0) && 0 | Ot(t, a = -2130706433 & e | 134217728) ? (o = 0 | ze(0 | t, 0 | e, 56), S(), a = (o = 0 == (0 | ye(t, a, 7 & o, n))) & ((0 | i[(a = n) >> 2]) == (0 | t) ? (0 | i[a + 4 >> 2]) == (0 | e) : 0) & 1, D = r, 0 | a) : (D = r, 0 | (a = 0))
                                    },
                                    _latLngToCell: Vt,
                                    _llvm_maxnum_f64: je,
                                    _llvm_minnum_f64: Ve,
                                    _llvm_round_f64: He,
                                    _localIjToCell: function(t, e, n, r, i) {
                                        var a, o;
                                        return t |= 0, e |= 0, n |= 0, i |= 0, o = D, D = D + 16 | 0, a = o, (r |= 0) ? n = 15 : (n = 0 | yt(n, a)) || (n = 0 | ce(t, e, a, i)), D = o, 0 | n
                                    },
                                    _malloc: Re,
                                    _maxFaceCount: function(t, e, n) {
                                        n |= 0;
                                        var r = 0,
                                            a = 0;
                                        if (a = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 45), S(), !(0 | F(127 & a))) return a = 2, i[n >> 2] = a, 0;
                                        if (a = 0 | ze(0 | t, 0 | e, 52), S(), !(a &= 15)) return a = 5, i[n >> 2] = a, 0;
                                        for (r = 1;;) {
                                            if (!(0 == ((0 | Ge(7, 0, 3 * (15 - r | 0) | 0)) & t | 0) & 0 == ((0 | S()) & e | 0))) {
                                                r = 2, t = 6;
                                                break
                                            }
                                            if (!(r >>> 0 < a >>> 0)) {
                                                r = 5, t = 6;
                                                break
                                            }
                                            r = r + 1 | 0
                                        }
                                        return 6 == (0 | t) ? (i[n >> 2] = r, 0) : 0
                                    },
                                    _maxGridDiskSize: function(t, e) {
                                        e |= 0;
                                        var n = 0,
                                            r = 0,
                                            a = 0;
                                        return (0 | (t |= 0)) < 0 ? 0 | (e = 2) : (0 | t) > 13780509 ? 0 | (e = 0 | ee(15, e)) : (a = 0 | Ue(0 | t, 0 | (n = ((0 | t) < 0) << 31 >> 31), 3, 0), r = 0 | S(), n = 0 | De(0 | t, 0 | n, 1, 0), n = 0 | De(0 | (n = 0 | Ue(0 | a, 0 | r, 0 | n, 0 | S())), 0 | S(), 1, 0), t = 0 | S(), i[e >> 2] = n, i[e + 4 >> 2] = t, 0 | (e = 0))
                                    },
                                    _maxPolygonToCellsSize: function(t, e, n, r) {
                                        e |= 0, r |= 0;
                                        var a, o = 0,
                                            s = 0,
                                            l = 0,
                                            A = 0,
                                            c = 0;
                                        if (a = D, D = D + 48 | 0, o = a + 16 | 0, s = a + 8 | 0, l = a, 0 | (n |= 0)) return D = a, 15;
                                        if (A = 0 | i[4 + (c = t |= 0) >> 2], i[(n = s) >> 2] = i[c >> 2], i[n + 4 >> 2] = A, de(s, o), !(e = 0 | Q(o, e, l))) {
                                            if (n = 0 | i[s >> 2], (0 | (s = 0 | i[t + 8 >> 2])) > 0) {
                                                o = 0 | i[t + 12 >> 2], e = 0;
                                                do {
                                                    n = (0 | i[o + (e << 3) >> 2]) + n | 0, e = e + 1 | 0
                                                } while ((0 | e) < (0 | s))
                                            }
                                            o = 0 | i[(e = l) >> 2], (0 | (e = 0 | i[e + 4 >> 2])) < (0 | (s = ((0 | n) < 0) << 31 >> 31)) | (0 | e) == (0 | s) & o >>> 0 < n >>> 0 ? (i[(e = l) >> 2] = n, i[e + 4 >> 2] = s, e = s) : n = o, A = 0 | De(0 | n, 0 | e, 12, 0), c = 0 | S(), i[(e = l) >> 2] = A, i[e + 4 >> 2] = c, i[(e = r) >> 2] = A, i[e + 4 >> 2] = c, e = 0
                                        }
                                        return D = a, 0 | e
                                    },
                                    _memcpy: We,
                                    _memset: Xe,
                                    _originToDirectedEdges: function(t, e, n) {
                                        n |= 0;
                                        var r, a = 0;
                                        return r = 0 == (0 | Ut(t |= 0, e |= 0)), e &= -2130706433, i[(a = n) >> 2] = r ? t : 0, i[a + 4 >> 2] = r ? 285212672 | e : 0, i[(a = n + 8 | 0) >> 2] = t, i[a + 4 >> 2] = 301989888 | e, i[(a = n + 16 | 0) >> 2] = t, i[a + 4 >> 2] = 318767104 | e, i[(a = n + 24 | 0) >> 2] = t, i[a + 4 >> 2] = 335544320 | e, i[(a = n + 32 | 0) >> 2] = t, i[a + 4 >> 2] = 352321536 | e, i[(n = n + 40 | 0) >> 2] = t, i[n + 4 >> 2] = 369098752 | e, 0
                                    },
                                    _pentagonCount: function() {
                                        return 12
                                    },
                                    _polygonToCells: function(t, e, n, r) {
                                        e |= 0, r |= 0;
                                        var a, o, s, l, A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0,
                                            m = 0,
                                            g = 0,
                                            v = 0,
                                            _ = 0,
                                            y = 0,
                                            x = 0,
                                            b = 0,
                                            M = 0,
                                            w = 0,
                                            E = 0,
                                            T = 0,
                                            C = 0,
                                            R = 0,
                                            P = 0,
                                            L = 0,
                                            I = 0,
                                            O = 0,
                                            U = 0,
                                            N = 0,
                                            F = 0;
                                        if (l = D, D = D + 112 | 0, a = l + 80 | 0, d = l + 72 | 0, o = l, s = l + 56 | 0, 0 | (n |= 0)) return D = l, 15;
                                        if (!(F = 0 | Re(32 + (i[(f = 8 + (t |= 0) | 0) >> 2] << 5) | 0))) return D = l, 13;
                                        if (fe(t, F), N = 0 | i[(U = t) + 4 >> 2], i[(n = d) >> 2] = i[U >> 2], i[n + 4 >> 2] = N, de(d, a), n = 0 | Q(a, e, o)) U = 0, N = 0;
                                        else {
                                            if (n = 0 | i[d >> 2], (0 | (c = 0 | i[f >> 2])) > 0) {
                                                u = 0 | i[t + 12 >> 2], A = 0;
                                                do {
                                                    n = (0 | i[u + (A << 3) >> 2]) + n | 0, A = A + 1 | 0
                                                } while ((0 | A) != (0 | c));
                                                A = n
                                            } else A = n;
                                            c = 0 | i[(n = o) >> 2], (0 | (n = 0 | i[n + 4 >> 2])) < (0 | (u = ((0 | A) < 0) << 31 >> 31)) | (0 | n) == (0 | u) & c >>> 0 < A >>> 0 ? (i[(n = o) >> 2] = A, i[n + 4 >> 2] = u, n = u) : A = c, U = 0 | De(0 | A, 0 | n, 12, 0), N = 0 | S(), i[(n = o) >> 2] = U, i[n + 4 >> 2] = N, n = 0
                                        }
                                        if (0 | n) return Pe(F), D = l, 0 | n;
                                        if (!(A = 0 | Le(U, 8))) return Pe(F), D = l, 13;
                                        if (!(h = 0 | Le(U, 8))) return Pe(F), Pe(A), D = l, 13;
                                        i[(I = a) >> 2] = 0, i[I + 4 >> 2] = 0, O = 0 | i[(I = t) + 4 >> 2], i[(n = d) >> 2] = i[I >> 2], i[n + 4 >> 2] = O, n = 0 | k(d, U, N, e, a, A, h);
                                        t: do {
                                            if (n) Pe(A), Pe(h), Pe(F);
                                            else {
                                                e: do {
                                                    if ((0 | i[f >> 2]) > 0) {
                                                        for (u = t + 12 | 0, c = 0; n = 0 | k((0 | i[u >> 2]) + (c << 3) | 0, U, N, e, a, A, h), c = c + 1 | 0, !(0 | n);)
                                                            if ((0 | c) >= (0 | i[f >> 2])) break e;
                                                        Pe(A), Pe(h), Pe(F);
                                                        break t
                                                    }
                                                } while (0);
                                                (0 | N) > 0 | 0 == (0 | N) & U >>> 0 > 0 && Xe(0 | h, 0, U << 3 | 0),
                                                I = 0 | i[(O = a) + 4 >> 2];e: do {
                                                    if ((0 | I) > 0 | 0 == (0 | I) & (0 | i[O >> 2]) >>> 0 > 0) {
                                                        R = A, P = h, L = A, I = h, O = A, n = A, E = A, T = h, C = h, A = h;
                                                        n: for (;;) {
                                                            for (x = 0, b = 0, M = 0, w = 0, c = 0, u = 0;;) {
                                                                d = (h = o) + 56 | 0;
                                                                do {
                                                                    i[h >> 2] = 0, h = h + 4 | 0
                                                                } while ((0 | h) < (0 | d));
                                                                if (0 | B(f = 0 | i[(e = R + (x << 3) | 0) >> 2], e = 0 | i[e + 4 >> 2], 1, o, 0)) {
                                                                    d = (h = o) + 56 | 0;
                                                                    do {
                                                                        i[h >> 2] = 0, h = h + 4 | 0
                                                                    } while ((0 | h) < (0 | d));
                                                                    0 | (h = 0 | Le(7, 4)) && (q(f, e, 1, o, h, 7, 0, 0), Pe(h))
                                                                }
                                                                for (y = 0;;) {
                                                                    v = 0 | i[(_ = o + (y << 3) | 0) >> 2], _ = 0 | i[_ + 4 >> 2];
                                                                    r: do {
                                                                        if (0 == (0 | v) & 0 == (0 | _)) h = c, d = u;
                                                                        else {
                                                                            if (p = 0 | ke(0 | v, 0 | _, 0 | U, 0 | N), f = 0 | S(), !(0 == (0 | (d = 0 | i[(e = h = r + (p << 3) | 0) >> 2])) & 0 == (0 | (e = 0 | i[e + 4 >> 2])))) {
                                                                                m = 0, g = 0;
                                                                                do {
                                                                                    if ((0 | m) > (0 | N) | (0 | m) == (0 | N) & g >>> 0 > U >>> 0) break n;
                                                                                    if ((0 | d) == (0 | v) & (0 | e) == (0 | _)) {
                                                                                        h = c, d = u;
                                                                                        break r
                                                                                    }
                                                                                    p = 0 | Ne(0 | (h = 0 | De(0 | p, 0 | f, 1, 0)), 0 | S(), 0 | U, 0 | N), f = 0 | S(), g = 0 | De(0 | g, 0 | m, 1, 0), m = 0 | S(), d = 0 | i[(e = h = r + (p << 3) | 0) >> 2], e = 0 | i[e + 4 >> 2]
                                                                                } while (!(0 == (0 | d) & 0 == (0 | e)))
                                                                            }
                                                                            0 == (0 | v) & 0 == (0 | _) ? (h = c, d = u) : (Xt(v, _, s), 0 | pe(t, F, s) && (g = 0 | De(0 | c, 0 | u, 1, 0), u = 0 | S(), i[(m = h) >> 2] = v, i[m + 4 >> 2] = _, i[(c = P + (c << 3) | 0) >> 2] = v, i[c + 4 >> 2] = _, c = g), h = c, d = u)
                                                                        }
                                                                    } while (0);
                                                                    if ((y = y + 1 | 0) >>> 0 >= 7) break;
                                                                    c = h, u = d
                                                                }
                                                                if (x = 0 | De(0 | x, 0 | b, 1, 0), b = 0 | S(), M = 0 | De(0 | M, 0 | w, 1, 0), w = 0 | S(), c = 0 | i[(u = a) >> 2], !((0 | w) < (0 | (u = 0 | i[u + 4 >> 2])) | (0 | w) == (0 | u) & M >>> 0 < c >>> 0)) break;
                                                                c = h, u = d
                                                            }
                                                            if ((0 | u) > 0 | 0 == (0 | u) & c >>> 0 > 0) {
                                                                c = 0, u = 0;
                                                                do {
                                                                    i[(w = R + (c << 3) | 0) >> 2] = 0, i[w + 4 >> 2] = 0, c = 0 | De(0 | c, 0 | u, 1, 0), u = 0 | S(), M = 0 | i[(w = a) + 4 >> 2]
                                                                } while ((0 | u) < (0 | M) | ((0 | u) == (0 | M) ? c >>> 0 < (0 | i[w >> 2]) >>> 0 : 0))
                                                            }
                                                            if (i[(w = a) >> 2] = h, i[w + 4 >> 2] = d, !((0 | d) > 0 | 0 == (0 | d) & h >>> 0 > 0)) break e;
                                                            y = A, x = C, b = O, M = T, w = P, A = E, C = n, T = L, E = y, n = x, O = I, I = b, L = M, P = R, R = w
                                                        }
                                                        Pe(L), Pe(I), Pe(F), n = 1;
                                                        break t
                                                    }
                                                    n = h
                                                } while (0);Pe(F),
                                                Pe(A),
                                                Pe(n),
                                                n = 0
                                            }
                                        } while (0);
                                        return D = l, 0 | n
                                    },
                                    _readInt64AsDoubleFromPointer: function(t) {
                                        return +(+((0 | i[(t |= 0) >> 2]) >>> 0) + 4294967296 * +(0 | i[t + 4 >> 2]))
                                    },
                                    _res0CellCount: function() {
                                        return 122
                                    },
                                    _round: Ye,
                                    _sbrk: Qe,
                                    _sizeOfCellBoundary: function() {
                                        return 168
                                    },
                                    _sizeOfCoordIJ: function() {
                                        return 8
                                    },
                                    _sizeOfGeoLoop: function() {
                                        return 8
                                    },
                                    _sizeOfGeoPolygon: function() {
                                        return 16
                                    },
                                    _sizeOfH3Index: function() {
                                        return 8
                                    },
                                    _sizeOfLatLng: function() {
                                        return 16
                                    },
                                    _sizeOfLinkedGeoPolygon: function() {
                                        return 12
                                    },
                                    _uncompactCells: function(t, e, n, r, a, o, s) {
                                        t |= 0, r |= 0, a |= 0, o |= 0;
                                        var l, A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0,
                                            f = 0,
                                            p = 0,
                                            m = 0;
                                        if (l = D, D = D + 16 | 0, m = l, !((0 | (n |= 0)) > 0 | 0 == (0 | n) & (e |= 0) >>> 0 > 0)) return D = l, 0;
                                        if ((0 | (s |= 0)) >= 16) return D = l, 12;
                                        f = 0, p = 0, d = 0, A = 0;
                                        t: for (;;) {
                                            if (h = 0 | ze(0 | (c = 0 | i[(u = t + (f << 3) | 0) >> 2]), 0 | (u = 0 | i[u + 4 >> 2]), 52), S(), (15 & h | 0) > (0 | s)) {
                                                A = 12, c = 11;
                                                break
                                            }
                                            if (Zt(m, c, u, s), 0 == (0 | (u = 0 | i[(h = m) >> 2])) & 0 == (0 | (h = 0 | i[h + 4 >> 2]))) c = d;
                                            else {
                                                c = d;
                                                do {
                                                    if (!((0 | A) < (0 | o) | (0 | A) == (0 | o) & c >>> 0 < a >>> 0)) {
                                                        c = 10;
                                                        break t
                                                    }
                                                    i[(d = r + (c << 3) | 0) >> 2] = u, i[d + 4 >> 2] = h, c = 0 | De(0 | c, 0 | A, 1, 0), A = 0 | S(), Jt(m), u = 0 | i[(d = m) >> 2], h = 0 | i[d + 4 >> 2]
                                                } while (!(0 == (0 | u) & 0 == (0 | h)))
                                            }
                                            if (f = 0 | De(0 | f, 0 | p, 1, 0), !((0 | (p = 0 | S())) < (0 | n) | (0 | p) == (0 | n) & f >>> 0 < e >>> 0)) {
                                                A = 0, c = 11;
                                                break
                                            }
                                            d = c
                                        }
                                        return 10 == (0 | c) ? (D = l, 0 | (m = 14)) : 11 == (0 | c) ? (D = l, 0 | A) : 0
                                    },
                                    _uncompactCellsSize: function(t, e, n, r, a) {
                                        t |= 0, e |= 0, n |= 0, r |= 0, a |= 0;
                                        var o, s, l = 0,
                                            A = 0,
                                            c = 0,
                                            u = 0,
                                            h = 0,
                                            d = 0;
                                        s = D, D = D + 16 | 0, o = s;
                                        t: do {
                                            if ((0 | n) > 0 | 0 == (0 | n) & e >>> 0 > 0) {
                                                for (h = 0, A = 0, l = 0, d = 0;;) {
                                                    if (!(0 == (0 | (c = 0 | i[(u = t + (h << 3) | 0) >> 2])) & 0 == (0 | (u = 0 | i[u + 4 >> 2])) || (u = 0 == (0 | qt(c, u, r, o)), A = 0 | De(0 | i[(c = o) >> 2], 0 | i[c + 4 >> 2], 0 | A, 0 | l), l = 0 | S(), u))) {
                                                        l = 12;
                                                        break
                                                    }
                                                    if (h = 0 | De(0 | h, 0 | d, 1, 0), !((0 | (d = 0 | S())) < (0 | n) | (0 | d) == (0 | n) & h >>> 0 < e >>> 0)) break t
                                                }
                                                return D = s, 0 | l
                                            }
                                            A = 0, l = 0
                                        } while (0);
                                        return i[a >> 2] = A, i[a + 4 >> 2] = l, D = s, 0
                                    },
                                    _vertexToLatLng: function(t, e, n) {
                                        n |= 0;
                                        var r, a, o, s, l = 0,
                                            A = 0;
                                        return s = D, D = D + 192 | 0, a = s, o = s + 168 | 0, l = 0 | ze(0 | (t |= 0), 0 | (e |= 0), 56), S(), l &= 7, 0 | (r = 0 | Wt(t, A = -2130706433 & e | 134217728, o)) ? (D = s, 0 | (A = r)) : (e = 0 | ze(0 | t, 0 | e, 52), S(), e &= 15, 0 | Ut(t, A) ? Tt(o, e, l, 1, a) : Lt(o, e, l, 1, a), A = a + 8 | 0, i[n >> 2] = i[A >> 2], i[n + 4 >> 2] = i[A + 4 >> 2], i[n + 8 >> 2] = i[A + 8 >> 2], i[n + 12 >> 2] = i[A + 12 >> 2], D = s, 0 | (A = 0))
                                    },
                                    establishStackSpace: function(t, e) {
                                        D = t |= 0
                                    },
                                    stackAlloc: function(t) {
                                        var e;
                                        return e = D, D = 15 + (D = D + (t |= 0) | 0) & -16, 0 | e
                                    },
                                    stackRestore: function(t) {
                                        D = t |= 0
                                    },
                                    stackSave: function() {
                                        return 0 | D
                                    }
                                }
                            }({
                                Math,
                                Int8Array,
                                Int32Array,
                                Uint8Array,
                                Float32Array,
                                Float64Array
                            }, {
                                a: at,
                                b: function(t) {
                                    A = t
                                },
                                c: function() {
                                    return A
                                },
                                d: function(t, e, n, r) {
                                    at("Assertion failed: " + y(t) + ", at: " + [e ? y(e) : "unknown filename", n, r ? y(r) : "unknown function"])
                                },
                                e: function(t) {
                                    return n.___errno_location && (m[n.___errno_location() >> 2] = t), t
                                },
                                f: j,
                                g: function(t, e, n) {
                                    f.set(f.subarray(e, e + n), t)
                                },
                                h: function(t) {
                                    var e = j(),
                                        n = 16777216,
                                        r = 2130706432;
                                    if (t > r) return !1;
                                    for (var i = Math.max(e, 16777216); i < t;) i = i <= 536870912 ? x(2 * i, n) : Math.min(x((3 * i + 2147483648) / 4, n), r);
                                    return !!V(i)
                                },
                                i: function(t) {
                                    at("OOM")
                                },
                                j: function(t) {
                                    return t
                                },
                                k: z,
                                l: V,
                                m: G,
                                n: function() {
                                    var t = G();
                                    return n.extraStackTrace && (t += "\n" + n.extraStackTrace()), z(t)
                                },
                                o: 24144,
                                p: 24128
                            }, h),
                            Z = (n.___divdi3 = Q.___divdi3, n.___muldi3 = Q.___muldi3, n.___remdi3 = Q.___remdi3, n.___uremdi3 = Q.___uremdi3, n._areNeighborCells = Q._areNeighborCells, n._bitshift64Ashr = Q._bitshift64Ashr, n._bitshift64Lshr = Q._bitshift64Lshr, n._bitshift64Shl = Q._bitshift64Shl, n._calloc = Q._calloc, n._cellAreaKm2 = Q._cellAreaKm2, n._cellAreaM2 = Q._cellAreaM2, n._cellAreaRads2 = Q._cellAreaRads2, n._cellToBoundary = Q._cellToBoundary, n._cellToCenterChild = Q._cellToCenterChild, n._cellToChildPos = Q._cellToChildPos, n._cellToChildren = Q._cellToChildren, n._cellToChildrenSize = Q._cellToChildrenSize, n._cellToLatLng = Q._cellToLatLng, n._cellToLocalIj = Q._cellToLocalIj, n._cellToParent = Q._cellToParent, n._cellToVertex = Q._cellToVertex, n._cellToVertexes = Q._cellToVertexes, n._cellsToDirectedEdge = Q._cellsToDirectedEdge, n._cellsToLinkedMultiPolygon = Q._cellsToLinkedMultiPolygon, n._childPosToCell = Q._childPosToCell, n._compactCells = Q._compactCells, n._destroyLinkedMultiPolygon = Q._destroyLinkedMultiPolygon, n._directedEdgeToBoundary = Q._directedEdgeToBoundary, n._directedEdgeToCells = Q._directedEdgeToCells, n._edgeLengthKm = Q._edgeLengthKm, n._edgeLengthM = Q._edgeLengthM, n._edgeLengthRads = Q._edgeLengthRads, n._emscripten_replace_memory = Q._emscripten_replace_memory),
                            J = (n._free = Q._free, n._getBaseCellNumber = Q._getBaseCellNumber, n._getDirectedEdgeDestination = Q._getDirectedEdgeDestination, n._getDirectedEdgeOrigin = Q._getDirectedEdgeOrigin, n._getHexagonAreaAvgKm2 = Q._getHexagonAreaAvgKm2, n._getHexagonAreaAvgM2 = Q._getHexagonAreaAvgM2, n._getHexagonEdgeLengthAvgKm = Q._getHexagonEdgeLengthAvgKm, n._getHexagonEdgeLengthAvgM = Q._getHexagonEdgeLengthAvgM, n._getIcosahedronFaces = Q._getIcosahedronFaces, n._getNumCells = Q._getNumCells, n._getPentagons = Q._getPentagons, n._getRes0Cells = Q._getRes0Cells, n._getResolution = Q._getResolution, n._greatCircleDistanceKm = Q._greatCircleDistanceKm, n._greatCircleDistanceM = Q._greatCircleDistanceM, n._greatCircleDistanceRads = Q._greatCircleDistanceRads, n._gridDisk = Q._gridDisk, n._gridDiskDistances = Q._gridDiskDistances, n._gridDistance = Q._gridDistance, n._gridPathCells = Q._gridPathCells, n._gridPathCellsSize = Q._gridPathCellsSize, n._gridRingUnsafe = Q._gridRingUnsafe, n._i64Add = Q._i64Add, n._i64Subtract = Q._i64Subtract, n._isPentagon = Q._isPentagon, n._isResClassIII = Q._isResClassIII, n._isValidCell = Q._isValidCell, n._isValidDirectedEdge = Q._isValidDirectedEdge, n._isValidVertex = Q._isValidVertex, n._latLngToCell = Q._latLngToCell, n._llvm_maxnum_f64 = Q._llvm_maxnum_f64, n._llvm_minnum_f64 = Q._llvm_minnum_f64, n._llvm_round_f64 = Q._llvm_round_f64, n._localIjToCell = Q._localIjToCell, n._malloc = Q._malloc, n._maxFaceCount = Q._maxFaceCount, n._maxGridDiskSize = Q._maxGridDiskSize, n._maxPolygonToCellsSize = Q._maxPolygonToCellsSize, n._memcpy = Q._memcpy, n._memset = Q._memset, n._originToDirectedEdges = Q._originToDirectedEdges, n._pentagonCount = Q._pentagonCount, n._polygonToCells = Q._polygonToCells, n._readInt64AsDoubleFromPointer = Q._readInt64AsDoubleFromPointer, n._res0CellCount = Q._res0CellCount, n._round = Q._round, n._sbrk = Q._sbrk, n._sizeOfCellBoundary = Q._sizeOfCellBoundary, n._sizeOfCoordIJ = Q._sizeOfCoordIJ, n._sizeOfGeoLoop = Q._sizeOfGeoLoop, n._sizeOfGeoPolygon = Q._sizeOfGeoPolygon, n._sizeOfH3Index = Q._sizeOfH3Index, n._sizeOfLatLng = Q._sizeOfLatLng, n._sizeOfLinkedGeoPolygon = Q._sizeOfLinkedGeoPolygon, n._uncompactCells = Q._uncompactCells, n._uncompactCellsSize = Q._uncompactCellsSize, n._vertexToLatLng = Q._vertexToLatLng, n.establishStackSpace = Q.establishStackSpace, n.stackAlloc = Q.stackAlloc),
                            K = n.stackRestore = Q.stackRestore,
                            $ = n.stackSave = Q.stackSave;
                        if (n.asm = Q, n.cwrap = function(t, e, n, r) {
                                var i = (n = n || []).every((function(t) {
                                    return "number" === t
                                }));
                                return "string" !== e && i && !r ? u(t) : function() {
                                    return function(t, e, n, r, i) {
                                        var a = {
                                                string: function(t) {
                                                    var e = 0;
                                                    if (null != t && 0 !== t) {
                                                        var n = 1 + (t.length << 2);
                                                        ! function(t, e, n) {
                                                            ! function(t, e, n, r) {
                                                                if (!(r > 0)) return 0;
                                                                for (var i = n + r - 1, a = 0; a < t.length; ++a) {
                                                                    var o = t.charCodeAt(a);
                                                                    if (o >= 55296 && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & t.charCodeAt(++a)), o <= 127) {
                                                                        if (n >= i) break;
                                                                        e[n++] = o
                                                                    } else if (o <= 2047) {
                                                                        if (n + 1 >= i) break;
                                                                        e[n++] = 192 | o >> 6, e[n++] = 128 | 63 & o
                                                                    } else if (o <= 65535) {
                                                                        if (n + 2 >= i) break;
                                                                        e[n++] = 224 | o >> 12, e[n++] = 128 | o >> 6 & 63, e[n++] = 128 | 63 & o
                                                                    } else {
                                                                        if (n + 3 >= i) break;
                                                                        e[n++] = 240 | o >> 18, e[n++] = 128 | o >> 12 & 63, e[n++] = 128 | o >> 6 & 63, e[n++] = 128 | 63 & o
                                                                    }
                                                                }
                                                                e[n] = 0
                                                            }(t, f, e, n)
                                                        }(t, e = J(n), n)
                                                    }
                                                    return e
                                                },
                                                array: function(t) {
                                                    var e = J(t.length);
                                                    return function(t, e) {
                                                        d.set(t, e)
                                                    }(t, e), e
                                                }
                                            },
                                            o = u(t),
                                            s = [],
                                            l = 0;
                                        if (r)
                                            for (var A = 0; A < r.length; A++) {
                                                var c = a[n[A]];
                                                c ? (0 === l && (l = $()), s[A] = c(r[A])) : s[A] = r[A]
                                            }
                                        var h = o.apply(null, s);
                                        return h = function(t) {
                                            return "string" === e ? y(t) : "boolean" === e ? Boolean(t) : t
                                        }(h), 0 !== l && K(l), h
                                    }(t, e, n, arguments)
                                }
                            }, n.setValue = function(t, e, n, r) {
                                switch ("*" === (n = n || "i8").charAt(n.length - 1) && (n = "i32"), n) {
                                    case "i1":
                                    case "i8":
                                        d[t >> 0] = e;
                                        break;
                                    case "i16":
                                        p[t >> 1] = e;
                                        break;
                                    case "i32":
                                        m[t >> 2] = e;
                                        break;
                                    case "i64":
                                        U = [e >>> 0, (q = e, +R(q) >= 1 ? q > 0 ? (0 | D(+L(q / 4294967296), 4294967295)) >>> 0 : ~~+P((q - +(~~q >>> 0)) / 4294967296) >>> 0 : 0)], m[t >> 2] = U[0], m[t + 4 >> 2] = U[1];
                                        break;
                                    case "float":
                                        g[t >> 2] = e;
                                        break;
                                    case "double":
                                        v[t >> 3] = e;
                                        break;
                                    default:
                                        at("invalid type for setValue: " + n)
                                }
                            }, n.getValue = function(t, e, n) {
                                switch ("*" === (e = e || "i8").charAt(e.length - 1) && (e = "i32"), e) {
                                    case "i1":
                                    case "i8":
                                        return d[t >> 0];
                                    case "i16":
                                        return p[t >> 1];
                                    case "i32":
                                    case "i64":
                                        return m[t >> 2];
                                    case "float":
                                        return g[t >> 2];
                                    case "double":
                                        return v[t >> 3];
                                    default:
                                        at("invalid type for getValue: " + e)
                                }
                                return null
                            }, N) {
                            F(N) || (X = N, N = n.locateFile ? n.locateFile(X, o) : o + X), I++, n.monitorRunDependencies && n.monitorRunDependencies(I);
                            var tt = function(t) {
                                    t.byteLength && (t = new Uint8Array(t)), f.set(t, 8), n.memoryInitializerRequest && delete n.memoryInitializerRequest.response,
                                        function(t) {
                                            if (I--, n.monitorRunDependencies && n.monitorRunDependencies(I), 0 == I && (null !== O && (clearInterval(O), O = null), B)) {
                                                var e = B;
                                                B = null, e()
                                            }
                                        }()
                                },
                                et = function() {
                                    i(N, tt, (function() {
                                        throw "could not load memory initializer " + N
                                    }))
                                },
                                nt = W(N);
                            if (nt) tt(nt.buffer);
                            else if (n.memoryInitializerRequest) {
                                var rt = function() {
                                    var t = n.memoryInitializerRequest,
                                        e = t.response;
                                    if (200 !== t.status && 0 !== t.status) {
                                        var r = W(n.memoryInitializerRequestURL);
                                        if (!r) return console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + t.status + ", retrying " + N), void et();
                                        e = r.buffer
                                    }
                                    tt(e)
                                };
                                n.memoryInitializerRequest.response ? setTimeout(rt, 0) : n.memoryInitializerRequest.addEventListener("load", rt)
                            } else et()
                        }

                        function it(t) {
                            function e() {
                                Y || (Y = !0, c || (w(E), w(T), n.onRuntimeInitialized && n.onRuntimeInitialized(), function() {
                                    if (n.postRun)
                                        for ("function" == typeof n.postRun && (n.postRun = [n.postRun]); n.postRun.length;) t = n.postRun.shift(), C.unshift(t);
                                    var t;
                                    w(C)
                                }()))
                            }
                            t = t || a, I > 0 || (function() {
                                if (n.preRun)
                                    for ("function" == typeof n.preRun && (n.preRun = [n.preRun]); n.preRun.length;) t = n.preRun.shift(), S.unshift(t);
                                var t;
                                w(S)
                            }(), I > 0 || (n.setStatus ? (n.setStatus("Running..."), setTimeout((function() {
                                setTimeout((function() {
                                    n.setStatus("")
                                }), 1), e()
                            }), 1)) : e()))
                        }

                        function at(t) {
                            throw n.onAbort && n.onAbort(t), s(t += ""), l(t), c = !0, "abort(" + t + "). Build with -s ASSERTIONS=1 for more info."
                        }
                        if (B = function t() {
                                Y || it(), Y || (B = t)
                            }, n.run = it, n.abort = at, n.preInit)
                            for ("function" == typeof n.preInit && (n.preInit = [n.preInit]); n.preInit.length > 0;) n.preInit.pop()();
                        return it(), t
                    }("object" == typeof r ? r : {}),
                    i = "number",
                    a = [
                        ["sizeOfH3Index", i],
                        ["sizeOfLatLng", i],
                        ["sizeOfCellBoundary", i],
                        ["sizeOfGeoLoop", i],
                        ["sizeOfGeoPolygon", i],
                        ["sizeOfLinkedGeoPolygon", i],
                        ["sizeOfCoordIJ", i],
                        ["readInt64AsDoubleFromPointer", i],
                        ["isValidCell", i, [i, i]],
                        ["latLngToCell", i, [i, i, i, i]],
                        ["cellToLatLng", i, [i, i, i]],
                        ["cellToBoundary", i, [i, i, i]],
                        ["maxGridDiskSize", i, [i, i]],
                        ["gridDisk", i, [i, i, i, i]],
                        ["gridDiskDistances", i, [i, i, i, i, i]],
                        ["gridRingUnsafe", i, [i, i, i, i]],
                        ["maxPolygonToCellsSize", i, [i, i, i, i]],
                        ["polygonToCells", i, [i, i, i, i]],
                        ["cellsToLinkedMultiPolygon", i, [i, i, i]],
                        ["destroyLinkedMultiPolygon", null, [i]],
                        ["compactCells", i, [i, i, i, i]],
                        ["uncompactCells", i, [i, i, i, i, i, i]],
                        ["uncompactCellsSize", i, [i, i, i, i, i]],
                        ["isPentagon", i, [i, i]],
                        ["isResClassIII", i, [i, i]],
                        ["getBaseCellNumber", i, [i, i]],
                        ["getResolution", i, [i, i]],
                        ["maxFaceCount", i, [i, i, i]],
                        ["getIcosahedronFaces", i, [i, i, i]],
                        ["cellToParent", i, [i, i, i, i]],
                        ["cellToChildren", i, [i, i, i, i]],
                        ["cellToCenterChild", i, [i, i, i, i]],
                        ["cellToChildrenSize", i, [i, i, i, i]],
                        ["cellToChildPos", i, [i, i, i, i]],
                        ["childPosToCell", i, [i, i, i, i, i, i]],
                        ["areNeighborCells", i, [i, i, i, i, i]],
                        ["cellsToDirectedEdge", i, [i, i, i, i, i]],
                        ["getDirectedEdgeOrigin", i, [i, i, i]],
                        ["getDirectedEdgeDestination", i, [i, i, i]],
                        ["isValidDirectedEdge", i, [i, i]],
                        ["directedEdgeToCells", i, [i, i, i]],
                        ["originToDirectedEdges", i, [i, i, i]],
                        ["directedEdgeToBoundary", i, [i, i, i]],
                        ["gridDistance", i, [i, i, i, i, i]],
                        ["gridPathCells", i, [i, i, i, i, i]],
                        ["gridPathCellsSize", i, [i, i, i, i, i]],
                        ["cellToLocalIj", i, [i, i, i, i, i, i]],
                        ["localIjToCell", i, [i, i, i, i, i]],
                        ["getHexagonAreaAvgM2", i, [i, i]],
                        ["getHexagonAreaAvgKm2", i, [i, i]],
                        ["getHexagonEdgeLengthAvgM", i, [i, i]],
                        ["getHexagonEdgeLengthAvgKm", i, [i, i]],
                        ["greatCircleDistanceM", i, [i, i]],
                        ["greatCircleDistanceKm", i, [i, i]],
                        ["greatCircleDistanceRads", i, [i, i]],
                        ["cellAreaM2", i, [i, i, i]],
                        ["cellAreaKm2", i, [i, i, i]],
                        ["cellAreaRads2", i, [i, i, i]],
                        ["edgeLengthM", i, [i, i, i]],
                        ["edgeLengthKm", i, [i, i, i]],
                        ["edgeLengthRads", i, [i, i, i]],
                        ["getNumCells", i, [i, i]],
                        ["getRes0Cells", i, [i]],
                        ["res0CellCount", i],
                        ["getPentagons", i, [i, i]],
                        ["pentagonCount", i],
                        ["cellToVertex", i, [i, i, i, i]],
                        ["cellToVertexes", i, [i, i, i]],
                        ["vertexToLatLng", i, [i, i, i]],
                        ["isValidVertex", i, [i, i]]
                    ],
                    o = 4,
                    s = 5,
                    l = {
                        0: "Success",
                        1: "The operation failed but a more specific error is not available",
                        2: "Argument was outside of acceptable range",
                        3: "Latitude or longitude arguments were outside of acceptable range"
                    };
                l[o] = "Resolution argument was outside of acceptable range", l[s] = "Cell argument was not valid", l[6] = "Directed edge argument was not valid", l[7] = "Undirected edge argument was not valid", l[8] = "Vertex argument was not valid", l[9] = "Pentagon distortion was encountered", l[10] = "Duplicate input", l[11] = "Cell arguments were not neighbors", l[12] = "Cell arguments had incompatible resolutions", l[13] = "Memory allocation failed", l[14] = "Bounds of provided memory were insufficient", l[15] = "Mode or flags argument was not valid";
                var A = 1e3,
                    c = 1001,
                    u = 1002,
                    h = {};
                h[A] = "Unknown unit", h[c] = "Array length out of bounds", h[u] = "Got unexpected null value for H3 index";
                var d = "Unknown error";

                function f(t, e, n) {
                    var r = n && "value" in n,
                        i = new Error((t[e] || d) + " (code: " + e + (r ? ", value: " + n.value : "") + ")");
                    return i.code = e, i
                }

                function p(t, e) {
                    return f(l, t, 2 === arguments.length ? {
                        value: e
                    } : {})
                }

                function m(t, e) {
                    return f(h, t, 2 === arguments.length ? {
                        value: e
                    } : {})
                }

                function g(t) {
                    if (0 !== t) throw p(t)
                }
                var v = {};
                a.forEach((function(t) {
                    v[t[0]] = r.cwrap.apply(r, t)
                }));
                var _ = 16,
                    y = 0,
                    x = 4,
                    b = 4,
                    M = 8,
                    w = 8,
                    S = v.sizeOfH3Index(),
                    E = v.sizeOfLatLng(),
                    T = v.sizeOfCellBoundary(),
                    C = v.sizeOfGeoPolygon(),
                    R = v.sizeOfGeoLoop(),
                    P = v.sizeOfLinkedGeoPolygon(),
                    L = v.sizeOfCoordIJ(),
                    D = {
                        m: "m",
                        m2: "m2",
                        km: "km",
                        km2: "km2",
                        rads: "rads",
                        rads2: "rads2"
                    };

                function I(t) {
                    if ("number" != typeof t || t < 0 || t > 15 || Math.floor(t) !== t) throw p(o, t);
                    return t
                }

                function O(t) {
                    if (!t) throw m(u);
                    return t
                }
                var B = Math.pow(2, 32) - 1;

                function q(t) {
                    if (t > B) throw m(c, t);
                    return t
                }
                var U = /[^0-9a-fA-F]/;

                function N(t) {
                    if (Array.isArray(t) && 2 === t.length && Number.isInteger(t[0]) && Number.isInteger(t[1])) return t;
                    if ("string" != typeof t || U.test(t)) return [0, 0];
                    var e = parseInt(t.substring(0, t.length - 8), _);
                    return [parseInt(t.substring(t.length - 8), _), e]
                }

                function k(t) {
                    if (t >= 0) return t.toString(_);
                    var e = z(8, (t &= 2147483647).toString(_));
                    return (parseInt(e[0], _) + 8).toString(_) + e.substring(1)
                }

                function F(t, e) {
                    return k(e) + z(8, k(t))
                }

                function z(t, e) {
                    for (var n = t - e.length, r = "", i = 0; i < n; i++) r += "0";
                    return r + e
                }
                var G = Math.pow(2, 32);

                function j(t, e, n) {
                    for (var i = t.length, a = r._calloc(i, E), o = n ? 1 : 0, s = n ? 0 : 1, l = 0; l < 2 * i; l += 2) r.HEAPF64.set([t[l / 2][o], t[l / 2][s]].map(Yt), a / M + l);
                    return r.HEAPU32.set([i, a], e / x), e
                }

                function V(t, e) {
                    void 0 === e && (e = 0);
                    var n = r.getValue(t + S * e, "i32"),
                        i = r.getValue(t + S * e + x, "i32");
                    return i ? F(n, i) : null
                }

                function H(t, e) {
                    return void 0 === e && (e = 0), r.getValue(t + M * e, "double")
                }

                function W(t) {
                    return v.readInt64AsDoubleFromPointer(t)
                }

                function X(t, e, n) {
                    r.HEAPU32.set(N(t), e / x + 2 * n)
                }

                function Y(t, e) {
                    for (var n = [], r = 0; r < e; r++) {
                        var i = V(t, r);
                        null !== i && n.push(i)
                    }
                    return n
                }

                function Q(t, e) {
                    for (var n = e.length, r = 0; r < n; r++) X(e[r], t, r)
                }

                function Z(t, e) {
                    var n = r._calloc(1, E);
                    return r.HEAPF64.set([t, e].map(Yt), n / M), n
                }

                function J(t) {
                    return Qt(r.getValue(t, "double"))
                }

                function K(t) {
                    return [J(t), J(t + M)]
                }

                function $(t) {
                    return [J(t + M), J(t)]
                }

                function tt(t, e, n) {
                    for (var i = r.getValue(t, "i32"), a = t + M, o = [], s = e ? $ : K, l = 0; l < 2 * i; l += 2) o.push(s(a + M * l));
                    return n && o.push(o[0]), o
                }

                function et(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return Boolean(v.isValidCell(n, r))
                }

                function nt(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return Boolean(v.isPentagon(n, r))
                }

                function rt(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return Boolean(v.isResClassIII(n, r))
                }

                function it(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return v.getBaseCellNumber(n, r)
                }

                function at(t) {
                    var e = N(t),
                        n = e[0],
                        i = e[1],
                        a = r._malloc(x);
                    try {
                        g(v.maxFaceCount(n, i, a));
                        var o = r.getValue(a, "i32"),
                            s = r._malloc(x * o);
                        try {
                            return g(v.getIcosahedronFaces(n, i, s)),
                                function(t, e) {
                                    for (var n = [], i = 0; i < e; i++) {
                                        var a = r.getValue(t + x * i, "i32");
                                        a >= 0 && n.push(a)
                                    }
                                    return n
                                }(s, o)
                        } finally {
                            r._free(s)
                        }
                    } finally {
                        r._free(a)
                    }
                }

                function ot(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return v.isValidCell(n, r) ? v.getResolution(n, r) : -1
                }

                function st(t, e, n) {
                    var i = r._malloc(E);
                    r.HEAPF64.set([t, e].map(Yt), i / M);
                    var a = r._malloc(S);
                    try {
                        return g(v.latLngToCell(i, n, a)), O(V(a))
                    } finally {
                        r._free(a), r._free(i)
                    }
                }

                function lt(t) {
                    var e = r._malloc(E),
                        n = N(t),
                        i = n[0],
                        a = n[1];
                    try {
                        return g(v.cellToLatLng(i, a, e)), K(e)
                    } finally {
                        r._free(e)
                    }
                }

                function At(t, e) {
                    var n = r._malloc(T),
                        i = N(t),
                        a = i[0],
                        o = i[1];
                    try {
                        return g(v.cellToBoundary(a, o, n)), tt(n, e, e)
                    } finally {
                        r._free(n)
                    }
                }

                function ct(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(S);
                    try {
                        return g(v.cellToParent(i, a, e, o)), O(V(o))
                    } finally {
                        r._free(o)
                    }
                }

                function ut(t, e) {
                    if (!et(t)) return [];
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = q(ht(t, e)),
                        s = r._calloc(o, S);
                    try {
                        return g(v.cellToChildren(i, a, e, s)), Y(s, o)
                    } finally {
                        r._free(s)
                    }
                }

                function ht(t, e) {
                    if (!et(t)) throw p(s);
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(w);
                    try {
                        return g(v.cellToChildrenSize(i, a, e, o)), W(o)
                    } finally {
                        r._free(o)
                    }
                }

                function dt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(S);
                    try {
                        return g(v.cellToCenterChild(i, a, e, o)), O(V(o))
                    } finally {
                        r._free(o)
                    }
                }

                function ft(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(w);
                    try {
                        return g(v.cellToChildPos(i, a, e, o)), W(o)
                    } finally {
                        r._free(o)
                    }
                }

                function pt(t, e, n) {
                    var i, a = "number" != typeof(i = t) ? [0, 0] : [0 | i, i / G | 0],
                        o = a[0],
                        s = a[1],
                        l = N(e),
                        A = l[0],
                        c = l[1],
                        u = r._malloc(S);
                    try {
                        return g(v.childPosToCell(o, s, A, c, n, u)), O(V(u))
                    } finally {
                        r._free(u)
                    }
                }

                function mt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(w);
                    try {
                        g(v.maxGridDiskSize(e, o));
                        var s = q(W(o)),
                            l = r._calloc(s, S);
                        try {
                            return g(v.gridDisk(i, a, e, l)), Y(l, s)
                        } finally {
                            r._free(l)
                        }
                    } finally {
                        r._free(o)
                    }
                }

                function gt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(w);
                    try {
                        g(v.maxGridDiskSize(e, o));
                        var s = q(W(o)),
                            l = r._calloc(s, S),
                            A = r._calloc(s, x);
                        try {
                            g(v.gridDiskDistances(i, a, e, l, A));
                            for (var c = [], u = 0; u < e + 1; u++) c.push([]);
                            for (var h = 0; h < s; h++) {
                                var d = V(l, h),
                                    f = r.getValue(A + x * h, "i32");
                                null !== d && c[f].push(d)
                            }
                            return c
                        } finally {
                            r._free(l), r._free(A)
                        }
                    } finally {
                        r._free(o)
                    }
                }

                function vt(t, e) {
                    var n = 0 === e ? 1 : 6 * e,
                        i = r._calloc(n, S);
                    try {
                        return g(v.gridRingUnsafe.apply(v, N(t).concat([e], [i]))), Y(i, n)
                    } finally {
                        r._free(i)
                    }
                }

                function _t(t, e, n) {
                    if (I(e), n = Boolean(n), 0 === t.length || 0 === t[0].length) return [];
                    var i = function(t, e) {
                            var n, i = t.length - 1,
                                a = r._calloc(C),
                                o = 0 + R,
                                s = o + x;
                            if (j(t[0], a + 0, e), i > 0) {
                                n = r._calloc(i, R);
                                for (var l = 0; l < i; l++) j(t[l + 1], n + R * l, e)
                            }
                            return r.setValue(a + o, i, "i32"), r.setValue(a + s, n, "i32"), a
                        }("number" == typeof t[0][0] ? [t] : t, n),
                        a = r._malloc(w);
                    try {
                        g(v.maxPolygonToCellsSize(i, e, 0, a));
                        var o = q(W(a)),
                            s = r._calloc(o, S);
                        try {
                            return g(v.polygonToCells(i, e, 0, s)), Y(s, o)
                        } finally {
                            r._free(s)
                        }
                    } finally {
                        r._free(a),
                            function(t) {
                                var e = 0 + R,
                                    n = e + x,
                                    i = x;
                                r._free(r.getValue(t + 0 + i, "i8*"));
                                var a = r.getValue(t + e, "i32");
                                if (a > 0) {
                                    for (var o = r.getValue(t + n, "i32"), s = 0; s < a; s++) r._free(r.getValue(o + R * s + i, "i8*"));
                                    r._free(o)
                                }
                                r._free(t)
                            }(i)
                    }
                }

                function yt(t, e) {
                    if (!t || !t.length) return [];
                    var n = t.length,
                        i = r._calloc(n, S);
                    Q(i, t);
                    var a = r._calloc(P);
                    try {
                        return g(v.cellsToLinkedMultiPolygon(i, n, a)),
                            function(t, e) {
                                for (var n, i, a, o, s = [], l = e ? $ : K; t;) {
                                    for (s.push(n = []), i = r.getValue(t, "i8*"); i;) {
                                        for (n.push(a = []), o = r.getValue(i, "i8*"); o;) a.push(l(o)), o = r.getValue(o + 2 * M, "i8*");
                                        e && a.push(a[0]), i = r.getValue(i + 2 * b, "i8*")
                                    }
                                    t = r.getValue(t + 2 * b, "i8*")
                                }
                                return s
                            }(a, e)
                    } finally {
                        v.destroyLinkedMultiPolygon(a), r._free(a), r._free(i)
                    }
                }

                function xt(t) {
                    if (!t || !t.length) return [];
                    var e = t.length,
                        n = r._calloc(e, S);
                    Q(n, t);
                    var i = r._calloc(e, S);
                    try {
                        return g(v.compactCells(n, i, e, y)), Y(i, e)
                    } finally {
                        r._free(n), r._free(i)
                    }
                }

                function bt(t, e) {
                    if (I(e), !t || !t.length) return [];
                    var n = t.length,
                        i = r._calloc(n, S);
                    Q(i, t);
                    var a = r._malloc(w);
                    try {
                        g(v.uncompactCellsSize(i, n, y, e, a));
                        var o = q(W(a)),
                            s = r._calloc(o, S);
                        try {
                            return g(v.uncompactCells(i, n, y, s, o, y, e)), Y(s, o)
                        } finally {
                            r._free(i), r._free(s)
                        }
                    } finally {
                        r._free(a)
                    }
                }

                function Mt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = N(e),
                        s = o[0],
                        l = o[1],
                        A = r._malloc(x);
                    try {
                        return g(v.areNeighborCells(i, a, s, l, A)),
                            function(t, e) {
                                void 0 === e && (e = 0);
                                var n = r.getValue(t + x * e, "i32");
                                return Boolean(n)
                            }(A)
                    } finally {
                        r._free(A)
                    }
                }

                function wt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = N(e),
                        s = o[0],
                        l = o[1],
                        A = r._malloc(S);
                    try {
                        return g(v.cellsToDirectedEdge(i, a, s, l, A)), O(V(A))
                    } finally {
                        r._free(A)
                    }
                }

                function St(t) {
                    var e = N(t),
                        n = e[0],
                        i = e[1],
                        a = r._malloc(S);
                    try {
                        return g(v.getDirectedEdgeOrigin(n, i, a)), O(V(a))
                    } finally {
                        r._free(a)
                    }
                }

                function Et(t) {
                    var e = N(t),
                        n = e[0],
                        i = e[1],
                        a = r._malloc(S);
                    try {
                        return g(v.getDirectedEdgeDestination(n, i, a)), O(V(a))
                    } finally {
                        r._free(a)
                    }
                }

                function Tt(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return Boolean(v.isValidDirectedEdge(n, r))
                }

                function Ct(t) {
                    var e = N(t),
                        n = e[0],
                        i = e[1],
                        a = r._calloc(2, S);
                    try {
                        return g(v.directedEdgeToCells(n, i, a)), Y(a, 2)
                    } finally {
                        r._free(a)
                    }
                }

                function Rt(t) {
                    var e = N(t),
                        n = e[0],
                        i = e[1],
                        a = r._calloc(6, S);
                    try {
                        return g(v.originToDirectedEdges(n, i, a)), Y(a, 6)
                    } finally {
                        r._free(a)
                    }
                }

                function Pt(t, e) {
                    var n = r._malloc(T),
                        i = N(t),
                        a = i[0],
                        o = i[1];
                    try {
                        return g(v.directedEdgeToBoundary(a, o, n)), tt(n, e)
                    } finally {
                        r._free(n)
                    }
                }

                function Lt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = N(e),
                        s = o[0],
                        l = o[1],
                        A = r._malloc(w);
                    try {
                        return g(v.gridDistance(i, a, s, l, A)), W(A)
                    } finally {
                        r._free(A)
                    }
                }

                function Dt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = N(e),
                        s = o[0],
                        l = o[1],
                        A = r._malloc(w);
                    try {
                        g(v.gridPathCellsSize(i, a, s, l, A));
                        var c = q(W(A)),
                            u = r._calloc(c, S);
                        try {
                            return v.gridPathCells(i, a, s, l, u), Y(u, c)
                        } finally {
                            r._free(u)
                        }
                    } finally {
                        r._free(A)
                    }
                }
                var It = 0;

                function Ot(t, e) {
                    var n, i = r._malloc(L);
                    try {
                        return g(v.cellToLocalIj.apply(v, N(t).concat(N(e), [It], [i]))), n = i, {
                            i: r.getValue(n, "i32"),
                            j: r.getValue(n + x, "i32")
                        }
                    } finally {
                        r._free(i)
                    }
                }

                function Bt(t, e) {
                    if (!e || "number" != typeof e.i || "number" != typeof e.j) throw new Error("Coordinates must be provided as an {i, j} object");
                    var n, i, a, o, s = r._malloc(L),
                        l = r._malloc(S);
                    n = s, a = (i = e).i, o = i.j, r.setValue(n, a, "i32"), r.setValue(n + x, o, "i32");
                    try {
                        return g(v.localIjToCell.apply(v, N(t).concat([s], [It], [l]))), O(V(l))
                    } finally {
                        r._free(s), r._free(l)
                    }
                }

                function qt(t, e, n) {
                    var i, a = Z(t[0], t[1]),
                        o = Z(e[0], e[1]);
                    switch (n) {
                        case D.m:
                            i = v.greatCircleDistanceM(a, o);
                            break;
                        case D.km:
                            i = v.greatCircleDistanceKm(a, o);
                            break;
                        case D.rads:
                            i = v.greatCircleDistanceRads(a, o);
                            break;
                        default:
                            i = null
                    }
                    if (r._free(a), r._free(o), null === i) throw m(A, n);
                    return i
                }

                function Ut(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(M);
                    try {
                        switch (e) {
                            case D.m2:
                                g(v.cellAreaM2(i, a, o));
                                break;
                            case D.km2:
                                g(v.cellAreaKm2(i, a, o));
                                break;
                            case D.rads2:
                                g(v.cellAreaRads2(i, a, o));
                                break;
                            default:
                                throw m(A, e)
                        }
                        return H(o)
                    } finally {
                        r._free(o)
                    }
                }

                function Nt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(M);
                    try {
                        switch (e) {
                            case D.m:
                                g(v.edgeLengthM(i, a, o));
                                break;
                            case D.km:
                                g(v.edgeLengthKm(i, a, o));
                                break;
                            case D.rads:
                                g(v.edgeLengthRads(i, a, o));
                                break;
                            default:
                                throw m(A, e)
                        }
                        return H(o)
                    } finally {
                        r._free(o)
                    }
                }

                function kt(t, e) {
                    I(t);
                    var n = r._malloc(M);
                    try {
                        switch (e) {
                            case D.m2:
                                g(v.getHexagonAreaAvgM2(t, n));
                                break;
                            case D.km2:
                                g(v.getHexagonAreaAvgKm2(t, n));
                                break;
                            default:
                                throw m(A, e)
                        }
                        return H(n)
                    } finally {
                        r._free(n)
                    }
                }

                function Ft(t, e) {
                    I(t);
                    var n = r._malloc(M);
                    try {
                        switch (e) {
                            case D.m:
                                g(v.getHexagonEdgeLengthAvgM(t, n));
                                break;
                            case D.km:
                                g(v.getHexagonEdgeLengthAvgKm(t, n));
                                break;
                            default:
                                throw m(A, e)
                        }
                        return H(n)
                    } finally {
                        r._free(n)
                    }
                }

                function zt(t, e) {
                    var n = N(t),
                        i = n[0],
                        a = n[1],
                        o = r._malloc(S);
                    try {
                        return g(v.cellToVertex(i, a, e, o)), O(V(o))
                    } finally {
                        r._free(o)
                    }
                }

                function Gt(t) {
                    var e = N(t),
                        n = e[0],
                        i = e[1],
                        a = r._calloc(6, S);
                    try {
                        return g(v.cellToVertexes(n, i, a)), Y(a, 6)
                    } finally {
                        r._free(a)
                    }
                }

                function jt(t) {
                    var e = r._malloc(E),
                        n = N(t),
                        i = n[0],
                        a = n[1];
                    try {
                        return g(v.vertexToLatLng(i, a, e)), K(e)
                    } finally {
                        r._free(e)
                    }
                }

                function Vt(t) {
                    var e = N(t),
                        n = e[0],
                        r = e[1];
                    return Boolean(v.isValidVertex(n, r))
                }

                function Ht(t) {
                    I(t);
                    var e = r._malloc(w);
                    try {
                        return g(v.getNumCells(t, e)), W(e)
                    } finally {
                        r._free(e)
                    }
                }

                function Wt() {
                    var t = v.res0CellCount(),
                        e = r._malloc(S * t);
                    try {
                        return g(v.getRes0Cells(e)), Y(e, t)
                    } finally {
                        r._free(e)
                    }
                }

                function Xt(t) {
                    I(t);
                    var e = v.pentagonCount(),
                        n = r._malloc(S * e);
                    try {
                        return g(v.getPentagons(t, n)), Y(n, e)
                    } finally {
                        r._free(n)
                    }
                }

                function Yt(t) {
                    return t * Math.PI / 180
                }

                function Qt(t) {
                    return 180 * t / Math.PI
                }
            },
            "./node_modules/rafor/index.js": t => {
                t.exports = function(t, e, n, r) {
                    var i = 0,
                        a = 0,
                        o = (r = r || {}).step || 1,
                        s = r.maxTimeMS || 8,
                        l = r.probeElements || 5e3;
                    setTimeout((function r() {
                        var A = Math.min(t.length, i + l),
                            c = i,
                            u = new Date;
                        for (c = i; c < A; c += o) e(t[c], c, t);
                        c < t.length ? (a += new Date - u, i = c, l = Math.round(i * s / a), setTimeout(r, 0)) : n(t)
                    }), 0)
                }
            },
            "./node_modules/yaot/index.js": (t, e, n) => {
                var r = n("./node_modules/yaot/lib/bounds3.js"),
                    i = n("./node_modules/yaot/lib/treeNode.js"),
                    a = new r,
                    o = n("./node_modules/rafor/index.js");
                t.exports = function(t) {
                    t = t || {};
                    var e, n, s = [],
                        l = {
                            initAsync: function(t, r) {
                                c(t);
                                var i = u(t);
                                o(t, (function(e, n) {
                                    i.insert(n, t, 0)
                                }), (function() {
                                    n = t, e = i, "function" == typeof r && r(l)
                                }), {
                                    step: 3
                                })
                            },
                            init: function(t) {
                                c(t), n = t, e = u(t);
                                for (var r = 0; r < t.length; r += 3) e.insert(r, n, 0)
                            },
                            bounds: function() {
                                return e ? e.bounds : a
                            },
                            intersectRay: function(t, r, i, a) {
                                if (!e) return s;
                                void 0 === i && (i = 0), void 0 === a && (a = Number.POSITIVE_INFINITY), i *= i, a *= a;
                                var o = [];
                                return e.query(o, n, (function(e) {
                                    var n, i = e.half,
                                        o = (e.x - i - t.x) / r.x,
                                        s = (e.x + i - t.x) / r.x,
                                        l = (e.y + i - t.y) / r.y,
                                        A = (e.y - i - t.y) / r.y,
                                        c = (e.z - i - t.z) / r.z,
                                        u = (e.z + i - t.z) / r.z,
                                        h = Math.min(Math.min(Math.max(o, s), Math.max(l, A)), Math.max(c, u));
                                    return !(h < 0) && (n = Math.max(Math.max(Math.min(o, s), Math.min(l, A)), Math.min(c, u))) <= h && n <= a
                                }), (function(e, n, r) {
                                    var o = (e - t.x) * (e - t.x) + (n - t.y) * (n - t.y) + (r - t.z) * (r - t.z);
                                    return i <= o && o <= a
                                })), o.sort((function(e, n) {
                                    var r = t[e],
                                        i = t[e + 1],
                                        a = t[e + 2],
                                        o = (r - t.x) * (r - t.x) + (i - t.y) * (i - t.y) + (a - t.z) * (a - t.z),
                                        s = t[n],
                                        l = t[n + 1],
                                        A = t[n + 2];
                                    return o - ((s - t.x) * (s - t.x) + (l - t.y) * (l - t.y) + (A - t.z) * (A - t.z))
                                }))
                            },
                            intersectSphere: function(t, r, i, a) {
                                if (!e) return s;
                                var o = [],
                                    l = a * a;
                                return e.query(o, n, (function(e) {
                                    var n = l,
                                        a = e.half;
                                    return t < e.x - a ? n -= A(t - (e.x - a)) : t > e.x + a && (n -= A(t - (e.x + a))), r < e.y - a ? n -= A(r - (e.y - a)) : r > e.y + a && (n -= A(r - (e.y + a))), i < e.z - a ? n -= A(i - (e.z - a)) : i > e.z + a && (n -= A(i - (e.z + a))), n > 0
                                }), (function(e, n, a) {
                                    return A(e - t) + A(n - r) + A(a - i) < l
                                })), o
                            },
                            getRoot: function() {
                                return e
                            }
                        };
                    return l;

                    function A(t) {
                        return t * t
                    }

                    function c(t) {
                        if (!t) throw new Error("Points array is required for quadtree to work");
                        if ("number" != typeof t.length) throw new Error("Points should be array-like object");
                        if (t.length % 3 != 0) throw new Error("Points array should consist of series of x,y,z coordinates and be multiple of 3")
                    }

                    function u(t) {
                        if (0 === t.length) {
                            var e = new r;
                            return new i(e)
                        }
                        for (var n = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY, A = Number.NEGATIVE_INFINITY, c = 0; c < t.length; c += 3) {
                            var u = t[c],
                                h = t[c + 1],
                                d = t[c + 2];
                            u < n && (n = u), u > s && (s = u), h < a && (a = h), h > l && (l = h), d < o && (o = d), d > A && (A = d)
                        }
                        var f = Math.max(Math.max(s - n, l - a), A - o),
                            p = (f += 2) / 2,
                            m = new r((n -= 1) + p, (a -= 1) + p, (o -= 1) + p, p);
                        return new i(m)
                    }
                }
            },
            "./node_modules/yaot/lib/bounds3.js": t => {
                function e(t, e, n, r) {
                    this.x = "number" == typeof t ? t : 0, this.y = "number" == typeof e ? e : 0, this.z = "number" == typeof n ? n : 0, this.half = "number" == typeof r ? r : 0
                }
                t.exports = e, e.prototype.contains = function(t, e, n) {
                    var r = this.half;
                    return this.x - r <= t && t < this.x + r && this.y - r <= e && e < this.y + r && this.z - r <= n && n < this.z + r
                }
            },
            "./node_modules/yaot/lib/treeNode.js": (t, e, n) => {
                var r = n("./node_modules/yaot/lib/bounds3.js");

                function i(t) {
                    this.bounds = t, this.q0 = null, this.q1 = null, this.q2 = null, this.q3 = null, this.q4 = null, this.q5 = null, this.q6 = null, this.q7 = null, this.items = null
                }
                t.exports = i, i.prototype.subdivide = function() {
                    var t = this.bounds,
                        e = t.half / 2;
                    this.q0 = new i(new r(t.x - e, t.y - e, t.z - e, e)), this.q1 = new i(new r(t.x + e, t.y - e, t.z - e, e)), this.q2 = new i(new r(t.x - e, t.y + e, t.z - e, e)), this.q3 = new i(new r(t.x + e, t.y + e, t.z - e, e)), this.q4 = new i(new r(t.x - e, t.y - e, t.z + e, e)), this.q5 = new i(new r(t.x + e, t.y - e, t.z + e, e)), this.q6 = new i(new r(t.x - e, t.y + e, t.z + e, e)), this.q7 = new i(new r(t.x + e, t.y + e, t.z + e, e))
                }, i.prototype.insert = function(t, e, n) {
                    if (null === this.q0) {
                        if (null === this.items ? this.items = [t] : this.items.push(t), this.items.length >= 4 && n < 16) {
                            this.subdivide();
                            for (var r = 0; r < this.items.length; ++r) this.insert(this.items[r], e, n + 1);
                            this.items = null
                        }
                    } else {
                        var i = e[t],
                            a = e[t + 1],
                            o = e[t + 2],
                            s = this.bounds,
                            l = 0;
                        i > s.x && (l += 1), a > s.y && (l += 2), o > s.z && (l += 4);
                        var A = function(t, e) {
                            return 0 === e ? t.q0 : 1 === e ? t.q1 : 2 === e ? t.q2 : 3 === e ? t.q3 : 4 === e ? t.q4 : 5 === e ? t.q5 : 6 === e ? t.q6 : 7 === e ? t.q7 : void 0
                        }(this, l);
                        A.insert(t, e, n + 1)
                    }
                }, i.prototype.query = function(t, e, n, r) {
                    if (n(this.bounds)) {
                        var i = this.items,
                            a = "function" == typeof r;
                        if (i)
                            for (var o = 0; o < i.length; ++o) {
                                var s = i[o];
                                a ? r(e[s], e[s + 1], e[s + 2]) && t.push(s) : t.push(s)
                            }
                        this.q0 && (this.q0.query(t, e, n, r), this.q1.query(t, e, n, r), this.q2.query(t, e, n, r), this.q3.query(t, e, n, r), this.q4.query(t, e, n, r), this.q5.query(t, e, n, r), this.q6.query(t, e, n, r), this.q7.query(t, e, n, r))
                    }
                }
            },
            "./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/@turf/invariant/dist/es/index.js");

                function i(t, e, n) {
                    if (void 0 === n && (n = {}), !t) throw new Error("point is required");
                    if (!e) throw new Error("polygon is required");
                    var i = (0, r.getCoord)(t),
                        o = (0, r.getGeom)(e),
                        s = o.type,
                        l = e.bbox,
                        A = o.coordinates;
                    if (l && !1 === function(t, e) {
                            return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1]
                        }(i, l)) return !1;
                    "Polygon" === s && (A = [A]);
                    for (var c = !1, u = 0; u < A.length && !c; u++)
                        if (a(i, A[u][0], n.ignoreBoundary)) {
                            for (var h = !1, d = 1; d < A[u].length && !h;) a(i, A[u][d], !n.ignoreBoundary) && (h = !0), d++;
                            h || (c = !0)
                        } return c
                }

                function a(t, e, n) {
                    var r = !1;
                    e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));
                    for (var i = 0, a = e.length - 1; i < e.length; a = i++) {
                        var o = e[i][0],
                            s = e[i][1],
                            l = e[a][0],
                            A = e[a][1];
                        if (t[1] * (o - l) + s * (l - t[0]) + A * (t[0] - o) == 0 && (o - t[0]) * (l - t[0]) <= 0 && (s - t[1]) * (A - t[1]) <= 0) return !n;
                        s > t[1] != A > t[1] && t[0] < (l - o) * (t[1] - s) / (A - s) + o && (r = !r)
                    }
                    return r
                }
            },
            "./node_modules/@turf/helpers/dist/es/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    areaFactors: () => o,
                    bearingToAzimuth: () => w,
                    convertArea: () => C,
                    convertLength: () => T,
                    degreesToRadians: () => E,
                    earthRadius: () => r,
                    factors: () => i,
                    feature: () => s,
                    featureCollection: () => p,
                    geometry: () => l,
                    geometryCollection: () => _,
                    isNumber: () => R,
                    isObject: () => P,
                    lengthToDegrees: () => M,
                    lengthToRadians: () => b,
                    lineString: () => d,
                    lineStrings: () => f,
                    multiLineString: () => m,
                    multiPoint: () => g,
                    multiPolygon: () => v,
                    point: () => A,
                    points: () => c,
                    polygon: () => u,
                    polygons: () => h,
                    radiansToDegrees: () => S,
                    radiansToLength: () => x,
                    round: () => y,
                    unitsFactors: () => a,
                    validateBBox: () => L,
                    validateId: () => D
                });
                var r = 6371008.8,
                    i = {
                        centimeters: 100 * r,
                        centimetres: 100 * r,
                        degrees: r / 111325,
                        feet: 3.28084 * r,
                        inches: 39.37 * r,
                        kilometers: r / 1e3,
                        kilometres: r / 1e3,
                        meters: r,
                        metres: r,
                        miles: r / 1609.344,
                        millimeters: 1e3 * r,
                        millimetres: 1e3 * r,
                        nauticalmiles: r / 1852,
                        radians: 1,
                        yards: 1.0936 * r
                    },
                    a = {
                        centimeters: 100,
                        centimetres: 100,
                        degrees: 1 / 111325,
                        feet: 3.28084,
                        inches: 39.37,
                        kilometers: .001,
                        kilometres: .001,
                        meters: 1,
                        metres: 1,
                        miles: 1 / 1609.344,
                        millimeters: 1e3,
                        millimetres: 1e3,
                        nauticalmiles: 1 / 1852,
                        radians: 1 / r,
                        yards: 1.0936133
                    },
                    o = {
                        acres: 247105e-9,
                        centimeters: 1e4,
                        centimetres: 1e4,
                        feet: 10.763910417,
                        hectares: 1e-4,
                        inches: 1550.003100006,
                        kilometers: 1e-6,
                        kilometres: 1e-6,
                        meters: 1,
                        metres: 1,
                        miles: 386e-9,
                        millimeters: 1e6,
                        millimetres: 1e6,
                        yards: 1.195990046
                    };

                function s(t, e, n) {
                    void 0 === n && (n = {});
                    var r = {
                        type: "Feature"
                    };
                    return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r
                }

                function l(t, e, n) {
                    switch (void 0 === n && (n = {}), t) {
                        case "Point":
                            return A(e).geometry;
                        case "LineString":
                            return d(e).geometry;
                        case "Polygon":
                            return u(e).geometry;
                        case "MultiPoint":
                            return g(e).geometry;
                        case "MultiLineString":
                            return m(e).geometry;
                        case "MultiPolygon":
                            return v(e).geometry;
                        default:
                            throw new Error(t + " is invalid")
                    }
                }

                function A(t, e, n) {
                    if (void 0 === n && (n = {}), !t) throw new Error("coordinates is required");
                    if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
                    if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long");
                    if (!R(t[0]) || !R(t[1])) throw new Error("coordinates must contain numbers");
                    return s({
                        type: "Point",
                        coordinates: t
                    }, e, n)
                }

                function c(t, e, n) {
                    return void 0 === n && (n = {}), p(t.map((function(t) {
                        return A(t, e)
                    })), n)
                }

                function u(t, e, n) {
                    void 0 === n && (n = {});
                    for (var r = 0, i = t; r < i.length; r++) {
                        var a = i[r];
                        if (a.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                        for (var o = 0; o < a[a.length - 1].length; o++)
                            if (a[a.length - 1][o] !== a[0][o]) throw new Error("First and last Position are not equivalent.")
                    }
                    return s({
                        type: "Polygon",
                        coordinates: t
                    }, e, n)
                }

                function h(t, e, n) {
                    return void 0 === n && (n = {}), p(t.map((function(t) {
                        return u(t, e)
                    })), n)
                }

                function d(t, e, n) {
                    if (void 0 === n && (n = {}), t.length < 2) throw new Error("coordinates must be an array of two or more positions");
                    return s({
                        type: "LineString",
                        coordinates: t
                    }, e, n)
                }

                function f(t, e, n) {
                    return void 0 === n && (n = {}), p(t.map((function(t) {
                        return d(t, e)
                    })), n)
                }

                function p(t, e) {
                    void 0 === e && (e = {});
                    var n = {
                        type: "FeatureCollection"
                    };
                    return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
                }

                function m(t, e, n) {
                    return void 0 === n && (n = {}), s({
                        type: "MultiLineString",
                        coordinates: t
                    }, e, n)
                }

                function g(t, e, n) {
                    return void 0 === n && (n = {}), s({
                        type: "MultiPoint",
                        coordinates: t
                    }, e, n)
                }

                function v(t, e, n) {
                    return void 0 === n && (n = {}), s({
                        type: "MultiPolygon",
                        coordinates: t
                    }, e, n)
                }

                function _(t, e, n) {
                    return void 0 === n && (n = {}), s({
                        type: "GeometryCollection",
                        geometries: t
                    }, e, n)
                }

                function y(t, e) {
                    if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error("precision must be a positive number");
                    var n = Math.pow(10, e || 0);
                    return Math.round(t * n) / n
                }

                function x(t, e) {
                    void 0 === e && (e = "kilometers");
                    var n = i[e];
                    if (!n) throw new Error(e + " units is invalid");
                    return t * n
                }

                function b(t, e) {
                    void 0 === e && (e = "kilometers");
                    var n = i[e];
                    if (!n) throw new Error(e + " units is invalid");
                    return t / n
                }

                function M(t, e) {
                    return S(b(t, e))
                }

                function w(t) {
                    var e = t % 360;
                    return e < 0 && (e += 360), e
                }

                function S(t) {
                    return t % (2 * Math.PI) * 180 / Math.PI
                }

                function E(t) {
                    return t % 360 * Math.PI / 180
                }

                function T(t, e, n) {
                    if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("length must be a positive number");
                    return x(b(t, e), n)
                }

                function C(t, e, n) {
                    if (void 0 === e && (e = "meters"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("area must be a positive number");
                    var r = o[e];
                    if (!r) throw new Error("invalid original units");
                    var i = o[n];
                    if (!i) throw new Error("invalid final units");
                    return t / r * i
                }

                function R(t) {
                    return !isNaN(t) && null !== t && !Array.isArray(t)
                }

                function P(t) {
                    return !!t && t.constructor === Object
                }

                function L(t) {
                    if (!t) throw new Error("bbox is required");
                    if (!Array.isArray(t)) throw new Error("bbox must be an Array");
                    if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers");
                    t.forEach((function(t) {
                        if (!R(t)) throw new Error("bbox must only contain numbers")
                    }))
                }

                function D(t) {
                    if (!t) throw new Error("id is required");
                    if (-1 === ["string", "number"].indexOf(typeof t)) throw new Error("id must be a number or a string")
                }
            },
            "./node_modules/@turf/invariant/dist/es/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    collectionOf: () => A,
                    containsNumber: () => o,
                    featureOf: () => l,
                    geojsonType: () => s,
                    getCoord: () => i,
                    getCoords: () => a,
                    getGeom: () => c,
                    getType: () => u
                });
                var r = n("./node_modules/@turf/helpers/dist/es/index.js");

                function i(t) {
                    if (!t) throw new Error("coord is required");
                    if (!Array.isArray(t)) {
                        if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type) return t.geometry.coordinates;
                        if ("Point" === t.type) return t.coordinates
                    }
                    if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return t;
                    throw new Error("coord must be GeoJSON Point or an Array of numbers")
                }

                function a(t) {
                    if (Array.isArray(t)) return t;
                    if ("Feature" === t.type) {
                        if (null !== t.geometry) return t.geometry.coordinates
                    } else if (t.coordinates) return t.coordinates;
                    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
                }

                function o(t) {
                    if (t.length > 1 && (0, r.isNumber)(t[0]) && (0, r.isNumber)(t[1])) return !0;
                    if (Array.isArray(t[0]) && t[0].length) return o(t[0]);
                    throw new Error("coordinates must only contain numbers")
                }

                function s(t, e, n) {
                    if (!e || !n) throw new Error("type and name required");
                    if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
                }

                function l(t, e, n) {
                    if (!t) throw new Error("No feature passed");
                    if (!n) throw new Error(".featureOf() requires a name");
                    if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
                    if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
                }

                function A(t, e, n) {
                    if (!t) throw new Error("No featureCollection passed");
                    if (!n) throw new Error(".collectionOf() requires a name");
                    if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required");
                    for (var r = 0, i = t.features; r < i.length; r++) {
                        var a = i[r];
                        if (!a || "Feature" !== a.type || !a.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
                        if (!a.geometry || a.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + a.geometry.type)
                    }
                }

                function c(t) {
                    return "Feature" === t.type ? t.geometry : t
                }

                function u(t, e) {
                    return "FeatureCollection" === t.type ? "FeatureCollection" : "GeometryCollection" === t.type ? "GeometryCollection" : "Feature" === t.type && null !== t.geometry ? t.geometry.type : t.type
                }
            },
            "./node_modules/@tweenjs/tween.js/dist/tween.esm.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    Easing: () => i,
                    Group: () => o,
                    Interpolation: () => s,
                    Sequence: () => l,
                    Tween: () => c,
                    VERSION: () => u,
                    add: () => m,
                    default: () => _,
                    getAll: () => f,
                    nextId: () => h,
                    now: () => a,
                    remove: () => g,
                    removeAll: () => p,
                    update: () => v
                });
                var r, i = Object.freeze({
                        Linear: Object.freeze({
                            None: function(t) {
                                return t
                            },
                            In: function(t) {
                                return this.None(t)
                            },
                            Out: function(t) {
                                return this.None(t)
                            },
                            InOut: function(t) {
                                return this.None(t)
                            }
                        }),
                        Quadratic: Object.freeze({
                            In: function(t) {
                                return t * t
                            },
                            Out: function(t) {
                                return t * (2 - t)
                            },
                            InOut: function(t) {
                                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                            }
                        }),
                        Cubic: Object.freeze({
                            In: function(t) {
                                return t * t * t
                            },
                            Out: function(t) {
                                return --t * t * t + 1
                            },
                            InOut: function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                            }
                        }),
                        Quartic: Object.freeze({
                            In: function(t) {
                                return t * t * t * t
                            },
                            Out: function(t) {
                                return 1 - --t * t * t * t
                            },
                            InOut: function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                            }
                        }),
                        Quintic: Object.freeze({
                            In: function(t) {
                                return t * t * t * t * t
                            },
                            Out: function(t) {
                                return --t * t * t * t * t + 1
                            },
                            InOut: function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                            }
                        }),
                        Sinusoidal: Object.freeze({
                            In: function(t) {
                                return 1 - Math.sin((1 - t) * Math.PI / 2)
                            },
                            Out: function(t) {
                                return Math.sin(t * Math.PI / 2)
                            },
                            InOut: function(t) {
                                return .5 * (1 - Math.sin(Math.PI * (.5 - t)))
                            }
                        }),
                        Exponential: Object.freeze({
                            In: function(t) {
                                return 0 === t ? 0 : Math.pow(1024, t - 1)
                            },
                            Out: function(t) {
                                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                            },
                            InOut: function(t) {
                                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                            }
                        }),
                        Circular: Object.freeze({
                            In: function(t) {
                                return 1 - Math.sqrt(1 - t * t)
                            },
                            Out: function(t) {
                                return Math.sqrt(1 - --t * t)
                            },
                            InOut: function(t) {
                                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                            }
                        }),
                        Elastic: Object.freeze({
                            In: function(t) {
                                return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
                            },
                            Out: function(t) {
                                return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1
                            },
                            InOut: function(t) {
                                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1
                            }
                        }),
                        Back: Object.freeze({
                            In: function(t) {
                                var e = 1.70158;
                                return 1 === t ? 1 : t * t * ((e + 1) * t - e)
                            },
                            Out: function(t) {
                                var e = 1.70158;
                                return 0 === t ? 0 : --t * t * ((e + 1) * t + e) + 1
                            },
                            InOut: function(t) {
                                var e = 2.5949095;
                                return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                            }
                        }),
                        Bounce: Object.freeze({
                            In: function(t) {
                                return 1 - i.Bounce.Out(1 - t)
                            },
                            Out: function(t) {
                                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                            },
                            InOut: function(t) {
                                return t < .5 ? .5 * i.Bounce.In(2 * t) : .5 * i.Bounce.Out(2 * t - 1) + .5
                            }
                        }),
                        generatePow: function(t) {
                            return void 0 === t && (t = 4), t = (t = t < Number.EPSILON ? Number.EPSILON : t) > 1e4 ? 1e4 : t, {
                                In: function(e) {
                                    return Math.pow(e, t)
                                },
                                Out: function(e) {
                                    return 1 - Math.pow(1 - e, t)
                                },
                                InOut: function(e) {
                                    return e < .5 ? Math.pow(2 * e, t) / 2 : (1 - Math.pow(2 - 2 * e, t)) / 2 + .5
                                }
                            }
                        }
                    }),
                    a = function() {
                        return performance.now()
                    },
                    o = function() {
                        function t() {
                            this._tweens = {}, this._tweensAddedDuringUpdate = {}
                        }
                        return t.prototype.getAll = function() {
                            var t = this;
                            return Object.keys(this._tweens).map((function(e) {
                                return t._tweens[e]
                            }))
                        }, t.prototype.removeAll = function() {
                            this._tweens = {}
                        }, t.prototype.add = function(t) {
                            this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t
                        }, t.prototype.remove = function(t) {
                            delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()]
                        }, t.prototype.update = function(t, e) {
                            void 0 === t && (t = a()), void 0 === e && (e = !1);
                            var n = Object.keys(this._tweens);
                            if (0 === n.length) return !1;
                            for (; n.length > 0;) {
                                this._tweensAddedDuringUpdate = {};
                                for (var r = 0; r < n.length; r++) {
                                    var i = this._tweens[n[r]],
                                        o = !e;
                                    i && !1 === i.update(t, o) && !e && delete this._tweens[n[r]]
                                }
                                n = Object.keys(this._tweensAddedDuringUpdate)
                            }
                            return !0
                        }, t
                    }(),
                    s = {
                        Linear: function(t, e) {
                            var n = t.length - 1,
                                r = n * e,
                                i = Math.floor(r),
                                a = s.Utils.Linear;
                            return e < 0 ? a(t[0], t[1], r) : e > 1 ? a(t[n], t[n - 1], n - r) : a(t[i], t[i + 1 > n ? n : i + 1], r - i)
                        },
                        Bezier: function(t, e) {
                            for (var n = 0, r = t.length - 1, i = Math.pow, a = s.Utils.Bernstein, o = 0; o <= r; o++) n += i(1 - e, r - o) * i(e, o) * t[o] * a(r, o);
                            return n
                        },
                        CatmullRom: function(t, e) {
                            var n = t.length - 1,
                                r = n * e,
                                i = Math.floor(r),
                                a = s.Utils.CatmullRom;
                            return t[0] === t[n] ? (e < 0 && (i = Math.floor(r = n * (1 + e))), a(t[(i - 1 + n) % n], t[i], t[(i + 1) % n], t[(i + 2) % n], r - i)) : e < 0 ? t[0] - (a(t[0], t[0], t[1], t[1], -r) - t[0]) : e > 1 ? t[n] - (a(t[n], t[n], t[n - 1], t[n - 1], r - n) - t[n]) : a(t[i ? i - 1 : 0], t[i], t[n < i + 1 ? n : i + 1], t[n < i + 2 ? n : i + 2], r - i)
                        },
                        Utils: {
                            Linear: function(t, e, n) {
                                return (e - t) * n + t
                            },
                            Bernstein: function(t, e) {
                                var n = s.Utils.Factorial;
                                return n(t) / n(e) / n(t - e)
                            },
                            Factorial: (r = [1], function(t) {
                                var e = 1;
                                if (r[t]) return r[t];
                                for (var n = t; n > 1; n--) e *= n;
                                return r[t] = e, e
                            }),
                            CatmullRom: function(t, e, n, r, i) {
                                var a = .5 * (n - t),
                                    o = .5 * (r - e),
                                    s = i * i;
                                return (2 * e - 2 * n + a + o) * (i * s) + (-3 * e + 3 * n - 2 * a - o) * s + a * i + e
                            }
                        }
                    },
                    l = function() {
                        function t() {}
                        return t.nextId = function() {
                            return t._nextId++
                        }, t._nextId = 0, t
                    }(),
                    A = new o,
                    c = function() {
                        function t(t, e) {
                            void 0 === e && (e = A), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = i.Linear.None, this._interpolationFunction = s.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = l.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1
                        }
                        return t.prototype.getId = function() {
                            return this._id
                        }, t.prototype.isPlaying = function() {
                            return this._isPlaying
                        }, t.prototype.isPaused = function() {
                            return this._isPaused
                        }, t.prototype.getDuration = function() {
                            return this._duration
                        }, t.prototype.to = function(t, e) {
                            if (void 0 === e && (e = 1e3), this._isPlaying) throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
                            return this._valuesEnd = t, this._propertiesAreSetUp = !1, this._duration = e < 0 ? 0 : e, this
                        }, t.prototype.duration = function(t) {
                            return void 0 === t && (t = 1e3), this._duration = t < 0 ? 0 : t, this
                        }, t.prototype.dynamic = function(t) {
                            return void 0 === t && (t = !1), this._isDynamic = t, this
                        }, t.prototype.start = function(t, e) {
                            if (void 0 === t && (t = a()), void 0 === e && (e = !1), this._isPlaying) return this;
                            if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed)
                                for (var n in this._reversed = !1, this._valuesStartRepeat) this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
                            if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
                                if (this._propertiesAreSetUp = !0, !this._isDynamic) {
                                    var r = {};
                                    for (var i in this._valuesEnd) r[i] = this._valuesEnd[i];
                                    this._valuesEnd = r
                                }
                                this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e)
                            }
                            return this
                        }, t.prototype.startFromCurrentValues = function(t) {
                            return this.start(t, !0)
                        }, t.prototype._setupProperties = function(t, e, n, r, i) {
                            for (var a in n) {
                                var o = t[a],
                                    s = Array.isArray(o),
                                    l = s ? "array" : typeof o,
                                    A = !s && Array.isArray(n[a]);
                                if ("undefined" !== l && "function" !== l) {
                                    if (A) {
                                        if (0 === (m = n[a]).length) continue;
                                        for (var c = [o], u = 0, h = m.length; u < h; u += 1) {
                                            var d = this._handleRelativeValue(o, m[u]);
                                            if (isNaN(d)) {
                                                A = !1, console.warn("Found invalid interpolation list. Skipping.");
                                                break
                                            }
                                            c.push(d)
                                        }
                                        A && (n[a] = c)
                                    }
                                    if ("object" !== l && !s || !o || A)(void 0 === e[a] || i) && (e[a] = o), s || (e[a] *= 1), r[a] = A ? n[a].slice().reverse() : e[a] || 0;
                                    else {
                                        e[a] = s ? [] : {};
                                        var f = o;
                                        for (var p in f) e[a][p] = f[p];
                                        r[a] = s ? [] : {};
                                        var m = n[a];
                                        if (!this._isDynamic) {
                                            var g = {};
                                            for (var p in m) g[p] = m[p];
                                            n[a] = m = g
                                        }
                                        this._setupProperties(f, e[a], m, r[a], i)
                                    }
                                }
                            }
                        }, t.prototype.stop = function() {
                            return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this
                        }, t.prototype.end = function() {
                            return this._goToEnd = !0, this.update(1 / 0), this
                        }, t.prototype.pause = function(t) {
                            return void 0 === t && (t = a()), this._isPaused || !this._isPlaying || (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this)), this
                        }, t.prototype.resume = function(t) {
                            return void 0 === t && (t = a()), this._isPaused && this._isPlaying ? (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this) : this
                        }, t.prototype.stopChainedTweens = function() {
                            for (var t = 0, e = this._chainedTweens.length; t < e; t++) this._chainedTweens[t].stop();
                            return this
                        }, t.prototype.group = function(t) {
                            return void 0 === t && (t = A), this._group = t, this
                        }, t.prototype.delay = function(t) {
                            return void 0 === t && (t = 0), this._delayTime = t, this
                        }, t.prototype.repeat = function(t) {
                            return void 0 === t && (t = 0), this._initialRepeat = t, this._repeat = t, this
                        }, t.prototype.repeatDelay = function(t) {
                            return this._repeatDelayTime = t, this
                        }, t.prototype.yoyo = function(t) {
                            return void 0 === t && (t = !1), this._yoyo = t, this
                        }, t.prototype.easing = function(t) {
                            return void 0 === t && (t = i.Linear.None), this._easingFunction = t, this
                        }, t.prototype.interpolation = function(t) {
                            return void 0 === t && (t = s.Linear), this._interpolationFunction = t, this
                        }, t.prototype.chain = function() {
                            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                            return this._chainedTweens = t, this
                        }, t.prototype.onStart = function(t) {
                            return this._onStartCallback = t, this
                        }, t.prototype.onEveryStart = function(t) {
                            return this._onEveryStartCallback = t, this
                        }, t.prototype.onUpdate = function(t) {
                            return this._onUpdateCallback = t, this
                        }, t.prototype.onRepeat = function(t) {
                            return this._onRepeatCallback = t, this
                        }, t.prototype.onComplete = function(t) {
                            return this._onCompleteCallback = t, this
                        }, t.prototype.onStop = function(t) {
                            return this._onStopCallback = t, this
                        }, t.prototype.update = function(t, e) {
                            var n, r, i = this;
                            if (void 0 === t && (t = a()), void 0 === e && (e = !0), this._isPaused) return !0;
                            var o = this._startTime + this._duration;
                            if (!this._goToEnd && !this._isPlaying) {
                                if (t > o) return !1;
                                e && this.start(t, !0)
                            }
                            if (this._goToEnd = !1, t < this._startTime) return !0;
                            !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), !1 === this._onEveryStartCallbackFired && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
                            var s = t - this._startTime,
                                l = this._duration + (null !== (n = this._repeatDelayTime) && void 0 !== n ? n : this._delayTime),
                                A = this._duration + this._repeat * l,
                                c = function() {
                                    if (0 === i._duration) return 1;
                                    if (s > A) return 1;
                                    var t = Math.trunc(s / l),
                                        e = s - t * l,
                                        n = Math.min(e / i._duration, 1);
                                    return 0 === n && s === i._duration ? 1 : n
                                }(),
                                u = this._easingFunction(c);
                            if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, u), this._onUpdateCallback && this._onUpdateCallback(this._object, c), 0 === this._duration || s >= this._duration) {
                                if (this._repeat > 0) {
                                    var h = Math.min(Math.trunc((s - this._duration) / l) + 1, this._repeat);
                                    for (r in isFinite(this._repeat) && (this._repeat -= h), this._valuesStartRepeat) this._yoyo || "string" != typeof this._valuesEnd[r] || (this._valuesStartRepeat[r] = this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];
                                    return this._yoyo && (this._reversed = !this._reversed), this._startTime += l * h, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0
                                }
                                this._onCompleteCallback && this._onCompleteCallback(this._object);
                                for (var d = 0, f = this._chainedTweens.length; d < f; d++) this._chainedTweens[d].start(this._startTime + this._duration, !1);
                                return this._isPlaying = !1, !1
                            }
                            return !0
                        }, t.prototype._updateProperties = function(t, e, n, r) {
                            for (var i in n)
                                if (void 0 !== e[i]) {
                                    var a = e[i] || 0,
                                        o = n[i],
                                        s = Array.isArray(t[i]),
                                        l = Array.isArray(o);
                                    !s && l ? t[i] = this._interpolationFunction(o, r) : "object" == typeof o && o ? this._updateProperties(t[i], a, o, r) : "number" == typeof(o = this._handleRelativeValue(a, o)) && (t[i] = a + (o - a) * r)
                                }
                        }, t.prototype._handleRelativeValue = function(t, e) {
                            return "string" != typeof e ? e : "+" === e.charAt(0) || "-" === e.charAt(0) ? t + parseFloat(e) : parseFloat(e)
                        }, t.prototype._swapEndStartRepeatValues = function(t) {
                            var e = this._valuesStartRepeat[t],
                                n = this._valuesEnd[t];
                            this._valuesStartRepeat[t] = "string" == typeof n ? this._valuesStartRepeat[t] + parseFloat(n) : this._valuesEnd[t], this._valuesEnd[t] = e
                        }, t
                    }(),
                    u = "23.1.1",
                    h = l.nextId,
                    d = A,
                    f = d.getAll.bind(d),
                    p = d.removeAll.bind(d),
                    m = d.add.bind(d),
                    g = d.remove.bind(d),
                    v = d.update.bind(d),
                    _ = {
                        Easing: i,
                        Group: o,
                        Interpolation: s,
                        now: a,
                        Sequence: l,
                        nextId: h,
                        Tween: c,
                        VERSION: u,
                        getAll: f,
                        removeAll: p,
                        add: m,
                        remove: g,
                        update: v
                    }
            },
            "./node_modules/accessor-fn/dist/accessor-fn.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                var r = function(t) {
                    return "function" == typeof t ? t : "string" == typeof t ? function(e) {
                        return e[t]
                    } : function(e) {
                        return t
                    }
                }
            },
            "./node_modules/d3-array/src/ascending.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    return null == t || null == e ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/bisect.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    bisectCenter: () => A,
                    bisectLeft: () => l,
                    bisectRight: () => s,
                    default: () => c
                });
                var r = n("./node_modules/d3-array/src/ascending.js"),
                    i = n("./node_modules/d3-array/src/bisector.js"),
                    a = n("./node_modules/d3-array/src/number.js");
                const o = (0, i.default)(r.default),
                    s = o.right,
                    l = o.left,
                    A = (0, i.default)(a.default).center,
                    c = s
            },
            "./node_modules/d3-array/src/bisector.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a
                });
                var r = n("./node_modules/d3-array/src/ascending.js"),
                    i = n("./node_modules/d3-array/src/descending.js");

                function a(t) {
                    let e, n, a;

                    function s(t, r, i = 0, a = t.length) {
                        if (i < a) {
                            if (0 !== e(r, r)) return a;
                            do {
                                const e = i + a >>> 1;
                                n(t[e], r) < 0 ? i = e + 1 : a = e
                            } while (i < a)
                        }
                        return i
                    }
                    return 2 !== t.length ? (e = r.default, n = (e, n) => (0, r.default)(t(e), n), a = (e, n) => t(e) - n) : (e = t === r.default || t === i.default ? t : o, n = t, a = t), {
                        left: s,
                        center: function(t, e, n = 0, r = t.length) {
                            const i = s(t, e, n, r - 1);
                            return i > n && a(t[i - 1], e) > -a(t[i], e) ? i - 1 : i
                        },
                        right: function(t, r, i = 0, a = t.length) {
                            if (i < a) {
                                if (0 !== e(r, r)) return a;
                                do {
                                    const e = i + a >>> 1;
                                    n(t[e], r) <= 0 ? i = e + 1 : a = e
                                } while (i < a)
                            }
                            return i
                        }
                    }
                }

                function o() {
                    return 0
                }
            },
            "./node_modules/d3-array/src/descending.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    return null == t || null == e ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/extent.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    let n, r;
                    if (void 0 === e)
                        for (const e of t) null != e && (void 0 === n ? e >= e && (n = r = e) : (n > e && (n = e), r < e && (r = e)));
                    else {
                        let i = -1;
                        for (let a of t) null != (a = e(a, ++i, t)) && (void 0 === n ? a >= a && (n = r = a) : (n > a && (n = a), r < a && (r = a)))
                    }
                    return [n, r]
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/fsum.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    Adder: () => r,
                    fcumsum: () => a,
                    fsum: () => i
                });
                class r {
                    constructor() {
                        this._partials = new Float64Array(32), this._n = 0
                    }
                    add(t) {
                        const e = this._partials;
                        let n = 0;
                        for (let r = 0; r < this._n && r < 32; r++) {
                            const i = e[r],
                                a = t + i,
                                o = Math.abs(t) < Math.abs(i) ? t - (a - i) : i - (a - t);
                            o && (e[n++] = o), t = a
                        }
                        return e[n] = t, this._n = n + 1, this
                    }
                    valueOf() {
                        const t = this._partials;
                        let e, n, r, i = this._n,
                            a = 0;
                        if (i > 0) {
                            for (a = t[--i]; i > 0 && (e = a, n = t[--i], a = e + n, r = n - (a - e), !r););
                            i > 0 && (r < 0 && t[i - 1] < 0 || r > 0 && t[i - 1] > 0) && (n = 2 * r, e = a + n, n == e - a && (a = e))
                        }
                        return a
                    }
                }

                function i(t, e) {
                    const n = new r;
                    if (void 0 === e)
                        for (let e of t)(e = +e) && n.add(e);
                    else {
                        let r = -1;
                        for (let i of t)(i = +e(i, ++r, t)) && n.add(i)
                    }
                    return +n
                }

                function a(t, e) {
                    const n = new r;
                    let i = -1;
                    return Float64Array.from(t, void 0 === e ? t => n.add(+t || 0) : r => n.add(+e(r, ++i, t) || 0))
                }
            },
            "./node_modules/d3-array/src/max.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    let n;
                    if (void 0 === e)
                        for (const e of t) null != e && (n < e || void 0 === n && e >= e) && (n = e);
                    else {
                        let r = -1;
                        for (let i of t) null != (i = e(i, ++r, t)) && (n < i || void 0 === n && i >= i) && (n = i)
                    }
                    return n
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/mean.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    let n = 0,
                        r = 0;
                    if (void 0 === e)
                        for (let e of t) null != e && (e = +e) >= e && (++n, r += e);
                    else {
                        let i = -1;
                        for (let a of t) null != (a = e(a, ++i, t)) && (a = +a) >= a && (++n, r += a)
                    }
                    if (n) return r / n
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/merge.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return Array.from(function*(t) {
                        for (const e of t) yield* e
                    }(t))
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/number.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return null === t ? NaN : +t
                }

                function* i(t, e) {
                    if (void 0 === e)
                        for (let e of t) null != e && (e = +e) >= e && (yield e);
                    else {
                        let n = -1;
                        for (let r of t) null != (r = e(r, ++n, t)) && (r = +r) >= r && (yield r)
                    }
                }
                n.r(e), n.d(e, {
                    default: () => r,
                    numbers: () => i
                })
            },
            "./node_modules/d3-array/src/range.js": (t, e, n) => {
                "use strict";

                function r(t, e, n) {
                    t = +t, e = +e, n = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +n;
                    for (var r = -1, i = 0 | Math.max(0, Math.ceil((e - t) / n)), a = new Array(i); ++r < i;) a[r] = t + r * n;
                    return a
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/sum.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    let n = 0;
                    if (void 0 === e)
                        for (let e of t)(e = +e) && (n += e);
                    else {
                        let r = -1;
                        for (let i of t)(i = +e(i, ++r, t)) && (n += i)
                    }
                    return n
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-array/src/ticks.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s,
                    tickIncrement: () => l,
                    tickStep: () => A
                });
                const r = Math.sqrt(50),
                    i = Math.sqrt(10),
                    a = Math.sqrt(2);

                function o(t, e, n) {
                    const s = (e - t) / Math.max(0, n),
                        l = Math.floor(Math.log10(s)),
                        A = s / Math.pow(10, l),
                        c = A >= r ? 10 : A >= i ? 5 : A >= a ? 2 : 1;
                    let u, h, d;
                    return l < 0 ? (d = Math.pow(10, -l) / c, u = Math.round(t * d), h = Math.round(e * d), u / d < t && ++u, h / d > e && --h, d = -d) : (d = Math.pow(10, l) * c, u = Math.round(t / d), h = Math.round(e / d), u * d < t && ++u, h * d > e && --h), h < u && .5 <= n && n < 2 ? o(t, e, 2 * n) : [u, h, d]
                }

                function s(t, e, n) {
                    if (!((n = +n) > 0)) return [];
                    if ((t = +t) == (e = +e)) return [t];
                    const r = e < t,
                        [i, a, s] = r ? o(e, t, n) : o(t, e, n);
                    if (!(a >= i)) return [];
                    const l = a - i + 1,
                        A = new Array(l);
                    if (r)
                        if (s < 0)
                            for (let t = 0; t < l; ++t) A[t] = (a - t) / -s;
                        else
                            for (let t = 0; t < l; ++t) A[t] = (a - t) * s;
                    else if (s < 0)
                        for (let t = 0; t < l; ++t) A[t] = (i + t) / -s;
                    else
                        for (let t = 0; t < l; ++t) A[t] = (i + t) * s;
                    return A
                }

                function l(t, e, n) {
                    return o(t = +t, e = +e, n = +n)[2]
                }

                function A(t, e, n) {
                    n = +n;
                    const r = (e = +e) < (t = +t),
                        i = r ? l(e, t, n) : l(t, e, n);
                    return (r ? -1 : 1) * (i < 0 ? 1 / -i : i)
                }
            },
            "./node_modules/d3-color/src/color.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    Color: () => i,
                    Rgb: () => S,
                    brighter: () => o,
                    darker: () => a,
                    default: () => y,
                    hsl: () => I,
                    hslConvert: () => D,
                    rgb: () => w,
                    rgbConvert: () => M
                });
                var r = n("./node_modules/d3-color/src/define.js");

                function i() {}
                var a = .7,
                    o = 1 / a,
                    s = "\\s*([+-]?\\d+)\\s*",
                    l = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
                    A = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
                    c = /^#([0-9a-f]{3,8})$/,
                    u = new RegExp(`^rgb\\(${s},${s},${s}\\)$`),
                    h = new RegExp(`^rgb\\(${A},${A},${A}\\)$`),
                    d = new RegExp(`^rgba\\(${s},${s},${s},${l}\\)$`),
                    f = new RegExp(`^rgba\\(${A},${A},${A},${l}\\)$`),
                    p = new RegExp(`^hsl\\(${l},${A},${A}\\)$`),
                    m = new RegExp(`^hsla\\(${l},${A},${A},${l}\\)$`),
                    g = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    };

                function v() {
                    return this.rgb().formatHex()
                }

                function _() {
                    return this.rgb().formatRgb()
                }

                function y(t) {
                    var e, n;
                    return t = (t + "").trim().toLowerCase(), (e = c.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), 6 === n ? x(e) : 3 === n ? new S(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | 240 & e, (15 & e) << 4 | 15 & e, 1) : 8 === n ? b(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (255 & e) / 255) : 4 === n ? b(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | 240 & e, ((15 & e) << 4 | 15 & e) / 255) : null) : (e = u.exec(t)) ? new S(e[1], e[2], e[3], 1) : (e = h.exec(t)) ? new S(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, 1) : (e = d.exec(t)) ? b(e[1], e[2], e[3], e[4]) : (e = f.exec(t)) ? b(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, e[4]) : (e = p.exec(t)) ? L(e[1], e[2] / 100, e[3] / 100, 1) : (e = m.exec(t)) ? L(e[1], e[2] / 100, e[3] / 100, e[4]) : g.hasOwnProperty(t) ? x(g[t]) : "transparent" === t ? new S(NaN, NaN, NaN, 0) : null
                }

                function x(t) {
                    return new S(t >> 16 & 255, t >> 8 & 255, 255 & t, 1)
                }

                function b(t, e, n, r) {
                    return r <= 0 && (t = e = n = NaN), new S(t, e, n, r)
                }

                function M(t) {
                    return t instanceof i || (t = y(t)), t ? new S((t = t.rgb()).r, t.g, t.b, t.opacity) : new S
                }

                function w(t, e, n, r) {
                    return 1 === arguments.length ? M(t) : new S(t, e, n, null == r ? 1 : r)
                }

                function S(t, e, n, r) {
                    this.r = +t, this.g = +e, this.b = +n, this.opacity = +r
                }

                function E() {
                    return `#${P(this.r)}${P(this.g)}${P(this.b)}`
                }

                function T() {
                    const t = C(this.opacity);
                    return `${1===t?"rgb(":"rgba("}${R(this.r)}, ${R(this.g)}, ${R(this.b)}${1===t?")":`, ${t})`}`
                }

                function C(t) {
                    return isNaN(t) ? 1 : Math.max(0, Math.min(1, t))
                }

                function R(t) {
                    return Math.max(0, Math.min(255, Math.round(t) || 0))
                }

                function P(t) {
                    return ((t = R(t)) < 16 ? "0" : "") + t.toString(16)
                }

                function L(t, e, n, r) {
                    return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new O(t, e, n, r)
                }

                function D(t) {
                    if (t instanceof O) return new O(t.h, t.s, t.l, t.opacity);
                    if (t instanceof i || (t = y(t)), !t) return new O;
                    if (t instanceof O) return t;
                    var e = (t = t.rgb()).r / 255,
                        n = t.g / 255,
                        r = t.b / 255,
                        a = Math.min(e, n, r),
                        o = Math.max(e, n, r),
                        s = NaN,
                        l = o - a,
                        A = (o + a) / 2;
                    return l ? (s = e === o ? (n - r) / l + 6 * (n < r) : n === o ? (r - e) / l + 2 : (e - n) / l + 4, l /= A < .5 ? o + a : 2 - o - a, s *= 60) : l = A > 0 && A < 1 ? 0 : s, new O(s, l, A, t.opacity)
                }

                function I(t, e, n, r) {
                    return 1 === arguments.length ? D(t) : new O(t, e, n, null == r ? 1 : r)
                }

                function O(t, e, n, r) {
                    this.h = +t, this.s = +e, this.l = +n, this.opacity = +r
                }

                function B(t) {
                    return (t = (t || 0) % 360) < 0 ? t + 360 : t
                }

                function q(t) {
                    return Math.max(0, Math.min(1, t || 0))
                }

                function U(t, e, n) {
                    return 255 * (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e)
                }(0, r.default)(i, y, {
                    copy(t) {
                        return Object.assign(new this.constructor, this, t)
                    },
                    displayable() {
                        return this.rgb().displayable()
                    },
                    hex: v,
                    formatHex: v,
                    formatHex8: function() {
                        return this.rgb().formatHex8()
                    },
                    formatHsl: function() {
                        return D(this).formatHsl()
                    },
                    formatRgb: _,
                    toString: _
                }), (0, r.default)(S, w, (0, r.extend)(i, {
                    brighter(t) {
                        return t = null == t ? o : Math.pow(o, t), new S(this.r * t, this.g * t, this.b * t, this.opacity)
                    },
                    darker(t) {
                        return t = null == t ? a : Math.pow(a, t), new S(this.r * t, this.g * t, this.b * t, this.opacity)
                    },
                    rgb() {
                        return this
                    },
                    clamp() {
                        return new S(R(this.r), R(this.g), R(this.b), C(this.opacity))
                    },
                    displayable() {
                        return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
                    },
                    hex: E,
                    formatHex: E,
                    formatHex8: function() {
                        return `#${P(this.r)}${P(this.g)}${P(this.b)}${P(255*(isNaN(this.opacity)?1:this.opacity))}`
                    },
                    formatRgb: T,
                    toString: T
                })), (0, r.default)(O, I, (0, r.extend)(i, {
                    brighter(t) {
                        return t = null == t ? o : Math.pow(o, t), new O(this.h, this.s, this.l * t, this.opacity)
                    },
                    darker(t) {
                        return t = null == t ? a : Math.pow(a, t), new O(this.h, this.s, this.l * t, this.opacity)
                    },
                    rgb() {
                        var t = this.h % 360 + 360 * (this.h < 0),
                            e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
                            n = this.l,
                            r = n + (n < .5 ? n : 1 - n) * e,
                            i = 2 * n - r;
                        return new S(U(t >= 240 ? t - 240 : t + 120, i, r), U(t, i, r), U(t < 120 ? t + 240 : t - 120, i, r), this.opacity)
                    },
                    clamp() {
                        return new O(B(this.h), q(this.s), q(this.l), C(this.opacity))
                    },
                    displayable() {
                        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
                    },
                    formatHsl() {
                        const t = C(this.opacity);
                        return `${1===t?"hsl(":"hsla("}${B(this.h)}, ${100*q(this.s)}%, ${100*q(this.l)}%${1===t?")":`, ${t})`}`
                    }
                }))
            },
            "./node_modules/d3-color/src/define.js": (t, e, n) => {
                "use strict";

                function r(t, e, n) {
                    t.prototype = e.prototype = n, n.constructor = t
                }

                function i(t, e) {
                    var n = Object.create(t.prototype);
                    for (var r in e) n[r] = e[r];
                    return n
                }
                n.r(e), n.d(e, {
                    default: () => r,
                    extend: () => i
                })
            },
            "./node_modules/d3-delaunay/src/delaunay.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => h
                });
                var r = n("./node_modules/delaunator/index.js"),
                    i = n("./node_modules/d3-delaunay/src/path.js"),
                    a = n("./node_modules/d3-delaunay/src/polygon.js"),
                    o = n("./node_modules/d3-delaunay/src/voronoi.js");
                const s = 2 * Math.PI,
                    l = Math.pow;

                function A(t) {
                    return t[0]
                }

                function c(t) {
                    return t[1]
                }

                function u(t, e, n) {
                    return [t + Math.sin(t + e) * n, e + Math.cos(t - e) * n]
                }
                class h {
                    static from(t, e = A, n = c, r) {
                        return new h("length" in t ? function(t, e, n, r) {
                            const i = t.length,
                                a = new Float64Array(2 * i);
                            for (let o = 0; o < i; ++o) {
                                const i = t[o];
                                a[2 * o] = e.call(r, i, o, t), a[2 * o + 1] = n.call(r, i, o, t)
                            }
                            return a
                        }(t, e, n, r) : Float64Array.from(function*(t, e, n, r) {
                            let i = 0;
                            for (const a of t) yield e.call(r, a, i, t), yield n.call(r, a, i, t), ++i
                        }(t, e, n, r)))
                    }
                    constructor(t) {
                        this._delaunator = new r.default(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
                    }
                    update() {
                        return this._delaunator.update(), this._init(), this
                    }
                    _init() {
                        const t = this._delaunator,
                            e = this.points;
                        if (t.hull && t.hull.length > 2 && function(t) {
                                const {
                                    triangles: e,
                                    coords: n
                                } = t;
                                for (let t = 0; t < e.length; t += 3) {
                                    const r = 2 * e[t],
                                        i = 2 * e[t + 1],
                                        a = 2 * e[t + 2];
                                    if ((n[a] - n[r]) * (n[i + 1] - n[r + 1]) - (n[i] - n[r]) * (n[a + 1] - n[r + 1]) > 1e-10) return !1
                                }
                                return !0
                            }(t)) {
                            this.collinear = Int32Array.from({
                                length: e.length / 2
                            }, ((t, e) => e)).sort(((t, n) => e[2 * t] - e[2 * n] || e[2 * t + 1] - e[2 * n + 1]));
                            const t = this.collinear[0],
                                n = this.collinear[this.collinear.length - 1],
                                i = [e[2 * t], e[2 * t + 1], e[2 * n], e[2 * n + 1]],
                                a = 1e-8 * Math.hypot(i[3] - i[1], i[2] - i[0]);
                            for (let t = 0, n = e.length / 2; t < n; ++t) {
                                const n = u(e[2 * t], e[2 * t + 1], a);
                                e[2 * t] = n[0], e[2 * t + 1] = n[1]
                            }
                            this._delaunator = new r.default(e)
                        } else delete this.collinear;
                        const n = this.halfedges = this._delaunator.halfedges,
                            i = this.hull = this._delaunator.hull,
                            a = this.triangles = this._delaunator.triangles,
                            o = this.inedges.fill(-1),
                            s = this._hullIndex.fill(-1);
                        for (let t = 0, e = n.length; t < e; ++t) {
                            const e = a[t % 3 == 2 ? t - 2 : t + 1]; - 1 !== n[t] && -1 !== o[e] || (o[e] = t)
                        }
                        for (let t = 0, e = i.length; t < e; ++t) s[i[t]] = t;
                        i.length <= 2 && i.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = i[0], o[i[0]] = 1, 2 === i.length && (o[i[1]] = 0, this.triangles[1] = i[1], this.triangles[2] = i[1]))
                    }
                    voronoi(t) {
                        return new o.default(this, t)
                    }* neighbors(t) {
                        const {
                            inedges: e,
                            hull: n,
                            _hullIndex: r,
                            halfedges: i,
                            triangles: a,
                            collinear: o
                        } = this;
                        if (o) {
                            const e = o.indexOf(t);
                            return e > 0 && (yield o[e - 1]), void(e < o.length - 1 && (yield o[e + 1]))
                        }
                        const s = e[t];
                        if (-1 === s) return;
                        let l = s,
                            A = -1;
                        do {
                            if (yield A = a[l], l = l % 3 == 2 ? l - 2 : l + 1, a[l] !== t) return;
                            if (l = i[l], -1 === l) {
                                const e = n[(r[t] + 1) % n.length];
                                return void(e !== A && (yield e))
                            }
                        } while (l !== s)
                    }
                    find(t, e, n = 0) {
                        if ((t = +t) != t || (e = +e) != e) return -1;
                        const r = n;
                        let i;
                        for (;
                            (i = this._step(n, t, e)) >= 0 && i !== n && i !== r;) n = i;
                        return i
                    }
                    _step(t, e, n) {
                        const {
                            inedges: r,
                            hull: i,
                            _hullIndex: a,
                            halfedges: o,
                            triangles: s,
                            points: A
                        } = this;
                        if (-1 === r[t] || !A.length) return (t + 1) % (A.length >> 1);
                        let c = t,
                            u = l(e - A[2 * t], 2) + l(n - A[2 * t + 1], 2);
                        const h = r[t];
                        let d = h;
                        do {
                            let r = s[d];
                            const h = l(e - A[2 * r], 2) + l(n - A[2 * r + 1], 2);
                            if (h < u && (u = h, c = r), d = d % 3 == 2 ? d - 2 : d + 1, s[d] !== t) break;
                            if (d = o[d], -1 === d) {
                                if (d = i[(a[t] + 1) % i.length], d !== r && l(e - A[2 * d], 2) + l(n - A[2 * d + 1], 2) < u) return d;
                                break
                            }
                        } while (d !== h);
                        return c
                    }
                    render(t) {
                        const e = null == t ? t = new i.default : void 0,
                            {
                                points: n,
                                halfedges: r,
                                triangles: a
                            } = this;
                        for (let e = 0, i = r.length; e < i; ++e) {
                            const i = r[e];
                            if (i < e) continue;
                            const o = 2 * a[e],
                                s = 2 * a[i];
                            t.moveTo(n[o], n[o + 1]), t.lineTo(n[s], n[s + 1])
                        }
                        return this.renderHull(t), e && e.value()
                    }
                    renderPoints(t, e) {
                        void 0 !== e || t && "function" == typeof t.moveTo || (e = t, t = null), e = null == e ? 2 : +e;
                        const n = null == t ? t = new i.default : void 0,
                            {
                                points: r
                            } = this;
                        for (let n = 0, i = r.length; n < i; n += 2) {
                            const i = r[n],
                                a = r[n + 1];
                            t.moveTo(i + e, a), t.arc(i, a, e, 0, s)
                        }
                        return n && n.value()
                    }
                    renderHull(t) {
                        const e = null == t ? t = new i.default : void 0,
                            {
                                hull: n,
                                points: r
                            } = this,
                            a = 2 * n[0],
                            o = n.length;
                        t.moveTo(r[a], r[a + 1]);
                        for (let e = 1; e < o; ++e) {
                            const i = 2 * n[e];
                            t.lineTo(r[i], r[i + 1])
                        }
                        return t.closePath(), e && e.value()
                    }
                    hullPolygon() {
                        const t = new a.default;
                        return this.renderHull(t), t.value()
                    }
                    renderTriangle(t, e) {
                        const n = null == e ? e = new i.default : void 0,
                            {
                                points: r,
                                triangles: a
                            } = this,
                            o = 2 * a[t *= 3],
                            s = 2 * a[t + 1],
                            l = 2 * a[t + 2];
                        return e.moveTo(r[o], r[o + 1]), e.lineTo(r[s], r[s + 1]), e.lineTo(r[l], r[l + 1]), e.closePath(), n && n.value()
                    }* trianglePolygons() {
                        const {
                            triangles: t
                        } = this;
                        for (let e = 0, n = t.length / 3; e < n; ++e) yield this.trianglePolygon(e)
                    }
                    trianglePolygon(t) {
                        const e = new a.default;
                        return this.renderTriangle(t, e), e.value()
                    }
                }
            },
            "./node_modules/d3-delaunay/src/path.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                const r = 1e-6;
                class i {
                    constructor() {
                        this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = ""
                    }
                    moveTo(t, e) {
                        this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+e}`
                    }
                    closePath() {
                        null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z")
                    }
                    lineTo(t, e) {
                        this._ += `L${this._x1=+t},${this._y1=+e}`
                    }
                    arc(t, e, n) {
                        const i = (t = +t) + (n = +n),
                            a = e = +e;
                        if (n < 0) throw new Error("negative radius");
                        null === this._x1 ? this._ += `M${i},${a}` : (Math.abs(this._x1 - i) > r || Math.abs(this._y1 - a) > r) && (this._ += "L" + i + "," + a), n && (this._ += `A${n},${n},0,1,1,${t-n},${e}A${n},${n},0,1,1,${this._x1=i},${this._y1=a}`)
                    }
                    rect(t, e, n, r) {
                        this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+e}h${+n}v${+r}h${-n}Z`
                    }
                    value() {
                        return this._ || null
                    }
                }
            },
            "./node_modules/d3-delaunay/src/polygon.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                class r {
                    constructor() {
                        this._ = []
                    }
                    moveTo(t, e) {
                        this._.push([t, e])
                    }
                    closePath() {
                        this._.push(this._[0].slice())
                    }
                    lineTo(t, e) {
                        this._.push([t, e])
                    }
                    value() {
                        return this._.length ? this._ : null
                    }
                }
            },
            "./node_modules/d3-delaunay/src/voronoi.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a
                });
                var r = n("./node_modules/d3-delaunay/src/path.js"),
                    i = n("./node_modules/d3-delaunay/src/polygon.js");
                class a {
                    constructor(t, [e, n, r, i] = [0, 0, 960, 500]) {
                        if (!((r = +r) >= (e = +e) && (i = +i) >= (n = +n))) throw new Error("invalid bounds");
                        this.delaunay = t, this._circumcenters = new Float64Array(2 * t.points.length), this.vectors = new Float64Array(2 * t.points.length), this.xmax = r, this.xmin = e, this.ymax = i, this.ymin = n, this._init()
                    }
                    update() {
                        return this.delaunay.update(), this._init(), this
                    }
                    _init() {
                        const {
                            delaunay: {
                                points: t,
                                hull: e,
                                triangles: n
                            },
                            vectors: r
                        } = this;
                        let i, a;
                        const o = this.circumcenters = this._circumcenters.subarray(0, n.length / 3 * 2);
                        for (let r, s, l = 0, A = 0, c = n.length; l < c; l += 3, A += 2) {
                            const c = 2 * n[l],
                                u = 2 * n[l + 1],
                                h = 2 * n[l + 2],
                                d = t[c],
                                f = t[c + 1],
                                p = t[u],
                                m = t[u + 1],
                                g = t[h],
                                v = t[h + 1],
                                _ = p - d,
                                y = m - f,
                                x = g - d,
                                b = v - f,
                                M = 2 * (_ * b - y * x);
                            if (Math.abs(M) < 1e-9) {
                                if (void 0 === i) {
                                    i = a = 0;
                                    for (const n of e) i += t[2 * n], a += t[2 * n + 1];
                                    i /= e.length, a /= e.length
                                }
                                const n = 1e9 * Math.sign((i - d) * b - (a - f) * x);
                                r = (d + g) / 2 - n * b, s = (f + v) / 2 + n * x
                            } else {
                                const t = 1 / M,
                                    e = _ * _ + y * y,
                                    n = x * x + b * b;
                                r = d + (b * e - y * n) * t, s = f + (_ * n - x * e) * t
                            }
                            o[A] = r, o[A + 1] = s
                        }
                        let s, l, A, c = e[e.length - 1],
                            u = 4 * c,
                            h = t[2 * c],
                            d = t[2 * c + 1];
                        r.fill(0);
                        for (let n = 0; n < e.length; ++n) c = e[n], s = u, l = h, A = d, u = 4 * c, h = t[2 * c], d = t[2 * c + 1], r[s + 2] = r[u] = A - d, r[s + 3] = r[u + 1] = h - l
                    }
                    render(t) {
                        const e = null == t ? t = new r.default : void 0,
                            {
                                delaunay: {
                                    halfedges: n,
                                    inedges: i,
                                    hull: a
                                },
                                circumcenters: o,
                                vectors: s
                            } = this;
                        if (a.length <= 1) return null;
                        for (let e = 0, r = n.length; e < r; ++e) {
                            const r = n[e];
                            if (r < e) continue;
                            const i = 2 * Math.floor(e / 3),
                                a = 2 * Math.floor(r / 3),
                                s = o[i],
                                l = o[i + 1],
                                A = o[a],
                                c = o[a + 1];
                            this._renderSegment(s, l, A, c, t)
                        }
                        let l, A = a[a.length - 1];
                        for (let e = 0; e < a.length; ++e) {
                            l = A, A = a[e];
                            const n = 2 * Math.floor(i[A] / 3),
                                r = o[n],
                                c = o[n + 1],
                                u = 4 * l,
                                h = this._project(r, c, s[u + 2], s[u + 3]);
                            h && this._renderSegment(r, c, h[0], h[1], t)
                        }
                        return e && e.value()
                    }
                    renderBounds(t) {
                        const e = null == t ? t = new r.default : void 0;
                        return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), e && e.value()
                    }
                    renderCell(t, e) {
                        const n = null == e ? e = new r.default : void 0,
                            i = this._clip(t);
                        if (null === i || !i.length) return;
                        e.moveTo(i[0], i[1]);
                        let a = i.length;
                        for (; i[0] === i[a - 2] && i[1] === i[a - 1] && a > 1;) a -= 2;
                        for (let t = 2; t < a; t += 2) i[t] === i[t - 2] && i[t + 1] === i[t - 1] || e.lineTo(i[t], i[t + 1]);
                        return e.closePath(), n && n.value()
                    }* cellPolygons() {
                        const {
                            delaunay: {
                                points: t
                            }
                        } = this;
                        for (let e = 0, n = t.length / 2; e < n; ++e) {
                            const t = this.cellPolygon(e);
                            t && (t.index = e, yield t)
                        }
                    }
                    cellPolygon(t) {
                        const e = new i.default;
                        return this.renderCell(t, e), e.value()
                    }
                    _renderSegment(t, e, n, r, i) {
                        let a;
                        const o = this._regioncode(t, e),
                            s = this._regioncode(n, r);
                        0 === o && 0 === s ? (i.moveTo(t, e), i.lineTo(n, r)) : (a = this._clipSegment(t, e, n, r, o, s)) && (i.moveTo(a[0], a[1]), i.lineTo(a[2], a[3]))
                    }
                    contains(t, e, n) {
                        return (e = +e) == e && (n = +n) == n && this.delaunay._step(t, e, n) === t
                    }* neighbors(t) {
                        const e = this._clip(t);
                        if (e)
                            for (const n of this.delaunay.neighbors(t)) {
                                const t = this._clip(n);
                                if (t) t: for (let r = 0, i = e.length; r < i; r += 2)
                                    for (let a = 0, o = t.length; a < o; a += 2)
                                        if (e[r] === t[a] && e[r + 1] === t[a + 1] && e[(r + 2) % i] === t[(a + o - 2) % o] && e[(r + 3) % i] === t[(a + o - 1) % o]) {
                                            yield n;
                                            break t
                                        }
                            }
                    }
                    _cell(t) {
                        const {
                            circumcenters: e,
                            delaunay: {
                                inedges: n,
                                halfedges: r,
                                triangles: i
                            }
                        } = this, a = n[t];
                        if (-1 === a) return null;
                        const o = [];
                        let s = a;
                        do {
                            const n = Math.floor(s / 3);
                            if (o.push(e[2 * n], e[2 * n + 1]), s = s % 3 == 2 ? s - 2 : s + 1, i[s] !== t) break;
                            s = r[s]
                        } while (s !== a && -1 !== s);
                        return o
                    }
                    _clip(t) {
                        if (0 === t && 1 === this.delaunay.hull.length) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
                        const e = this._cell(t);
                        if (null === e) return null;
                        const {
                            vectors: n
                        } = this, r = 4 * t;
                        return this._simplify(n[r] || n[r + 1] ? this._clipInfinite(t, e, n[r], n[r + 1], n[r + 2], n[r + 3]) : this._clipFinite(t, e))
                    }
                    _clipFinite(t, e) {
                        const n = e.length;
                        let r, i, a, o, s = null,
                            l = e[n - 2],
                            A = e[n - 1],
                            c = this._regioncode(l, A),
                            u = 0;
                        for (let h = 0; h < n; h += 2)
                            if (r = l, i = A, l = e[h], A = e[h + 1], a = c, c = this._regioncode(l, A), 0 === a && 0 === c) o = u, u = 0, s ? s.push(l, A) : s = [l, A];
                            else {
                                let e, n, h, d, f;
                                if (0 === a) {
                                    if (null === (e = this._clipSegment(r, i, l, A, a, c))) continue;
                                    [n, h, d, f] = e
                                } else {
                                    if (null === (e = this._clipSegment(l, A, r, i, c, a))) continue;
                                    [d, f, n, h] = e, o = u, u = this._edgecode(n, h), o && u && this._edge(t, o, u, s, s.length), s ? s.push(n, h) : s = [n, h]
                                }
                                o = u, u = this._edgecode(d, f), o && u && this._edge(t, o, u, s, s.length), s ? s.push(d, f) : s = [d, f]
                            } if (s) o = u, u = this._edgecode(s[0], s[1]), o && u && this._edge(t, o, u, s, s.length);
                        else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
                        return s
                    }
                    _clipSegment(t, e, n, r, i, a) {
                        const o = i < a;
                        for (o && ([t, e, n, r, i, a] = [n, r, t, e, a, i]);;) {
                            if (0 === i && 0 === a) return o ? [n, r, t, e] : [t, e, n, r];
                            if (i & a) return null;
                            let s, l, A = i || a;
                            8 & A ? (s = t + (n - t) * (this.ymax - e) / (r - e), l = this.ymax) : 4 & A ? (s = t + (n - t) * (this.ymin - e) / (r - e), l = this.ymin) : 2 & A ? (l = e + (r - e) * (this.xmax - t) / (n - t), s = this.xmax) : (l = e + (r - e) * (this.xmin - t) / (n - t), s = this.xmin), i ? (t = s, e = l, i = this._regioncode(t, e)) : (n = s, r = l, a = this._regioncode(n, r))
                        }
                    }
                    _clipInfinite(t, e, n, r, i, a) {
                        let o, s = Array.from(e);
                        if ((o = this._project(s[0], s[1], n, r)) && s.unshift(o[0], o[1]), (o = this._project(s[s.length - 2], s[s.length - 1], i, a)) && s.push(o[0], o[1]), s = this._clipFinite(t, s))
                            for (let e, n = 0, r = s.length, i = this._edgecode(s[r - 2], s[r - 1]); n < r; n += 2) e = i, i = this._edgecode(s[n], s[n + 1]), e && i && (n = this._edge(t, e, i, s, n), r = s.length);
                        else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (s = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
                        return s
                    }
                    _edge(t, e, n, r, i) {
                        for (; e !== n;) {
                            let n, a;
                            switch (e) {
                                case 5:
                                    e = 4;
                                    continue;
                                case 4:
                                    e = 6, n = this.xmax, a = this.ymin;
                                    break;
                                case 6:
                                    e = 2;
                                    continue;
                                case 2:
                                    e = 10, n = this.xmax, a = this.ymax;
                                    break;
                                case 10:
                                    e = 8;
                                    continue;
                                case 8:
                                    e = 9, n = this.xmin, a = this.ymax;
                                    break;
                                case 9:
                                    e = 1;
                                    continue;
                                case 1:
                                    e = 5, n = this.xmin, a = this.ymin
                            }
                            r[i] === n && r[i + 1] === a || !this.contains(t, n, a) || (r.splice(i, 0, n, a), i += 2)
                        }
                        return i
                    }
                    _project(t, e, n, r) {
                        let i, a, o, s = 1 / 0;
                        if (r < 0) {
                            if (e <= this.ymin) return null;
                            (i = (this.ymin - e) / r) < s && (o = this.ymin, a = t + (s = i) * n)
                        } else if (r > 0) {
                            if (e >= this.ymax) return null;
                            (i = (this.ymax - e) / r) < s && (o = this.ymax, a = t + (s = i) * n)
                        }
                        if (n > 0) {
                            if (t >= this.xmax) return null;
                            (i = (this.xmax - t) / n) < s && (a = this.xmax, o = e + (s = i) * r)
                        } else if (n < 0) {
                            if (t <= this.xmin) return null;
                            (i = (this.xmin - t) / n) < s && (a = this.xmin, o = e + (s = i) * r)
                        }
                        return [a, o]
                    }
                    _edgecode(t, e) {
                        return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (e === this.ymin ? 4 : e === this.ymax ? 8 : 0)
                    }
                    _regioncode(t, e) {
                        return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (e < this.ymin ? 4 : e > this.ymax ? 8 : 0)
                    }
                    _simplify(t) {
                        if (t && t.length > 4) {
                            for (let e = 0; e < t.length; e += 2) {
                                const n = (e + 2) % t.length,
                                    r = (e + 4) % t.length;
                                (t[e] === t[n] && t[n] === t[r] || t[e + 1] === t[n + 1] && t[n + 1] === t[r + 1]) && (t.splice(n, 2), e -= 2)
                            }
                            t.length || (t = null)
                        }
                        return t
                    }
                }
            },
            "./node_modules/d3-format/src/defaultLocale.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s,
                    format: () => i,
                    formatPrefix: () => a
                });
                var r, i, a, o = n("./node_modules/d3-format/src/locale.js");

                function s(t) {
                    return r = (0, o.default)(t), i = r.format, a = r.formatPrefix, r
                }
                s({
                    thousands: ",",
                    grouping: [3],
                    currency: ["$", ""]
                })
            },
            "./node_modules/d3-format/src/exponent.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-format/src/formatDecimal.js");

                function i(t) {
                    return (t = (0, r.formatDecimalParts)(Math.abs(t))) ? t[1] : NaN
                }
            },
            "./node_modules/d3-format/src/formatDecimal.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10)
                }

                function i(t, e) {
                    if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
                    var n, r = t.slice(0, n);
                    return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(n + 1)]
                }
                n.r(e), n.d(e, {
                    default: () => r,
                    formatDecimalParts: () => i
                })
            },
            "./node_modules/d3-format/src/formatGroup.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    return function(n, r) {
                        for (var i = n.length, a = [], o = 0, s = t[0], l = 0; i > 0 && s > 0 && (l + s + 1 > r && (s = Math.max(1, r - l)), a.push(n.substring(i -= s, i + s)), !((l += s + 1) > r));) s = t[o = (o + 1) % t.length];
                        return a.reverse().join(e)
                    }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-format/src/formatNumerals.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return function(e) {
                        return e.replace(/[0-9]/g, (function(e) {
                            return t[+e]
                        }))
                    }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-format/src/formatPrefixAuto.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a,
                    prefixExponent: () => r
                });
                var r, i = n("./node_modules/d3-format/src/formatDecimal.js");

                function a(t, e) {
                    var n = (0, i.formatDecimalParts)(t, e);
                    if (!n) return t + "";
                    var a = n[0],
                        o = n[1],
                        s = o - (r = 3 * Math.max(-8, Math.min(8, Math.floor(o / 3)))) + 1,
                        l = a.length;
                    return s === l ? a : s > l ? a + new Array(s - l + 1).join("0") : s > 0 ? a.slice(0, s) + "." + a.slice(s) : "0." + new Array(1 - s).join("0") + (0, i.formatDecimalParts)(t, Math.max(0, e + s - 1))[0]
                }
            },
            "./node_modules/d3-format/src/formatRounded.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-format/src/formatDecimal.js");

                function i(t, e) {
                    var n = (0, r.formatDecimalParts)(t, e);
                    if (!n) return t + "";
                    var i = n[0],
                        a = n[1];
                    return a < 0 ? "0." + new Array(-a).join("0") + i : i.length > a + 1 ? i.slice(0, a + 1) + "." + i.slice(a + 1) : i + new Array(a - i.length + 2).join("0")
                }
            },
            "./node_modules/d3-format/src/formatSpecifier.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    FormatSpecifier: () => a,
                    default: () => i
                });
                var r = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

                function i(t) {
                    if (!(e = r.exec(t))) throw new Error("invalid format: " + t);
                    var e;
                    return new a({
                        fill: e[1],
                        align: e[2],
                        sign: e[3],
                        symbol: e[4],
                        zero: e[5],
                        width: e[6],
                        comma: e[7],
                        precision: e[8] && e[8].slice(1),
                        trim: e[9],
                        type: e[10]
                    })
                }

                function a(t) {
                    this.fill = void 0 === t.fill ? " " : t.fill + "", this.align = void 0 === t.align ? ">" : t.align + "", this.sign = void 0 === t.sign ? "-" : t.sign + "", this.symbol = void 0 === t.symbol ? "" : t.symbol + "", this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? "" : t.type + ""
                }
                i.prototype = a.prototype, a.prototype.toString = function() {
                    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type
                }
            },
            "./node_modules/d3-format/src/formatTrim.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    t: for (var e, n = t.length, r = 1, i = -1; r < n; ++r) switch (t[r]) {
                        case ".":
                            i = e = r;
                            break;
                        case "0":
                            0 === i && (i = r), e = r;
                            break;
                        default:
                            if (!+t[r]) break t;
                            i > 0 && (i = 0)
                    }
                    return i > 0 ? t.slice(0, i) + t.slice(e + 1) : t
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-format/src/formatTypes.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => o
                });
                var r = n("./node_modules/d3-format/src/formatDecimal.js"),
                    i = n("./node_modules/d3-format/src/formatPrefixAuto.js"),
                    a = n("./node_modules/d3-format/src/formatRounded.js");
                const o = {
                    "%": (t, e) => (100 * t).toFixed(e),
                    b: t => Math.round(t).toString(2),
                    c: t => t + "",
                    d: r.default,
                    e: (t, e) => t.toExponential(e),
                    f: (t, e) => t.toFixed(e),
                    g: (t, e) => t.toPrecision(e),
                    o: t => Math.round(t).toString(8),
                    p: (t, e) => (0, a.default)(100 * t, e),
                    r: a.default,
                    s: i.default,
                    X: t => Math.round(t).toString(16).toUpperCase(),
                    x: t => Math.round(t).toString(16)
                }
            },
            "./node_modules/d3-format/src/identity.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return t
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-format/src/locale.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => d
                });
                var r = n("./node_modules/d3-format/src/exponent.js"),
                    i = n("./node_modules/d3-format/src/formatGroup.js"),
                    a = n("./node_modules/d3-format/src/formatNumerals.js"),
                    o = n("./node_modules/d3-format/src/formatSpecifier.js"),
                    s = n("./node_modules/d3-format/src/formatTrim.js"),
                    l = n("./node_modules/d3-format/src/formatTypes.js"),
                    A = n("./node_modules/d3-format/src/formatPrefixAuto.js"),
                    c = n("./node_modules/d3-format/src/identity.js"),
                    u = Array.prototype.map,
                    h = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

                function d(t) {
                    var e = void 0 === t.grouping || void 0 === t.thousands ? c.default : (0, i.default)(u.call(t.grouping, Number), t.thousands + ""),
                        n = void 0 === t.currency ? "" : t.currency[0] + "",
                        d = void 0 === t.currency ? "" : t.currency[1] + "",
                        f = void 0 === t.decimal ? "." : t.decimal + "",
                        p = void 0 === t.numerals ? c.default : (0, a.default)(u.call(t.numerals, String)),
                        m = void 0 === t.percent ? "%" : t.percent + "",
                        g = void 0 === t.minus ? "−" : t.minus + "",
                        v = void 0 === t.nan ? "NaN" : t.nan + "";

                    function _(t) {
                        var r = (t = (0, o.default)(t)).fill,
                            i = t.align,
                            a = t.sign,
                            c = t.symbol,
                            u = t.zero,
                            _ = t.width,
                            y = t.comma,
                            x = t.precision,
                            b = t.trim,
                            M = t.type;
                        "n" === M ? (y = !0, M = "g") : l.default[M] || (void 0 === x && (x = 12), b = !0, M = "g"), (u || "0" === r && "=" === i) && (u = !0, r = "0", i = "=");
                        var w = "$" === c ? n : "#" === c && /[boxX]/.test(M) ? "0" + M.toLowerCase() : "",
                            S = "$" === c ? d : /[%p]/.test(M) ? m : "",
                            E = l.default[M],
                            T = /[defgprs%]/.test(M);

                        function C(t) {
                            var n, o, l, c = w,
                                d = S;
                            if ("c" === M) d = E(t) + d, t = "";
                            else {
                                var m = (t = +t) < 0 || 1 / t < 0;
                                if (t = isNaN(t) ? v : E(Math.abs(t), x), b && (t = (0, s.default)(t)), m && 0 == +t && "+" !== a && (m = !1), c = (m ? "(" === a ? a : g : "-" === a || "(" === a ? "" : a) + c, d = ("s" === M ? h[8 + A.prefixExponent / 3] : "") + d + (m && "(" === a ? ")" : ""), T)
                                    for (n = -1, o = t.length; ++n < o;)
                                        if (48 > (l = t.charCodeAt(n)) || l > 57) {
                                            d = (46 === l ? f + t.slice(n + 1) : t.slice(n)) + d, t = t.slice(0, n);
                                            break
                                        }
                            }
                            y && !u && (t = e(t, 1 / 0));
                            var C = c.length + t.length + d.length,
                                R = C < _ ? new Array(_ - C + 1).join(r) : "";
                            switch (y && u && (t = e(R + t, R.length ? _ - d.length : 1 / 0), R = ""), i) {
                                case "<":
                                    t = c + t + d + R;
                                    break;
                                case "=":
                                    t = c + R + t + d;
                                    break;
                                case "^":
                                    t = R.slice(0, C = R.length >> 1) + c + t + d + R.slice(C);
                                    break;
                                default:
                                    t = R + c + t + d
                            }
                            return p(t)
                        }
                        return x = void 0 === x ? 6 : /[gprs]/.test(M) ? Math.max(1, Math.min(21, x)) : Math.max(0, Math.min(20, x)), C.toString = function() {
                            return t + ""
                        }, C
                    }
                    return {
                        format: _,
                        formatPrefix: function(t, e) {
                            var n = _(((t = (0, o.default)(t)).type = "f", t)),
                                i = 3 * Math.max(-8, Math.min(8, Math.floor((0, r.default)(e) / 3))),
                                a = Math.pow(10, -i),
                                s = h[8 + i / 3];
                            return function(t) {
                                return n(a * t) + s
                            }
                        }
                    }
                }
            },
            "./node_modules/d3-format/src/precisionFixed.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-format/src/exponent.js");

                function i(t) {
                    return Math.max(0, -(0, r.default)(Math.abs(t)))
                }
            },
            "./node_modules/d3-format/src/precisionPrefix.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-format/src/exponent.js");

                function i(t, e) {
                    return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor((0, r.default)(e) / 3))) - (0, r.default)(Math.abs(t)))
                }
            },
            "./node_modules/d3-format/src/precisionRound.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-format/src/exponent.js");

                function i(t, e) {
                    return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, (0, r.default)(e) - (0, r.default)(t)) + 1
                }
            },
            "./node_modules/d3-geo-voronoi/src/cartesian.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    cartesian: () => a,
                    cartesianAdd: () => A,
                    cartesianAddInPlace: () => l,
                    cartesianCross: () => s,
                    cartesianDot: () => o,
                    cartesianNormalize: () => h,
                    cartesianNormalizeInPlace: () => u,
                    cartesianScale: () => c,
                    spherical: () => i
                });
                var r = n("./node_modules/d3-geo-voronoi/src/math.js");

                function i(t) {
                    return [(0, r.atan2)(t[1], t[0]), (0, r.asin)(t[2])]
                }

                function a(t) {
                    var e = t[0],
                        n = t[1],
                        i = (0, r.cos)(n);
                    return [i * (0, r.cos)(e), i * (0, r.sin)(e), (0, r.sin)(n)]
                }

                function o(t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
                }

                function s(t, e) {
                    return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
                }

                function l(t, e) {
                    t[0] += e[0], t[1] += e[1], t[2] += e[2]
                }

                function A(t, e) {
                    return [t[0] + e[0], t[1] + e[1], t[2] + e[2]]
                }

                function c(t, e) {
                    return [t[0] * e, t[1] * e, t[2] * e]
                }

                function u(t) {
                    var e = (0, r.sqrt)(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
                    t[0] /= e, t[1] /= e, t[2] /= e
                }

                function h(t) {
                    var e = (0, r.sqrt)(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
                    return [t[0] / e, t[1] / e, t[2] / e]
                }
            },
            "./node_modules/d3-geo-voronoi/src/delaunay.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    excess: () => u,
                    geoDelaunay: () => h
                });
                var r = n("./node_modules/d3-delaunay/src/delaunay.js"),
                    i = n("./node_modules/d3-geo/src/rotation.js"),
                    a = n("./node_modules/d3-geo/src/projection/stereographic.js"),
                    o = n("./node_modules/d3-array/src/extent.js"),
                    s = n("./node_modules/d3-geo-voronoi/src/math.js"),
                    l = n("./node_modules/d3-geo-voronoi/src/cartesian.js");

                function A(t) {
                    return [(0, s.atan2)(t[1], t[0]) * s.degrees, (0, s.asin)((0, s.max)(-1, (0, s.min)(1, t[2]))) * s.degrees]
                }

                function c(t) {
                    const e = t[0] * s.radians,
                        n = t[1] * s.radians,
                        r = (0, s.cos)(n);
                    return [r * (0, s.cos)(e), r * (0, s.sin)(e), (0, s.sin)(n)]
                }

                function u(t) {
                    return t = t.map((t => c(t))), (0, l.cartesianDot)(t[0], (0, l.cartesianCross)(t[2], t[1]))
                }

                function h(t) {
                    const e = function(t) {
                            if (t.length < 2) return {};
                            let e = 0;
                            for (; isNaN(t[e][0] + t[e][1]) && e++ < t.length;);
                            const n = (0, i.default)(t[e]),
                                o = (0, a.default)().translate([0, 0]).scale(1).rotate(n.invert([180, 0])),
                                l = [];
                            let A = 1;
                            for (let e = 0, n = (t = t.map(o)).length; e < n; e++) {
                                let n = t[e][0] ** 2 + t[e][1] ** 2;
                                !isFinite(n) || n > 1e32 ? l.push(e) : n > A && (A = n)
                            }
                            const c = 1e6 * (0, s.sqrt)(A);
                            l.forEach((e => t[e] = [c, 0])), t.push([0, c]), t.push([-c, 0]), t.push([0, -c]);
                            const u = r.default.from(t);
                            u.projection = o;
                            const {
                                triangles: h,
                                halfedges: d,
                                inedges: f
                            } = u, p = [];
                            for (let n = 0, r = d.length; n < r; n++)
                                if (d[n] < 0) {
                                    const t = n % 3 == 2 ? n - 2 : n + 1,
                                        r = n % 3 == 0 ? n + 2 : n - 1,
                                        i = d[t],
                                        a = d[r];
                                    d[i] = a, d[a] = i, d[t] = d[r] = -1, h[n] = h[t] = h[r] = e, f[h[i]] = i % 3 == 0 ? i + 2 : i - 1, f[h[a]] = a % 3 == 0 ? a + 2 : a - 1, p.push(Math.min(n, t, r)), n += 2 - n % 3
                                } else h[n] > t.length - 3 - 1 && (h[n] = e);
                            return u
                        }(t),
                        n = function(t) {
                            const {
                                triangles: e
                            } = t;
                            if (!e) return [];
                            const n = [];
                            for (let t = 0, r = e.length / 3; t < r; t++) {
                                const r = e[3 * t],
                                    i = e[3 * t + 1],
                                    a = e[3 * t + 2];
                                r !== i && i !== a && n.push([r, a, i])
                            }
                            return n
                        }(e),
                        h = function(t, e) {
                            const n = new Set;
                            return 2 === e.length ? [
                                [0, 1]
                            ] : (t.forEach((t => {
                                if (t[0] !== t[1] && !(u(t.map((t => e[t]))) < 0))
                                    for (let e, r = 0; r < 3; r++) e = (r + 1) % 3, n.add((0, o.default)([t[r], t[e]]).join("-"))
                            })), Array.from(n, (t => t.split("-").map(Number))))
                        }(n, t),
                        f = function(t, e) {
                            const n = [];
                            return t.forEach((t => {
                                for (let e = 0; e < 3; e++) {
                                    const r = t[e],
                                        i = t[(e + 1) % 3];
                                    n[r] = n[r] || [], n[r].push(i)
                                }
                            })), 0 === t.length && (2 === e ? (n[0] = [1], n[1] = [0]) : 1 === e && (n[0] = [])), n
                        }(n, t.length),
                        p = function(t, e) {
                            function n(t, e) {
                                let n = t[0] - e[0],
                                    r = t[1] - e[1],
                                    i = t[2] - e[2];
                                return n * n + r * r + i * i
                            }
                            return function(r, i, a) {
                                void 0 === a && (a = 0);
                                let o, s, l = a;
                                const A = c([r, i]);
                                do {
                                    o = a, a = null, s = n(A, c(e[o])), t[o].forEach((t => {
                                        let r = n(A, c(e[t]));
                                        if (r < s) return s = r, a = t, void(l = t)
                                    }))
                                } while (null !== a);
                                return l
                            }
                        }(f, t),
                        m = function(t, e) {
                            return t.map((t => {
                                const n = t.map((t => e[t])).map(c),
                                    r = (0, l.cartesianAdd)((0, l.cartesianAdd)((0, l.cartesianCross)(n[1], n[0]), (0, l.cartesianCross)(n[2], n[1])), (0, l.cartesianCross)(n[0], n[2]));
                                return A((0, l.cartesianNormalize)(r))
                            }))
                        }(n, t),
                        {
                            polygons: g,
                            centers: v
                        } = function(t, e, n) {
                            const r = [],
                                i = t.slice();
                            if (0 === e.length) {
                                if (n.length < 2) return {
                                    polygons: r,
                                    centers: i
                                };
                                if (2 === n.length) {
                                    const t = c(n[0]),
                                        e = c(n[1]),
                                        o = (0, l.cartesianNormalize)((0, l.cartesianAdd)(t, e)),
                                        s = (0, l.cartesianNormalize)((0, l.cartesianCross)(t, e)),
                                        u = (0, l.cartesianCross)(o, s),
                                        h = [o, (0, l.cartesianCross)(o, u), (0, l.cartesianCross)((0, l.cartesianCross)(o, u), u), (0, l.cartesianCross)((0, l.cartesianCross)((0, l.cartesianCross)(o, u), u), u)].map(A).map(a);
                                    return r.push(h), r.push(h.slice().reverse()), {
                                        polygons: r,
                                        centers: i
                                    }
                                }
                            }
                            e.forEach(((t, e) => {
                                for (let n = 0; n < 3; n++) {
                                    const i = t[n],
                                        a = t[(n + 1) % 3],
                                        o = t[(n + 2) % 3];
                                    r[i] = r[i] || [], r[i].push([a, o, e, [i, a, o]])
                                }
                            }));

                            function a(t) {
                                let n = -1;
                                return i.slice(e.length, 1 / 0).forEach(((r, i) => {
                                    r[0] === t[0] && r[1] === t[1] && (n = i + e.length)
                                })), n < 0 && (n = i.length, i.push(t)), n
                            }
                            return {
                                polygons: r.map((t => {
                                    const e = [t[0][2]];
                                    let r = t[0][1];
                                    for (let n = 1; n < t.length; n++)
                                        for (let n = 0; n < t.length; n++)
                                            if (t[n][0] == r) {
                                                r = t[n][1], e.push(t[n][2]);
                                                break
                                            } if (e.length > 2) return e;
                                    if (2 == e.length) {
                                        const r = d(n[t[0][3][0]], n[t[0][3][1]], i[e[0]]),
                                            o = d(n[t[0][3][2]], n[t[0][3][0]], i[e[0]]),
                                            s = a(r),
                                            l = a(o);
                                        return [e[0], l, e[1], s]
                                    }
                                })),
                                centers: i
                            }
                        }(m, n, t),
                        _ = function(t) {
                            const e = [];
                            return t.forEach((t => {
                                if (!t) return;
                                let n = t[t.length - 1];
                                for (let r of t) r > n && e.push([n, r]), n = r
                            })), e
                        }(g),
                        y = function(t, e) {
                            const n = new Set,
                                r = [];
                            t.map((t => {
                                if (!(u(t.map((t => e[t > e.length ? 0 : t]))) > 1e-12))
                                    for (let e = 0; e < 3; e++) {
                                        let r = [t[e], t[(e + 1) % 3]],
                                            i = `${r[0]}-${r[1]}`;
                                        n.has(i) ? n.delete(i) : n.add(`${r[1]}-${r[0]}`)
                                    }
                            }));
                            const i = new Map;
                            let a;
                            if (n.forEach((t => {
                                    t = t.split("-").map(Number), i.set(t[0], t[1]), a = t[0]
                                })), void 0 === a) return r;
                            let o = a;
                            do {
                                r.push(o);
                                let t = i.get(o);
                                i.set(o, -1), o = t
                            } while (o > -1 && o !== a);
                            return r
                        }(n, t),
                        x = function(t, e) {
                            return function(n) {
                                const r = new Map,
                                    i = new Map;
                                return t.forEach(((t, e) => {
                                    const a = t.join("-");
                                    r.set(a, n[e]), i.set(a, !0)
                                })), e.forEach((t => {
                                    let e = 0,
                                        n = -1;
                                    for (let i = 0; i < 3; i++) {
                                        let a = (0, o.default)([t[i], t[(i + 1) % 3]]).join("-");
                                        r.get(a) > e && (e = r.get(a), n = a)
                                    }
                                    i.set(n, !1)
                                })), t.map((t => i.get(t.join("-"))))
                            }
                        }(h, n);
                    return {
                        delaunay: e,
                        edges: h,
                        triangles: n,
                        centers: v,
                        neighbors: f,
                        polygons: g,
                        mesh: _,
                        hull: y,
                        urquhart: x,
                        find: p
                    }
                }

                function d(t, e, n) {
                    t = c(t), e = c(e), n = c(n);
                    const r = (0, s.sign)((0, l.cartesianDot)((0, l.cartesianCross)(e, t), n));
                    return A((0, l.cartesianNormalize)((0, l.cartesianAdd)(t, e)).map((t => r * t)))
                }
            },
            "./node_modules/d3-geo-voronoi/src/math.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    abs: () => u,
                    acos: () => E,
                    asin: () => T,
                    atan: () => h,
                    atan2: () => d,
                    ceil: () => p,
                    cos: () => f,
                    degrees: () => A,
                    epsilon: () => r,
                    epsilon2: () => i,
                    exp: () => m,
                    floor: () => g,
                    halfPi: () => o,
                    haversin: () => C,
                    log: () => v,
                    max: () => _,
                    min: () => y,
                    pi: () => a,
                    pow: () => x,
                    quarterPi: () => s,
                    radians: () => c,
                    sign: () => M,
                    sin: () => b,
                    sqrt: () => w,
                    tan: () => S,
                    tau: () => l
                });
                const r = 1e-6,
                    i = 1e-12,
                    a = Math.PI,
                    o = a / 2,
                    s = a / 4,
                    l = 2 * a,
                    A = 180 / a,
                    c = a / 180,
                    u = Math.abs,
                    h = Math.atan,
                    d = Math.atan2,
                    f = Math.cos,
                    p = Math.ceil,
                    m = Math.exp,
                    g = Math.floor,
                    v = Math.log,
                    _ = Math.max,
                    y = Math.min,
                    x = Math.pow,
                    b = Math.sin,
                    M = Math.sign || function(t) {
                        return t > 0 ? 1 : t < 0 ? -1 : 0
                    },
                    w = Math.sqrt,
                    S = Math.tan;

                function E(t) {
                    return t > 1 ? 0 : t < -1 ? a : Math.acos(t)
                }

                function T(t) {
                    return t > 1 ? o : t < -1 ? -o : Math.asin(t)
                }

                function C(t) {
                    return (t = b(t / 2)) * t
                }
            },
            "./node_modules/d3-geo-voronoi/src/voronoi.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    geoVoronoi: () => o
                });
                var r = n("./node_modules/d3-geo/src/centroid.js"),
                    i = n("./node_modules/d3-geo/src/distance.js"),
                    a = n("./node_modules/d3-geo-voronoi/src/delaunay.js");

                function o(t) {
                    const e = function(t) {
                        if (e.delaunay = null, e._data = t, "object" == typeof e._data && "FeatureCollection" === e._data.type && (e._data = e._data.features), "object" == typeof e._data) {
                            const t = e._data.map((t => [e._vx(t), e._vy(t), t])).filter((t => isFinite(t[0] + t[1])));
                            e.points = t.map((t => [t[0], t[1]])), e.valid = t.map((t => t[2])), e.delaunay = (0, a.geoDelaunay)(e.points)
                        }
                        return e
                    };
                    return e._vx = function(t) {
                        return "object" == typeof t && "type" in t ? (0, r.default)(t)[0] : 0 in t ? t[0] : void 0
                    }, e._vy = function(t) {
                        return "object" == typeof t && "type" in t ? (0, r.default)(t)[1] : 1 in t ? t[1] : void 0
                    }, e.x = function(t) {
                        return t ? (e._vx = t, e) : e._vx
                    }, e.y = function(t) {
                        return t ? (e._vy = t, e) : e._vy
                    }, e.polygons = function(t) {
                        if (void 0 !== t && e(t), !e.delaunay) return !1;
                        const n = {
                            type: "FeatureCollection",
                            features: []
                        };
                        return 0 === e.valid.length || (e.delaunay.polygons.forEach(((t, r) => n.features.push({
                            type: "Feature",
                            geometry: t ? {
                                type: "Polygon",
                                coordinates: [
                                    [...t, t[0]].map((t => e.delaunay.centers[t]))
                                ]
                            } : null,
                            properties: {
                                site: e.valid[r],
                                sitecoordinates: e.points[r],
                                neighbours: e.delaunay.neighbors[r]
                            }
                        }))), 1 === e.valid.length && n.features.push({
                            type: "Feature",
                            geometry: {
                                type: "Sphere"
                            },
                            properties: {
                                site: e.valid[0],
                                sitecoordinates: e.points[0],
                                neighbours: []
                            }
                        })), n
                    }, e.triangles = function(t) {
                        return void 0 !== t && e(t), !!e.delaunay && {
                            type: "FeatureCollection",
                            features: e.delaunay.triangles.map(((t, n) => ((t = t.map((t => e.points[t]))).center = e.delaunay.centers[n], t))).filter((t => (0, a.excess)(t) > 0)).map((t => ({
                                type: "Feature",
                                properties: {
                                    circumcenter: t.center
                                },
                                geometry: {
                                    type: "Polygon",
                                    coordinates: [
                                        [...t, t[0]]
                                    ]
                                }
                            })))
                        }
                    }, e.links = function(t) {
                        if (void 0 !== t && e(t), !e.delaunay) return !1;
                        const n = e.delaunay.edges.map((t => (0, i.default)(e.points[t[0]], e.points[t[1]]))),
                            r = e.delaunay.urquhart(n);
                        return {
                            type: "FeatureCollection",
                            features: e.delaunay.edges.map(((t, i) => ({
                                type: "Feature",
                                properties: {
                                    source: e.valid[t[0]],
                                    target: e.valid[t[1]],
                                    length: n[i],
                                    urquhart: !!r[i]
                                },
                                geometry: {
                                    type: "LineString",
                                    coordinates: [e.points[t[0]], e.points[t[1]]]
                                }
                            })))
                        }
                    }, e.mesh = function(t) {
                        return void 0 !== t && e(t), !!e.delaunay && {
                            type: "MultiLineString",
                            coordinates: e.delaunay.edges.map((t => [e.points[t[0]], e.points[t[1]]]))
                        }
                    }, e.cellMesh = function(t) {
                        if (void 0 !== t && e(t), !e.delaunay) return !1;
                        const {
                            centers: n,
                            polygons: r
                        } = e.delaunay, i = [];
                        for (const t of r)
                            if (t)
                                for (let e = t.length, r = t[e - 1], a = t[0], o = 0; o < e; r = a, a = t[++o]) a > r && i.push([n[r], n[a]]);
                        return {
                            type: "MultiLineString",
                            coordinates: i
                        }
                    }, e._found = void 0, e.find = function(t, n, r) {
                        if (e._found = e.delaunay.find(t, n, e._found), !r || (0, i.default)([t, n], e.points[e._found]) < r) return e._found
                    }, e.hull = function(t) {
                        void 0 !== t && e(t);
                        const n = e.delaunay.hull,
                            r = e.points;
                        return 0 === n.length ? null : {
                            type: "Polygon",
                            coordinates: [
                                [...n.map((t => r[t])), r[n[0]]]
                            ]
                        }
                    }, t ? e(t) : e
                }
            },
            "./node_modules/d3-geo/src/area.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    areaRingSum: () => h,
                    areaStream: () => f,
                    default: () => _
                });
                var r, i, a, o, s, l = n("./node_modules/d3-array/src/fsum.js"),
                    A = n("./node_modules/d3-geo/src/math.js"),
                    c = n("./node_modules/d3-geo/src/noop.js"),
                    u = n("./node_modules/d3-geo/src/stream.js"),
                    h = new l.Adder,
                    d = new l.Adder,
                    f = {
                        point: c.default,
                        lineStart: c.default,
                        lineEnd: c.default,
                        polygonStart: function() {
                            h = new l.Adder, f.lineStart = p, f.lineEnd = m
                        },
                        polygonEnd: function() {
                            var t = +h;
                            d.add(t < 0 ? A.tau + t : t), this.lineStart = this.lineEnd = this.point = c.default
                        },
                        sphere: function() {
                            d.add(A.tau)
                        }
                    };

                function p() {
                    f.point = g
                }

                function m() {
                    v(r, i)
                }

                function g(t, e) {
                    f.point = v, r = t, i = e, t *= A.radians, e *= A.radians, a = t, o = (0, A.cos)(e = e / 2 + A.quarterPi), s = (0, A.sin)(e)
                }

                function v(t, e) {
                    t *= A.radians, e = (e *= A.radians) / 2 + A.quarterPi;
                    var n = t - a,
                        r = n >= 0 ? 1 : -1,
                        i = r * n,
                        l = (0, A.cos)(e),
                        c = (0, A.sin)(e),
                        u = s * c,
                        d = o * l + u * (0, A.cos)(i),
                        f = u * r * (0, A.sin)(i);
                    h.add((0, A.atan2)(f, d)), a = t, o = l, s = c
                }

                function _(t) {
                    return d = new l.Adder, (0, u.default)(t, f), 2 * d
                }
            },
            "./node_modules/d3-geo/src/bounds.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => P
                });
                var r, i, a, o, s, l, A, c, u, h, d, f = n("./node_modules/d3-array/src/fsum.js"),
                    p = n("./node_modules/d3-geo/src/area.js"),
                    m = n("./node_modules/d3-geo/src/cartesian.js"),
                    g = n("./node_modules/d3-geo/src/math.js"),
                    v = n("./node_modules/d3-geo/src/stream.js"),
                    _ = {
                        point: y,
                        lineStart: b,
                        lineEnd: M,
                        polygonStart: function() {
                            _.point = w, _.lineStart = S, _.lineEnd = E, u = new f.Adder, p.areaStream.polygonStart()
                        },
                        polygonEnd: function() {
                            p.areaStream.polygonEnd(), _.point = y, _.lineStart = b, _.lineEnd = M, p.areaRingSum < 0 ? (r = -(a = 180), i = -(o = 90)) : u > g.epsilon ? o = 90 : u < -g.epsilon && (i = -90), d[0] = r, d[1] = a
                        },
                        sphere: function() {
                            r = -(a = 180), i = -(o = 90)
                        }
                    };

                function y(t, e) {
                    h.push(d = [r = t, a = t]), e < i && (i = e), e > o && (o = e)
                }

                function x(t, e) {
                    var n = (0, m.cartesian)([t * g.radians, e * g.radians]);
                    if (c) {
                        var l = (0, m.cartesianCross)(c, n),
                            A = [l[1], -l[0], 0],
                            u = (0, m.cartesianCross)(A, l);
                        (0, m.cartesianNormalizeInPlace)(u), u = (0, m.spherical)(u);
                        var f, p = t - s,
                            v = p > 0 ? 1 : -1,
                            _ = u[0] * g.degrees * v,
                            y = (0, g.abs)(p) > 180;
                        y ^ (v * s < _ && _ < v * t) ? (f = u[1] * g.degrees) > o && (o = f) : y ^ (v * s < (_ = (_ + 360) % 360 - 180) && _ < v * t) ? (f = -u[1] * g.degrees) < i && (i = f) : (e < i && (i = e), e > o && (o = e)), y ? t < s ? T(r, t) > T(r, a) && (a = t) : T(t, a) > T(r, a) && (r = t) : a >= r ? (t < r && (r = t), t > a && (a = t)) : t > s ? T(r, t) > T(r, a) && (a = t) : T(t, a) > T(r, a) && (r = t)
                    } else h.push(d = [r = t, a = t]);
                    e < i && (i = e), e > o && (o = e), c = n, s = t
                }

                function b() {
                    _.point = x
                }

                function M() {
                    d[0] = r, d[1] = a, _.point = y, c = null
                }

                function w(t, e) {
                    if (c) {
                        var n = t - s;
                        u.add((0, g.abs)(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
                    } else l = t, A = e;
                    p.areaStream.point(t, e), x(t, e)
                }

                function S() {
                    p.areaStream.lineStart()
                }

                function E() {
                    w(l, A), p.areaStream.lineEnd(), (0, g.abs)(u) > g.epsilon && (r = -(a = 180)), d[0] = r, d[1] = a, c = null
                }

                function T(t, e) {
                    return (e -= t) < 0 ? e + 360 : e
                }

                function C(t, e) {
                    return t[0] - e[0]
                }

                function R(t, e) {
                    return t[0] <= t[1] ? t[0] <= e && e <= t[1] : e < t[0] || t[1] < e
                }

                function P(t) {
                    var e, n, s, l, A, c, u;
                    if (o = a = -(r = i = 1 / 0), h = [], (0, v.default)(t, _), n = h.length) {
                        for (h.sort(C), e = 1, A = [s = h[0]]; e < n; ++e) R(s, (l = h[e])[0]) || R(s, l[1]) ? (T(s[0], l[1]) > T(s[0], s[1]) && (s[1] = l[1]), T(l[0], s[1]) > T(s[0], s[1]) && (s[0] = l[0])) : A.push(s = l);
                        for (c = -1 / 0, e = 0, s = A[n = A.length - 1]; e <= n; s = l, ++e) l = A[e], (u = T(s[1], l[0])) > c && (c = u, r = l[0], a = s[1])
                    }
                    return h = d = null, r === 1 / 0 || i === 1 / 0 ? [
                        [NaN, NaN],
                        [NaN, NaN]
                    ] : [
                        [r, i],
                        [a, o]
                    ]
                }
            },
            "./node_modules/d3-geo/src/cartesian.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    cartesian: () => a,
                    cartesianAddInPlace: () => l,
                    cartesianCross: () => s,
                    cartesianDot: () => o,
                    cartesianNormalizeInPlace: () => c,
                    cartesianScale: () => A,
                    spherical: () => i
                });
                var r = n("./node_modules/d3-geo/src/math.js");

                function i(t) {
                    return [(0, r.atan2)(t[1], t[0]), (0, r.asin)(t[2])]
                }

                function a(t) {
                    var e = t[0],
                        n = t[1],
                        i = (0, r.cos)(n);
                    return [i * (0, r.cos)(e), i * (0, r.sin)(e), (0, r.sin)(n)]
                }

                function o(t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
                }

                function s(t, e) {
                    return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
                }

                function l(t, e) {
                    t[0] += e[0], t[1] += e[1], t[2] += e[2]
                }

                function A(t, e) {
                    return [t[0] * e, t[1] * e, t[2] * e]
                }

                function c(t) {
                    var e = (0, r.sqrt)(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
                    t[0] /= e, t[1] /= e, t[2] /= e
                }
            },
            "./node_modules/d3-geo/src/centroid.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => O
                });
                var r, i, a, o, s, l, A, c, u, h, d, f, p, m, g, v, _ = n("./node_modules/d3-array/src/fsum.js"),
                    y = n("./node_modules/d3-geo/src/math.js"),
                    x = n("./node_modules/d3-geo/src/noop.js"),
                    b = n("./node_modules/d3-geo/src/stream.js"),
                    M = {
                        sphere: x.default,
                        point: w,
                        lineStart: E,
                        lineEnd: R,
                        polygonStart: function() {
                            M.lineStart = P, M.lineEnd = L
                        },
                        polygonEnd: function() {
                            M.lineStart = E, M.lineEnd = R
                        }
                    };

                function w(t, e) {
                    t *= y.radians, e *= y.radians;
                    var n = (0, y.cos)(e);
                    S(n * (0, y.cos)(t), n * (0, y.sin)(t), (0, y.sin)(e))
                }

                function S(t, e, n) {
                    ++r, a += (t - a) / r, o += (e - o) / r, s += (n - s) / r
                }

                function E() {
                    M.point = T
                }

                function T(t, e) {
                    t *= y.radians, e *= y.radians;
                    var n = (0, y.cos)(e);
                    m = n * (0, y.cos)(t), g = n * (0, y.sin)(t), v = (0, y.sin)(e), M.point = C, S(m, g, v)
                }

                function C(t, e) {
                    t *= y.radians, e *= y.radians;
                    var n = (0, y.cos)(e),
                        r = n * (0, y.cos)(t),
                        a = n * (0, y.sin)(t),
                        o = (0, y.sin)(e),
                        s = (0, y.atan2)((0, y.sqrt)((s = g * o - v * a) * s + (s = v * r - m * o) * s + (s = m * a - g * r) * s), m * r + g * a + v * o);
                    i += s, l += s * (m + (m = r)), A += s * (g + (g = a)), c += s * (v + (v = o)), S(m, g, v)
                }

                function R() {
                    M.point = w
                }

                function P() {
                    M.point = D
                }

                function L() {
                    I(f, p), M.point = w
                }

                function D(t, e) {
                    f = t, p = e, t *= y.radians, e *= y.radians, M.point = I;
                    var n = (0, y.cos)(e);
                    m = n * (0, y.cos)(t), g = n * (0, y.sin)(t), v = (0, y.sin)(e), S(m, g, v)
                }

                function I(t, e) {
                    t *= y.radians, e *= y.radians;
                    var n = (0, y.cos)(e),
                        r = n * (0, y.cos)(t),
                        a = n * (0, y.sin)(t),
                        o = (0, y.sin)(e),
                        s = g * o - v * a,
                        f = v * r - m * o,
                        p = m * a - g * r,
                        _ = (0, y.hypot)(s, f, p),
                        x = (0, y.asin)(_),
                        b = _ && -x / _;
                    u.add(b * s), h.add(b * f), d.add(b * p), i += x, l += x * (m + (m = r)), A += x * (g + (g = a)), c += x * (v + (v = o)), S(m, g, v)
                }

                function O(t) {
                    r = i = a = o = s = l = A = c = 0, u = new _.Adder, h = new _.Adder, d = new _.Adder, (0, b.default)(t, M);
                    var e = +u,
                        n = +h,
                        f = +d,
                        p = (0, y.hypot)(e, n, f);
                    return p < y.epsilon2 && (e = l, n = A, f = c, i < y.epsilon && (e = a, n = o, f = s), (p = (0, y.hypot)(e, n, f)) < y.epsilon2) ? [NaN, NaN] : [(0, y.atan2)(n, e) * y.degrees, (0, y.asin)(f / p) * y.degrees]
                }
            },
            "./node_modules/d3-geo/src/circle.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    circleStream: () => s,
                    default: () => A
                });
                var r = n("./node_modules/d3-geo/src/cartesian.js"),
                    i = n("./node_modules/d3-geo/src/constant.js"),
                    a = n("./node_modules/d3-geo/src/math.js"),
                    o = n("./node_modules/d3-geo/src/rotation.js");

                function s(t, e, n, i, o, s) {
                    if (n) {
                        var A = (0, a.cos)(e),
                            c = (0, a.sin)(e),
                            u = i * n;
                        null == o ? (o = e + i * a.tau, s = e - u / 2) : (o = l(A, o), s = l(A, s), (i > 0 ? o < s : o > s) && (o += i * a.tau));
                        for (var h, d = o; i > 0 ? d > s : d < s; d -= u) h = (0, r.spherical)([A, -c * (0, a.cos)(d), -c * (0, a.sin)(d)]), t.point(h[0], h[1])
                    }
                }

                function l(t, e) {
                    (e = (0, r.cartesian)(e))[0] -= t, (0, r.cartesianNormalizeInPlace)(e);
                    var n = (0, a.acos)(-e[1]);
                    return ((-e[2] < 0 ? -n : n) + a.tau - a.epsilon) % a.tau
                }

                function A() {
                    var t, e, n = (0, i.default)([0, 0]),
                        r = (0, i.default)(90),
                        l = (0, i.default)(6),
                        A = {
                            point: function(n, r) {
                                t.push(n = e(n, r)), n[0] *= a.degrees, n[1] *= a.degrees
                            }
                        };

                    function c() {
                        var i = n.apply(this, arguments),
                            c = r.apply(this, arguments) * a.radians,
                            u = l.apply(this, arguments) * a.radians;
                        return t = [], e = (0, o.rotateRadians)(-i[0] * a.radians, -i[1] * a.radians, 0).invert, s(A, c, u, 1), i = {
                            type: "Polygon",
                            coordinates: [t]
                        }, t = e = null, i
                    }
                    return c.center = function(t) {
                        return arguments.length ? (n = "function" == typeof t ? t : (0, i.default)([+t[0], +t[1]]), c) : n
                    }, c.radius = function(t) {
                        return arguments.length ? (r = "function" == typeof t ? t : (0, i.default)(+t), c) : r
                    }, c.precision = function(t) {
                        return arguments.length ? (l = "function" == typeof t ? t : (0, i.default)(+t), c) : l
                    }, c
                }
            },
            "./node_modules/d3-geo/src/clip/antimeridian.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a
                });
                var r = n("./node_modules/d3-geo/src/clip/index.js"),
                    i = n("./node_modules/d3-geo/src/math.js");
                const a = (0, r.default)((function() {
                    return !0
                }), (function(t) {
                    var e, n = NaN,
                        r = NaN,
                        a = NaN;
                    return {
                        lineStart: function() {
                            t.lineStart(), e = 1
                        },
                        point: function(o, s) {
                            var l = o > 0 ? i.pi : -i.pi,
                                A = (0, i.abs)(o - n);
                            (0, i.abs)(A - i.pi) < i.epsilon ? (t.point(n, r = (r + s) / 2 > 0 ? i.halfPi : -i.halfPi), t.point(a, r), t.lineEnd(), t.lineStart(), t.point(l, r), t.point(o, r), e = 0) : a !== l && A >= i.pi && ((0, i.abs)(n - a) < i.epsilon && (n -= a * i.epsilon), (0, i.abs)(o - l) < i.epsilon && (o -= l * i.epsilon), r = function(t, e, n, r) {
                                var a, o, s = (0, i.sin)(t - n);
                                return (0, i.abs)(s) > i.epsilon ? (0, i.atan)(((0, i.sin)(e) * (o = (0, i.cos)(r)) * (0, i.sin)(n) - (0, i.sin)(r) * (a = (0, i.cos)(e)) * (0, i.sin)(t)) / (a * o * s)) : (e + r) / 2
                            }(n, r, o, s), t.point(a, r), t.lineEnd(), t.lineStart(), t.point(l, r), e = 0), t.point(n = o, r = s), a = l
                        },
                        lineEnd: function() {
                            t.lineEnd(), n = r = NaN
                        },
                        clean: function() {
                            return 2 - e
                        }
                    }
                }), (function(t, e, n, r) {
                    var a;
                    if (null == t) a = n * i.halfPi, r.point(-i.pi, a), r.point(0, a), r.point(i.pi, a), r.point(i.pi, 0), r.point(i.pi, -a), r.point(0, -a), r.point(-i.pi, -a), r.point(-i.pi, 0), r.point(-i.pi, a);
                    else if ((0, i.abs)(t[0] - e[0]) > i.epsilon) {
                        var o = t[0] < e[0] ? i.pi : -i.pi;
                        a = n * o / 2, r.point(-o, a), r.point(0, a), r.point(o, a)
                    } else r.point(e[0], e[1])
                }), [-i.pi, -i.halfPi])
            },
            "./node_modules/d3-geo/src/clip/buffer.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-geo/src/noop.js");

                function i() {
                    var t, e = [];
                    return {
                        point: function(e, n, r) {
                            t.push([e, n, r])
                        },
                        lineStart: function() {
                            e.push(t = [])
                        },
                        lineEnd: r.default,
                        rejoin: function() {
                            e.length > 1 && e.push(e.pop().concat(e.shift()))
                        },
                        result: function() {
                            var n = e;
                            return e = [], t = null, n
                        }
                    }
                }
            },
            "./node_modules/d3-geo/src/clip/circle.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/d3-geo/src/cartesian.js"),
                    i = n("./node_modules/d3-geo/src/circle.js"),
                    a = n("./node_modules/d3-geo/src/math.js"),
                    o = n("./node_modules/d3-geo/src/pointEqual.js"),
                    s = n("./node_modules/d3-geo/src/clip/index.js");

                function l(t) {
                    var e = (0, a.cos)(t),
                        n = 6 * a.radians,
                        l = e > 0,
                        A = (0, a.abs)(e) > a.epsilon;

                    function c(t, n) {
                        return (0, a.cos)(t) * (0, a.cos)(n) > e
                    }

                    function u(t, n, i) {
                        var o = (0, r.cartesian)(t),
                            s = (0, r.cartesian)(n),
                            l = [1, 0, 0],
                            A = (0, r.cartesianCross)(o, s),
                            c = (0, r.cartesianDot)(A, A),
                            u = A[0],
                            h = c - u * u;
                        if (!h) return !i && t;
                        var d = e * c / h,
                            f = -e * u / h,
                            p = (0, r.cartesianCross)(l, A),
                            m = (0, r.cartesianScale)(l, d),
                            g = (0, r.cartesianScale)(A, f);
                        (0, r.cartesianAddInPlace)(m, g);
                        var v = p,
                            _ = (0, r.cartesianDot)(m, v),
                            y = (0, r.cartesianDot)(v, v),
                            x = _ * _ - y * ((0, r.cartesianDot)(m, m) - 1);
                        if (!(x < 0)) {
                            var b = (0, a.sqrt)(x),
                                M = (0, r.cartesianScale)(v, (-_ - b) / y);
                            if ((0, r.cartesianAddInPlace)(M, m), M = (0, r.spherical)(M), !i) return M;
                            var w, S = t[0],
                                E = n[0],
                                T = t[1],
                                C = n[1];
                            E < S && (w = S, S = E, E = w);
                            var R = E - S,
                                P = (0, a.abs)(R - a.pi) < a.epsilon;
                            if (!P && C < T && (w = T, T = C, C = w), P || R < a.epsilon ? P ? T + C > 0 ^ M[1] < ((0, a.abs)(M[0] - S) < a.epsilon ? T : C) : T <= M[1] && M[1] <= C : R > a.pi ^ (S <= M[0] && M[0] <= E)) {
                                var L = (0, r.cartesianScale)(v, (-_ + b) / y);
                                return (0, r.cartesianAddInPlace)(L, m), [M, (0, r.spherical)(L)]
                            }
                        }
                    }

                    function h(e, n) {
                        var r = l ? t : a.pi - t,
                            i = 0;
                        return e < -r ? i |= 1 : e > r && (i |= 2), n < -r ? i |= 4 : n > r && (i |= 8), i
                    }
                    return (0, s.default)(c, (function(t) {
                        var e, n, r, i, s;
                        return {
                            lineStart: function() {
                                i = r = !1, s = 1
                            },
                            point: function(d, f) {
                                var p, m = [d, f],
                                    g = c(d, f),
                                    v = l ? g ? 0 : h(d, f) : g ? h(d + (d < 0 ? a.pi : -a.pi), f) : 0;
                                if (!e && (i = r = g) && t.lineStart(), g !== r && (!(p = u(e, m)) || (0, o.default)(e, p) || (0, o.default)(m, p)) && (m[2] = 1), g !== r) s = 0, g ? (t.lineStart(), p = u(m, e), t.point(p[0], p[1])) : (p = u(e, m), t.point(p[0], p[1], 2), t.lineEnd()), e = p;
                                else if (A && e && l ^ g) {
                                    var _;
                                    v & n || !(_ = u(m, e, !0)) || (s = 0, l ? (t.lineStart(), t.point(_[0][0], _[0][1]), t.point(_[1][0], _[1][1]), t.lineEnd()) : (t.point(_[1][0], _[1][1]), t.lineEnd(), t.lineStart(), t.point(_[0][0], _[0][1], 3)))
                                }!g || e && (0, o.default)(e, m) || t.point(m[0], m[1]), e = m, r = g, n = v
                            },
                            lineEnd: function() {
                                r && t.lineEnd(), e = null
                            },
                            clean: function() {
                                return s | (i && r) << 1
                            }
                        }
                    }), (function(e, r, a, o) {
                        (0, i.circleStream)(o, t, n, a, e, r)
                    }), l ? [0, -t] : [-a.pi, t - a.pi])
                }
            },
            "./node_modules/d3-geo/src/clip/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/d3-geo/src/clip/buffer.js"),
                    i = n("./node_modules/d3-geo/src/clip/rejoin.js"),
                    a = n("./node_modules/d3-geo/src/math.js"),
                    o = n("./node_modules/d3-geo/src/polygonContains.js"),
                    s = n("./node_modules/d3-array/src/merge.js");

                function l(t, e, n, a) {
                    return function(l) {
                        var u, h, d, f = e(l),
                            p = (0, r.default)(),
                            m = e(p),
                            g = !1,
                            v = {
                                point: _,
                                lineStart: x,
                                lineEnd: b,
                                polygonStart: function() {
                                    v.point = M, v.lineStart = w, v.lineEnd = S, h = [], u = []
                                },
                                polygonEnd: function() {
                                    v.point = _, v.lineStart = x, v.lineEnd = b, h = (0, s.default)(h);
                                    var t = (0, o.default)(u, a);
                                    h.length ? (g || (l.polygonStart(), g = !0), (0, i.default)(h, c, t, n, l)) : t && (g || (l.polygonStart(), g = !0), l.lineStart(), n(null, null, 1, l), l.lineEnd()), g && (l.polygonEnd(), g = !1), h = u = null
                                },
                                sphere: function() {
                                    l.polygonStart(), l.lineStart(), n(null, null, 1, l), l.lineEnd(), l.polygonEnd()
                                }
                            };

                        function _(e, n) {
                            t(e, n) && l.point(e, n)
                        }

                        function y(t, e) {
                            f.point(t, e)
                        }

                        function x() {
                            v.point = y, f.lineStart()
                        }

                        function b() {
                            v.point = _, f.lineEnd()
                        }

                        function M(t, e) {
                            d.push([t, e]), m.point(t, e)
                        }

                        function w() {
                            m.lineStart(), d = []
                        }

                        function S() {
                            M(d[0][0], d[0][1]), m.lineEnd();
                            var t, e, n, r, i = m.clean(),
                                a = p.result(),
                                o = a.length;
                            if (d.pop(), u.push(d), d = null, o)
                                if (1 & i) {
                                    if ((e = (n = a[0]).length - 1) > 0) {
                                        for (g || (l.polygonStart(), g = !0), l.lineStart(), t = 0; t < e; ++t) l.point((r = n[t])[0], r[1]);
                                        l.lineEnd()
                                    }
                                } else o > 1 && 2 & i && a.push(a.pop().concat(a.shift())), h.push(a.filter(A))
                        }
                        return v
                    }
                }

                function A(t) {
                    return t.length > 1
                }

                function c(t, e) {
                    return ((t = t.x)[0] < 0 ? t[1] - a.halfPi - a.epsilon : a.halfPi - t[1]) - ((e = e.x)[0] < 0 ? e[1] - a.halfPi - a.epsilon : a.halfPi - e[1])
                }
            },
            "./node_modules/d3-geo/src/clip/line.js": (t, e, n) => {
                "use strict";

                function r(t, e, n, r, i, a) {
                    var o, s = t[0],
                        l = t[1],
                        A = 0,
                        c = 1,
                        u = e[0] - s,
                        h = e[1] - l;
                    if (o = n - s, u || !(o > 0)) {
                        if (o /= u, u < 0) {
                            if (o < A) return;
                            o < c && (c = o)
                        } else if (u > 0) {
                            if (o > c) return;
                            o > A && (A = o)
                        }
                        if (o = i - s, u || !(o < 0)) {
                            if (o /= u, u < 0) {
                                if (o > c) return;
                                o > A && (A = o)
                            } else if (u > 0) {
                                if (o < A) return;
                                o < c && (c = o)
                            }
                            if (o = r - l, h || !(o > 0)) {
                                if (o /= h, h < 0) {
                                    if (o < A) return;
                                    o < c && (c = o)
                                } else if (h > 0) {
                                    if (o > c) return;
                                    o > A && (A = o)
                                }
                                if (o = a - l, h || !(o < 0)) {
                                    if (o /= h, h < 0) {
                                        if (o > c) return;
                                        o > A && (A = o)
                                    } else if (h > 0) {
                                        if (o < A) return;
                                        o < c && (c = o)
                                    }
                                    return A > 0 && (t[0] = s + A * u, t[1] = l + A * h), c < 1 && (e[0] = s + c * u, e[1] = l + c * h), !0
                                }
                            }
                        }
                    }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-geo/src/clip/rectangle.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => c
                });
                var r = n("./node_modules/d3-geo/src/math.js"),
                    i = n("./node_modules/d3-geo/src/clip/buffer.js"),
                    a = n("./node_modules/d3-geo/src/clip/line.js"),
                    o = n("./node_modules/d3-geo/src/clip/rejoin.js"),
                    s = n("./node_modules/d3-array/src/merge.js"),
                    l = 1e9,
                    A = -l;

                function c(t, e, n, c) {
                    function u(r, i) {
                        return t <= r && r <= n && e <= i && i <= c
                    }

                    function h(r, i, a, o) {
                        var s = 0,
                            l = 0;
                        if (null == r || (s = d(r, a)) !== (l = d(i, a)) || p(r, i) < 0 ^ a > 0)
                            do {
                                o.point(0 === s || 3 === s ? t : n, s > 1 ? c : e)
                            } while ((s = (s + a + 4) % 4) !== l);
                        else o.point(i[0], i[1])
                    }

                    function d(i, a) {
                        return (0, r.abs)(i[0] - t) < r.epsilon ? a > 0 ? 0 : 3 : (0, r.abs)(i[0] - n) < r.epsilon ? a > 0 ? 2 : 1 : (0, r.abs)(i[1] - e) < r.epsilon ? a > 0 ? 1 : 0 : a > 0 ? 3 : 2
                    }

                    function f(t, e) {
                        return p(t.x, e.x)
                    }

                    function p(t, e) {
                        var n = d(t, 1),
                            r = d(e, 1);
                        return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0]
                    }
                    return function(r) {
                        var d, p, m, g, v, _, y, x, b, M, w, S = r,
                            E = (0, i.default)(),
                            T = {
                                point: C,
                                lineStart: function() {
                                    T.point = R, p && p.push(m = []), M = !0, b = !1, y = x = NaN
                                },
                                lineEnd: function() {
                                    d && (R(g, v), _ && b && E.rejoin(), d.push(E.result())), T.point = C, b && S.lineEnd()
                                },
                                polygonStart: function() {
                                    S = E, d = [], p = [], w = !0
                                },
                                polygonEnd: function() {
                                    var e = function() {
                                            for (var e = 0, n = 0, r = p.length; n < r; ++n)
                                                for (var i, a, o = p[n], s = 1, l = o.length, A = o[0], u = A[0], h = A[1]; s < l; ++s) i = u, a = h, u = (A = o[s])[0], h = A[1], a <= c ? h > c && (u - i) * (c - a) > (h - a) * (t - i) && ++e : h <= c && (u - i) * (c - a) < (h - a) * (t - i) && --e;
                                            return e
                                        }(),
                                        n = w && e,
                                        i = (d = (0, s.default)(d)).length;
                                    (n || i) && (r.polygonStart(), n && (r.lineStart(), h(null, null, 1, r), r.lineEnd()), i && (0, o.default)(d, f, e, h, r), r.polygonEnd()), S = r, d = p = m = null
                                }
                            };

                        function C(t, e) {
                            u(t, e) && S.point(t, e)
                        }

                        function R(r, i) {
                            var o = u(r, i);
                            if (p && m.push([r, i]), M) g = r, v = i, _ = o, M = !1, o && (S.lineStart(), S.point(r, i));
                            else if (o && b) S.point(r, i);
                            else {
                                var s = [y = Math.max(A, Math.min(l, y)), x = Math.max(A, Math.min(l, x))],
                                    h = [r = Math.max(A, Math.min(l, r)), i = Math.max(A, Math.min(l, i))];
                                (0, a.default)(s, h, t, e, n, c) ? (b || (S.lineStart(), S.point(s[0], s[1])), S.point(h[0], h[1]), o || S.lineEnd(), w = !1) : o && (S.lineStart(), S.point(r, i), w = !1)
                            }
                            y = r, x = i, b = o
                        }
                        return T
                    }
                }
            },
            "./node_modules/d3-geo/src/clip/rejoin.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => o
                });
                var r = n("./node_modules/d3-geo/src/pointEqual.js"),
                    i = n("./node_modules/d3-geo/src/math.js");

                function a(t, e, n, r) {
                    this.x = t, this.z = e, this.o = n, this.e = r, this.v = !1, this.n = this.p = null
                }

                function o(t, e, n, o, l) {
                    var A, c, u = [],
                        h = [];
                    if (t.forEach((function(t) {
                            if (!((e = t.length - 1) <= 0)) {
                                var e, n, o = t[0],
                                    s = t[e];
                                if ((0, r.default)(o, s)) {
                                    if (!o[2] && !s[2]) {
                                        for (l.lineStart(), A = 0; A < e; ++A) l.point((o = t[A])[0], o[1]);
                                        return void l.lineEnd()
                                    }
                                    s[0] += 2 * i.epsilon
                                }
                                u.push(n = new a(o, t, null, !0)), h.push(n.o = new a(o, null, n, !1)), u.push(n = new a(s, t, null, !1)), h.push(n.o = new a(s, null, n, !0))
                            }
                        })), u.length) {
                        for (h.sort(e), s(u), s(h), A = 0, c = h.length; A < c; ++A) h[A].e = n = !n;
                        for (var d, f, p = u[0];;) {
                            for (var m = p, g = !0; m.v;)
                                if ((m = m.n) === p) return;
                            d = m.z, l.lineStart();
                            do {
                                if (m.v = m.o.v = !0, m.e) {
                                    if (g)
                                        for (A = 0, c = d.length; A < c; ++A) l.point((f = d[A])[0], f[1]);
                                    else o(m.x, m.n.x, 1, l);
                                    m = m.n
                                } else {
                                    if (g)
                                        for (d = m.p.z, A = d.length - 1; A >= 0; --A) l.point((f = d[A])[0], f[1]);
                                    else o(m.x, m.p.x, -1, l);
                                    m = m.p
                                }
                                d = (m = m.o).z, g = !g
                            } while (!m.v);
                            l.lineEnd()
                        }
                    }
                }

                function s(t) {
                    if (e = t.length) {
                        for (var e, n, r = 0, i = t[0]; ++r < e;) i.n = n = t[r], n.p = i, i = n;
                        i.n = n = t[0], n.p = i
                    }
                }
            },
            "./node_modules/d3-geo/src/compose.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    function n(n, r) {
                        return n = t(n, r), e(n[0], n[1])
                    }
                    return t.invert && e.invert && (n.invert = function(n, r) {
                        return (n = e.invert(n, r)) && t.invert(n[0], n[1])
                    }), n
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-geo/src/constant.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return function() {
                        return t
                    }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-geo/src/contains.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => f
                });
                var r = n("./node_modules/d3-geo/src/polygonContains.js"),
                    i = n("./node_modules/d3-geo/src/distance.js"),
                    a = n("./node_modules/d3-geo/src/math.js"),
                    o = {
                        Feature: function(t, e) {
                            return l(t.geometry, e)
                        },
                        FeatureCollection: function(t, e) {
                            for (var n = t.features, r = -1, i = n.length; ++r < i;)
                                if (l(n[r].geometry, e)) return !0;
                            return !1
                        }
                    },
                    s = {
                        Sphere: function() {
                            return !0
                        },
                        Point: function(t, e) {
                            return A(t.coordinates, e)
                        },
                        MultiPoint: function(t, e) {
                            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)
                                if (A(n[r], e)) return !0;
                            return !1
                        },
                        LineString: function(t, e) {
                            return c(t.coordinates, e)
                        },
                        MultiLineString: function(t, e) {
                            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)
                                if (c(n[r], e)) return !0;
                            return !1
                        },
                        Polygon: function(t, e) {
                            return u(t.coordinates, e)
                        },
                        MultiPolygon: function(t, e) {
                            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)
                                if (u(n[r], e)) return !0;
                            return !1
                        },
                        GeometryCollection: function(t, e) {
                            for (var n = t.geometries, r = -1, i = n.length; ++r < i;)
                                if (l(n[r], e)) return !0;
                            return !1
                        }
                    };

                function l(t, e) {
                    return !(!t || !s.hasOwnProperty(t.type)) && s[t.type](t, e)
                }

                function A(t, e) {
                    return 0 === (0, i.default)(t, e)
                }

                function c(t, e) {
                    for (var n, r, o, s = 0, l = t.length; s < l; s++) {
                        if (0 === (r = (0, i.default)(t[s], e))) return !0;
                        if (s > 0 && (o = (0, i.default)(t[s], t[s - 1])) > 0 && n <= o && r <= o && (n + r - o) * (1 - Math.pow((n - r) / o, 2)) < a.epsilon2 * o) return !0;
                        n = r
                    }
                    return !1
                }

                function u(t, e) {
                    return !!(0, r.default)(t.map(h), d(e))
                }

                function h(t) {
                    return (t = t.map(d)).pop(), t
                }

                function d(t) {
                    return [t[0] * a.radians, t[1] * a.radians]
                }

                function f(t, e) {
                    return (t && o.hasOwnProperty(t.type) ? o[t.type] : l)(t, e)
                }
            },
            "./node_modules/d3-geo/src/distance.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => o
                });
                var r = n("./node_modules/d3-geo/src/length.js"),
                    i = [null, null],
                    a = {
                        type: "LineString",
                        coordinates: i
                    };

                function o(t, e) {
                    return i[0] = t, i[1] = e, (0, r.default)(a)
                }
            },
            "./node_modules/d3-geo/src/graticule.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s,
                    graticule10: () => l
                });
                var r = n("./node_modules/d3-array/src/range.js"),
                    i = n("./node_modules/d3-geo/src/math.js");

                function a(t, e, n) {
                    var a = (0, r.default)(t, e - i.epsilon, n).concat(e);
                    return function(t) {
                        return a.map((function(e) {
                            return [t, e]
                        }))
                    }
                }

                function o(t, e, n) {
                    var a = (0, r.default)(t, e - i.epsilon, n).concat(e);
                    return function(t) {
                        return a.map((function(e) {
                            return [e, t]
                        }))
                    }
                }

                function s() {
                    var t, e, n, s, l, A, c, u, h, d, f, p, m = 10,
                        g = m,
                        v = 90,
                        _ = 360,
                        y = 2.5;

                    function x() {
                        return {
                            type: "MultiLineString",
                            coordinates: b()
                        }
                    }

                    function b() {
                        return (0, r.default)((0, i.ceil)(s / v) * v, n, v).map(f).concat((0, r.default)((0, i.ceil)(u / _) * _, c, _).map(p)).concat((0, r.default)((0, i.ceil)(e / m) * m, t, m).filter((function(t) {
                            return (0, i.abs)(t % v) > i.epsilon
                        })).map(h)).concat((0, r.default)((0, i.ceil)(A / g) * g, l, g).filter((function(t) {
                            return (0, i.abs)(t % _) > i.epsilon
                        })).map(d))
                    }
                    return x.lines = function() {
                        return b().map((function(t) {
                            return {
                                type: "LineString",
                                coordinates: t
                            }
                        }))
                    }, x.outline = function() {
                        return {
                            type: "Polygon",
                            coordinates: [f(s).concat(p(c).slice(1), f(n).reverse().slice(1), p(u).reverse().slice(1))]
                        }
                    }, x.extent = function(t) {
                        return arguments.length ? x.extentMajor(t).extentMinor(t) : x.extentMinor()
                    }, x.extentMajor = function(t) {
                        return arguments.length ? (s = +t[0][0], n = +t[1][0], u = +t[0][1], c = +t[1][1], s > n && (t = s, s = n, n = t), u > c && (t = u, u = c, c = t), x.precision(y)) : [
                            [s, u],
                            [n, c]
                        ]
                    }, x.extentMinor = function(n) {
                        return arguments.length ? (e = +n[0][0], t = +n[1][0], A = +n[0][1], l = +n[1][1], e > t && (n = e, e = t, t = n), A > l && (n = A, A = l, l = n), x.precision(y)) : [
                            [e, A],
                            [t, l]
                        ]
                    }, x.step = function(t) {
                        return arguments.length ? x.stepMajor(t).stepMinor(t) : x.stepMinor()
                    }, x.stepMajor = function(t) {
                        return arguments.length ? (v = +t[0], _ = +t[1], x) : [v, _]
                    }, x.stepMinor = function(t) {
                        return arguments.length ? (m = +t[0], g = +t[1], x) : [m, g]
                    }, x.precision = function(r) {
                        return arguments.length ? (y = +r, h = a(A, l, 90), d = o(e, t, y), f = a(u, c, 90), p = o(s, n, y), x) : y
                    }, x.extentMajor([
                        [-180, -90 + i.epsilon],
                        [180, 90 - i.epsilon]
                    ]).extentMinor([
                        [-180, -80 - i.epsilon],
                        [180, 80 + i.epsilon]
                    ])
                }

                function l() {
                    return s()()
                }
            },
            "./node_modules/d3-geo/src/identity.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                const r = t => t
            },
            "./node_modules/d3-geo/src/interpolate.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-geo/src/math.js");

                function i(t, e) {
                    var n = t[0] * r.radians,
                        i = t[1] * r.radians,
                        a = e[0] * r.radians,
                        o = e[1] * r.radians,
                        s = (0, r.cos)(i),
                        l = (0, r.sin)(i),
                        A = (0, r.cos)(o),
                        c = (0, r.sin)(o),
                        u = s * (0, r.cos)(n),
                        h = s * (0, r.sin)(n),
                        d = A * (0, r.cos)(a),
                        f = A * (0, r.sin)(a),
                        p = 2 * (0, r.asin)((0, r.sqrt)((0, r.haversin)(o - i) + s * A * (0, r.haversin)(a - n))),
                        m = (0, r.sin)(p),
                        g = p ? function(t) {
                            var e = (0, r.sin)(t *= p) / m,
                                n = (0, r.sin)(p - t) / m,
                                i = n * u + e * d,
                                a = n * h + e * f,
                                o = n * l + e * c;
                            return [(0, r.atan2)(a, i) * r.degrees, (0, r.atan2)(o, (0, r.sqrt)(i * i + a * a)) * r.degrees]
                        } : function() {
                            return [n * r.degrees, i * r.degrees]
                        };
                    return g.distance = p, g
                }
            },
            "./node_modules/d3-geo/src/length.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => p
                });
                var r, i, a, o, s = n("./node_modules/d3-array/src/fsum.js"),
                    l = n("./node_modules/d3-geo/src/math.js"),
                    A = n("./node_modules/d3-geo/src/noop.js"),
                    c = n("./node_modules/d3-geo/src/stream.js"),
                    u = {
                        sphere: A.default,
                        point: A.default,
                        lineStart: function() {
                            u.point = d, u.lineEnd = h
                        },
                        lineEnd: A.default,
                        polygonStart: A.default,
                        polygonEnd: A.default
                    };

                function h() {
                    u.point = u.lineEnd = A.default
                }

                function d(t, e) {
                    t *= l.radians, e *= l.radians, i = t, a = (0, l.sin)(e), o = (0, l.cos)(e), u.point = f
                }

                function f(t, e) {
                    t *= l.radians, e *= l.radians;
                    var n = (0, l.sin)(e),
                        s = (0, l.cos)(e),
                        A = (0, l.abs)(t - i),
                        c = (0, l.cos)(A),
                        u = s * (0, l.sin)(A),
                        h = o * n - a * s * c,
                        d = a * n + o * s * c;
                    r.add((0, l.atan2)((0, l.sqrt)(u * u + h * h), d)), i = t, a = n, o = s
                }

                function p(t) {
                    return r = new s.Adder, (0, c.default)(t, u), +r
                }
            },
            "./node_modules/d3-geo/src/math.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    abs: () => u,
                    acos: () => S,
                    asin: () => E,
                    atan: () => h,
                    atan2: () => d,
                    ceil: () => p,
                    cos: () => f,
                    degrees: () => A,
                    epsilon: () => r,
                    epsilon2: () => i,
                    exp: () => m,
                    floor: () => g,
                    halfPi: () => o,
                    haversin: () => T,
                    hypot: () => v,
                    log: () => _,
                    pi: () => a,
                    pow: () => y,
                    quarterPi: () => s,
                    radians: () => c,
                    sign: () => b,
                    sin: () => x,
                    sqrt: () => M,
                    tan: () => w,
                    tau: () => l
                });
                var r = 1e-6,
                    i = 1e-12,
                    a = Math.PI,
                    o = a / 2,
                    s = a / 4,
                    l = 2 * a,
                    A = 180 / a,
                    c = a / 180,
                    u = Math.abs,
                    h = Math.atan,
                    d = Math.atan2,
                    f = Math.cos,
                    p = Math.ceil,
                    m = Math.exp,
                    g = Math.floor,
                    v = Math.hypot,
                    _ = Math.log,
                    y = Math.pow,
                    x = Math.sin,
                    b = Math.sign || function(t) {
                        return t > 0 ? 1 : t < 0 ? -1 : 0
                    },
                    M = Math.sqrt,
                    w = Math.tan;

                function S(t) {
                    return t > 1 ? 0 : t < -1 ? a : Math.acos(t)
                }

                function E(t) {
                    return t > 1 ? o : t < -1 ? -o : Math.asin(t)
                }

                function T(t) {
                    return (t = x(t / 2)) * t
                }
            },
            "./node_modules/d3-geo/src/noop.js": (t, e, n) => {
                "use strict";

                function r() {}
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-geo/src/path/bounds.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/d3-geo/src/noop.js"),
                    i = 1 / 0,
                    a = i,
                    o = -i,
                    s = o;
                const l = {
                    point: function(t, e) {
                        t < i && (i = t), t > o && (o = t), e < a && (a = e), e > s && (s = e)
                    },
                    lineStart: r.default,
                    lineEnd: r.default,
                    polygonStart: r.default,
                    polygonEnd: r.default,
                    result: function() {
                        var t = [
                            [i, a],
                            [o, s]
                        ];
                        return o = s = -(a = i = 1 / 0), t
                    }
                }
            },
            "./node_modules/d3-geo/src/pointEqual.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-geo/src/math.js");

                function i(t, e) {
                    return (0, r.abs)(t[0] - e[0]) < r.epsilon && (0, r.abs)(t[1] - e[1]) < r.epsilon
                }
            },
            "./node_modules/d3-geo/src/polygonContains.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s
                });
                var r = n("./node_modules/d3-array/src/fsum.js"),
                    i = n("./node_modules/d3-geo/src/cartesian.js"),
                    a = n("./node_modules/d3-geo/src/math.js");

                function o(t) {
                    return (0, a.abs)(t[0]) <= a.pi ? t[0] : (0, a.sign)(t[0]) * (((0, a.abs)(t[0]) + a.pi) % a.tau - a.pi)
                }

                function s(t, e) {
                    var n = o(e),
                        s = e[1],
                        l = (0, a.sin)(s),
                        A = [(0, a.sin)(n), -(0, a.cos)(n), 0],
                        c = 0,
                        u = 0,
                        h = new r.Adder;
                    1 === l ? s = a.halfPi + a.epsilon : -1 === l && (s = -a.halfPi - a.epsilon);
                    for (var d = 0, f = t.length; d < f; ++d)
                        if (m = (p = t[d]).length)
                            for (var p, m, g = p[m - 1], v = o(g), _ = g[1] / 2 + a.quarterPi, y = (0, a.sin)(_), x = (0, a.cos)(_), b = 0; b < m; ++b, v = w, y = E, x = T, g = M) {
                                var M = p[b],
                                    w = o(M),
                                    S = M[1] / 2 + a.quarterPi,
                                    E = (0, a.sin)(S),
                                    T = (0, a.cos)(S),
                                    C = w - v,
                                    R = C >= 0 ? 1 : -1,
                                    P = R * C,
                                    L = P > a.pi,
                                    D = y * E;
                                if (h.add((0, a.atan2)(D * R * (0, a.sin)(P), x * T + D * (0, a.cos)(P))), c += L ? C + R * a.tau : C, L ^ v >= n ^ w >= n) {
                                    var I = (0, i.cartesianCross)((0, i.cartesian)(g), (0, i.cartesian)(M));
                                    (0, i.cartesianNormalizeInPlace)(I);
                                    var O = (0, i.cartesianCross)(A, I);
                                    (0, i.cartesianNormalizeInPlace)(O);
                                    var B = (L ^ C >= 0 ? -1 : 1) * (0, a.asin)(O[2]);
                                    (s > B || s === B && (I[0] || I[1])) && (u += L ^ C >= 0 ? 1 : -1)
                                }
                            }
                    return (c < -a.epsilon || c < a.epsilon && h < -a.epsilon2) ^ 1 & u
                }
            },
            "./node_modules/d3-geo/src/projection/azimuthal.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    azimuthalInvert: () => a,
                    azimuthalRaw: () => i
                });
                var r = n("./node_modules/d3-geo/src/math.js");

                function i(t) {
                    return function(e, n) {
                        var i = (0, r.cos)(e),
                            a = (0, r.cos)(n),
                            o = t(i * a);
                        return o === 1 / 0 ? [2, 0] : [o * a * (0, r.sin)(e), o * (0, r.sin)(n)]
                    }
                }

                function a(t) {
                    return function(e, n) {
                        var i = (0, r.sqrt)(e * e + n * n),
                            a = t(i),
                            o = (0, r.sin)(a),
                            s = (0, r.cos)(a);
                        return [(0, r.atan2)(e * o, i * s), (0, r.asin)(i && n * o / i)]
                    }
                }
            },
            "./node_modules/d3-geo/src/projection/fit.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    fitExtent: () => o,
                    fitHeight: () => A,
                    fitSize: () => s,
                    fitWidth: () => l
                });
                var r = n("./node_modules/d3-geo/src/stream.js"),
                    i = n("./node_modules/d3-geo/src/path/bounds.js");

                function a(t, e, n) {
                    var a = t.clipExtent && t.clipExtent();
                    return t.scale(150).translate([0, 0]), null != a && t.clipExtent(null), (0, r.default)(n, t.stream(i.default)), e(i.default.result()), null != a && t.clipExtent(a), t
                }

                function o(t, e, n) {
                    return a(t, (function(n) {
                        var r = e[1][0] - e[0][0],
                            i = e[1][1] - e[0][1],
                            a = Math.min(r / (n[1][0] - n[0][0]), i / (n[1][1] - n[0][1])),
                            o = +e[0][0] + (r - a * (n[1][0] + n[0][0])) / 2,
                            s = +e[0][1] + (i - a * (n[1][1] + n[0][1])) / 2;
                        t.scale(150 * a).translate([o, s])
                    }), n)
                }

                function s(t, e, n) {
                    return o(t, [
                        [0, 0], e
                    ], n)
                }

                function l(t, e, n) {
                    return a(t, (function(n) {
                        var r = +e,
                            i = r / (n[1][0] - n[0][0]),
                            a = (r - i * (n[1][0] + n[0][0])) / 2,
                            o = -i * n[0][1];
                        t.scale(150 * i).translate([a, o])
                    }), n)
                }

                function A(t, e, n) {
                    return a(t, (function(n) {
                        var r = +e,
                            i = r / (n[1][1] - n[0][1]),
                            a = -i * n[0][0],
                            o = (r - i * (n[1][1] + n[0][1])) / 2;
                        t.scale(150 * i).translate([a, o])
                    }), n)
                }
            },
            "./node_modules/d3-geo/src/projection/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => p,
                    projectionMutator: () => m
                });
                var r = n("./node_modules/d3-geo/src/clip/antimeridian.js"),
                    i = n("./node_modules/d3-geo/src/clip/circle.js"),
                    a = n("./node_modules/d3-geo/src/clip/rectangle.js"),
                    o = n("./node_modules/d3-geo/src/compose.js"),
                    s = n("./node_modules/d3-geo/src/identity.js"),
                    l = n("./node_modules/d3-geo/src/math.js"),
                    A = n("./node_modules/d3-geo/src/rotation.js"),
                    c = n("./node_modules/d3-geo/src/transform.js"),
                    u = n("./node_modules/d3-geo/src/projection/fit.js"),
                    h = n("./node_modules/d3-geo/src/projection/resample.js"),
                    d = (0, c.transformer)({
                        point: function(t, e) {
                            this.stream.point(t * l.radians, e * l.radians)
                        }
                    });

                function f(t, e, n, r, i, a) {
                    if (!a) return function(t, e, n, r, i) {
                        function a(a, o) {
                            return [e + t * (a *= r), n - t * (o *= i)]
                        }
                        return a.invert = function(a, o) {
                            return [(a - e) / t * r, (n - o) / t * i]
                        }, a
                    }(t, e, n, r, i);
                    var o = (0, l.cos)(a),
                        s = (0, l.sin)(a),
                        A = o * t,
                        c = s * t,
                        u = o / t,
                        h = s / t,
                        d = (s * n - o * e) / t,
                        f = (s * e + o * n) / t;

                    function p(t, a) {
                        return [A * (t *= r) - c * (a *= i) + e, n - c * t - A * a]
                    }
                    return p.invert = function(t, e) {
                        return [r * (u * t - h * e + d), i * (f - h * t - u * e)]
                    }, p
                }

                function p(t) {
                    return m((function() {
                        return t
                    }))()
                }

                function m(t) {
                    var e, n, p, m, g, v, _, y, x, b, M = 150,
                        w = 480,
                        S = 250,
                        E = 0,
                        T = 0,
                        C = 0,
                        R = 0,
                        P = 0,
                        L = 0,
                        D = 1,
                        I = 1,
                        O = null,
                        B = r.default,
                        q = null,
                        U = s.default,
                        N = .5;

                    function k(t) {
                        return y(t[0] * l.radians, t[1] * l.radians)
                    }

                    function F(t) {
                        return (t = y.invert(t[0], t[1])) && [t[0] * l.degrees, t[1] * l.degrees]
                    }

                    function z() {
                        var t = f(M, 0, 0, D, I, L).apply(null, e(E, T)),
                            r = f(M, w - t[0], S - t[1], D, I, L);
                        return n = (0, A.rotateRadians)(C, R, P), _ = (0, o.default)(e, r), y = (0, o.default)(n, _), v = (0, h.default)(_, N), G()
                    }

                    function G() {
                        return x = b = null, k
                    }
                    return k.stream = function(t) {
                            return x && b === t ? x : x = d(function(t) {
                                return (0, c.transformer)({
                                    point: function(e, n) {
                                        var r = t(e, n);
                                        return this.stream.point(r[0], r[1])
                                    }
                                })
                            }(n)(B(v(U(b = t)))))
                        }, k.preclip = function(t) {
                            return arguments.length ? (B = t, O = void 0, G()) : B
                        }, k.postclip = function(t) {
                            return arguments.length ? (U = t, q = p = m = g = null, G()) : U
                        }, k.clipAngle = function(t) {
                            return arguments.length ? (B = +t ? (0, i.default)(O = t * l.radians) : (O = null, r.default), G()) : O * l.degrees
                        }, k.clipExtent = function(t) {
                            return arguments.length ? (U = null == t ? (q = p = m = g = null, s.default) : (0, a.default)(q = +t[0][0], p = +t[0][1], m = +t[1][0], g = +t[1][1]), G()) : null == q ? null : [
                                [q, p],
                                [m, g]
                            ]
                        }, k.scale = function(t) {
                            return arguments.length ? (M = +t, z()) : M
                        }, k.translate = function(t) {
                            return arguments.length ? (w = +t[0], S = +t[1], z()) : [w, S]
                        }, k.center = function(t) {
                            return arguments.length ? (E = t[0] % 360 * l.radians, T = t[1] % 360 * l.radians, z()) : [E * l.degrees, T * l.degrees]
                        }, k.rotate = function(t) {
                            return arguments.length ? (C = t[0] % 360 * l.radians, R = t[1] % 360 * l.radians, P = t.length > 2 ? t[2] % 360 * l.radians : 0, z()) : [C * l.degrees, R * l.degrees, P * l.degrees]
                        }, k.angle = function(t) {
                            return arguments.length ? (L = t % 360 * l.radians, z()) : L * l.degrees
                        }, k.reflectX = function(t) {
                            return arguments.length ? (D = t ? -1 : 1, z()) : D < 0
                        }, k.reflectY = function(t) {
                            return arguments.length ? (I = t ? -1 : 1, z()) : I < 0
                        }, k.precision = function(t) {
                            return arguments.length ? (v = (0, h.default)(_, N = t * t), G()) : (0, l.sqrt)(N)
                        }, k.fitExtent = function(t, e) {
                            return (0, u.fitExtent)(k, t, e)
                        }, k.fitSize = function(t, e) {
                            return (0, u.fitSize)(k, t, e)
                        }, k.fitWidth = function(t, e) {
                            return (0, u.fitWidth)(k, t, e)
                        }, k.fitHeight = function(t, e) {
                            return (0, u.fitHeight)(k, t, e)
                        },
                        function() {
                            return e = t.apply(this, arguments), k.invert = e.invert && F, z()
                        }
                }
            },
            "./node_modules/d3-geo/src/projection/resample.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/d3-geo/src/cartesian.js"),
                    i = n("./node_modules/d3-geo/src/math.js"),
                    a = n("./node_modules/d3-geo/src/transform.js"),
                    o = 16,
                    s = (0, i.cos)(30 * i.radians);

                function l(t, e) {
                    return +e ? function(t, e) {
                        function n(r, a, o, l, A, c, u, h, d, f, p, m, g, v) {
                            var _ = u - r,
                                y = h - a,
                                x = _ * _ + y * y;
                            if (x > 4 * e && g--) {
                                var b = l + f,
                                    M = A + p,
                                    w = c + m,
                                    S = (0, i.sqrt)(b * b + M * M + w * w),
                                    E = (0, i.asin)(w /= S),
                                    T = (0, i.abs)((0, i.abs)(w) - 1) < i.epsilon || (0, i.abs)(o - d) < i.epsilon ? (o + d) / 2 : (0, i.atan2)(M, b),
                                    C = t(T, E),
                                    R = C[0],
                                    P = C[1],
                                    L = R - r,
                                    D = P - a,
                                    I = y * L - _ * D;
                                (I * I / x > e || (0, i.abs)((_ * L + y * D) / x - .5) > .3 || l * f + A * p + c * m < s) && (n(r, a, o, l, A, c, R, P, T, b /= S, M /= S, w, g, v), v.point(R, P), n(R, P, T, b, M, w, u, h, d, f, p, m, g, v))
                            }
                        }
                        return function(e) {
                            var i, a, s, l, A, c, u, h, d, f, p, m, g = {
                                point: v,
                                lineStart: _,
                                lineEnd: x,
                                polygonStart: function() {
                                    e.polygonStart(), g.lineStart = b
                                },
                                polygonEnd: function() {
                                    e.polygonEnd(), g.lineStart = _
                                }
                            };

                            function v(n, r) {
                                n = t(n, r), e.point(n[0], n[1])
                            }

                            function _() {
                                h = NaN, g.point = y, e.lineStart()
                            }

                            function y(i, a) {
                                var s = (0, r.cartesian)([i, a]),
                                    l = t(i, a);
                                n(h, d, u, f, p, m, h = l[0], d = l[1], u = i, f = s[0], p = s[1], m = s[2], o, e), e.point(h, d)
                            }

                            function x() {
                                g.point = v, e.lineEnd()
                            }

                            function b() {
                                _(), g.point = M, g.lineEnd = w
                            }

                            function M(t, e) {
                                y(i = t, e), a = h, s = d, l = f, A = p, c = m, g.point = y
                            }

                            function w() {
                                n(h, d, u, f, p, m, a, s, i, l, A, c, o, e), g.lineEnd = x, x()
                            }
                            return g
                        }
                    }(t, e) : function(t) {
                        return (0, a.transformer)({
                            point: function(e, n) {
                                e = t(e, n), this.stream.point(e[0], e[1])
                            }
                        })
                    }(t)
                }
            },
            "./node_modules/d3-geo/src/projection/stereographic.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s,
                    stereographicRaw: () => o
                });
                var r = n("./node_modules/d3-geo/src/math.js"),
                    i = n("./node_modules/d3-geo/src/projection/azimuthal.js"),
                    a = n("./node_modules/d3-geo/src/projection/index.js");

                function o(t, e) {
                    var n = (0, r.cos)(e),
                        i = 1 + (0, r.cos)(t) * n;
                    return [n * (0, r.sin)(t) / i, (0, r.sin)(e) / i]
                }

                function s() {
                    return (0, a.default)(o).scale(250).clipAngle(142)
                }
                o.invert = (0, i.azimuthalInvert)((function(t) {
                    return 2 * (0, r.atan)(t)
                }))
            },
            "./node_modules/d3-geo/src/rotation.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => c,
                    rotateRadians: () => o
                });
                var r = n("./node_modules/d3-geo/src/compose.js"),
                    i = n("./node_modules/d3-geo/src/math.js");

                function a(t, e) {
                    return (0, i.abs)(t) > i.pi && (t -= Math.round(t / i.tau) * i.tau), [t, e]
                }

                function o(t, e, n) {
                    return (t %= i.tau) ? e || n ? (0, r.default)(l(t), A(e, n)) : l(t) : e || n ? A(e, n) : a
                }

                function s(t) {
                    return function(e, n) {
                        return e += t, (0, i.abs)(e) > i.pi && (e -= Math.round(e / i.tau) * i.tau), [e, n]
                    }
                }

                function l(t) {
                    var e = s(t);
                    return e.invert = s(-t), e
                }

                function A(t, e) {
                    var n = (0, i.cos)(t),
                        r = (0, i.sin)(t),
                        a = (0, i.cos)(e),
                        o = (0, i.sin)(e);

                    function s(t, e) {
                        var s = (0, i.cos)(e),
                            l = (0, i.cos)(t) * s,
                            A = (0, i.sin)(t) * s,
                            c = (0, i.sin)(e),
                            u = c * n + l * r;
                        return [(0, i.atan2)(A * a - u * o, l * n - c * r), (0, i.asin)(u * a + A * o)]
                    }
                    return s.invert = function(t, e) {
                        var s = (0, i.cos)(e),
                            l = (0, i.cos)(t) * s,
                            A = (0, i.sin)(t) * s,
                            c = (0, i.sin)(e),
                            u = c * a - A * o;
                        return [(0, i.atan2)(A * a + c * o, l * n + u * r), (0, i.asin)(u * n - l * r)]
                    }, s
                }

                function c(t) {
                    function e(e) {
                        return (e = t(e[0] * i.radians, e[1] * i.radians))[0] *= i.degrees, e[1] *= i.degrees, e
                    }
                    return t = o(t[0] * i.radians, t[1] * i.radians, t.length > 2 ? t[2] * i.radians : 0), e.invert = function(e) {
                        return (e = t.invert(e[0] * i.radians, e[1] * i.radians))[0] *= i.degrees, e[1] *= i.degrees, e
                    }, e
                }
                a.invert = a
            },
            "./node_modules/d3-geo/src/stream.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    t && a.hasOwnProperty(t.type) && a[t.type](t, e)
                }
                n.r(e), n.d(e, {
                    default: () => l
                });
                var i = {
                        Feature: function(t, e) {
                            r(t.geometry, e)
                        },
                        FeatureCollection: function(t, e) {
                            for (var n = t.features, i = -1, a = n.length; ++i < a;) r(n[i].geometry, e)
                        }
                    },
                    a = {
                        Sphere: function(t, e) {
                            e.sphere()
                        },
                        Point: function(t, e) {
                            t = t.coordinates, e.point(t[0], t[1], t[2])
                        },
                        MultiPoint: function(t, e) {
                            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) t = n[r], e.point(t[0], t[1], t[2])
                        },
                        LineString: function(t, e) {
                            o(t.coordinates, e, 0)
                        },
                        MultiLineString: function(t, e) {
                            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) o(n[r], e, 0)
                        },
                        Polygon: function(t, e) {
                            s(t.coordinates, e)
                        },
                        MultiPolygon: function(t, e) {
                            for (var n = t.coordinates, r = -1, i = n.length; ++r < i;) s(n[r], e)
                        },
                        GeometryCollection: function(t, e) {
                            for (var n = t.geometries, i = -1, a = n.length; ++i < a;) r(n[i], e)
                        }
                    };

                function o(t, e, n) {
                    var r, i = -1,
                        a = t.length - n;
                    for (e.lineStart(); ++i < a;) r = t[i], e.point(r[0], r[1], r[2]);
                    e.lineEnd()
                }

                function s(t, e) {
                    var n = -1,
                        r = t.length;
                    for (e.polygonStart(); ++n < r;) o(t[n], e, 1);
                    e.polygonEnd()
                }

                function l(t, e) {
                    t && i.hasOwnProperty(t.type) ? i[t.type](t, e) : r(t, e)
                }
            },
            "./node_modules/d3-geo/src/transform.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return {
                        stream: i(t)
                    }
                }

                function i(t) {
                    return function(e) {
                        var n = new a;
                        for (var r in t) n[r] = t[r];
                        return n.stream = e, n
                    }
                }

                function a() {}
                n.r(e), n.d(e, {
                    default: () => r,
                    transformer: () => i
                }), a.prototype = {
                    constructor: a,
                    point: function(t, e) {
                        this.stream.point(t, e)
                    },
                    sphere: function() {
                        this.stream.sphere()
                    },
                    lineStart: function() {
                        this.stream.lineStart()
                    },
                    lineEnd: function() {
                        this.stream.lineEnd()
                    },
                    polygonStart: function() {
                        this.stream.polygonStart()
                    },
                    polygonEnd: function() {
                        this.stream.polygonEnd()
                    }
                }
            },
            "./node_modules/d3-interpolate/src/array.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a,
                    genericArray: () => o
                });
                var r = n("./node_modules/d3-interpolate/src/value.js"),
                    i = n("./node_modules/d3-interpolate/src/numberArray.js");

                function a(t, e) {
                    return ((0, i.isNumberArray)(e) ? i.default : o)(t, e)
                }

                function o(t, e) {
                    var n, i = e ? e.length : 0,
                        a = t ? Math.min(i, t.length) : 0,
                        o = new Array(a),
                        s = new Array(i);
                    for (n = 0; n < a; ++n) o[n] = (0, r.default)(t[n], e[n]);
                    for (; n < i; ++n) s[n] = e[n];
                    return function(t) {
                        for (n = 0; n < a; ++n) s[n] = o[n](t);
                        return s
                    }
                }
            },
            "./node_modules/d3-interpolate/src/basis.js": (t, e, n) => {
                "use strict";

                function r(t, e, n, r, i) {
                    var a = t * t,
                        o = a * t;
                    return ((1 - 3 * t + 3 * a - o) * e + (4 - 6 * a + 3 * o) * n + (1 + 3 * t + 3 * a - 3 * o) * r + o * i) / 6
                }

                function i(t) {
                    var e = t.length - 1;
                    return function(n) {
                        var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, e - 1) : Math.floor(n * e),
                            a = t[i],
                            o = t[i + 1],
                            s = i > 0 ? t[i - 1] : 2 * a - o,
                            l = i < e - 1 ? t[i + 2] : 2 * o - a;
                        return r((n - i / e) * e, s, a, o, l)
                    }
                }
                n.r(e), n.d(e, {
                    basis: () => r,
                    default: () => i
                })
            },
            "./node_modules/d3-interpolate/src/basisClosed.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-interpolate/src/basis.js");

                function i(t) {
                    var e = t.length;
                    return function(n) {
                        var i = Math.floor(((n %= 1) < 0 ? ++n : n) * e),
                            a = t[(i + e - 1) % e],
                            o = t[i % e],
                            s = t[(i + 1) % e],
                            l = t[(i + 2) % e];
                        return (0, r.basis)((n - i / e) * e, a, o, s, l)
                    }
                }
            },
            "./node_modules/d3-interpolate/src/color.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s,
                    gamma: () => o,
                    hue: () => a
                });
                var r = n("./node_modules/d3-interpolate/src/constant.js");

                function i(t, e) {
                    return function(n) {
                        return t + n * e
                    }
                }

                function a(t, e) {
                    var n = e - t;
                    return n ? i(t, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : (0, r.default)(isNaN(t) ? e : t)
                }

                function o(t) {
                    return 1 == (t = +t) ? s : function(e, n) {
                        return n - e ? function(t, e, n) {
                            return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n,
                                function(r) {
                                    return Math.pow(t + r * e, n)
                                }
                        }(e, n, t) : (0, r.default)(isNaN(e) ? n : e)
                    }
                }

                function s(t, e) {
                    var n = e - t;
                    return n ? i(t, n) : (0, r.default)(isNaN(t) ? e : t)
                }
            },
            "./node_modules/d3-interpolate/src/constant.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                const r = t => () => t
            },
            "./node_modules/d3-interpolate/src/date.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    var n = new Date;
                    return t = +t, e = +e,
                        function(r) {
                            return n.setTime(t * (1 - r) + e * r), n
                        }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-interpolate/src/number.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    return t = +t, e = +e,
                        function(n) {
                            return t * (1 - n) + e * n
                        }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-interpolate/src/numberArray.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    e || (e = []);
                    var n, r = t ? Math.min(e.length, t.length) : 0,
                        i = e.slice();
                    return function(a) {
                        for (n = 0; n < r; ++n) i[n] = t[n] * (1 - a) + e[n] * a;
                        return i
                    }
                }

                function i(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                }
                n.r(e), n.d(e, {
                    default: () => r,
                    isNumberArray: () => i
                })
            },
            "./node_modules/d3-interpolate/src/object.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/d3-interpolate/src/value.js");

                function i(t, e) {
                    var n, i = {},
                        a = {};
                    for (n in null !== t && "object" == typeof t || (t = {}), null !== e && "object" == typeof e || (e = {}), e) n in t ? i[n] = (0, r.default)(t[n], e[n]) : a[n] = e[n];
                    return function(t) {
                        for (n in i) a[n] = i[n](t);
                        return a
                    }
                }
            },
            "./node_modules/d3-interpolate/src/rgb.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s,
                    rgbBasis: () => A,
                    rgbBasisClosed: () => c
                });
                var r = n("./node_modules/d3-color/src/color.js"),
                    i = n("./node_modules/d3-interpolate/src/basis.js"),
                    a = n("./node_modules/d3-interpolate/src/basisClosed.js"),
                    o = n("./node_modules/d3-interpolate/src/color.js");
                const s = function t(e) {
                    var n = (0, o.gamma)(e);

                    function i(t, e) {
                        var i = n((t = (0, r.rgb)(t)).r, (e = (0, r.rgb)(e)).r),
                            a = n(t.g, e.g),
                            s = n(t.b, e.b),
                            l = (0, o.default)(t.opacity, e.opacity);
                        return function(e) {
                            return t.r = i(e), t.g = a(e), t.b = s(e), t.opacity = l(e), t + ""
                        }
                    }
                    return i.gamma = t, i
                }(1);

                function l(t) {
                    return function(e) {
                        var n, i, a = e.length,
                            o = new Array(a),
                            s = new Array(a),
                            l = new Array(a);
                        for (n = 0; n < a; ++n) i = (0, r.rgb)(e[n]), o[n] = i.r || 0, s[n] = i.g || 0, l[n] = i.b || 0;
                        return o = t(o), s = t(s), l = t(l), i.opacity = 1,
                            function(t) {
                                return i.r = o(t), i.g = s(t), i.b = l(t), i + ""
                            }
                    }
                }
                var A = l(i.default),
                    c = l(a.default)
            },
            "./node_modules/d3-interpolate/src/round.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    return t = +t, e = +e,
                        function(n) {
                            return Math.round(t * (1 - n) + e * n)
                        }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-interpolate/src/string.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => o
                });
                var r = n("./node_modules/d3-interpolate/src/number.js"),
                    i = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
                    a = new RegExp(i.source, "g");

                function o(t, e) {
                    var n, o, s, l = i.lastIndex = a.lastIndex = 0,
                        A = -1,
                        c = [],
                        u = [];
                    for (t += "", e += "";
                        (n = i.exec(t)) && (o = a.exec(e));)(s = o.index) > l && (s = e.slice(l, s), c[A] ? c[A] += s : c[++A] = s), (n = n[0]) === (o = o[0]) ? c[A] ? c[A] += o : c[++A] = o : (c[++A] = null, u.push({
                        i: A,
                        x: (0, r.default)(n, o)
                    })), l = a.lastIndex;
                    return l < e.length && (s = e.slice(l), c[A] ? c[A] += s : c[++A] = s), c.length < 2 ? u[0] ? function(t) {
                        return function(e) {
                            return t(e) + ""
                        }
                    }(u[0].x) : function(t) {
                        return function() {
                            return t
                        }
                    }(e) : (e = u.length, function(t) {
                        for (var n, r = 0; r < e; ++r) c[(n = u[r]).i] = n.x(t);
                        return c.join("")
                    })
                }
            },
            "./node_modules/d3-interpolate/src/value.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => h
                });
                var r = n("./node_modules/d3-color/src/color.js"),
                    i = n("./node_modules/d3-interpolate/src/rgb.js"),
                    a = n("./node_modules/d3-interpolate/src/array.js"),
                    o = n("./node_modules/d3-interpolate/src/date.js"),
                    s = n("./node_modules/d3-interpolate/src/number.js"),
                    l = n("./node_modules/d3-interpolate/src/object.js"),
                    A = n("./node_modules/d3-interpolate/src/string.js"),
                    c = n("./node_modules/d3-interpolate/src/constant.js"),
                    u = n("./node_modules/d3-interpolate/src/numberArray.js");

                function h(t, e) {
                    var n, h = typeof e;
                    return null == e || "boolean" === h ? (0, c.default)(e) : ("number" === h ? s.default : "string" === h ? (n = (0, r.default)(e)) ? (e = n, i.default) : A.default : e instanceof r.default ? i.default : e instanceof Date ? o.default : (0, u.isNumberArray)(e) ? u.default : Array.isArray(e) ? a.genericArray : "function" != typeof e.valueOf && "function" != typeof e.toString || isNaN(e) ? l.default : s.default)(t, e)
                }
            },
            "./node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - 14825.05 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + 707.56 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - 6838.66 * t))))))) + ")"
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-scale/src/constant.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return function() {
                        return t
                    }
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-scale/src/continuous.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    copy: () => f,
                    default: () => m,
                    identity: () => c,
                    transformer: () => p
                });
                var r = n("./node_modules/d3-array/src/bisect.js"),
                    i = n("./node_modules/d3-interpolate/src/value.js"),
                    a = n("./node_modules/d3-interpolate/src/number.js"),
                    o = n("./node_modules/d3-interpolate/src/round.js"),
                    s = n("./node_modules/d3-scale/src/constant.js"),
                    l = n("./node_modules/d3-scale/src/number.js"),
                    A = [0, 1];

                function c(t) {
                    return t
                }

                function u(t, e) {
                    return (e -= t = +t) ? function(n) {
                        return (n - t) / e
                    } : (0, s.default)(isNaN(e) ? NaN : .5)
                }

                function h(t, e, n) {
                    var r = t[0],
                        i = t[1],
                        a = e[0],
                        o = e[1];
                    return i < r ? (r = u(i, r), a = n(o, a)) : (r = u(r, i), a = n(a, o)),
                        function(t) {
                            return a(r(t))
                        }
                }

                function d(t, e, n) {
                    var i = Math.min(t.length, e.length) - 1,
                        a = new Array(i),
                        o = new Array(i),
                        s = -1;
                    for (t[i] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < i;) a[s] = u(t[s], t[s + 1]), o[s] = n(e[s], e[s + 1]);
                    return function(e) {
                        var n = (0, r.default)(t, e, 1, i) - 1;
                        return o[n](a[n](e))
                    }
                }

                function f(t, e) {
                    return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())
                }

                function p() {
                    var t, e, n, r, s, u, f = A,
                        p = A,
                        m = i.default,
                        g = c;

                    function v() {
                        var t, e, n, i = Math.min(f.length, p.length);
                        return g !== c && (t = f[0], e = f[i - 1], t > e && (n = t, t = e, e = n), g = function(n) {
                            return Math.max(t, Math.min(e, n))
                        }), r = i > 2 ? d : h, s = u = null, _
                    }

                    function _(e) {
                        return null == e || isNaN(e = +e) ? n : (s || (s = r(f.map(t), p, m)))(t(g(e)))
                    }
                    return _.invert = function(n) {
                            return g(e((u || (u = r(p, f.map(t), a.default)))(n)))
                        }, _.domain = function(t) {
                            return arguments.length ? (f = Array.from(t, l.default), v()) : f.slice()
                        }, _.range = function(t) {
                            return arguments.length ? (p = Array.from(t), v()) : p.slice()
                        }, _.rangeRound = function(t) {
                            return p = Array.from(t), m = o.default, v()
                        }, _.clamp = function(t) {
                            return arguments.length ? (g = !!t || c, v()) : g !== c
                        }, _.interpolate = function(t) {
                            return arguments.length ? (m = t, v()) : m
                        }, _.unknown = function(t) {
                            return arguments.length ? (n = t, _) : n
                        },
                        function(n, r) {
                            return t = n, e = r, v()
                        }
                }

                function m() {
                    return p()(c, c)
                }
            },
            "./node_modules/d3-scale/src/init.js": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    switch (arguments.length) {
                        case 0:
                            break;
                        case 1:
                            this.range(t);
                            break;
                        default:
                            this.range(e).domain(t)
                    }
                    return this
                }

                function i(t, e) {
                    switch (arguments.length) {
                        case 0:
                            break;
                        case 1:
                            "function" == typeof t ? this.interpolator(t) : this.range(t);
                            break;
                        default:
                            this.domain(t), "function" == typeof e ? this.interpolator(e) : this.range(e)
                    }
                    return this
                }
                n.r(e), n.d(e, {
                    initInterpolator: () => i,
                    initRange: () => r
                })
            },
            "./node_modules/d3-scale/src/linear.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l,
                    linearish: () => s
                });
                var r = n("./node_modules/d3-array/src/ticks.js"),
                    i = n("./node_modules/d3-scale/src/continuous.js"),
                    a = n("./node_modules/d3-scale/src/init.js"),
                    o = n("./node_modules/d3-scale/src/tickFormat.js");

                function s(t) {
                    var e = t.domain;
                    return t.ticks = function(t) {
                        var n = e();
                        return (0, r.default)(n[0], n[n.length - 1], null == t ? 10 : t)
                    }, t.tickFormat = function(t, n) {
                        var r = e();
                        return (0, o.default)(r[0], r[r.length - 1], null == t ? 10 : t, n)
                    }, t.nice = function(n) {
                        null == n && (n = 10);
                        var i, a, o = e(),
                            s = 0,
                            l = o.length - 1,
                            A = o[s],
                            c = o[l],
                            u = 10;
                        for (c < A && (a = A, A = c, c = a, a = s, s = l, l = a); u-- > 0;) {
                            if ((a = (0, r.tickIncrement)(A, c, n)) === i) return o[s] = A, o[l] = c, e(o);
                            if (a > 0) A = Math.floor(A / a) * a, c = Math.ceil(c / a) * a;
                            else {
                                if (!(a < 0)) break;
                                A = Math.ceil(A * a) / a, c = Math.floor(c * a) / a
                            }
                            i = a
                        }
                        return t
                    }, t
                }

                function l() {
                    var t = (0, i.default)();
                    return t.copy = function() {
                        return (0, i.copy)(t, l())
                    }, a.initRange.apply(t, arguments), s(t)
                }
            },
            "./node_modules/d3-scale/src/number.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return +t
                }
                n.r(e), n.d(e, {
                    default: () => r
                })
            },
            "./node_modules/d3-scale/src/tickFormat.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => A
                });
                var r = n("./node_modules/d3-array/src/ticks.js"),
                    i = n("./node_modules/d3-format/src/formatSpecifier.js"),
                    a = n("./node_modules/d3-format/src/precisionPrefix.js"),
                    o = n("./node_modules/d3-format/src/defaultLocale.js"),
                    s = n("./node_modules/d3-format/src/precisionRound.js"),
                    l = n("./node_modules/d3-format/src/precisionFixed.js");

                function A(t, e, n, A) {
                    var c, u = (0, r.tickStep)(t, e, n);
                    switch ((A = (0, i.default)(null == A ? ",f" : A)).type) {
                        case "s":
                            var h = Math.max(Math.abs(t), Math.abs(e));
                            return null != A.precision || isNaN(c = (0, a.default)(u, h)) || (A.precision = c), (0, o.formatPrefix)(A, h);
                        case "":
                        case "e":
                        case "g":
                        case "p":
                        case "r":
                            null != A.precision || isNaN(c = (0, s.default)(u, Math.max(Math.abs(t), Math.abs(e)))) || (A.precision = c - ("e" === A.type));
                            break;
                        case "f":
                        case "%":
                            null != A.precision || isNaN(c = (0, l.default)(u)) || (A.precision = c - 2 * ("%" === A.type))
                    }
                    return (0, o.format)(A)
                }
            },
            "./node_modules/data-joint/dist/data-joint.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => u
                });
                var r = n("./node_modules/index-array-by/dist/index-array-by.mjs");

                function i(t, e) {
                    var n = Object.keys(t);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(t);
                        e && (r = r.filter((function(e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        }))), n.push.apply(n, r)
                    }
                    return n
                }

                function a(t, e, n) {
                    return (e = function(t) {
                        var e = function(t, e) {
                            if ("object" != typeof t || null === t) return t;
                            var n = t[Symbol.toPrimitive];
                            if (void 0 !== n) {
                                var r = n.call(t, "string");
                                if ("object" != typeof r) return r;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }
                            return String(t)
                        }(t);
                        return "symbol" == typeof e ? e : String(e)
                    }(e)) in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                function o(t, e) {
                    return function(t) {
                        if (Array.isArray(t)) return t
                    }(t) || function(t, e) {
                        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (null != n) {
                            var r, i, a, o, s = [],
                                l = !0,
                                A = !1;
                            try {
                                if (a = (n = n.call(t)).next, 0 === e) {
                                    if (Object(n) !== n) return;
                                    l = !1
                                } else
                                    for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                            } catch (t) {
                                A = !0, i = t
                            } finally {
                                try {
                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                } finally {
                                    if (A) throw i
                                }
                            }
                            return s
                        }
                    }(t, e) || l(t, e) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function s(t) {
                    return function(t) {
                        if (Array.isArray(t)) return A(t)
                    }(t) || function(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || l(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function l(t, e) {
                    if (t) {
                        if ("string" == typeof t) return A(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? A(t, e) : void 0
                    }
                }

                function A(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }
                var c = ["createObj", "updateObj", "exitObj", "objBindAttr", "dataBindAttr"];

                function u(t, e, n, l, A) {
                    var u = A.createObj,
                        h = void 0 === u ? function(t) {
                            return {}
                        } : u,
                        d = A.updateObj,
                        f = void 0 === d ? function(t, e) {} : d,
                        p = A.exitObj,
                        m = void 0 === p ? function(t) {} : p,
                        g = A.objBindAttr,
                        v = void 0 === g ? "__obj" : g,
                        _ = A.dataBindAttr,
                        y = void 0 === _ ? "__data" : _,
                        x = function(t, e) {
                            if (null == t) return {};
                            var n, r, i = function(t, e) {
                                if (null == t) return {};
                                var n, r, i = {},
                                    a = Object.keys(t);
                                for (r = 0; r < a.length; r++) n = a[r], e.indexOf(n) >= 0 || (i[n] = t[n]);
                                return i
                            }(t, e);
                            if (Object.getOwnPropertySymbols) {
                                var a = Object.getOwnPropertySymbols(t);
                                for (r = 0; r < a.length; r++) n = a[r], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
                            }
                            return i
                        }(A, c),
                        b = function(t, e, n) {
                            var i = n.objBindAttr,
                                l = void 0 === i ? "__obj" : i,
                                A = n.dataBindAttr,
                                c = void 0 === A ? "__data" : A,
                                u = n.idAccessor,
                                h = n.purge,
                                d = void 0 !== h && h,
                                f = function(t) {
                                    return t.hasOwnProperty(c)
                                },
                                p = e.filter((function(t) {
                                    return !f(t)
                                })),
                                m = e.filter(f).map((function(t) {
                                    return t[c]
                                })),
                                g = d ? {
                                    enter: t,
                                    exit: m,
                                    update: []
                                } : function(t, e, n) {
                                    var i = {
                                        enter: [],
                                        update: [],
                                        exit: []
                                    };
                                    if (n) {
                                        var a = (0, r.default)(t, n, !1),
                                            l = (0, r.default)(e, n, !1),
                                            A = Object.assign({}, a, l);
                                        Object.entries(A).forEach((function(t) {
                                            var e = o(t, 2),
                                                n = e[0],
                                                r = e[1],
                                                s = a.hasOwnProperty(n) ? l.hasOwnProperty(n) ? "update" : "exit" : "enter";
                                            i[s].push("update" === s ? [a[n], l[n]] : r)
                                        }))
                                    } else {
                                        var c = new Set(t),
                                            u = new Set(e);
                                        new Set([].concat(s(c), s(u))).forEach((function(t) {
                                            var e = c.has(t) ? u.has(t) ? "update" : "exit" : "enter";
                                            i[e].push("update" === e ? [t, t] : t)
                                        }))
                                    }
                                    return i
                                }(m, t, u);
                            return g.update = g.update.map((function(t) {
                                var e = o(t, 2),
                                    n = e[0],
                                    r = e[1];
                                return n !== r && (r[l] = n[l], r[l][c] = r), r
                            })), g.exit = g.exit.concat(p.map((function(t) {
                                return a({}, l, t)
                            }))), g
                        }(t, e, function(t) {
                            for (var e = 1; e < arguments.length; e++) {
                                var n = null != arguments[e] ? arguments[e] : {};
                                e % 2 ? i(Object(n), !0).forEach((function(e) {
                                    a(t, e, n[e])
                                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i(Object(n)).forEach((function(e) {
                                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                                }))
                            }
                            return t
                        }({
                            objBindAttr: v,
                            dataBindAttr: y
                        }, x)),
                        M = b.enter,
                        w = b.update;
                    b.exit.forEach((function(t) {
                        var e = t[v];
                        delete t[v], m(e), l(e)
                    }));
                    var S = function(t) {
                        var e = [];
                        return t.forEach((function(t) {
                            var n = h(t);
                            n && (n[y] = t, t[v] = n, e.push(n))
                        })), e
                    }(M);
                    ! function(t) {
                        t.forEach((function(t) {
                            var e = t[v];
                            e && (e[y] = t, f(e, t))
                        }))
                    }([].concat(s(M), s(w))), S.forEach(n)
                }
            },
            "./node_modules/delaunator/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => o
                });
                var r = n("./node_modules/robust-predicates/index.js");
                const i = Math.pow(2, -52),
                    a = new Uint32Array(512);
                class o {
                    static from(t, e = h, n = d) {
                        const r = t.length,
                            i = new Float64Array(2 * r);
                        for (let a = 0; a < r; a++) {
                            const r = t[a];
                            i[2 * a] = e(r), i[2 * a + 1] = n(r)
                        }
                        return new o(i)
                    }
                    constructor(t) {
                        const e = t.length >> 1;
                        if (e > 0 && "number" != typeof t[0]) throw new Error("Expected coords to contain numbers.");
                        this.coords = t;
                        const n = Math.max(2 * e - 5, 0);
                        this._triangles = new Uint32Array(3 * n), this._halfedges = new Int32Array(3 * n), this._hashSize = Math.ceil(Math.sqrt(e)), this._hullPrev = new Uint32Array(e), this._hullNext = new Uint32Array(e), this._hullTri = new Uint32Array(e), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(e), this._dists = new Float64Array(e), this.update()
                    }
                    update() {
                        const {
                            coords: t,
                            _hullPrev: e,
                            _hullNext: n,
                            _hullTri: a,
                            _hullHash: o
                        } = this, l = t.length >> 1;
                        let u = 1 / 0,
                            h = 1 / 0,
                            d = -1 / 0,
                            f = -1 / 0;
                        for (let e = 0; e < l; e++) {
                            const n = t[2 * e],
                                r = t[2 * e + 1];
                            n < u && (u = n), r < h && (h = r), n > d && (d = n), r > f && (f = r), this._ids[e] = e
                        }
                        const p = (u + d) / 2,
                            m = (h + f) / 2;
                        let g, v, _;
                        for (let e = 0, n = 1 / 0; e < l; e++) {
                            const r = s(p, m, t[2 * e], t[2 * e + 1]);
                            r < n && (g = e, n = r)
                        }
                        const y = t[2 * g],
                            x = t[2 * g + 1];
                        for (let e = 0, n = 1 / 0; e < l; e++) {
                            if (e === g) continue;
                            const r = s(y, x, t[2 * e], t[2 * e + 1]);
                            r < n && r > 0 && (v = e, n = r)
                        }
                        let b = t[2 * v],
                            M = t[2 * v + 1],
                            w = 1 / 0;
                        for (let e = 0; e < l; e++) {
                            if (e === g || e === v) continue;
                            const n = A(y, x, b, M, t[2 * e], t[2 * e + 1]);
                            n < w && (_ = e, w = n)
                        }
                        let S = t[2 * _],
                            E = t[2 * _ + 1];
                        if (w === 1 / 0) {
                            for (let e = 0; e < l; e++) this._dists[e] = t[2 * e] - t[0] || t[2 * e + 1] - t[1];
                            c(this._ids, this._dists, 0, l - 1);
                            const e = new Uint32Array(l);
                            let n = 0;
                            for (let t = 0, r = -1 / 0; t < l; t++) {
                                const i = this._ids[t],
                                    a = this._dists[i];
                                a > r && (e[n++] = i, r = a)
                            }
                            return this.hull = e.subarray(0, n), this.triangles = new Uint32Array(0), void(this.halfedges = new Uint32Array(0))
                        }
                        if ((0, r.orient2d)(y, x, b, M, S, E) < 0) {
                            const t = v,
                                e = b,
                                n = M;
                            v = _, b = S, M = E, _ = t, S = e, E = n
                        }
                        const T = function(t, e, n, r, i, a) {
                            const o = n - t,
                                s = r - e,
                                l = i - t,
                                A = a - e,
                                c = o * o + s * s,
                                u = l * l + A * A,
                                h = .5 / (o * A - s * l);
                            return {
                                x: t + (A * c - s * u) * h,
                                y: e + (o * u - l * c) * h
                            }
                        }(y, x, b, M, S, E);
                        this._cx = T.x, this._cy = T.y;
                        for (let e = 0; e < l; e++) this._dists[e] = s(t[2 * e], t[2 * e + 1], T.x, T.y);
                        c(this._ids, this._dists, 0, l - 1), this._hullStart = g;
                        let C = 3;
                        n[g] = e[_] = v, n[v] = e[g] = _, n[_] = e[v] = g, a[g] = 0, a[v] = 1, a[_] = 2, o.fill(-1), o[this._hashKey(y, x)] = g, o[this._hashKey(b, M)] = v, o[this._hashKey(S, E)] = _, this.trianglesLen = 0, this._addTriangle(g, v, _, -1, -1, -1);
                        for (let s, l, A = 0; A < this._ids.length; A++) {
                            const c = this._ids[A],
                                u = t[2 * c],
                                h = t[2 * c + 1];
                            if (A > 0 && Math.abs(u - s) <= i && Math.abs(h - l) <= i) continue;
                            if (s = u, l = h, c === g || c === v || c === _) continue;
                            let d = 0;
                            for (let t = 0, e = this._hashKey(u, h); t < this._hashSize && (d = o[(e + t) % this._hashSize], -1 === d || d === n[d]); t++);
                            d = e[d];
                            let f, p = d;
                            for (; f = n[p], (0, r.orient2d)(u, h, t[2 * p], t[2 * p + 1], t[2 * f], t[2 * f + 1]) >= 0;)
                                if (p = f, p === d) {
                                    p = -1;
                                    break
                                } if (-1 === p) continue;
                            let m = this._addTriangle(p, c, n[p], -1, -1, a[p]);
                            a[c] = this._legalize(m + 2), a[p] = m, C++;
                            let y = n[p];
                            for (; f = n[y], (0, r.orient2d)(u, h, t[2 * y], t[2 * y + 1], t[2 * f], t[2 * f + 1]) < 0;) m = this._addTriangle(y, c, f, a[c], -1, a[y]), a[c] = this._legalize(m + 2), n[y] = y, C--, y = f;
                            if (p === d)
                                for (; f = e[p], (0, r.orient2d)(u, h, t[2 * f], t[2 * f + 1], t[2 * p], t[2 * p + 1]) < 0;) m = this._addTriangle(f, c, p, -1, a[p], a[f]), this._legalize(m + 2), a[f] = m, n[p] = p, C--, p = f;
                            this._hullStart = e[c] = p, n[p] = e[y] = c, n[c] = y, o[this._hashKey(u, h)] = c, o[this._hashKey(t[2 * p], t[2 * p + 1])] = p
                        }
                        this.hull = new Uint32Array(C);
                        for (let t = 0, e = this._hullStart; t < C; t++) this.hull[t] = e, e = n[e];
                        this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen)
                    }
                    _hashKey(t, e) {
                        return Math.floor(function(t, e) {
                            const n = t / (Math.abs(t) + Math.abs(e));
                            return (e > 0 ? 3 - n : 1 + n) / 4
                        }(t - this._cx, e - this._cy) * this._hashSize) % this._hashSize
                    }
                    _legalize(t) {
                        const {
                            _triangles: e,
                            _halfedges: n,
                            coords: r
                        } = this;
                        let i = 0,
                            o = 0;
                        for (;;) {
                            const s = n[t],
                                A = t - t % 3;
                            if (o = A + (t + 2) % 3, -1 === s) {
                                if (0 === i) break;
                                t = a[--i];
                                continue
                            }
                            const c = s - s % 3,
                                u = A + (t + 1) % 3,
                                h = c + (s + 2) % 3,
                                d = e[o],
                                f = e[t],
                                p = e[u],
                                m = e[h];
                            if (l(r[2 * d], r[2 * d + 1], r[2 * f], r[2 * f + 1], r[2 * p], r[2 * p + 1], r[2 * m], r[2 * m + 1])) {
                                e[t] = m, e[s] = d;
                                const r = n[h];
                                if (-1 === r) {
                                    let e = this._hullStart;
                                    do {
                                        if (this._hullTri[e] === h) {
                                            this._hullTri[e] = t;
                                            break
                                        }
                                        e = this._hullPrev[e]
                                    } while (e !== this._hullStart)
                                }
                                this._link(t, r), this._link(s, n[o]), this._link(o, h);
                                const l = c + (s + 1) % 3;
                                i < a.length && (a[i++] = l)
                            } else {
                                if (0 === i) break;
                                t = a[--i]
                            }
                        }
                        return o
                    }
                    _link(t, e) {
                        this._halfedges[t] = e, -1 !== e && (this._halfedges[e] = t)
                    }
                    _addTriangle(t, e, n, r, i, a) {
                        const o = this.trianglesLen;
                        return this._triangles[o] = t, this._triangles[o + 1] = e, this._triangles[o + 2] = n, this._link(o, r), this._link(o + 1, i), this._link(o + 2, a), this.trianglesLen += 3, o
                    }
                }

                function s(t, e, n, r) {
                    const i = t - n,
                        a = e - r;
                    return i * i + a * a
                }

                function l(t, e, n, r, i, a, o, s) {
                    const l = t - o,
                        A = e - s,
                        c = n - o,
                        u = r - s,
                        h = i - o,
                        d = a - s,
                        f = c * c + u * u,
                        p = h * h + d * d;
                    return l * (u * p - f * d) - A * (c * p - f * h) + (l * l + A * A) * (c * d - u * h) < 0
                }

                function A(t, e, n, r, i, a) {
                    const o = n - t,
                        s = r - e,
                        l = i - t,
                        A = a - e,
                        c = o * o + s * s,
                        u = l * l + A * A,
                        h = .5 / (o * A - s * l),
                        d = (A * c - s * u) * h,
                        f = (o * u - l * c) * h;
                    return d * d + f * f
                }

                function c(t, e, n, r) {
                    if (r - n <= 20)
                        for (let i = n + 1; i <= r; i++) {
                            const r = t[i],
                                a = e[r];
                            let o = i - 1;
                            for (; o >= n && e[t[o]] > a;) t[o + 1] = t[o--];
                            t[o + 1] = r
                        } else {
                            let i = n + 1,
                                a = r;
                            u(t, n + r >> 1, i), e[t[n]] > e[t[r]] && u(t, n, r), e[t[i]] > e[t[r]] && u(t, i, r), e[t[n]] > e[t[i]] && u(t, n, i);
                            const o = t[i],
                                s = e[o];
                            for (;;) {
                                do {
                                    i++
                                } while (e[t[i]] < s);
                                do {
                                    a--
                                } while (e[t[a]] > s);
                                if (a < i) break;
                                u(t, i, a)
                            }
                            t[n + 1] = t[a], t[a] = o, r - i + 1 >= a - n ? (c(t, e, i, r), c(t, e, n, a - 1)) : (c(t, e, n, a - 1), c(t, e, i, r))
                        }
                }

                function u(t, e, n) {
                    const r = t[e];
                    t[e] = t[n], t[n] = r
                }

                function h(t) {
                    return t[0]
                }

                function d(t) {
                    return t[1]
                }
            },
            "./node_modules/index-array-by/dist/index-array-by.mjs": (t, e, n) => {
                "use strict";

                function r(t, e) {
                    if (t) {
                        if ("string" == typeof t) return i(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? i(t, e) : void 0
                    }
                }

                function i(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }

                function a(t) {
                    var e = function(t, e) {
                        if ("object" != typeof t || null === t) return t;
                        var n = t[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(t, "string");
                            if ("object" != typeof r) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(t)
                    }(t);
                    return "symbol" == typeof e ? e : String(e)
                }
                n.r(e), n.d(e, {
                    default: () => o
                });
                var o = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                        s = (e instanceof Array ? e.length ? e : [void 0] : [e]).map((function(t) {
                            return {
                                keyAccessor: t,
                                isProp: !(t instanceof Function)
                            }
                        })),
                        l = t.reduce((function(t, e) {
                            var r = t,
                                i = e;
                            return s.forEach((function(t, e) {
                                var o, l = t.keyAccessor;
                                if (t.isProp) {
                                    var A = i,
                                        c = A[l],
                                        u = function(t, e) {
                                            if (null == t) return {};
                                            var n, r, i = function(t, e) {
                                                if (null == t) return {};
                                                var n, r, i = {},
                                                    a = Object.keys(t);
                                                for (r = 0; r < a.length; r++) n = a[r], e.indexOf(n) >= 0 || (i[n] = t[n]);
                                                return i
                                            }(t, e);
                                            if (Object.getOwnPropertySymbols) {
                                                var a = Object.getOwnPropertySymbols(t);
                                                for (r = 0; r < a.length; r++) n = a[r], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
                                            }
                                            return i
                                        }(A, [l].map(a));
                                    o = c, i = u
                                } else o = l(i, e);
                                e + 1 < s.length ? (r.hasOwnProperty(o) || (r[o] = {}), r = r[o]) : n ? (r.hasOwnProperty(o) || (r[o] = []), r[o].push(i)) : r[o] = i
                            })), t
                        }), {});
                    n instanceof Function && function t(e) {
                        var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        r === s.length ? Object.keys(e).forEach((function(t) {
                            return e[t] = n(e[t])
                        })) : Object.values(e).forEach((function(e) {
                            return t(e, r + 1)
                        }))
                    }(l);
                    var A = l;
                    return o && (A = [], function t(e) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        n.length === s.length ? A.push({
                            keys: n,
                            vals: e
                        }) : Object.entries(e).forEach((function(e) {
                            var a, o, s = (o = 2, function(t) {
                                    if (Array.isArray(t)) return t
                                }(a = e) || function(t, e) {
                                    var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                                    if (null != n) {
                                        var r, i, a, o, s = [],
                                            l = !0,
                                            A = !1;
                                        try {
                                            if (a = (n = n.call(t)).next, 0 === e) {
                                                if (Object(n) !== n) return;
                                                l = !1
                                            } else
                                                for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                                        } catch (t) {
                                            A = !0, i = t
                                        } finally {
                                            try {
                                                if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                            } finally {
                                                if (A) throw i
                                            }
                                        }
                                        return s
                                    }
                                }(a, o) || r(a, o) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                }()),
                                l = s[0],
                                A = s[1];
                            return t(A, [].concat(function(t) {
                                return function(t) {
                                    if (Array.isArray(t)) return i(t)
                                }(t) || function(t) {
                                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                                }(t) || r(t) || function() {
                                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                }()
                            }(n), [l]))
                        }))
                    }(l), e instanceof Array && 0 === e.length && 1 === A.length && (A[0].keys = [])), A
                }
            },
            "./node_modules/kapsule/dist/kapsule.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/lodash-es/debounce.js");

                function i(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(i = function(t, e) {
                            if ("object" != typeof t || null === t) return t;
                            var n = t[Symbol.toPrimitive];
                            if (void 0 !== n) {
                                var r = n.call(t, "string");
                                if ("object" != typeof r) return r;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }
                            return String(t)
                        }(r.key)) ? i : String(i)), r)
                    }
                    var i
                }

                function a(t, e, n) {
                    return e && i(t.prototype, e), n && i(t, n), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }

                function o(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }
                var s = a((function t(e, n) {
                    var r = n.default,
                        i = void 0 === r ? null : r,
                        a = n.triggerUpdate,
                        o = void 0 === a || a,
                        s = n.onChange,
                        l = void 0 === s ? function(t, e) {} : s;
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.name = e, this.defaultVal = i, this.triggerUpdate = o, this.onChange = l
                }));

                function l(t) {
                    var e = t.stateInit,
                        n = void 0 === e ? function() {
                            return {}
                        } : e,
                        i = t.props,
                        a = void 0 === i ? {} : i,
                        l = t.methods,
                        A = void 0 === l ? {} : l,
                        c = t.aliases,
                        u = void 0 === c ? {} : c,
                        h = t.init,
                        d = void 0 === h ? function() {} : h,
                        f = t.update,
                        p = void 0 === f ? function() {} : f,
                        m = Object.keys(a).map((function(t) {
                            return new s(t, a[t])
                        }));
                    return function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            e = Object.assign({}, n instanceof Function ? n(t) : n, {
                                initialised: !1
                            }),
                            i = {};

                        function a(e) {
                            return s(e, t), l(), a
                        }
                        var s = function(t, n) {
                                d.call(a, t, e, n), e.initialised = !0
                            },
                            l = (0, r.default)((function() {
                                e.initialised && (p.call(a, e, i), i = {})
                            }), 1);
                        return m.forEach((function(t) {
                            a[t.name] = function(t) {
                                var n = t.name,
                                    r = t.triggerUpdate,
                                    o = void 0 !== r && r,
                                    s = t.onChange,
                                    A = void 0 === s ? function(t, e) {} : s,
                                    c = t.defaultVal,
                                    u = void 0 === c ? null : c;
                                return function(t) {
                                    var r = e[n];
                                    if (!arguments.length) return r;
                                    var s = void 0 === t ? u : t;
                                    return e[n] = s, A.call(a, s, e, r), !i.hasOwnProperty(n) && (i[n] = r), o && l(), a
                                }
                            }(t)
                        })), Object.keys(A).forEach((function(t) {
                            a[t] = function() {
                                for (var n, r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
                                return (n = A[t]).call.apply(n, [a, e].concat(i))
                            }
                        })), Object.entries(u).forEach((function(t) {
                            var e, n, r = (n = 2, function(t) {
                                    if (Array.isArray(t)) return t
                                }(e = t) || function(t, e) {
                                    var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                                    if (null != n) {
                                        var r, i, a, o, s = [],
                                            l = !0,
                                            A = !1;
                                        try {
                                            if (a = (n = n.call(t)).next, 0 === e) {
                                                if (Object(n) !== n) return;
                                                l = !1
                                            } else
                                                for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                                        } catch (t) {
                                            A = !0, i = t
                                        } finally {
                                            try {
                                                if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                            } finally {
                                                if (A) throw i
                                            }
                                        }
                                        return s
                                    }
                                }(e, n) || function(t, e) {
                                    if (t) {
                                        if ("string" == typeof t) return o(t, e);
                                        var n = Object.prototype.toString.call(t).slice(8, -1);
                                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? o(t, e) : void 0
                                    }
                                }(e, n) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                }()),
                                i = r[0],
                                s = r[1];
                            return a[i] = a[s]
                        })), a.resetProps = function() {
                            return m.forEach((function(t) {
                                a[t.name](t.defaultVal)
                            })), a
                        }, a.resetProps(), e._rerender = l, a
                    }
                }
            },
            "./node_modules/lodash-es/_Symbol.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                const r = n("./node_modules/lodash-es/_root.js").default.Symbol
            },
            "./node_modules/lodash-es/_baseGetTag.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => s
                });
                var r = n("./node_modules/lodash-es/_Symbol.js"),
                    i = n("./node_modules/lodash-es/_getRawTag.js"),
                    a = n("./node_modules/lodash-es/_objectToString.js"),
                    o = r.default ? r.default.toStringTag : void 0;
                const s = function(t) {
                    return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : o && o in Object(t) ? (0, i.default)(t) : (0, a.default)(t)
                }
            },
            "./node_modules/lodash-es/_baseTrim.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a
                });
                var r = n("./node_modules/lodash-es/_trimmedEndIndex.js"),
                    i = /^\s+/;
                const a = function(t) {
                    return t ? t.slice(0, (0, r.default)(t) + 1).replace(i, "") : t
                }
            },
            "./node_modules/lodash-es/_freeGlobal.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                const r = "object" == typeof global && global && global.Object === Object && global
            },
            "./node_modules/lodash-es/_getRawTag.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/lodash-es/_Symbol.js"),
                    i = Object.prototype,
                    a = i.hasOwnProperty,
                    o = i.toString,
                    s = r.default ? r.default.toStringTag : void 0;
                const l = function(t) {
                    var e = a.call(t, s),
                        n = t[s];
                    try {
                        t[s] = void 0;
                        var r = !0
                    } catch (t) {}
                    var i = o.call(t);
                    return r && (e ? t[s] = n : delete t[s]), i
                }
            },
            "./node_modules/lodash-es/_objectToString.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = Object.prototype.toString;
                const i = function(t) {
                    return r.call(t)
                }
            },
            "./node_modules/lodash-es/_root.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a
                });
                var r = n("./node_modules/lodash-es/_freeGlobal.js"),
                    i = "object" == typeof self && self && self.Object === Object && self;
                const a = r.default || i || Function("return this")()
            },
            "./node_modules/lodash-es/_trimmedEndIndex.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = /\s/;
                const i = function(t) {
                    for (var e = t.length; e-- && r.test(t.charAt(e)););
                    return e
                }
            },
            "./node_modules/lodash-es/debounce.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => l
                });
                var r = n("./node_modules/lodash-es/isObject.js"),
                    i = n("./node_modules/lodash-es/now.js"),
                    a = n("./node_modules/lodash-es/toNumber.js"),
                    o = Math.max,
                    s = Math.min;
                const l = function(t, e, n) {
                    var l, A, c, u, h, d, f = 0,
                        p = !1,
                        m = !1,
                        g = !0;
                    if ("function" != typeof t) throw new TypeError("Expected a function");

                    function v(e) {
                        var n = l,
                            r = A;
                        return l = A = void 0, f = e, u = t.apply(r, n)
                    }

                    function _(t) {
                        var n = t - d;
                        return void 0 === d || n >= e || n < 0 || m && t - f >= c
                    }

                    function y() {
                        var t = (0, i.default)();
                        if (_(t)) return x(t);
                        h = setTimeout(y, function(t) {
                            var n = e - (t - d);
                            return m ? s(n, c - (t - f)) : n
                        }(t))
                    }

                    function x(t) {
                        return h = void 0, g && l ? v(t) : (l = A = void 0, u)
                    }

                    function b() {
                        var t = (0, i.default)(),
                            n = _(t);
                        if (l = arguments, A = this, d = t, n) {
                            if (void 0 === h) return function(t) {
                                return f = t, h = setTimeout(y, e), p ? v(t) : u
                            }(d);
                            if (m) return clearTimeout(h), h = setTimeout(y, e), v(d)
                        }
                        return void 0 === h && (h = setTimeout(y, e)), u
                    }
                    return e = (0, a.default)(e) || 0, (0, r.default)(n) && (p = !!n.leading, c = (m = "maxWait" in n) ? o((0, a.default)(n.maxWait) || 0, e) : c, g = "trailing" in n ? !!n.trailing : g), b.cancel = function() {
                        void 0 !== h && clearTimeout(h), f = 0, l = d = A = h = void 0
                    }, b.flush = function() {
                        return void 0 === h ? u : x((0, i.default)())
                    }, b
                }
            },
            "./node_modules/lodash-es/isObject.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                const r = function(t) {
                    var e = typeof t;
                    return null != t && ("object" == e || "function" == e)
                }
            },
            "./node_modules/lodash-es/isObjectLike.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => r
                });
                const r = function(t) {
                    return null != t && "object" == typeof t
                }
            },
            "./node_modules/lodash-es/isSymbol.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => a
                });
                var r = n("./node_modules/lodash-es/_baseGetTag.js"),
                    i = n("./node_modules/lodash-es/isObjectLike.js");
                const a = function(t) {
                    return "symbol" == typeof t || (0, i.default)(t) && "[object Symbol]" == (0, r.default)(t)
                }
            },
            "./node_modules/lodash-es/now.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => i
                });
                var r = n("./node_modules/lodash-es/_root.js");
                const i = function() {
                    return r.default.Date.now()
                }
            },
            "./node_modules/lodash-es/toNumber.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => c
                });
                var r = n("./node_modules/lodash-es/_baseTrim.js"),
                    i = n("./node_modules/lodash-es/isObject.js"),
                    a = n("./node_modules/lodash-es/isSymbol.js"),
                    o = /^[-+]0x[0-9a-f]+$/i,
                    s = /^0b[01]+$/i,
                    l = /^0o[0-7]+$/i,
                    A = parseInt;
                const c = function(t) {
                    if ("number" == typeof t) return t;
                    if ((0, a.default)(t)) return NaN;
                    if ((0, i.default)(t)) {
                        var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                        t = (0, i.default)(e) ? e + "" : e
                    }
                    if ("string" != typeof t) return 0 === t ? t : +t;
                    t = (0, r.default)(t);
                    var n = s.test(t);
                    return n || l.test(t) ? A(t.slice(2), n ? 2 : 8) : o.test(t) ? NaN : +t
                }
            },
            "./node_modules/robust-predicates/esm/incircle.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    incircle: () => N,
                    incirclefast: () => k
                });
                var r = n("./node_modules/robust-predicates/esm/util.js");
                const i = (10 + 96 * r.epsilon) * r.epsilon,
                    a = (4 + 48 * r.epsilon) * r.epsilon,
                    o = (44 + 576 * r.epsilon) * r.epsilon * r.epsilon,
                    s = (0, r.vec)(4),
                    l = (0, r.vec)(4),
                    A = (0, r.vec)(4),
                    c = (0, r.vec)(4),
                    u = (0, r.vec)(4),
                    h = (0, r.vec)(4),
                    d = (0, r.vec)(4),
                    f = (0, r.vec)(4),
                    p = (0, r.vec)(8),
                    m = (0, r.vec)(8),
                    g = (0, r.vec)(8),
                    v = (0, r.vec)(8),
                    _ = (0, r.vec)(8),
                    y = (0, r.vec)(8),
                    x = (0, r.vec)(8),
                    b = (0, r.vec)(8),
                    M = (0, r.vec)(8),
                    w = (0, r.vec)(4),
                    S = (0, r.vec)(4),
                    E = (0, r.vec)(4),
                    T = (0, r.vec)(8),
                    C = (0, r.vec)(16),
                    R = (0, r.vec)(16),
                    P = (0, r.vec)(16),
                    L = (0, r.vec)(32),
                    D = (0, r.vec)(32),
                    I = (0, r.vec)(48),
                    O = (0, r.vec)(64);
                let B = (0, r.vec)(1152),
                    q = (0, r.vec)(1152);

                function U(t, e, n) {
                    t = (0, r.sum)(t, B, e, n, q);
                    const i = B;
                    return B = q, q = i, t
                }

                function N(t, e, n, q, N, k, F, z) {
                    const G = t - F,
                        j = n - F,
                        V = N - F,
                        H = e - z,
                        W = q - z,
                        X = k - z,
                        Y = j * X,
                        Q = V * W,
                        Z = G * G + H * H,
                        J = V * H,
                        K = G * X,
                        $ = j * j + W * W,
                        tt = G * W,
                        et = j * H,
                        nt = V * V + X * X,
                        rt = Z * (Y - Q) + $ * (J - K) + nt * (tt - et),
                        it = (Math.abs(Y) + Math.abs(Q)) * Z + (Math.abs(J) + Math.abs(K)) * $ + (Math.abs(tt) + Math.abs(et)) * nt,
                        at = i * it;
                    return rt > at || -rt > at ? rt : function(t, e, n, i, q, N, k, F, z) {
                        let G, j, V, H, W, X, Y, Q, Z, J, K, $, tt, et, nt, rt, it, at, ot, st, lt, At, ct, ut, ht, dt, ft, pt, mt, gt, vt, _t, yt, xt, bt;
                        const Mt = t - k,
                            wt = n - k,
                            St = q - k,
                            Et = e - F,
                            Tt = i - F,
                            Ct = N - F;
                        vt = wt * Ct, ct = r.splitter * wt, ut = ct - (ct - wt), ht = wt - ut, ct = r.splitter * Ct, dt = ct - (ct - Ct), ft = Ct - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = St * Tt, ct = r.splitter * St, ut = ct - (ct - St), ht = St - ut, ct = r.splitter * Tt, dt = ct - (ct - Tt), ft = Tt - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t - xt, At = _t - pt, s[0] = _t - (pt + At) + (At - xt), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt - yt, At = gt - pt, s[1] = gt - (pt + At) + (At - yt), bt = mt + pt, At = bt - mt, s[2] = mt - (bt - At) + (pt - At), s[3] = bt, vt = St * Et, ct = r.splitter * St, ut = ct - (ct - St), ht = St - ut, ct = r.splitter * Et, dt = ct - (ct - Et), ft = Et - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = Mt * Ct, ct = r.splitter * Mt, ut = ct - (ct - Mt), ht = Mt - ut, ct = r.splitter * Ct, dt = ct - (ct - Ct), ft = Ct - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t - xt, At = _t - pt, l[0] = _t - (pt + At) + (At - xt), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt - yt, At = gt - pt, l[1] = gt - (pt + At) + (At - yt), bt = mt + pt, At = bt - mt, l[2] = mt - (bt - At) + (pt - At), l[3] = bt, vt = Mt * Tt, ct = r.splitter * Mt, ut = ct - (ct - Mt), ht = Mt - ut, ct = r.splitter * Tt, dt = ct - (ct - Tt), ft = Tt - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = wt * Et, ct = r.splitter * wt, ut = ct - (ct - wt), ht = wt - ut, ct = r.splitter * Et, dt = ct - (ct - Et), ft = Et - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t - xt, At = _t - pt, A[0] = _t - (pt + At) + (At - xt), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt - yt, At = gt - pt, A[1] = gt - (pt + At) + (At - yt), bt = mt + pt, At = bt - mt, A[2] = mt - (bt - At) + (pt - At), A[3] = bt, G = (0, r.sum)((0, r.sum)((0, r.sum)((0, r.scale)((0, r.scale)(4, s, Mt, T), T, Mt, C), C, (0, r.scale)((0, r.scale)(4, s, Et, T), T, Et, R), R, L), L, (0, r.sum)((0, r.scale)((0, r.scale)(4, l, wt, T), T, wt, C), C, (0, r.scale)((0, r.scale)(4, l, Tt, T), T, Tt, R), R, D), D, O), O, (0, r.sum)((0, r.scale)((0, r.scale)(4, A, St, T), T, St, C), C, (0, r.scale)((0, r.scale)(4, A, Ct, T), T, Ct, R), R, L), L, B);
                        let Rt = (0, r.estimate)(G, B),
                            Pt = a * z;
                        if (Rt >= Pt || -Rt >= Pt) return Rt;
                        if (At = t - Mt, j = t - (Mt + At) + (At - k), At = e - Et, W = e - (Et + At) + (At - F), At = n - wt, V = n - (wt + At) + (At - k), At = i - Tt, X = i - (Tt + At) + (At - F), At = q - St, H = q - (St + At) + (At - k), At = N - Ct, Y = N - (Ct + At) + (At - F), 0 === j && 0 === V && 0 === H && 0 === W && 0 === X && 0 === Y) return Rt;
                        if (Pt = o * z + r.resulterrbound * Math.abs(Rt), Rt += (Mt * Mt + Et * Et) * (wt * Y + Ct * V - (Tt * H + St * X)) + 2 * (Mt * j + Et * W) * (wt * Ct - Tt * St) + ((wt * wt + Tt * Tt) * (St * W + Et * H - (Ct * j + Mt * Y)) + 2 * (wt * V + Tt * X) * (St * Et - Ct * Mt)) + ((St * St + Ct * Ct) * (Mt * X + Tt * j - (Et * V + wt * W)) + 2 * (St * H + Ct * Y) * (Mt * Tt - Et * wt)), Rt >= Pt || -Rt >= Pt) return Rt;
                        if (0 === V && 0 === X && 0 === H && 0 === Y || (vt = Mt * Mt, ct = r.splitter * Mt, ut = ct - (ct - Mt), ht = Mt - ut, _t = ht * ht - (vt - ut * ut - (ut + ut) * ht), yt = Et * Et, ct = r.splitter * Et, ut = ct - (ct - Et), ht = Et - ut, xt = ht * ht - (yt - ut * ut - (ut + ut) * ht), pt = _t + xt, At = pt - _t, c[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, c[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, c[2] = mt - (bt - At) + (pt - At), c[3] = bt), 0 === H && 0 === Y && 0 === j && 0 === W || (vt = wt * wt, ct = r.splitter * wt, ut = ct - (ct - wt), ht = wt - ut, _t = ht * ht - (vt - ut * ut - (ut + ut) * ht), yt = Tt * Tt, ct = r.splitter * Tt, ut = ct - (ct - Tt), ht = Tt - ut, xt = ht * ht - (yt - ut * ut - (ut + ut) * ht), pt = _t + xt, At = pt - _t, u[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, u[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, u[2] = mt - (bt - At) + (pt - At), u[3] = bt), 0 === j && 0 === W && 0 === V && 0 === X || (vt = St * St, ct = r.splitter * St, ut = ct - (ct - St), ht = St - ut, _t = ht * ht - (vt - ut * ut - (ut + ut) * ht), yt = Ct * Ct, ct = r.splitter * Ct, ut = ct - (ct - Ct), ht = Ct - ut, xt = ht * ht - (yt - ut * ut - (ut + ut) * ht), pt = _t + xt, At = pt - _t, h[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, h[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, h[2] = mt - (bt - At) + (pt - At), h[3] = bt), 0 !== j && (Q = (0, r.scale)(4, s, j, p), G = U(G, (0, r.sum_three)((0, r.scale)(Q, p, 2 * Mt, C), C, (0, r.scale)((0, r.scale)(4, h, j, T), T, Tt, R), R, (0, r.scale)((0, r.scale)(4, u, j, T), T, -Ct, P), P, L, I), I)), 0 !== W && (Z = (0, r.scale)(4, s, W, m), G = U(G, (0, r.sum_three)((0, r.scale)(Z, m, 2 * Et, C), C, (0, r.scale)((0, r.scale)(4, u, W, T), T, St, R), R, (0, r.scale)((0, r.scale)(4, h, W, T), T, -wt, P), P, L, I), I)), 0 !== V && (J = (0, r.scale)(4, l, V, g), G = U(G, (0, r.sum_three)((0, r.scale)(J, g, 2 * wt, C), C, (0, r.scale)((0, r.scale)(4, c, V, T), T, Ct, R), R, (0, r.scale)((0, r.scale)(4, h, V, T), T, -Et, P), P, L, I), I)), 0 !== X && (K = (0, r.scale)(4, l, X, v), G = U(G, (0, r.sum_three)((0, r.scale)(K, v, 2 * Tt, C), C, (0, r.scale)((0, r.scale)(4, h, X, T), T, Mt, R), R, (0, r.scale)((0, r.scale)(4, c, X, T), T, -St, P), P, L, I), I)), 0 !== H && ($ = (0, r.scale)(4, A, H, _), G = U(G, (0, r.sum_three)((0, r.scale)($, _, 2 * St, C), C, (0, r.scale)((0, r.scale)(4, u, H, T), T, Et, R), R, (0, r.scale)((0, r.scale)(4, c, H, T), T, -Tt, P), P, L, I), I)), 0 !== Y && (tt = (0, r.scale)(4, A, Y, y), G = U(G, (0, r.sum_three)((0, r.scale)(tt, y, 2 * Ct, C), C, (0, r.scale)((0, r.scale)(4, c, Y, T), T, wt, R), R, (0, r.scale)((0, r.scale)(4, u, Y, T), T, -Mt, P), P, L, I), I)), 0 !== j || 0 !== W) {
                            if (0 !== V || 0 !== X || 0 !== H || 0 !== Y ? (vt = V * Ct, ct = r.splitter * V, ut = ct - (ct - V), ht = V - ut, ct = r.splitter * Ct, dt = ct - (ct - Ct), ft = Ct - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = wt * Y, ct = r.splitter * wt, ut = ct - (ct - wt), ht = wt - ut, ct = r.splitter * Y, dt = ct - (ct - Y), ft = Y - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t + xt, At = pt - _t, d[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, d[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, d[2] = mt - (bt - At) + (pt - At), d[3] = bt, vt = H * -Tt, ct = r.splitter * H, ut = ct - (ct - H), ht = H - ut, ct = r.splitter * -Tt, dt = ct - (ct - -Tt), ft = -Tt - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = St * -X, ct = r.splitter * St, ut = ct - (ct - St), ht = St - ut, ct = r.splitter * -X, dt = ct - (ct - -X), ft = -X - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t + xt, At = pt - _t, f[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, f[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, f[2] = mt - (bt - At) + (pt - At), f[3] = bt, nt = (0, r.sum)(4, d, 4, f, b), vt = V * Y, ct = r.splitter * V, ut = ct - (ct - V), ht = V - ut, ct = r.splitter * Y, dt = ct - (ct - Y), ft = Y - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = H * X, ct = r.splitter * H, ut = ct - (ct - H), ht = H - ut, ct = r.splitter * X, dt = ct - (ct - X), ft = X - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t - xt, At = _t - pt, S[0] = _t - (pt + At) + (At - xt), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt - yt, At = gt - pt, S[1] = gt - (pt + At) + (At - yt), bt = mt + pt, At = bt - mt, S[2] = mt - (bt - At) + (pt - At), S[3] = bt, at = 4) : (b[0] = 0, nt = 1, S[0] = 0, at = 1), 0 !== j) {
                                const t = (0, r.scale)(nt, b, j, P);
                                G = U(G, (0, r.sum)((0, r.scale)(Q, p, j, C), C, (0, r.scale)(t, P, 2 * Mt, L), L, I), I);
                                const e = (0, r.scale)(at, S, j, T);
                                G = U(G, (0, r.sum_three)((0, r.scale)(e, T, 2 * Mt, C), C, (0, r.scale)(e, T, j, R), R, (0, r.scale)(t, P, j, L), L, D, O), O), 0 !== X && (G = U(G, (0, r.scale)((0, r.scale)(4, h, j, T), T, X, C), C)), 0 !== Y && (G = U(G, (0, r.scale)((0, r.scale)(4, u, -j, T), T, Y, C), C))
                            }
                            if (0 !== W) {
                                const t = (0, r.scale)(nt, b, W, P);
                                G = U(G, (0, r.sum)((0, r.scale)(Z, m, W, C), C, (0, r.scale)(t, P, 2 * Et, L), L, I), I);
                                const e = (0, r.scale)(at, S, W, T);
                                G = U(G, (0, r.sum_three)((0, r.scale)(e, T, 2 * Et, C), C, (0, r.scale)(e, T, W, R), R, (0, r.scale)(t, P, W, L), L, D, O), O)
                            }
                        }
                        if (0 !== V || 0 !== X) {
                            if (0 !== H || 0 !== Y || 0 !== j || 0 !== W ? (vt = H * Et, ct = r.splitter * H, ut = ct - (ct - H), ht = H - ut, ct = r.splitter * Et, dt = ct - (ct - Et), ft = Et - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = St * W, ct = r.splitter * St, ut = ct - (ct - St), ht = St - ut, ct = r.splitter * W, dt = ct - (ct - W), ft = W - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t + xt, At = pt - _t, d[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, d[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, d[2] = mt - (bt - At) + (pt - At), d[3] = bt, st = -Ct, lt = -Y, vt = j * st, ct = r.splitter * j, ut = ct - (ct - j), ht = j - ut, ct = r.splitter * st, dt = ct - (ct - st), ft = st - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = Mt * lt, ct = r.splitter * Mt, ut = ct - (ct - Mt), ht = Mt - ut, ct = r.splitter * lt, dt = ct - (ct - lt), ft = lt - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t + xt, At = pt - _t, f[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, f[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, f[2] = mt - (bt - At) + (pt - At), f[3] = bt, rt = (0, r.sum)(4, d, 4, f, M), vt = H * W, ct = r.splitter * H, ut = ct - (ct - H), ht = H - ut, ct = r.splitter * W, dt = ct - (ct - W), ft = W - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = j * Y, ct = r.splitter * j, ut = ct - (ct - j), ht = j - ut, ct = r.splitter * Y, dt = ct - (ct - Y), ft = Y - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t - xt, At = _t - pt, E[0] = _t - (pt + At) + (At - xt), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt - yt, At = gt - pt, E[1] = gt - (pt + At) + (At - yt), bt = mt + pt, At = bt - mt, E[2] = mt - (bt - At) + (pt - At), E[3] = bt, ot = 4) : (M[0] = 0, rt = 1, E[0] = 0, ot = 1), 0 !== V) {
                                const t = (0, r.scale)(rt, M, V, P);
                                G = U(G, (0, r.sum)((0, r.scale)(J, g, V, C), C, (0, r.scale)(t, P, 2 * wt, L), L, I), I);
                                const e = (0, r.scale)(ot, E, V, T);
                                G = U(G, (0, r.sum_three)((0, r.scale)(e, T, 2 * wt, C), C, (0, r.scale)(e, T, V, R), R, (0, r.scale)(t, P, V, L), L, D, O), O), 0 !== Y && (G = U(G, (0, r.scale)((0, r.scale)(4, c, V, T), T, Y, C), C)), 0 !== W && (G = U(G, (0, r.scale)((0, r.scale)(4, h, -V, T), T, W, C), C))
                            }
                            if (0 !== X) {
                                const t = (0, r.scale)(rt, M, X, P);
                                G = U(G, (0, r.sum)((0, r.scale)(K, v, X, C), C, (0, r.scale)(t, P, 2 * Tt, L), L, I), I);
                                const e = (0, r.scale)(ot, E, X, T);
                                G = U(G, (0, r.sum_three)((0, r.scale)(e, T, 2 * Tt, C), C, (0, r.scale)(e, T, X, R), R, (0, r.scale)(t, P, X, L), L, D, O), O)
                            }
                        }
                        if (0 !== H || 0 !== Y) {
                            if (0 !== j || 0 !== W || 0 !== V || 0 !== X ? (vt = j * Tt, ct = r.splitter * j, ut = ct - (ct - j), ht = j - ut, ct = r.splitter * Tt, dt = ct - (ct - Tt), ft = Tt - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = Mt * X, ct = r.splitter * Mt, ut = ct - (ct - Mt), ht = Mt - ut, ct = r.splitter * X, dt = ct - (ct - X), ft = X - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t + xt, At = pt - _t, d[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, d[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, d[2] = mt - (bt - At) + (pt - At), d[3] = bt, st = -Et, lt = -W, vt = V * st, ct = r.splitter * V, ut = ct - (ct - V), ht = V - ut, ct = r.splitter * st, dt = ct - (ct - st), ft = st - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = wt * lt, ct = r.splitter * wt, ut = ct - (ct - wt), ht = wt - ut, ct = r.splitter * lt, dt = ct - (ct - lt), ft = lt - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t + xt, At = pt - _t, f[0] = _t - (pt - At) + (xt - At), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt + yt, At = pt - gt, f[1] = gt - (pt - At) + (yt - At), bt = mt + pt, At = bt - mt, f[2] = mt - (bt - At) + (pt - At), f[3] = bt, et = (0, r.sum)(4, d, 4, f, x), vt = j * X, ct = r.splitter * j, ut = ct - (ct - j), ht = j - ut, ct = r.splitter * X, dt = ct - (ct - X), ft = X - dt, _t = ht * ft - (vt - ut * dt - ht * dt - ut * ft), yt = V * W, ct = r.splitter * V, ut = ct - (ct - V), ht = V - ut, ct = r.splitter * W, dt = ct - (ct - W), ft = W - dt, xt = ht * ft - (yt - ut * dt - ht * dt - ut * ft), pt = _t - xt, At = _t - pt, w[0] = _t - (pt + At) + (At - xt), mt = vt + pt, At = mt - vt, gt = vt - (mt - At) + (pt - At), pt = gt - yt, At = gt - pt, w[1] = gt - (pt + At) + (At - yt), bt = mt + pt, At = bt - mt, w[2] = mt - (bt - At) + (pt - At), w[3] = bt, it = 4) : (x[0] = 0, et = 1, w[0] = 0, it = 1), 0 !== H) {
                                const t = (0, r.scale)(et, x, H, P);
                                G = U(G, (0, r.sum)((0, r.scale)($, _, H, C), C, (0, r.scale)(t, P, 2 * St, L), L, I), I);
                                const e = (0, r.scale)(it, w, H, T);
                                G = U(G, (0, r.sum_three)((0, r.scale)(e, T, 2 * St, C), C, (0, r.scale)(e, T, H, R), R, (0, r.scale)(t, P, H, L), L, D, O), O), 0 !== W && (G = U(G, (0, r.scale)((0, r.scale)(4, u, H, T), T, W, C), C)), 0 !== X && (G = U(G, (0, r.scale)((0, r.scale)(4, c, -H, T), T, X, C), C))
                            }
                            if (0 !== Y) {
                                const t = (0, r.scale)(et, x, Y, P);
                                G = U(G, (0, r.sum)((0, r.scale)(tt, y, Y, C), C, (0, r.scale)(t, P, 2 * Ct, L), L, I), I);
                                const e = (0, r.scale)(it, w, Y, T);
                                G = U(G, (0, r.sum_three)((0, r.scale)(e, T, 2 * Ct, C), C, (0, r.scale)(e, T, Y, R), R, (0, r.scale)(t, P, Y, L), L, D, O), O)
                            }
                        }
                        return B[G - 1]
                    }(t, e, n, q, N, k, F, z, it)
                }

                function k(t, e, n, r, i, a, o, s) {
                    const l = t - o,
                        A = e - s,
                        c = n - o,
                        u = r - s,
                        h = i - o,
                        d = a - s;
                    return (l * l + A * A) * (c * d - h * u) + (c * c + u * u) * (h * A - l * d) + (h * h + d * d) * (l * u - c * A)
                }
            },
            "./node_modules/robust-predicates/esm/insphere.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    insphere: () => rt,
                    inspherefast: () => it
                });
                var r = n("./node_modules/robust-predicates/esm/util.js");
                const i = (16 + 224 * r.epsilon) * r.epsilon,
                    a = (5 + 72 * r.epsilon) * r.epsilon,
                    o = (71 + 1408 * r.epsilon) * r.epsilon * r.epsilon,
                    s = (0, r.vec)(4),
                    l = (0, r.vec)(4),
                    A = (0, r.vec)(4),
                    c = (0, r.vec)(4),
                    u = (0, r.vec)(4),
                    h = (0, r.vec)(4),
                    d = (0, r.vec)(4),
                    f = (0, r.vec)(4),
                    p = (0, r.vec)(4),
                    m = (0, r.vec)(4),
                    g = (0, r.vec)(24),
                    v = (0, r.vec)(24),
                    _ = (0, r.vec)(24),
                    y = (0, r.vec)(24),
                    x = (0, r.vec)(24),
                    b = (0, r.vec)(24),
                    M = (0, r.vec)(24),
                    w = (0, r.vec)(24),
                    S = (0, r.vec)(24),
                    E = (0, r.vec)(24),
                    T = (0, r.vec)(1152),
                    C = (0, r.vec)(1152),
                    R = (0, r.vec)(1152),
                    P = (0, r.vec)(1152),
                    L = (0, r.vec)(1152),
                    D = (0, r.vec)(2304),
                    I = (0, r.vec)(2304),
                    O = (0, r.vec)(3456),
                    B = (0, r.vec)(5760),
                    q = (0, r.vec)(8),
                    U = (0, r.vec)(8),
                    N = (0, r.vec)(8),
                    k = (0, r.vec)(16),
                    F = (0, r.vec)(24),
                    z = (0, r.vec)(48),
                    G = (0, r.vec)(48),
                    j = (0, r.vec)(96),
                    V = (0, r.vec)(192),
                    H = (0, r.vec)(384),
                    W = (0, r.vec)(384),
                    X = (0, r.vec)(384),
                    Y = (0, r.vec)(768);

                function Q(t, e, n, i, a, o, s) {
                    return (0, r.sum_three)((0, r.scale)(4, t, i, q), q, (0, r.scale)(4, e, a, U), U, (0, r.scale)(4, n, o, N), N, k, s)
                }

                function Z(t, e, n, i, a, o, s, l, A, c, u, h) {
                    const d = (0, r.sum)((0, r.sum)(t, e, n, i, z), z, (0, r.negate)((0, r.sum)(a, o, s, l, G), G), G, j);
                    return (0, r.sum_three)((0, r.scale)((0, r.scale)(d, j, A, V), V, A, H), H, (0, r.scale)((0, r.scale)(d, j, c, V), V, c, W), W, (0, r.scale)((0, r.scale)(d, j, u, V), V, u, X), X, Y, h)
                }
                const J = (0, r.vec)(96),
                    K = (0, r.vec)(96),
                    $ = (0, r.vec)(96),
                    tt = (0, r.vec)(1152);

                function et(t, e, n, i, a, o, s, l, A, c) {
                    const u = Q(t, e, n, i, a, o, F);
                    return (0, r.sum_three)((0, r.scale)((0, r.scale)(u, F, s, z), z, s, J), J, (0, r.scale)((0, r.scale)(u, F, l, z), z, l, K), K, (0, r.scale)((0, r.scale)(u, F, A, z), z, A, $), $, V, c)
                }

                function nt(t, e, n, i, q, U, N, k, F, z, G, j, V, H, W, X) {
                    let Y, J, K, $, nt, rt, it, at, ot, st, lt, At, ct, ut, ht, dt, ft, pt, mt, gt, vt, _t, yt, xt, bt, Mt, wt, St, Et, Tt, Ct;
                    const Rt = t - V,
                        Pt = i - V,
                        Lt = N - V,
                        Dt = z - V,
                        It = e - H,
                        Ot = q - H,
                        Bt = k - H,
                        qt = G - H,
                        Ut = n - W,
                        Nt = U - W,
                        kt = F - W,
                        Ft = j - W;
                    St = Rt * Ot, gt = r.splitter * Rt, vt = gt - (gt - Rt), _t = Rt - vt, gt = r.splitter * Ot, yt = gt - (gt - Ot), xt = Ot - yt, Et = _t * xt - (St - vt * yt - _t * yt - vt * xt), Tt = Pt * It, gt = r.splitter * Pt, vt = gt - (gt - Pt), _t = Pt - vt, gt = r.splitter * It, yt = gt - (gt - It), xt = It - yt, Ct = _t * xt - (Tt - vt * yt - _t * yt - vt * xt), bt = Et - Ct, mt = Et - bt, s[0] = Et - (bt + mt) + (mt - Ct), Mt = St + bt, mt = Mt - St, wt = St - (Mt - mt) + (bt - mt), bt = wt - Tt, mt = wt - bt, s[1] = wt - (bt + mt) + (mt - Tt), Y = Mt + bt, mt = Y - Mt, s[2] = Mt - (Y - mt) + (bt - mt), s[3] = Y, St = Pt * Bt, gt = r.splitter * Pt, vt = gt - (gt - Pt), _t = Pt - vt, gt = r.splitter * Bt, yt = gt - (gt - Bt), xt = Bt - yt, Et = _t * xt - (St - vt * yt - _t * yt - vt * xt), Tt = Lt * Ot, gt = r.splitter * Lt, vt = gt - (gt - Lt), _t = Lt - vt, gt = r.splitter * Ot, yt = gt - (gt - Ot), xt = Ot - yt, Ct = _t * xt - (Tt - vt * yt - _t * yt - vt * xt), bt = Et - Ct, mt = Et - bt, l[0] = Et - (bt + mt) + (mt - Ct), Mt = St + bt, mt = Mt - St, wt = St - (Mt - mt) + (bt - mt), bt = wt - Tt, mt = wt - bt, l[1] = wt - (bt + mt) + (mt - Tt), J = Mt + bt, mt = J - Mt, l[2] = Mt - (J - mt) + (bt - mt), l[3] = J, St = Lt * qt, gt = r.splitter * Lt, vt = gt - (gt - Lt), _t = Lt - vt, gt = r.splitter * qt, yt = gt - (gt - qt), xt = qt - yt, Et = _t * xt - (St - vt * yt - _t * yt - vt * xt), Tt = Dt * Bt, gt = r.splitter * Dt, vt = gt - (gt - Dt), _t = Dt - vt, gt = r.splitter * Bt, yt = gt - (gt - Bt), xt = Bt - yt, Ct = _t * xt - (Tt - vt * yt - _t * yt - vt * xt), bt = Et - Ct, mt = Et - bt, A[0] = Et - (bt + mt) + (mt - Ct), Mt = St + bt, mt = Mt - St, wt = St - (Mt - mt) + (bt - mt), bt = wt - Tt, mt = wt - bt, A[1] = wt - (bt + mt) + (mt - Tt), K = Mt + bt, mt = K - Mt, A[2] = Mt - (K - mt) + (bt - mt), A[3] = K, St = Dt * It, gt = r.splitter * Dt, vt = gt - (gt - Dt), _t = Dt - vt, gt = r.splitter * It, yt = gt - (gt - It), xt = It - yt, Et = _t * xt - (St - vt * yt - _t * yt - vt * xt), Tt = Rt * qt, gt = r.splitter * Rt, vt = gt - (gt - Rt), _t = Rt - vt, gt = r.splitter * qt, yt = gt - (gt - qt), xt = qt - yt, Ct = _t * xt - (Tt - vt * yt - _t * yt - vt * xt), bt = Et - Ct, mt = Et - bt, p[0] = Et - (bt + mt) + (mt - Ct), Mt = St + bt, mt = Mt - St, wt = St - (Mt - mt) + (bt - mt), bt = wt - Tt, mt = wt - bt, p[1] = wt - (bt + mt) + (mt - Tt), $ = Mt + bt, mt = $ - Mt, p[2] = Mt - ($ - mt) + (bt - mt), p[3] = $, St = Rt * Bt, gt = r.splitter * Rt, vt = gt - (gt - Rt), _t = Rt - vt, gt = r.splitter * Bt, yt = gt - (gt - Bt), xt = Bt - yt, Et = _t * xt - (St - vt * yt - _t * yt - vt * xt), Tt = Lt * It, gt = r.splitter * Lt, vt = gt - (gt - Lt), _t = Lt - vt, gt = r.splitter * It, yt = gt - (gt - It), xt = It - yt, Ct = _t * xt - (Tt - vt * yt - _t * yt - vt * xt), bt = Et - Ct, mt = Et - bt, h[0] = Et - (bt + mt) + (mt - Ct), Mt = St + bt, mt = Mt - St, wt = St - (Mt - mt) + (bt - mt), bt = wt - Tt, mt = wt - bt, h[1] = wt - (bt + mt) + (mt - Tt), nt = Mt + bt, mt = nt - Mt, h[2] = Mt - (nt - mt) + (bt - mt), h[3] = nt, St = Pt * qt, gt = r.splitter * Pt, vt = gt - (gt - Pt), _t = Pt - vt, gt = r.splitter * qt, yt = gt - (gt - qt), xt = qt - yt, Et = _t * xt - (St - vt * yt - _t * yt - vt * xt), Tt = Dt * Ot, gt = r.splitter * Dt, vt = gt - (gt - Dt), _t = Dt - vt, gt = r.splitter * Ot, yt = gt - (gt - Ot), xt = Ot - yt, Ct = _t * xt - (Tt - vt * yt - _t * yt - vt * xt), bt = Et - Ct, mt = Et - bt, d[0] = Et - (bt + mt) + (mt - Ct), Mt = St + bt, mt = Mt - St, wt = St - (Mt - mt) + (bt - mt), bt = wt - Tt, mt = wt - bt, d[1] = wt - (bt + mt) + (mt - Tt), rt = Mt + bt, mt = rt - Mt, d[2] = Mt - (rt - mt) + (bt - mt), d[3] = rt;
                    const zt = (0, r.sum)((0, r.sum)((0, r.negate)(et(l, A, d, Ft, Nt, -kt, Rt, It, Ut, T), T), T, et(A, p, h, Ut, kt, Ft, Pt, Ot, Nt, C), C, D), D, (0, r.sum)((0, r.negate)(et(p, s, d, Nt, Ft, Ut, Lt, Bt, kt, R), R), R, et(s, l, h, kt, Ut, -Nt, Dt, qt, Ft, P), P, I), I, tt);
                    let Gt = (0, r.estimate)(zt, tt),
                        jt = a * X;
                    if (Gt >= jt || -Gt >= jt) return Gt;
                    if (mt = t - Rt, it = t - (Rt + mt) + (mt - V), mt = e - It, lt = e - (It + mt) + (mt - H), mt = n - Ut, ht = n - (Ut + mt) + (mt - W), mt = i - Pt, at = i - (Pt + mt) + (mt - V), mt = q - Ot, At = q - (Ot + mt) + (mt - H), mt = U - Nt, dt = U - (Nt + mt) + (mt - W), mt = N - Lt, ot = N - (Lt + mt) + (mt - V), mt = k - Bt, ct = k - (Bt + mt) + (mt - H), mt = F - kt, ft = F - (kt + mt) + (mt - W), mt = z - Dt, st = z - (Dt + mt) + (mt - V), mt = G - qt, ut = G - (qt + mt) + (mt - H), mt = j - Ft, pt = j - (Ft + mt) + (mt - W), 0 === it && 0 === lt && 0 === ht && 0 === at && 0 === At && 0 === dt && 0 === ot && 0 === ct && 0 === ft && 0 === st && 0 === ut && 0 === pt) return Gt;
                    jt = o * X + r.resulterrbound * Math.abs(Gt);
                    const Vt = Rt * At + Ot * it - (It * at + Pt * lt),
                        Ht = Pt * ct + Bt * at - (Ot * ot + Lt * At),
                        Wt = Lt * ut + qt * ot - (Bt * st + Dt * ct),
                        Xt = Dt * lt + It * st - (qt * it + Rt * ut),
                        Yt = Rt * ct + Bt * it - (It * ot + Lt * lt),
                        Qt = Pt * ut + qt * at - (Ot * st + Dt * At);
                    return Gt += (Pt * Pt + Ot * Ot + Nt * Nt) * (kt * Xt + Ft * Yt + Ut * Wt + (ft * $ + pt * nt + ht * K)) + (Dt * Dt + qt * qt + Ft * Ft) * (Ut * Ht - Nt * Yt + kt * Vt + (ht * J - dt * nt + ft * Y)) - ((Rt * Rt + It * It + Ut * Ut) * (Nt * Wt - kt * Qt + Ft * Ht + (dt * K - ft * rt + pt * J)) + (Lt * Lt + Bt * Bt + kt * kt) * (Ft * Vt + Ut * Qt + Nt * Xt + (pt * Y + ht * rt + dt * $))) + 2 * ((Pt * at + Ot * At + Nt * dt) * (kt * $ + Ft * nt + Ut * K) + (Dt * st + qt * ut + Ft * pt) * (Ut * J - Nt * nt + kt * Y) - ((Rt * it + It * lt + Ut * ht) * (Nt * K - kt * rt + Ft * J) + (Lt * ot + Bt * ct + kt * ft) * (Ft * Y + Ut * rt + Nt * $))), Gt >= jt || -Gt >= jt ? Gt : function(t, e, n, i, a, o, q, U, N, k, F, z, G, j, V) {
                        let H, W, X, Y, J, K, $, tt, et, nt, rt, it, at, ot;
                        nt = t * a, W = r.splitter * t, X = W - (W - t), Y = t - X, W = r.splitter * a, J = W - (W - a), K = a - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = i * e, W = r.splitter * i, X = W - (W - i), Y = i - X, W = r.splitter * e, J = W - (W - e), K = e - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, s[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, s[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, s[2] = tt - (ot - H) + ($ - H), s[3] = ot, nt = i * U, W = r.splitter * i, X = W - (W - i), Y = i - X, W = r.splitter * U, J = W - (W - U), K = U - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = q * a, W = r.splitter * q, X = W - (W - q), Y = q - X, W = r.splitter * a, J = W - (W - a), K = a - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, l[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, l[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, l[2] = tt - (ot - H) + ($ - H), l[3] = ot, nt = q * F, W = r.splitter * q, X = W - (W - q), Y = q - X, W = r.splitter * F, J = W - (W - F), K = F - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = k * U, W = r.splitter * k, X = W - (W - k), Y = k - X, W = r.splitter * U, J = W - (W - U), K = U - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, A[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, A[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, A[2] = tt - (ot - H) + ($ - H), A[3] = ot, nt = k * j, W = r.splitter * k, X = W - (W - k), Y = k - X, W = r.splitter * j, J = W - (W - j), K = j - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = G * F, W = r.splitter * G, X = W - (W - G), Y = G - X, W = r.splitter * F, J = W - (W - F), K = F - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, c[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, c[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, c[2] = tt - (ot - H) + ($ - H), c[3] = ot, nt = G * e, W = r.splitter * G, X = W - (W - G), Y = G - X, W = r.splitter * e, J = W - (W - e), K = e - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = t * j, W = r.splitter * t, X = W - (W - t), Y = t - X, W = r.splitter * j, J = W - (W - j), K = j - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, u[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, u[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, u[2] = tt - (ot - H) + ($ - H), u[3] = ot, nt = t * U, W = r.splitter * t, X = W - (W - t), Y = t - X, W = r.splitter * U, J = W - (W - U), K = U - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = q * e, W = r.splitter * q, X = W - (W - q), Y = q - X, W = r.splitter * e, J = W - (W - e), K = e - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, h[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, h[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, h[2] = tt - (ot - H) + ($ - H), h[3] = ot, nt = i * F, W = r.splitter * i, X = W - (W - i), Y = i - X, W = r.splitter * F, J = W - (W - F), K = F - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = k * a, W = r.splitter * k, X = W - (W - k), Y = k - X, W = r.splitter * a, J = W - (W - a), K = a - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, d[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, d[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, d[2] = tt - (ot - H) + ($ - H), d[3] = ot, nt = q * j, W = r.splitter * q, X = W - (W - q), Y = q - X, W = r.splitter * j, J = W - (W - j), K = j - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = G * U, W = r.splitter * G, X = W - (W - G), Y = G - X, W = r.splitter * U, J = W - (W - U), K = U - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, f[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, f[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, f[2] = tt - (ot - H) + ($ - H), f[3] = ot, nt = k * e, W = r.splitter * k, X = W - (W - k), Y = k - X, W = r.splitter * e, J = W - (W - e), K = e - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = t * F, W = r.splitter * t, X = W - (W - t), Y = t - X, W = r.splitter * F, J = W - (W - F), K = F - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, p[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, p[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, p[2] = tt - (ot - H) + ($ - H), p[3] = ot, nt = G * a, W = r.splitter * G, X = W - (W - G), Y = G - X, W = r.splitter * a, J = W - (W - a), K = a - J, rt = Y * K - (nt - X * J - Y * J - X * K), it = i * j, W = r.splitter * i, X = W - (W - i), Y = i - X, W = r.splitter * j, J = W - (W - j), K = j - J, at = Y * K - (it - X * J - Y * J - X * K), $ = rt - at, H = rt - $, m[0] = rt - ($ + H) + (H - at), tt = nt + $, H = tt - nt, et = nt - (tt - H) + ($ - H), $ = et - it, H = et - $, m[1] = et - ($ + H) + (H - it), ot = tt + $, H = ot - tt, m[2] = tt - (ot - H) + ($ - H), m[3] = ot;
                        const st = Q(s, l, h, N, n, -o, g),
                            lt = Q(l, A, d, z, o, -N, v),
                            At = Q(A, c, f, V, N, -z, _),
                            ct = Q(c, u, p, n, z, -V, y),
                            ut = Q(u, s, m, o, V, -n, x),
                            ht = Q(s, d, p, z, n, o, b),
                            dt = Q(l, f, m, V, o, N, M),
                            ft = Q(A, p, h, n, N, z, w),
                            pt = Q(c, m, d, o, z, V, S),
                            mt = Q(u, h, f, N, V, n, E),
                            gt = (0, r.sum_three)(Z(At, _, dt, M, pt, S, lt, v, t, e, n, T), T, Z(ct, y, ft, w, mt, E, At, _, i, a, o, C), C, (0, r.sum_three)(Z(ut, x, pt, S, ht, b, ct, y, q, U, N, R), R, Z(st, g, mt, E, dt, M, ut, x, k, F, z, P), P, Z(lt, v, ht, b, ft, w, st, g, G, j, V, L), L, I, O), O, D, B);
                        return B[gt - 1]
                    }(t, e, n, i, q, U, N, k, F, z, G, j, V, H, W)
                }

                function rt(t, e, n, r, a, o, s, l, A, c, u, h, d, f, p) {
                    const m = t - d,
                        g = r - d,
                        v = s - d,
                        _ = c - d,
                        y = e - f,
                        x = a - f,
                        b = l - f,
                        M = u - f,
                        w = n - p,
                        S = o - p,
                        E = A - p,
                        T = h - p,
                        C = m * x,
                        R = g * y,
                        P = C - R,
                        L = g * b,
                        D = v * x,
                        I = L - D,
                        O = v * M,
                        B = _ * b,
                        q = O - B,
                        U = _ * y,
                        N = m * M,
                        k = U - N,
                        F = m * b,
                        z = v * y,
                        G = F - z,
                        j = g * M,
                        V = _ * x,
                        H = j - V,
                        W = m * m + y * y + w * w,
                        X = g * g + x * x + S * S,
                        Y = v * v + b * b + E * E,
                        Q = _ * _ + M * M + T * T,
                        Z = Y * (T * P + w * H + S * k) - Q * (w * I - S * G + E * P) + (W * (S * q - E * H + T * I) - X * (E * k + T * G + w * q)),
                        J = Math.abs(w),
                        K = Math.abs(S),
                        $ = Math.abs(E),
                        tt = Math.abs(T),
                        et = Math.abs(C) + Math.abs(R),
                        rt = Math.abs(L) + Math.abs(D),
                        it = Math.abs(O) + Math.abs(B),
                        at = Math.abs(U) + Math.abs(N),
                        ot = Math.abs(F) + Math.abs(z),
                        st = Math.abs(j) + Math.abs(V),
                        lt = (it * K + st * $ + rt * tt) * W + (at * $ + ot * tt + it * J) * X + (et * tt + st * J + at * K) * Y + (rt * J + ot * K + et * $) * Q,
                        At = i * lt;
                    return Z > At || -Z > At ? Z : -nt(t, e, n, r, a, o, s, l, A, c, u, h, d, f, p, lt)
                }

                function it(t, e, n, r, i, a, o, s, l, A, c, u, h, d, f) {
                    const p = t - h,
                        m = r - h,
                        g = o - h,
                        v = A - h,
                        _ = e - d,
                        y = i - d,
                        x = s - d,
                        b = c - d,
                        M = n - f,
                        w = a - f,
                        S = l - f,
                        E = u - f,
                        T = p * y - m * _,
                        C = m * x - g * y,
                        R = g * b - v * x,
                        P = v * _ - p * b,
                        L = p * x - g * _,
                        D = m * b - v * y;
                    return (g * g + x * x + S * S) * (E * T + M * D + w * P) - (v * v + b * b + E * E) * (M * C - w * L + S * T) + ((p * p + _ * _ + M * M) * (w * R - S * D + E * C) - (m * m + y * y + w * w) * (S * P + E * L + M * R))
                }
            },
            "./node_modules/robust-predicates/esm/orient2d.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    orient2d: () => h,
                    orient2dfast: () => d
                });
                var r = n("./node_modules/robust-predicates/esm/util.js");
                const i = (3 + 16 * r.epsilon) * r.epsilon,
                    a = (2 + 12 * r.epsilon) * r.epsilon,
                    o = (9 + 64 * r.epsilon) * r.epsilon * r.epsilon,
                    s = (0, r.vec)(4),
                    l = (0, r.vec)(8),
                    A = (0, r.vec)(12),
                    c = (0, r.vec)(16),
                    u = (0, r.vec)(4);

                function h(t, e, n, h, d, f) {
                    const p = (e - f) * (n - d),
                        m = (t - d) * (h - f),
                        g = p - m,
                        v = Math.abs(p + m);
                    return Math.abs(g) >= i * v ? g : - function(t, e, n, i, h, d, f) {
                        let p, m, g, v, _, y, x, b, M, w, S, E, T, C, R, P, L, D;
                        const I = t - h,
                            O = n - h,
                            B = e - d,
                            q = i - d;
                        C = I * q, y = r.splitter * I, x = y - (y - I), b = I - x, y = r.splitter * q, M = y - (y - q), w = q - M, R = b * w - (C - x * M - b * M - x * w), P = B * O, y = r.splitter * B, x = y - (y - B), b = B - x, y = r.splitter * O, M = y - (y - O), w = O - M, L = b * w - (P - x * M - b * M - x * w), S = R - L, _ = R - S, s[0] = R - (S + _) + (_ - L), E = C + S, _ = E - C, T = C - (E - _) + (S - _), S = T - P, _ = T - S, s[1] = T - (S + _) + (_ - P), D = E + S, _ = D - E, s[2] = E - (D - _) + (S - _), s[3] = D;
                        let U = (0, r.estimate)(4, s),
                            N = a * f;
                        if (U >= N || -U >= N) return U;
                        if (_ = t - I, p = t - (I + _) + (_ - h), _ = n - O, g = n - (O + _) + (_ - h), _ = e - B, m = e - (B + _) + (_ - d), _ = i - q, v = i - (q + _) + (_ - d), 0 === p && 0 === m && 0 === g && 0 === v) return U;
                        if (N = o * f + r.resulterrbound * Math.abs(U), U += I * v + q * p - (B * g + O * m), U >= N || -U >= N) return U;
                        C = p * q, y = r.splitter * p, x = y - (y - p), b = p - x, y = r.splitter * q, M = y - (y - q), w = q - M, R = b * w - (C - x * M - b * M - x * w), P = m * O, y = r.splitter * m, x = y - (y - m), b = m - x, y = r.splitter * O, M = y - (y - O), w = O - M, L = b * w - (P - x * M - b * M - x * w), S = R - L, _ = R - S, u[0] = R - (S + _) + (_ - L), E = C + S, _ = E - C, T = C - (E - _) + (S - _), S = T - P, _ = T - S, u[1] = T - (S + _) + (_ - P), D = E + S, _ = D - E, u[2] = E - (D - _) + (S - _), u[3] = D;
                        const k = (0, r.sum)(4, s, 4, u, l);
                        C = I * v, y = r.splitter * I, x = y - (y - I), b = I - x, y = r.splitter * v, M = y - (y - v), w = v - M, R = b * w - (C - x * M - b * M - x * w), P = B * g, y = r.splitter * B, x = y - (y - B), b = B - x, y = r.splitter * g, M = y - (y - g), w = g - M, L = b * w - (P - x * M - b * M - x * w), S = R - L, _ = R - S, u[0] = R - (S + _) + (_ - L), E = C + S, _ = E - C, T = C - (E - _) + (S - _), S = T - P, _ = T - S, u[1] = T - (S + _) + (_ - P), D = E + S, _ = D - E, u[2] = E - (D - _) + (S - _), u[3] = D;
                        const F = (0, r.sum)(k, l, 4, u, A);
                        C = p * v, y = r.splitter * p, x = y - (y - p), b = p - x, y = r.splitter * v, M = y - (y - v), w = v - M, R = b * w - (C - x * M - b * M - x * w), P = m * g, y = r.splitter * m, x = y - (y - m), b = m - x, y = r.splitter * g, M = y - (y - g), w = g - M, L = b * w - (P - x * M - b * M - x * w), S = R - L, _ = R - S, u[0] = R - (S + _) + (_ - L), E = C + S, _ = E - C, T = C - (E - _) + (S - _), S = T - P, _ = T - S, u[1] = T - (S + _) + (_ - P), D = E + S, _ = D - E, u[2] = E - (D - _) + (S - _), u[3] = D;
                        const z = (0, r.sum)(F, A, 4, u, c);
                        return c[z - 1]
                    }(t, e, n, h, d, f, v)
                }

                function d(t, e, n, r, i, a) {
                    return (e - a) * (n - i) - (t - i) * (r - a)
                }
            },
            "./node_modules/robust-predicates/esm/orient3d.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    orient3d: () => R,
                    orient3dfast: () => P
                });
                var r = n("./node_modules/robust-predicates/esm/util.js");
                const i = (7 + 56 * r.epsilon) * r.epsilon,
                    a = (3 + 28 * r.epsilon) * r.epsilon,
                    o = (26 + 288 * r.epsilon) * r.epsilon * r.epsilon,
                    s = (0, r.vec)(4),
                    l = (0, r.vec)(4),
                    A = (0, r.vec)(4),
                    c = (0, r.vec)(4),
                    u = (0, r.vec)(4),
                    h = (0, r.vec)(4),
                    d = (0, r.vec)(4),
                    f = (0, r.vec)(4),
                    p = (0, r.vec)(4),
                    m = (0, r.vec)(8),
                    g = (0, r.vec)(8),
                    v = (0, r.vec)(8),
                    _ = (0, r.vec)(4),
                    y = (0, r.vec)(8),
                    x = (0, r.vec)(8),
                    b = (0, r.vec)(8),
                    M = (0, r.vec)(12);
                let w = (0, r.vec)(192),
                    S = (0, r.vec)(192);

                function E(t, e, n) {
                    t = (0, r.sum)(t, w, e, n, S);
                    const i = w;
                    return w = S, S = i, t
                }

                function T(t, e, n, i, a, o, s, l) {
                    let A, c, u, h, d, f, p, m, g, v, _, y, x, b, M;
                    return 0 === t ? 0 === e ? (s[0] = 0, l[0] = 0, 1) : (M = -e, v = M * n, c = r.splitter * M, u = c - (c - M), h = M - u, c = r.splitter * n, d = c - (c - n), f = n - d, s[0] = h * f - (v - u * d - h * d - u * f), s[1] = v, v = e * a, c = r.splitter * e, u = c - (c - e), h = e - u, c = r.splitter * a, d = c - (c - a), f = a - d, l[0] = h * f - (v - u * d - h * d - u * f), l[1] = v, 2) : 0 === e ? (v = t * i, c = r.splitter * t, u = c - (c - t), h = t - u, c = r.splitter * i, d = c - (c - i), f = i - d, s[0] = h * f - (v - u * d - h * d - u * f), s[1] = v, M = -t, v = M * o, c = r.splitter * M, u = c - (c - M), h = M - u, c = r.splitter * o, d = c - (c - o), f = o - d, l[0] = h * f - (v - u * d - h * d - u * f), l[1] = v, 2) : (v = t * i, c = r.splitter * t, u = c - (c - t), h = t - u, c = r.splitter * i, d = c - (c - i), f = i - d, _ = h * f - (v - u * d - h * d - u * f), y = e * n, c = r.splitter * e, u = c - (c - e), h = e - u, c = r.splitter * n, d = c - (c - n), f = n - d, x = h * f - (y - u * d - h * d - u * f), p = _ - x, A = _ - p, s[0] = _ - (p + A) + (A - x), m = v + p, A = m - v, g = v - (m - A) + (p - A), p = g - y, A = g - p, s[1] = g - (p + A) + (A - y), b = m + p, A = b - m, s[2] = m - (b - A) + (p - A), s[3] = b, v = e * a, c = r.splitter * e, u = c - (c - e), h = e - u, c = r.splitter * a, d = c - (c - a), f = a - d, _ = h * f - (v - u * d - h * d - u * f), y = t * o, c = r.splitter * t, u = c - (c - t), h = t - u, c = r.splitter * o, d = c - (c - o), f = o - d, x = h * f - (y - u * d - h * d - u * f), p = _ - x, A = _ - p, l[0] = _ - (p + A) + (A - x), m = v + p, A = m - v, g = v - (m - A) + (p - A), p = g - y, A = g - p, l[1] = g - (p + A) + (A - y), b = m + p, A = b - m, l[2] = m - (b - A) + (p - A), l[3] = b, 4)
                }

                function C(t, e, n, i, a) {
                    let o, s, l, A, c, u, h, d, f, p, m, g, v;
                    return m = e * n, s = r.splitter * e, l = s - (s - e), A = e - l, s = r.splitter * n, c = s - (s - n), u = n - c, g = A * u - (m - l * c - A * c - l * u), s = r.splitter * i, c = s - (s - i), u = i - c, h = g * i, s = r.splitter * g, l = s - (s - g), A = g - l, _[0] = A * u - (h - l * c - A * c - l * u), d = m * i, s = r.splitter * m, l = s - (s - m), A = m - l, p = A * u - (d - l * c - A * c - l * u), f = h + p, o = f - h, _[1] = h - (f - o) + (p - o), v = d + f, _[2] = f - (v - d), _[3] = v, t = E(t, 4, _), 0 !== a && (s = r.splitter * a, c = s - (s - a), u = a - c, h = g * a, s = r.splitter * g, l = s - (s - g), A = g - l, _[0] = A * u - (h - l * c - A * c - l * u), d = m * a, s = r.splitter * m, l = s - (s - m), A = m - l, p = A * u - (d - l * c - A * c - l * u), f = h + p, o = f - h, _[1] = h - (f - o) + (p - o), v = d + f, _[2] = f - (v - d), _[3] = v, t = E(t, 4, _)), t
                }

                function R(t, e, n, _, S, R, P, L, D, I, O, B) {
                    const q = t - I,
                        U = _ - I,
                        N = P - I,
                        k = e - O,
                        F = S - O,
                        z = L - O,
                        G = n - B,
                        j = R - B,
                        V = D - B,
                        H = U * z,
                        W = N * F,
                        X = N * k,
                        Y = q * z,
                        Q = q * F,
                        Z = U * k,
                        J = G * (H - W) + j * (X - Y) + V * (Q - Z),
                        K = (Math.abs(H) + Math.abs(W)) * Math.abs(G) + (Math.abs(X) + Math.abs(Y)) * Math.abs(j) + (Math.abs(Q) + Math.abs(Z)) * Math.abs(V),
                        $ = i * K;
                    return J > $ || -J > $ ? J : function(t, e, n, i, _, S, R, P, L, D, I, O, B) {
                        let q, U, N, k, F, z, G, j, V, H, W, X, Y, Q, Z, J, K, $, tt, et, nt, rt, it, at;
                        const ot = t - D,
                            st = i - D,
                            lt = R - D,
                            At = e - I,
                            ct = _ - I,
                            ut = P - I,
                            ht = n - O,
                            dt = S - O,
                            ft = L - O;
                        et = st * ut, X = r.splitter * st, Y = X - (X - st), Q = st - Y, X = r.splitter * ut, Z = X - (X - ut), J = ut - Z, nt = Q * J - (et - Y * Z - Q * Z - Y * J), rt = lt * ct, X = r.splitter * lt, Y = X - (X - lt), Q = lt - Y, X = r.splitter * ct, Z = X - (X - ct), J = ct - Z, it = Q * J - (rt - Y * Z - Q * Z - Y * J), K = nt - it, W = nt - K, s[0] = nt - (K + W) + (W - it), $ = et + K, W = $ - et, tt = et - ($ - W) + (K - W), K = tt - rt, W = tt - K, s[1] = tt - (K + W) + (W - rt), at = $ + K, W = at - $, s[2] = $ - (at - W) + (K - W), s[3] = at, et = lt * At, X = r.splitter * lt, Y = X - (X - lt), Q = lt - Y, X = r.splitter * At, Z = X - (X - At), J = At - Z, nt = Q * J - (et - Y * Z - Q * Z - Y * J), rt = ot * ut, X = r.splitter * ot, Y = X - (X - ot), Q = ot - Y, X = r.splitter * ut, Z = X - (X - ut), J = ut - Z, it = Q * J - (rt - Y * Z - Q * Z - Y * J), K = nt - it, W = nt - K, l[0] = nt - (K + W) + (W - it), $ = et + K, W = $ - et, tt = et - ($ - W) + (K - W), K = tt - rt, W = tt - K, l[1] = tt - (K + W) + (W - rt), at = $ + K, W = at - $, l[2] = $ - (at - W) + (K - W), l[3] = at, et = ot * ct, X = r.splitter * ot, Y = X - (X - ot), Q = ot - Y, X = r.splitter * ct, Z = X - (X - ct), J = ct - Z, nt = Q * J - (et - Y * Z - Q * Z - Y * J), rt = st * At, X = r.splitter * st, Y = X - (X - st), Q = st - Y, X = r.splitter * At, Z = X - (X - At), J = At - Z, it = Q * J - (rt - Y * Z - Q * Z - Y * J), K = nt - it, W = nt - K, A[0] = nt - (K + W) + (W - it), $ = et + K, W = $ - et, tt = et - ($ - W) + (K - W), K = tt - rt, W = tt - K, A[1] = tt - (K + W) + (W - rt), at = $ + K, W = at - $, A[2] = $ - (at - W) + (K - W), A[3] = at, q = (0, r.sum)((0, r.sum)((0, r.scale)(4, s, ht, y), y, (0, r.scale)(4, l, dt, x), x, b), b, (0, r.scale)(4, A, ft, y), y, w);
                        let pt = (0, r.estimate)(q, w),
                            mt = a * B;
                        if (pt >= mt || -pt >= mt) return pt;
                        if (W = t - ot, U = t - (ot + W) + (W - D), W = i - st, N = i - (st + W) + (W - D), W = R - lt, k = R - (lt + W) + (W - D), W = e - At, F = e - (At + W) + (W - I), W = _ - ct, z = _ - (ct + W) + (W - I), W = P - ut, G = P - (ut + W) + (W - I), W = n - ht, j = n - (ht + W) + (W - O), W = S - dt, V = S - (dt + W) + (W - O), W = L - ft, H = L - (ft + W) + (W - O), 0 === U && 0 === N && 0 === k && 0 === F && 0 === z && 0 === G && 0 === j && 0 === V && 0 === H) return pt;
                        if (mt = o * B + r.resulterrbound * Math.abs(pt), pt += ht * (st * G + ut * N - (ct * k + lt * z)) + j * (st * ut - ct * lt) + dt * (lt * F + At * k - (ut * U + ot * G)) + V * (lt * At - ut * ot) + ft * (ot * z + ct * U - (At * N + st * F)) + H * (ot * ct - At * st), pt >= mt || -pt >= mt) return pt;
                        const gt = T(U, F, st, ct, lt, ut, c, u),
                            vt = T(N, z, lt, ut, ot, At, h, d),
                            _t = T(k, G, ot, At, st, ct, f, p),
                            yt = (0, r.sum)(vt, h, _t, p, m);
                        q = E(q, (0, r.scale)(yt, m, ht, b), b);
                        const xt = (0, r.sum)(_t, f, gt, u, g);
                        q = E(q, (0, r.scale)(xt, g, dt, b), b);
                        const bt = (0, r.sum)(gt, c, vt, d, v);
                        return q = E(q, (0, r.scale)(bt, v, ft, b), b), 0 !== j && (q = E(q, (0, r.scale)(4, s, j, M), M), q = E(q, (0, r.scale)(yt, m, j, b), b)), 0 !== V && (q = E(q, (0, r.scale)(4, l, V, M), M), q = E(q, (0, r.scale)(xt, g, V, b), b)), 0 !== H && (q = E(q, (0, r.scale)(4, A, H, M), M), q = E(q, (0, r.scale)(bt, v, H, b), b)), 0 !== U && (0 !== z && (q = C(q, U, z, ft, H)), 0 !== G && (q = C(q, -U, G, dt, V))), 0 !== N && (0 !== G && (q = C(q, N, G, ht, j)), 0 !== F && (q = C(q, -N, F, ft, H))), 0 !== k && (0 !== F && (q = C(q, k, F, dt, V)), 0 !== z && (q = C(q, -k, z, ht, j))), w[q - 1]
                    }(t, e, n, _, S, R, P, L, D, I, O, B, K)
                }

                function P(t, e, n, r, i, a, o, s, l, A, c, u) {
                    const h = e - c,
                        d = i - c,
                        f = s - c,
                        p = n - u,
                        m = a - u,
                        g = l - u;
                    return (t - A) * (d * g - m * f) + (r - A) * (f * p - g * h) + (o - A) * (h * m - p * d)
                }
            },
            "./node_modules/robust-predicates/esm/util.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    epsilon: () => r,
                    estimate: () => c,
                    negate: () => A,
                    resulterrbound: () => a,
                    scale: () => l,
                    splitter: () => i,
                    sum: () => o,
                    sum_three: () => s,
                    vec: () => u
                });
                const r = 11102230246251565e-32,
                    i = 134217729,
                    a = (3 + 8 * r) * r;

                function o(t, e, n, r, i) {
                    let a, o, s, l, A = e[0],
                        c = r[0],
                        u = 0,
                        h = 0;
                    c > A == c > -A ? (a = A, A = e[++u]) : (a = c, c = r[++h]);
                    let d = 0;
                    if (u < t && h < n)
                        for (c > A == c > -A ? (o = A + a, s = a - (o - A), A = e[++u]) : (o = c + a, s = a - (o - c), c = r[++h]), a = o, 0 !== s && (i[d++] = s); u < t && h < n;) c > A == c > -A ? (o = a + A, l = o - a, s = a - (o - l) + (A - l), A = e[++u]) : (o = a + c, l = o - a, s = a - (o - l) + (c - l), c = r[++h]), a = o, 0 !== s && (i[d++] = s);
                    for (; u < t;) o = a + A, l = o - a, s = a - (o - l) + (A - l), A = e[++u], a = o, 0 !== s && (i[d++] = s);
                    for (; h < n;) o = a + c, l = o - a, s = a - (o - l) + (c - l), c = r[++h], a = o, 0 !== s && (i[d++] = s);
                    return 0 === a && 0 !== d || (i[d++] = a), d
                }

                function s(t, e, n, r, i, a, s, l) {
                    return o(o(t, e, n, r, s), s, i, a, l)
                }

                function l(t, e, n, r) {
                    let a, o, s, l, A, c, u, h, d, f, p;
                    u = i * n, f = u - (u - n), p = n - f;
                    let m = e[0];
                    a = m * n, u = i * m, h = u - (u - m), d = m - h, s = d * p - (a - h * f - d * f - h * p);
                    let g = 0;
                    0 !== s && (r[g++] = s);
                    for (let v = 1; v < t; v++) m = e[v], l = m * n, u = i * m, h = u - (u - m), d = m - h, A = d * p - (l - h * f - d * f - h * p), o = a + A, c = o - a, s = a - (o - c) + (A - c), 0 !== s && (r[g++] = s), a = l + o, s = o - (a - l), 0 !== s && (r[g++] = s);
                    return 0 === a && 0 !== g || (r[g++] = a), g
                }

                function A(t, e) {
                    for (let n = 0; n < t; n++) e[n] = -e[n];
                    return t
                }

                function c(t, e) {
                    let n = e[0];
                    for (let r = 1; r < t; r++) n += e[r];
                    return n
                }

                function u(t) {
                    return new Float64Array(t)
                }
            },
            "./node_modules/robust-predicates/index.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    incircle: () => a.incircle,
                    incirclefast: () => a.incirclefast,
                    insphere: () => o.insphere,
                    inspherefast: () => o.inspherefast,
                    orient2d: () => r.orient2d,
                    orient2dfast: () => r.orient2dfast,
                    orient3d: () => i.orient3d,
                    orient3dfast: () => i.orient3dfast
                });
                var r = n("./node_modules/robust-predicates/esm/orient2d.js"),
                    i = n("./node_modules/robust-predicates/esm/orient3d.js"),
                    a = n("./node_modules/robust-predicates/esm/incircle.js"),
                    o = n("./node_modules/robust-predicates/esm/insphere.js")
            },
            "./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    ConicPolygonBufferGeometry: () => T,
                    ConicPolygonGeometry: () => T
                });
                var r = n("./node_modules/three/build/three.module.js"),
                    i = n("./node_modules/d3-array/src/merge.js"),
                    a = n("./node_modules/d3-array/src/mean.js"),
                    o = n("./node_modules/d3-array/src/extent.js"),
                    s = n("./node_modules/earcut/src/earcut.js"),
                    l = n("./node_modules/delaunator/index.js"),
                    A = n("./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js"),
                    c = n("./node_modules/d3-geo/src/bounds.js"),
                    u = n("./node_modules/d3-geo/src/distance.js"),
                    h = n("./node_modules/d3-geo/src/interpolate.js"),
                    d = n("./node_modules/d3-geo/src/contains.js"),
                    f = n("./node_modules/d3-geo-voronoi/src/voronoi.js"),
                    p = n("./node_modules/d3-scale/src/linear.js");

                function m(t, e, n) {
                    return e = v(e),
                        function(t, e) {
                            if (e && ("object" == typeof e || "function" == typeof e)) return e;
                            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                            return function(t) {
                                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return t
                            }(t)
                        }(t, g() ? Reflect.construct(e, n || [], v(t).constructor) : e.apply(t, n))
                }

                function g() {
                    try {
                        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                    } catch (t) {}
                    return (g = function() {
                        return !!t
                    })()
                }

                function v(t) {
                    return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, v(t)
                }

                function _(t, e) {
                    return _ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                        return t.__proto__ = e, t
                    }, _(t, e)
                }

                function y(t, e) {
                    return function(t) {
                        if (Array.isArray(t)) return t
                    }(t) || function(t, e) {
                        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (null != n) {
                            var r, i, a, o, s = [],
                                l = !0,
                                A = !1;
                            try {
                                if (a = (n = n.call(t)).next, 0 === e) {
                                    if (Object(n) !== n) return;
                                    l = !1
                                } else
                                    for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                            } catch (t) {
                                A = !0, i = t
                            } finally {
                                try {
                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                } finally {
                                    if (A) throw i
                                }
                            }
                            return s
                        }
                    }(t, e) || b(t, e) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function x(t) {
                    return function(t) {
                        if (Array.isArray(t)) return M(t)
                    }(t) || function(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || b(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function b(t, e) {
                    if (t) {
                        if ("string" == typeof t) return M(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? M(t, e) : void 0
                    }
                }

                function M(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }

                function w(t, e) {
                    return arguments.length > 2 && void 0 !== arguments[2] && arguments[2] ? (0, d.default)(e, t) : (0, A.default)(t, e)
                }
                var S = window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        Float32BufferAttribute: r.Float32BufferAttribute
                    },
                    E = (new S.BufferGeometry).setAttribute ? "setAttribute" : "addAttribute",
                    T = function(t) {
                        function e(t, n, r, A, d, g, v) {
                            var _;
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e), (_ = m(this, e)).type = "ConicPolygonBufferGeometry", _.parameters = {
                                polygonGeoJson: t,
                                startHeight: n,
                                endHeight: r,
                                closedBottom: A,
                                closedTop: d,
                                includeSides: g,
                                curvatureResolution: v
                            }, n = n || 0, r = r || 1, A = void 0 === A || A, d = void 0 === d || d, g = void 0 === g || g;
                            var b = function(t) {
                                    var e = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).resolution,
                                        n = void 0 === e ? 1 / 0 : e,
                                        r = function(t, e) {
                                            return t.map((function(t) {
                                                var n, r = [];
                                                return t.forEach((function(t) {
                                                    if (n) {
                                                        var i = 180 * (0, u.default)(t, n) / Math.PI;
                                                        if (i > e)
                                                            for (var a = (0, h.default)(n, t), o = 1 / Math.ceil(i / e), s = o; s < 1;) r.push(a(s)), s += o
                                                    }
                                                    r.push(n = t)
                                                })), r
                                            }))
                                        }(t, n),
                                        A = (0, i.default)(r),
                                        d = function(t, e) {
                                            var n = {
                                                    type: "Polygon",
                                                    coordinates: t
                                                },
                                                r = y((0, c.default)(n), 2),
                                                i = y(r[0], 2),
                                                a = i[0],
                                                o = i[1],
                                                s = y(r[1], 2),
                                                l = s[0],
                                                A = s[1];
                                            if (Math.min(Math.abs(l - a), Math.abs(A - o)) < e) return [];
                                            var u = a > l || A >= 89 || o <= -89;
                                            return function(t) {
                                                for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.minLng, r = e.maxLng, i = e.minLat, a = e.maxLat, o = Math.round(Math.pow(360 / t, 2) / Math.PI), s = (1 + Math.sqrt(5)) / 2, l = function(t) {
                                                        return Math.acos(2 * t / o - 1) / Math.PI * 180 - 90
                                                    }, A = function(t) {
                                                        return o * (Math.cos((t + 90) * Math.PI / 180) + 1) / 2
                                                    }, c = [void 0 !== a ? Math.ceil(A(a)) : 0, void 0 !== i ? Math.floor(A(i)) : o - 1], u = void 0 === n && void 0 === r ? function() {
                                                        return !0
                                                    } : void 0 === n ? function(t) {
                                                        return t <= r
                                                    } : void 0 === r ? function(t) {
                                                        return t >= n
                                                    } : r >= n ? function(t) {
                                                        return t >= n && t <= r
                                                    } : function(t) {
                                                        return t >= n || t <= r
                                                    }, h = [], d = c[0]; d <= c[1]; d++) {
                                                    var f = d / s * 360 % 360 - 180;
                                                    u(f) && h.push([f, l(d)])
                                                }
                                                return h
                                            }(e, {
                                                minLng: a,
                                                maxLng: l,
                                                minLat: o,
                                                maxLat: A
                                            }).filter((function(t) {
                                                return w(t, n, u)
                                            }))
                                        }(t, n),
                                        m = [].concat(x(A), x(d)),
                                        g = {
                                            type: "Polygon",
                                            coordinates: t
                                        },
                                        v = y((0, c.default)(g), 2),
                                        _ = y(v[0], 2),
                                        b = _[0],
                                        M = _[1],
                                        S = y(v[1], 2),
                                        E = S[0],
                                        T = S[1],
                                        C = b > E || T >= 89 || M <= -89,
                                        R = [];
                                    if (C) {
                                        var P = (0, f.geoVoronoi)(m).triangles(),
                                            L = new Map(m.map((function(t, e) {
                                                var n = y(t, 2),
                                                    r = n[0],
                                                    i = n[1];
                                                return ["".concat(r, "-").concat(i), e]
                                            })));
                                        P.features.forEach((function(t) {
                                            var e, n = t.geometry.coordinates[0].slice(0, 3).reverse(),
                                                r = [];
                                            if (n.forEach((function(t) {
                                                    var e = y(t, 2),
                                                        n = e[0],
                                                        i = e[1],
                                                        a = "".concat(n, "-").concat(i);
                                                    L.has(a) && r.push(L.get(a))
                                                })), 3 === r.length) {
                                                if (r.some((function(t) {
                                                        return t < A.length
                                                    })) && !w(t.properties.circumcenter, g, C)) return;
                                                (e = R).push.apply(e, r)
                                            }
                                        }))
                                    } else if (d.length)
                                        for (var D = l.default.from(m), I = function(t) {
                                                var e, n = [2, 1, 0].map((function(e) {
                                                        return D.triangles[t + e]
                                                    })),
                                                    r = n.map((function(t) {
                                                        return m[t]
                                                    }));
                                                if (n.some((function(t) {
                                                        return t < A.length
                                                    })) && !w([0, 1].map((function(t) {
                                                        return (0, a.default)(r, (function(e) {
                                                            return e[t]
                                                        }))
                                                    })), g, C)) return 1;
                                                (e = R).push.apply(e, x(n))
                                            }, O = 0, B = D.triangles.length; O < B; O += 3) I(O);
                                    else {
                                        var q = s.flatten(r),
                                            U = q.vertices,
                                            N = q.holes;
                                        R = s(U, void 0 === N ? [] : N, 2)
                                    }
                                    var k = (0, p.default)((0, o.default)(m, (function(t) {
                                            return t[0]
                                        })), [0, 1]),
                                        F = (0, p.default)((0, o.default)(m, (function(t) {
                                            return t[1]
                                        })), [0, 1]),
                                        z = m.map((function(t) {
                                            var e = y(t, 2),
                                                n = e[0],
                                                r = e[1];
                                            return [k(n), F(r)]
                                        }));
                                    return {
                                        contour: r,
                                        triangles: {
                                            points: m,
                                            indices: R,
                                            uvs: z
                                        }
                                    }
                                }(t, {
                                    resolution: v = v || 5
                                }),
                                M = b.contour,
                                T = b.triangles,
                                C = (0, i.default)(T.uvs),
                                R = [],
                                P = [],
                                L = [],
                                D = 0,
                                I = function(t) {
                                    var e = Math.round(R.length / 3),
                                        n = L.length;
                                    R = R.concat(t.vertices), P = P.concat(t.uvs), L = L.concat(e ? t.indices.map((function(t) {
                                        return t + e
                                    })) : t.indices), _.addGroup(n, L.length - n, D++)
                                };

                            function O(t, e) {
                                var n = t.map((function(t) {
                                    return t.map((function(t) {
                                        var n = y(t, 2),
                                            r = n[0];
                                        return function(t, e) {
                                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                                r = (90 - t) * Math.PI / 180,
                                                i = (90 - e) * Math.PI / 180;
                                            return [n * Math.sin(r) * Math.cos(i), n * Math.cos(r), n * Math.sin(r) * Math.sin(i)]
                                        }(n[1], r, e)
                                    }))
                                }));
                                return s.flatten(n)
                            }

                            function B(t) {
                                return {
                                    indices: arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] ? T.indices.slice().reverse() : T.indices,
                                    vertices: O([T.points], t).vertices,
                                    uvs: C
                                }
                            }
                            return g && I(function() {
                                for (var t = O(M, n), e = t.vertices, a = t.holes, o = O(M, r).vertices, s = (0, i.default)([o, e]), l = Math.round(o.length / 3), A = new Set(a), c = 0, u = [], h = 0; h < l; h++) {
                                    var d = h + 1;
                                    if (d === l) d = c;
                                    else if (A.has(d)) {
                                        var f = d;
                                        d = c, c = f
                                    }
                                    u.push(h, h + l, d + l), u.push(d + l, d, h)
                                }
                                for (var p = [], m = 1; m >= 0; m--)
                                    for (var g = 0; g < l; g += 1) p.push(g / (l - 1), m);
                                return {
                                    indices: u,
                                    vertices: s,
                                    uvs: p
                                }
                            }()), A && I(B(n, !1)), d && I(B(r, !0)), _.setIndex(L), _[E]("position", new S.Float32BufferAttribute(R, 3)), _[E]("uv", new S.Float32BufferAttribute(P, 2)), _.computeVertexNormals(), _
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), Object.defineProperty(t, "prototype", {
                                writable: !1
                            }), e && _(t, e)
                        }(e, t), n = e, Object.defineProperty(n, "prototype", {
                            writable: !1
                        }), n;
                        var n
                    }(S.BufferGeometry)
            },
            "./node_modules/three-fatline/dist/three-fatline.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    Line2: () => T,
                    LineGeometry: () => E,
                    LineMaterial: () => c,
                    LineSegments2: () => S,
                    LineSegmentsGeometry: () => l
                });
                var r = n("./node_modules/three/build/three.module.js");
                const i = window.THREE ? window.THREE : {
                    Box3: r.Box3,
                    BufferGeometry: r.BufferGeometry,
                    Float32BufferAttribute: r.Float32BufferAttribute,
                    InstancedBufferGeometry: r.InstancedBufferGeometry,
                    InstancedInterleavedBuffer: r.InstancedInterleavedBuffer,
                    InterleavedBufferAttribute: r.InterleavedBufferAttribute,
                    Sphere: r.Sphere,
                    Vector3: r.Vector3,
                    WireframeGeometry: r.WireframeGeometry
                };
                var a = (new i.BufferGeometry).setAttribute ? "setAttribute" : "addAttribute";
                const o = new i.Box3,
                    s = new i.Vector3;
                class l extends i.InstancedBufferGeometry {
                    constructor() {
                        super(), this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this[a]("position", new i.Float32BufferAttribute([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this[a]("uv", new i.Float32BufferAttribute([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2))
                    }
                    applyMatrix4(t) {
                        const e = this.attributes.instanceStart,
                            n = this.attributes.instanceEnd;
                        return void 0 !== e && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    setPositions(t) {
                        let e;
                        t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
                        const n = new i.InstancedInterleavedBuffer(e, 6, 1);
                        return this[a]("instanceStart", new i.InterleavedBufferAttribute(n, 3, 0)), this[a]("instanceEnd", new i.InterleavedBufferAttribute(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
                    }
                    setColors(t) {
                        let e;
                        t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
                        const n = new i.InstancedInterleavedBuffer(e, 6, 1);
                        return this[a]("instanceColorStart", new i.InterleavedBufferAttribute(n, 3, 0)), this[a]("instanceColorEnd", new i.InterleavedBufferAttribute(n, 3, 3)), this
                    }
                    fromWireframeGeometry(t) {
                        return this.setPositions(t.attributes.position.array), this
                    }
                    fromEdgesGeometry(t) {
                        return this.setPositions(t.attributes.position.array), this
                    }
                    fromMesh(t) {
                        return this.fromWireframeGeometry(new i.WireframeGeometry(t.geometry)), this
                    }
                    fromLineSegments(t) {
                        const e = t.geometry;
                        if (!e.isGeometry) return e.isBufferGeometry && this.setPositions(e.attributes.position.array), this;
                        console.error("LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new i.Box3);
                        const t = this.attributes.instanceStart,
                            e = this.attributes.instanceEnd;
                        void 0 !== t && void 0 !== e && (this.boundingBox.setFromBufferAttribute(t), o.setFromBufferAttribute(e), this.boundingBox.union(o))
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new i.Sphere), null === this.boundingBox && this.computeBoundingBox();
                        const t = this.attributes.instanceStart,
                            e = this.attributes.instanceEnd;
                        if (void 0 !== t && void 0 !== e) {
                            const n = this.boundingSphere.center;
                            this.boundingBox.getCenter(n);
                            let r = 0;
                            for (let i = 0, a = t.count; i < a; i++) s.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(s)), s.fromBufferAttribute(e, i), r = Math.max(r, n.distanceToSquared(s));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
                        }
                    }
                    toJSON() {}
                    applyMatrix(t) {
                        return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t)
                    }
                }
                l.prototype.isLineSegmentsGeometry = !0;
                const A = window.THREE ? window.THREE : {
                    ShaderLib: r.ShaderLib,
                    ShaderMaterial: r.ShaderMaterial,
                    UniformsLib: r.UniformsLib,
                    UniformsUtils: r.UniformsUtils,
                    Vector2: r.Vector2
                };
                A.UniformsLib.line = {
                    worldUnits: {
                        value: 1
                    },
                    linewidth: {
                        value: 1
                    },
                    resolution: {
                        value: new A.Vector2(1, 1)
                    },
                    dashScale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    dashOffset: {
                        value: 0
                    },
                    gapSize: {
                        value: 1
                    }
                }, A.ShaderLib.line = {
                    uniforms: A.UniformsUtils.merge([A.UniformsLib.common, A.UniformsLib.fog, A.UniformsLib.line]),
                    vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
                    fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"
                };
                class c extends A.ShaderMaterial {
                    constructor(t) {
                        super({
                            type: "LineMaterial",
                            uniforms: A.UniformsUtils.clone(A.ShaderLib.line.uniforms),
                            vertexShader: A.ShaderLib.line.vertexShader,
                            fragmentShader: A.ShaderLib.line.fragmentShader,
                            clipping: !0
                        }), Object.defineProperties(this, {
                            color: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.diffuse.value
                                },
                                set: function(t) {
                                    this.uniforms.diffuse.value = t
                                }
                            },
                            worldUnits: {
                                enumerable: !0,
                                get: function() {
                                    return "WORLD_UNITS" in this.defines
                                },
                                set: function(t) {
                                    !0 === t ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
                                }
                            },
                            linewidth: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.linewidth.value
                                },
                                set: function(t) {
                                    this.uniforms.linewidth.value = t
                                }
                            },
                            dashed: {
                                enumerable: !0,
                                get: function() {
                                    return Boolean("USE_DASH" in this.defines)
                                },
                                set(t) {
                                    Boolean(t) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === t ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
                                }
                            },
                            dashScale: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.dashScale.value
                                },
                                set: function(t) {
                                    this.uniforms.dashScale.value = t
                                }
                            },
                            dashSize: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.dashSize.value
                                },
                                set: function(t) {
                                    this.uniforms.dashSize.value = t
                                }
                            },
                            dashOffset: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.dashOffset.value
                                },
                                set: function(t) {
                                    this.uniforms.dashOffset.value = t
                                }
                            },
                            gapSize: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.gapSize.value
                                },
                                set: function(t) {
                                    this.uniforms.gapSize.value = t
                                }
                            },
                            opacity: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.opacity.value
                                },
                                set: function(t) {
                                    this.uniforms.opacity.value = t
                                }
                            },
                            resolution: {
                                enumerable: !0,
                                get: function() {
                                    return this.uniforms.resolution.value
                                },
                                set: function(t) {
                                    this.uniforms.resolution.value.copy(t)
                                }
                            },
                            alphaToCoverage: {
                                enumerable: !0,
                                get: function() {
                                    return Boolean("ALPHA_TO_COVERAGE" in this.defines)
                                },
                                set: function(t) {
                                    Boolean(t) !== Boolean("ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === t ? (this.defines.ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.ALPHA_TO_COVERAGE, this.extensions.derivatives = !1)
                                }
                            }
                        }), this.setValues(t)
                    }
                }
                c.prototype.isLineMaterial = !0;
                const u = window.THREE ? window.THREE : {
                    Box3: r.Box3,
                    BufferGeometry: r.BufferGeometry,
                    InstancedInterleavedBuffer: r.InstancedInterleavedBuffer,
                    InterleavedBufferAttribute: r.InterleavedBufferAttribute,
                    Line3: r.Line3,
                    MathUtils: r.MathUtils,
                    Matrix4: r.Matrix4,
                    Mesh: r.Mesh,
                    Sphere: r.Sphere,
                    Vector3: r.Vector3,
                    Vector4: r.Vector4
                };
                var h = (new u.BufferGeometry).setAttribute ? "setAttribute" : "addAttribute";
                const d = new u.Vector3,
                    f = new u.Vector3,
                    p = new u.Vector4,
                    m = new u.Vector4,
                    g = new u.Vector4,
                    v = new u.Vector3,
                    _ = new u.Matrix4,
                    y = new u.Line3,
                    x = new u.Vector3,
                    b = new u.Box3,
                    M = new u.Sphere,
                    w = new u.Vector4;
                class S extends u.Mesh {
                    constructor(t = new l, e = new c({
                        color: 16777215 * Math.random()
                    })) {
                        super(t, e), this.type = "LineSegments2"
                    }
                    computeLineDistances() {
                        const t = this.geometry,
                            e = t.attributes.instanceStart,
                            n = t.attributes.instanceEnd,
                            r = new Float32Array(2 * e.count);
                        for (let t = 0, i = 0, a = e.count; t < a; t++, i += 2) d.fromBufferAttribute(e, t), f.fromBufferAttribute(n, t), r[i] = 0 === i ? 0 : r[i - 1], r[i + 1] = r[i] + d.distanceTo(f);
                        const i = new u.InstancedInterleavedBuffer(r, 2, 1);
                        return t[h]("instanceDistanceStart", new u.InterleavedBufferAttribute(i, 1, 0)), t[h]("instanceDistanceEnd", new u.InterleavedBufferAttribute(i, 1, 1)), this
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
                        const n = void 0 !== t.params.Line2 && t.params.Line2.threshold || 0,
                            r = t.ray,
                            i = t.camera,
                            a = i.projectionMatrix,
                            o = this.matrixWorld,
                            s = this.geometry,
                            l = this.material,
                            A = l.resolution,
                            c = l.linewidth + n,
                            h = s.attributes.instanceStart,
                            d = s.attributes.instanceEnd,
                            f = -i.near,
                            S = 2 * Math.max(c / A.width, c / A.height);
                        null === s.boundingSphere && s.computeBoundingSphere(), M.copy(s.boundingSphere).applyMatrix4(o);
                        const E = Math.max(i.near, M.distanceToPoint(r.origin));
                        w.set(0, 0, -E, 1).applyMatrix4(i.projectionMatrix), w.multiplyScalar(1 / w.w), w.applyMatrix4(i.projectionMatrixInverse);
                        const T = .5 * Math.abs(S / w.w);
                        if (M.radius += T, !1 === t.ray.intersectsSphere(M)) return;
                        null === s.boundingBox && s.computeBoundingBox(), b.copy(s.boundingBox).applyMatrix4(o);
                        const C = Math.max(i.near, b.distanceToPoint(r.origin));
                        w.set(0, 0, -C, 1).applyMatrix4(i.projectionMatrix), w.multiplyScalar(1 / w.w), w.applyMatrix4(i.projectionMatrixInverse);
                        const R = .5 * Math.abs(S / w.w);
                        if (b.max.x += R, b.max.y += R, b.max.z += R, b.min.x -= R, b.min.y -= R, b.min.z -= R, !1 !== t.ray.intersectsBox(b)) {
                            r.at(1, g), g.w = 1, g.applyMatrix4(i.matrixWorldInverse), g.applyMatrix4(a), g.multiplyScalar(1 / g.w), g.x *= A.x / 2, g.y *= A.y / 2, g.z = 0, v.copy(g), _.multiplyMatrices(i.matrixWorldInverse, o);
                            for (let t = 0, n = h.count; t < n; t++) {
                                if (p.fromBufferAttribute(h, t), m.fromBufferAttribute(d, t), p.w = 1, m.w = 1, p.applyMatrix4(_), m.applyMatrix4(_), p.z > f && m.z > f) continue;
                                if (p.z > f) {
                                    const t = p.z - m.z,
                                        e = (p.z - f) / t;
                                    p.lerp(m, e)
                                } else if (m.z > f) {
                                    const t = m.z - p.z,
                                        e = (m.z - f) / t;
                                    m.lerp(p, e)
                                }
                                p.applyMatrix4(a), m.applyMatrix4(a), p.multiplyScalar(1 / p.w), m.multiplyScalar(1 / m.w), p.x *= A.x / 2, p.y *= A.y / 2, m.x *= A.x / 2, m.y *= A.y / 2, y.start.copy(p), y.start.z = 0, y.end.copy(m), y.end.z = 0;
                                const n = y.closestPointToPointParameter(v, !0);
                                y.at(n, x);
                                const i = u.MathUtils.lerp(p.z, m.z, n),
                                    s = i >= -1 && i <= 1,
                                    l = v.distanceTo(x) < .5 * c;
                                if (s && l) {
                                    y.start.fromBufferAttribute(h, t), y.end.fromBufferAttribute(d, t), y.start.applyMatrix4(o), y.end.applyMatrix4(o);
                                    const n = new u.Vector3,
                                        i = new u.Vector3;
                                    r.distanceSqToSegment(y.start, y.end, i, n), e.push({
                                        point: i,
                                        pointOnLine: n,
                                        distance: r.origin.distanceTo(i),
                                        object: this,
                                        face: null,
                                        faceIndex: t,
                                        uv: null,
                                        uv2: null
                                    })
                                }
                            }
                        }
                    }
                }
                S.prototype.LineSegments2 = !0;
                class E extends l {
                    constructor() {
                        super(), this.type = "LineGeometry"
                    }
                    setPositions(t) {
                        for (var e = t.length - 3, n = new Float32Array(2 * e), r = 0; r < e; r += 3) n[2 * r] = t[r], n[2 * r + 1] = t[r + 1], n[2 * r + 2] = t[r + 2], n[2 * r + 3] = t[r + 3], n[2 * r + 4] = t[r + 4], n[2 * r + 5] = t[r + 5];
                        return super.setPositions(n), this
                    }
                    setColors(t) {
                        for (var e = t.length - 3, n = new Float32Array(2 * e), r = 0; r < e; r += 3) n[2 * r] = t[r], n[2 * r + 1] = t[r + 1], n[2 * r + 2] = t[r + 2], n[2 * r + 3] = t[r + 3], n[2 * r + 4] = t[r + 4], n[2 * r + 5] = t[r + 5];
                        return super.setColors(n), this
                    }
                    fromLine(t) {
                        var e = t.geometry;
                        if (!e.isGeometry) return e.isBufferGeometry && this.setPositions(e.attributes.position.array), this;
                        console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
                E.prototype.isLineGeometry = !0;
                class T extends S {
                    constructor(t = new E, e = new c({
                        color: 16777215 * Math.random()
                    })) {
                        super(t, e), this.type = "Line2"
                    }
                }
                T.prototype.isLine2 = !0
            },
            "./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    GeoJsonGeometry: () => g
                });
                var r = n("./node_modules/three/build/three.module.js"),
                    i = n("./node_modules/earcut/src/earcut.js"),
                    a = n("./node_modules/d3-geo/src/distance.js"),
                    o = n("./node_modules/d3-geo/src/interpolate.js");

                function s(t, e, n) {
                    return e = A(e),
                        function(t, e) {
                            if (e && ("object" == typeof e || "function" == typeof e)) return e;
                            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                            return function(t) {
                                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return t
                            }(t)
                        }(t, l() ? Reflect.construct(e, n || [], A(t).constructor) : e.apply(t, n))
                }

                function l() {
                    try {
                        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                    } catch (t) {}
                    return (l = function() {
                        return !!t
                    })()
                }

                function A(t) {
                    return A = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, A(t)
                }

                function c(t, e) {
                    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                        return t.__proto__ = e, t
                    }, c(t, e)
                }

                function u(t, e) {
                    return function(t) {
                        if (Array.isArray(t)) return t
                    }(t) || function(t, e) {
                        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (null != n) {
                            var r, i, a, o, s = [],
                                l = !0,
                                A = !1;
                            try {
                                if (a = (n = n.call(t)).next, 0 === e) {
                                    if (Object(n) !== n) return;
                                    l = !1
                                } else
                                    for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                            } catch (t) {
                                A = !0, i = t
                            } finally {
                                try {
                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                } finally {
                                    if (A) throw i
                                }
                            }
                            return s
                        }
                    }(t, e) || h(t, e) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function h(t, e) {
                    if (t) {
                        if ("string" == typeof t) return d(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? d(t, e) : void 0
                    }
                }

                function d(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }
                var f = function() {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            e = [],
                            n = null;
                        return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((function(r) {
                            if (n) {
                                var i = 180 * (0, a.default)(r, n) / Math.PI;
                                if (i > t)
                                    for (var s = (0, o.default)(n, r), l = 1 / Math.ceil(i / t), A = l; A < 1;) e.push(s(A)), A += l
                            }
                            e.push(n = r)
                        })), e
                    },
                    p = "undefined" != typeof window && window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        Float32BufferAttribute: r.Float32BufferAttribute
                    },
                    m = (new p.BufferGeometry).setAttribute ? "setAttribute" : "addAttribute",
                    g = function(t) {
                        function e(t) {
                            var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                                a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5;
                            ! function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e), (n = s(this, e)).type = "GeoJsonGeometry", n.parameters = {
                                geoJson: t,
                                radius: r,
                                resolution: a
                            };
                            var o = ({
                                    Point: h,
                                    MultiPoint: function(t, e) {
                                        var n = {
                                            vertices: [],
                                            indices: []
                                        };
                                        return t.map((function(t) {
                                            return h(t, e)
                                        })).forEach((function(t) {
                                            var e = u(t, 1)[0];
                                            v(n, e)
                                        })), [n]
                                    },
                                    LineString: d,
                                    MultiLineString: function(t, e) {
                                        var n = {
                                            vertices: [],
                                            indices: []
                                        };
                                        return t.map((function(t) {
                                            return d(t, e)
                                        })).forEach((function(t) {
                                            var e = u(t, 1)[0];
                                            v(n, e)
                                        })), [n]
                                    },
                                    Polygon: g,
                                    MultiPolygon: function(t, e) {
                                        var n = {
                                                vertices: [],
                                                indices: []
                                            },
                                            r = {
                                                vertices: [],
                                                indices: []
                                            };
                                        t.map((function(t) {
                                            return g(t, e)
                                        })).forEach((function(t) {
                                            var e = u(t, 2),
                                                i = e[0],
                                                a = e[1];
                                            v(n, i), a && v(r, a)
                                        }));
                                        var i = [n];
                                        return r.vertices.length && i.push(r), i
                                    }
                                } [t.type] || function() {
                                    return []
                                })(t.coordinates, r),
                                l = [],
                                A = [],
                                c = 0;

                            function h(t, e) {
                                return [{
                                    vertices: y(t[1], t[0], e),
                                    indices: []
                                }]
                            }

                            function d(t, e) {
                                for (var n = f(t, a).map((function(t) {
                                        var n = u(t, 2),
                                            r = n[0];
                                        return y(n[1], r, e)
                                    })), r = i.flatten([n]).vertices, o = Math.round(r.length / 3), s = [], l = 1; l < o; l++) s.push(l - 1, l);
                                return [{
                                    vertices: r,
                                    indices: s
                                }]
                            }

                            function g(t, e) {
                                for (var n = t.map((function(t) {
                                        return f(t, a).map((function(t) {
                                            var n = u(t, 2),
                                                r = n[0];
                                            return y(n[1], r, e)
                                        }))
                                    })), r = i.flatten(n), o = r.vertices, s = r.holes, l = s[0] || 1 / 0, A = o.slice(0, 3 * l), c = o.slice(3 * l), h = new Set(s), d = Math.round(o.length / 3), p = [], m = [], g = 1; g < d; g++) h.has(g) || (g < l ? p.push(g - 1, g) : m.push(g - 1 - l, g - l));
                                var v = [{
                                    indices: p,
                                    vertices: A
                                }];
                                return s.length && v.push({
                                    indices: m,
                                    vertices: c
                                }), v
                            }
                            return o.forEach((function(t) {
                                var e = l.length;
                                v({
                                    indices: l,
                                    vertices: A
                                }, t), n.addGroup(e, l.length - e, c++)
                            })), l.length && n.setIndex(l), A.length && n[m]("position", new p.Float32BufferAttribute(A, 3)), n
                        }
                        return function(t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), Object.defineProperty(t, "prototype", {
                                writable: !1
                            }), e && c(t, e)
                        }(e, t), n = e, Object.defineProperty(n, "prototype", {
                            writable: !1
                        }), n;
                        var n
                    }(p.BufferGeometry);

                function v(t, e) {
                    var n = Math.round(t.vertices.length / 3);
                    _(t.vertices, e.vertices), _(t.indices, e.indices.map((function(t) {
                        return t + n
                    })))
                }

                function _(t, e) {
                    var n, r = function(t, e) {
                        var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!n) {
                            if (Array.isArray(t) || (n = h(t))) {
                                n && (t = n);
                                var r = 0,
                                    i = function() {};
                                return {
                                    s: i,
                                    n: function() {
                                        return r >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[r++]
                                        }
                                    },
                                    e: function(t) {
                                        throw t
                                    },
                                    f: i
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var a, o = !0,
                            s = !1;
                        return {
                            s: function() {
                                n = n.call(t)
                            },
                            n: function() {
                                var t = n.next();
                                return o = t.done, t
                            },
                            e: function(t) {
                                s = !0, a = t
                            },
                            f: function() {
                                try {
                                    o || null == n.return || n.return()
                                } finally {
                                    if (s) throw a
                                }
                            }
                        }
                    }(e);
                    try {
                        for (r.s(); !(n = r.n()).done;) {
                            var i = n.value;
                            t.push(i)
                        }
                    } catch (t) {
                        r.e(t)
                    } finally {
                        r.f()
                    }
                }

                function y(t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        r = (90 - t) * Math.PI / 180,
                        i = (90 - e) * Math.PI / 180;
                    return [n * Math.sin(r) * Math.cos(i), n * Math.cos(r), n * Math.sin(r) * Math.sin(i)]
                }
            },
            "./node_modules/three-globe/dist/three-globe.mjs": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    default: () => Ge
                });
                var r = n("./node_modules/three/build/three.module.js"),
                    i = n("./node_modules/kapsule/dist/kapsule.mjs"),
                    a = n("./node_modules/@tweenjs/tween.js/dist/tween.esm.js"),
                    o = n("./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs"),
                    s = n("./node_modules/d3-geo/src/graticule.js"),
                    l = n("./node_modules/d3-geo/src/distance.js"),
                    A = n("./node_modules/d3-geo/src/interpolate.js"),
                    c = n("./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"),
                    u = n("./node_modules/accessor-fn/dist/accessor-fn.mjs"),
                    h = n("./node_modules/d3-color/src/color.js"),
                    d = n("./node_modules/tinycolor2/esm/tinycolor.js"),
                    f = n("./node_modules/data-joint/dist/data-joint.mjs"),
                    p = n("./node_modules/frame-ticker/dist/FrameTicker.js"),
                    m = n("./node_modules/d3-scale/src/linear.js"),
                    g = n("./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs"),
                    v = n("./node_modules/index-array-by/dist/index-array-by.mjs"),
                    _ = n("./node_modules/h3-js/dist/browser/h3-js.es.js"),
                    y = n("./node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js"),
                    x = n("./node_modules/d3-array/src/sum.js"),
                    b = n("./node_modules/d3-array/src/max.js"),
                    M = n("./node_modules/yaot/index.js"),
                    w = n("./node_modules/three-fatline/dist/three-fatline.mjs"),
                    S = n("./node_modules/d3-interpolate/src/array.js"),
                    E = n("./node_modules/three/examples/jsm/geometries/TextGeometry.js"),
                    T = n("./node_modules/three/examples/jsm/loaders/FontLoader.js"),
                    C = n("./node_modules/three/examples/jsm/renderers/CSS2DRenderer.js");

                function R(t, e, n) {
                    return e = k(e),
                        function(t, e) {
                            if (e && ("object" == typeof e || "function" == typeof e)) return e;
                            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                            return z(t)
                        }(t, P() ? Reflect.construct(e, n || [], k(t).constructor) : e.apply(t, n))
                }

                function P() {
                    try {
                        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                    } catch (t) {}
                    return (P = function() {
                        return !!t
                    })()
                }

                function L(t, e) {
                    var n = Object.keys(t);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(t);
                        e && (r = r.filter((function(e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        }))), n.push.apply(n, r)
                    }
                    return n
                }

                function D(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = null != arguments[e] ? arguments[e] : {};
                        e % 2 ? L(Object(n), !0).forEach((function(e) {
                            U(t, e, n[e])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : L(Object(n)).forEach((function(e) {
                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                        }))
                    }
                    return t
                }

                function I(t) {
                    var e = function(t, e) {
                        if ("object" != typeof t || !t) return t;
                        var n = t[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(t, "string");
                            if ("object" != typeof r) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(t)
                    }(t);
                    return "symbol" == typeof e ? e : String(e)
                }

                function O(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function B(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, I(r.key), r)
                    }
                }

                function q(t, e, n) {
                    return e && B(t.prototype, e), n && B(t, n), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }

                function U(t, e, n) {
                    return (e = I(e)) in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                function N(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && F(t, e)
                }

                function k(t) {
                    return k = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, k(t)
                }

                function F(t, e) {
                    return F = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                        return t.__proto__ = e, t
                    }, F(t, e)
                }

                function z(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function G(t, e) {
                    return function(t) {
                        if (Array.isArray(t)) return t
                    }(t) || function(t, e) {
                        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (null != n) {
                            var r, i, a, o, s = [],
                                l = !0,
                                A = !1;
                            try {
                                if (a = (n = n.call(t)).next, 0 === e) {
                                    if (Object(n) !== n) return;
                                    l = !1
                                } else
                                    for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
                            } catch (t) {
                                A = !0, i = t
                            } finally {
                                try {
                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                } finally {
                                    if (A) throw i
                                }
                            }
                            return s
                        }
                    }(t, e) || V(t, e) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function j(t) {
                    return function(t) {
                        if (Array.isArray(t)) return H(t)
                    }(t) || function(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || V(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function V(t, e) {
                    if (t) {
                        if ("string" == typeof t) return H(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? H(t, e) : void 0
                    }
                }

                function H(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }

                function W(t, e) {
                    return function(t, e) {
                        return e.get ? e.get.call(t) : e.value
                    }(t, Y(t, e, "get"))
                }

                function X(t, e, n) {
                    return function(t, e, n) {
                        if (e.set) e.set.call(t, n);
                        else {
                            if (!e.writable) throw new TypeError("attempted to set read only private field");
                            e.value = n
                        }
                    }(t, Y(t, e, "set"), n), n
                }

                function Y(t, e, n) {
                    if (!e.has(t)) throw new TypeError("attempted to " + n + " private field on non-instance");
                    return e.get(t)
                }

                function Q(t, e) {
                    if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
                }

                function Z(t, e, n) {
                    Q(t, e), e.set(t, n)
                }
                var J = function t(e) {
                        e instanceof Array ? e.forEach(t) : (e.map && e.map.dispose(), e.dispose())
                    },
                    K = function t(e) {
                        e.geometry && e.geometry.dispose(), e.material && J(e.material), e.texture && e.texture.dispose(), e.children && e.children.forEach(t)
                    },
                    $ = function(t) {
                        if (t && t.children)
                            for (; t.children.length;) {
                                var e = t.children[0];
                                t.remove(e), K(e)
                            }
                    };

                function tt(t, e) {
                    var n = new e;
                    return {
                        linkProp: function(e) {
                            return {
                                default: n[e](),
                                onChange: function(n, r) {
                                    r[t][e](n)
                                },
                                triggerUpdate: !1
                            }
                        },
                        linkMethod: function(e) {
                            return function(n) {
                                for (var r = n[t], i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) a[o - 1] = arguments[o];
                                var s = r[e].apply(r, a);
                                return s === r ? this : s
                            }
                        }
                    }
                }
                var et = 100;

                function nt() {
                    return et
                }

                function rt(t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        r = (90 - t) * Math.PI / 180,
                        i = (90 - e) * Math.PI / 180,
                        a = et * (1 + n);
                    return {
                        x: a * Math.sin(r) * Math.cos(i),
                        y: a * Math.cos(r),
                        z: a * Math.sin(r) * Math.sin(i)
                    }
                }

                function it(t) {
                    var e = t.x,
                        n = t.y,
                        r = t.z,
                        i = Math.sqrt(e * e + n * n + r * r),
                        a = Math.acos(n / i),
                        o = Math.atan2(r, e);
                    return {
                        lat: 90 - 180 * a / Math.PI,
                        lng: 90 - 180 * o / Math.PI - (o < -Math.PI / 2 ? 360 : 0),
                        altitude: i / et - 1
                    }
                }

                function at(t) {
                    return t * Math.PI / 180
                }
                var ot = window.THREE ? window.THREE : {
                        BackSide: r.BackSide,
                        BufferAttribute: r.BufferAttribute,
                        Color: r.Color,
                        Mesh: r.Mesh,
                        ShaderMaterial: r.ShaderMaterial
                    },
                    st = {
                        backside: !0,
                        coefficient: .5,
                        color: "gold",
                        size: 2,
                        power: 1
                    };
                var lt = window.THREE ? window.THREE : {
                        Color: r.Color,
                        LineBasicMaterial: r.LineBasicMaterial,
                        LineSegments: r.LineSegments,
                        Mesh: r.Mesh,
                        MeshPhongMaterial: r.MeshPhongMaterial,
                        SphereGeometry: r.SphereGeometry,
                        SRGBColorSpace: r.SRGBColorSpace,
                        TextureLoader: r.TextureLoader
                    },
                    At = (0, i.default)({
                        props: {
                            globeImageUrl: {},
                            bumpImageUrl: {},
                            showGlobe: {
                                default: !0,
                                onChange: function(t, e) {
                                    e.globeObj.visible = !!t
                                },
                                triggerUpdate: !1
                            },
                            showGraticules: {
                                default: !1,
                                onChange: function(t, e) {
                                    e.graticulesObj.visible = !!t
                                },
                                triggerUpdate: !1
                            },
                            showAtmosphere: {
                                default: !0,
                                onChange: function(t, e) {
                                    e.atmosphereObj && (e.atmosphereObj.visible = !!t)
                                },
                                triggerUpdate: !1
                            },
                            atmosphereColor: {
                                default: "lightskyblue"
                            },
                            atmosphereAltitude: {
                                default: .15
                            },
                            onReady: {
                                default: function() {},
                                triggerUpdate: !1
                            }
                        },
                        methods: {
                            globeMaterial: function(t, e) {
                                return void 0 !== e ? (t.globeObj.material = e || t.defaultGlobeMaterial, this) : t.globeObj.material
                            },
                            _destructor: function(t) {
                                $(t.globeObj), $(t.graticulesObj)
                            }
                        },
                        stateInit: function() {
                            var t = new lt.SphereGeometry(et, 75, 75),
                                e = new lt.MeshPhongMaterial({
                                    color: 0
                                }),
                                n = new lt.Mesh(t, e);
                            return n.rotation.y = -Math.PI / 2, n.__globeObjType = "globe", {
                                globeObj: n,
                                graticulesObj: new lt.LineSegments(new o.GeoJsonGeometry((0, s.graticule10)(), et, 2), new lt.LineBasicMaterial({
                                    color: "lightgrey",
                                    transparent: !0,
                                    opacity: .1
                                })),
                                defaultGlobeMaterial: e
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t, e.scene.add(e.globeObj), e.scene.add(e.graticulesObj), e.ready = !1
                        },
                        update: function(t, e) {
                            var n = t.globeObj.material;
                            if (e.hasOwnProperty("globeImageUrl") && (t.globeImageUrl ? (new lt.TextureLoader).load(t.globeImageUrl, (function(e) {
                                    e.colorSpace = lt.SRGBColorSpace, n.map = e, n.color = null, n.needsUpdate = !0, !t.ready && (t.ready = !0) && setTimeout(t.onReady)
                                })) : !n.color && (n.color = new lt.Color(0))), e.hasOwnProperty("bumpImageUrl") && (t.bumpImageUrl ? t.bumpImageUrl && (new lt.TextureLoader).load(t.bumpImageUrl, (function(t) {
                                    n.bumpMap = t, n.needsUpdate = !0
                                })) : (n.bumpMap = null, n.needsUpdate = !0)), (e.hasOwnProperty("atmosphereColor") || e.hasOwnProperty("atmosphereAltitude")) && (t.atmosphereObj && (t.scene.remove(t.atmosphereObj), $(t.atmosphereObj)), t.atmosphereColor && t.atmosphereAltitude)) {
                                var r = t.atmosphereObj = function(t) {
                                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : st,
                                        n = e.backside,
                                        r = e.coefficient,
                                        i = e.color,
                                        a = e.size,
                                        o = e.power,
                                        s = function(t, e) {
                                            for (var n = t.clone(), r = new Float32Array(3 * t.attributes.position.count), i = 0, a = r.length; i < a; i++) {
                                                var o = t.attributes.normal.array[i],
                                                    s = t.attributes.position.array[i];
                                                r[i] = s + o * e
                                            }
                                            return n.setAttribute("position", new ot.BufferAttribute(r, 3)), n
                                        }(t, a),
                                        l = function(t, e, n) {
                                            return new ot.ShaderMaterial({
                                                depthWrite: !1,
                                                fragmentShader: "\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}",
                                                transparent: !0,
                                                uniforms: {
                                                    coefficient: {
                                                        value: t
                                                    },
                                                    color: {
                                                        value: new ot.Color(e)
                                                    },
                                                    power: {
                                                        value: n
                                                    }
                                                },
                                                vertexShader: "\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
                                            })
                                        }(r, i, o);
                                    return n && (l.side = ot.BackSide), new ot.Mesh(s, l)
                                }(t.globeObj.geometry, {
                                    backside: !0,
                                    color: t.atmosphereColor,
                                    size: et * t.atmosphereAltitude,
                                    power: 3.5,
                                    coefficient: .1
                                });
                                r.visible = !!t.showAtmosphere, r.__globeObjType = "atmosphere", t.scene.add(r)
                            }
                            t.ready || t.globeImageUrl || (t.ready = !0, t.onReady())
                        }
                    }),
                    ct = function(t) {
                        return isNaN(t) ? parseInt((0, d.default)(t).toHex(), 16) : t
                    },
                    ut = function(t) {
                        return t && isNaN(t) ? (0, h.default)(t).opacity : 1
                    },
                    ht = function(t) {
                        var e, n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                            a = 1,
                            o = /^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.eE+-]+)\s*\)$/.exec(t.trim().toLowerCase());
                        if (o) {
                            var s = G(o.slice(1), 4),
                                l = s[0],
                                A = s[1],
                                c = s[2],
                                u = s[3];
                            e = new r.Color("rgb(".concat(+l, ",").concat(+A, ",").concat(+c, ")")), a = Math.min(+u, 1)
                        } else e = new r.Color(t);
                        i && e.convertLinearToSRGB();
                        var h = e.toArray();
                        return n ? [].concat(j(h), [a]) : h
                    },
                    dt = window.THREE ? window.THREE : {
                        Float32BufferAttribute: r.Float32BufferAttribute
                    };

                function ft(t, e) {
                    var n = new(arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : dt.Float32BufferAttribute)(t.length * e, e);
                    return 1 === e ? t.forEach((function(t, e) {
                        return n.setX(e, t)
                    })) : t.forEach((function(t, r) {
                        return n.set(t, r * e)
                    })), n
                }

                function pt(t, e) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        r = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}).removeDelay,
                        i = void 0 === r ? 0 : r;
                    return (0, f.default)(t, e.children, (function(t) {
                        return e.add(t)
                    }), (function(t) {
                        var n = function() {
                            e.remove(t), $(t), t && t.hasOwnProperty("__data") && delete t.__data.__currentTargetD
                        };
                        i ? setTimeout(n, i) : n()
                    }), D({
                        objBindAttr: "__threeObj"
                    }, n))
                }
                var mt = window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        Color: r.Color,
                        CylinderGeometry: r.CylinderGeometry,
                        Matrix4: r.Matrix4,
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        Object3D: r.Object3D,
                        Vector3: r.Vector3
                    },
                    gt = Object.assign({}, c),
                    vt = gt.BufferGeometryUtils || gt,
                    _t = (0, i.default)({
                        props: {
                            pointsData: {
                                default: []
                            },
                            pointLat: {
                                default: "lat"
                            },
                            pointLng: {
                                default: "lng"
                            },
                            pointColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            pointAltitude: {
                                default: .1
                            },
                            pointRadius: {
                                default: .25
                            },
                            pointResolution: {
                                default: 12,
                                triggerUpdate: !1
                            },
                            pointsMerge: {
                                default: !1
                            },
                            pointsTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.pointLat),
                                n = (0, u.default)(t.pointLng),
                                r = (0, u.default)(t.pointAltitude),
                                i = (0, u.default)(t.pointRadius),
                                o = (0, u.default)(t.pointColor),
                                s = new mt.CylinderGeometry(1, 1, 1, t.pointResolution);
                            s.applyMatrix4((new mt.Matrix4).makeRotationX(Math.PI / 2)), s.applyMatrix4((new mt.Matrix4).makeTranslation(0, 0, -.5));
                            var l = 2 * Math.PI * et / 360,
                                A = {},
                                c = t.pointsMerge ? new mt.Object3D : t.scene;
                            if (pt(t.pointsData, c, {
                                    createObj: function() {
                                        var t = new mt.Mesh(s);
                                        return t.__globeObjType = "point", t
                                    },
                                    updateObj: function(s, c) {
                                        var u = function(e) {
                                                var n = s.__currentTargetD = e,
                                                    r = n.r,
                                                    i = n.alt,
                                                    a = n.lat,
                                                    o = n.lng;
                                                Object.assign(s.position, rt(a, o));
                                                var A = t.pointsMerge ? new mt.Vector3(0, 0, 0) : t.scene.localToWorld(new mt.Vector3(0, 0, 0));
                                                s.lookAt(A), s.scale.x = s.scale.y = Math.min(30, r) * l, s.scale.z = Math.max(i * et, .1)
                                            },
                                            h = {
                                                alt: +r(c),
                                                r: +i(c),
                                                lat: +e(c),
                                                lng: +n(c)
                                            },
                                            d = s.__currentTargetD || Object.assign({}, h, {
                                                alt: -.001
                                            });
                                        if (Object.keys(h).some((function(t) {
                                                return d[t] !== h[t]
                                            })) && (t.pointsMerge || !t.pointsTransitionDuration || t.pointsTransitionDuration < 0 ? u(h) : new a.Tween(d).to(h, t.pointsTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(u).start()), !t.pointsMerge) {
                                            var f = o(c),
                                                p = f ? ut(f) : 0,
                                                m = !!p;
                                            s.visible = m, m && (A.hasOwnProperty(f) || (A[f] = new mt.MeshLambertMaterial({
                                                color: ct(f),
                                                transparent: p < 1,
                                                opacity: p
                                            })), s.material = A[f])
                                        }
                                    }
                                }), t.pointsMerge) {
                                var h = t.pointsData.length ? (vt.mergeGeometries || vt.mergeBufferGeometries)(t.pointsData.map((function(t) {
                                        var e = t.__threeObj;
                                        t.__threeObj = void 0;
                                        var n = e.geometry.clone();
                                        e.updateMatrix(), n.applyMatrix4(e.matrix);
                                        var r = ht(o(t));
                                        return n.setAttribute("color", ft(j(new Array(n.getAttribute("position").count)).map((function() {
                                            return r
                                        })), 4)), n
                                    }))) : new mt.BufferGeometry,
                                    d = new mt.Mesh(h, new mt.MeshLambertMaterial({
                                        color: 16777215,
                                        transparent: !0,
                                        vertexColors: !0
                                    }));
                                d.__globeObjType = "points", d.__data = t.pointsData, $(t.scene), t.scene.add(d)
                            }
                        }
                    }),
                    yt = ["stroke"],
                    xt = window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        CubicBezierCurve3: r.CubicBezierCurve3,
                        Curve: r.Curve,
                        Group: r.Group,
                        Line: r.Line,
                        Mesh: r.Mesh,
                        NormalBlending: r.NormalBlending,
                        QuadraticBezierCurve3: r.QuadraticBezierCurve3,
                        ShaderMaterial: r.ShaderMaterial,
                        TubeGeometry: r.TubeGeometry,
                        Vector3: r.Vector3
                    },
                    bt = p.default || p,
                    Mt = {
                        uniforms: {
                            dashOffset: {
                                value: 0
                            },
                            dashSize: {
                                value: 1
                            },
                            gapSize: {
                                value: 0
                            },
                            dashTranslate: {
                                value: 0
                            }
                        },
                        vertexShader: "\n    uniform float dashTranslate; \n\n    attribute vec4 vertexColor;\n    varying vec4 vColor;\n    \n    attribute float vertexRelDistance;\n    varying float vRelDistance;\n\n    void main() {\n      // pass through colors and distances\n      vColor = vertexColor;\n      vRelDistance = vertexRelDistance + dashTranslate;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",
                        fragmentShader: "\n    uniform float dashOffset; \n    uniform float dashSize;\n    uniform float gapSize; \n    \n    varying vec4 vColor;\n    varying float vRelDistance;\n    \n    void main() {\n      // ignore pixels in the gap\n      if (vRelDistance < dashOffset) discard;\n      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;\n    \n      // set px color: [r, g, b, a], interpolated between vertices \n      gl_FragColor = vColor; \n    }\n  "
                    },
                    wt = (0, i.default)({
                        props: {
                            arcsData: {
                                default: []
                            },
                            arcStartLat: {
                                default: "startLat"
                            },
                            arcStartLng: {
                                default: "startLng"
                            },
                            arcEndLat: {
                                default: "endLat"
                            },
                            arcEndLng: {
                                default: "endLng"
                            },
                            arcColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            arcAltitude: {},
                            arcAltitudeAutoScale: {
                                default: .5
                            },
                            arcStroke: {},
                            arcCurveResolution: {
                                default: 64,
                                triggerUpdate: !1
                            },
                            arcCircularResolution: {
                                default: 6,
                                triggerUpdate: !1
                            },
                            arcDashLength: {
                                default: 1
                            },
                            arcDashGap: {
                                default: 0
                            },
                            arcDashInitialGap: {
                                default: 0
                            },
                            arcDashAnimateTime: {
                                default: 0
                            },
                            arcsTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            }
                        },
                        methods: {
                            pauseAnimation: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.pause()
                            },
                            resumeAnimation: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.resume()
                            },
                            _destructor: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.dispose()
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t, e.ticker = new bt, e.ticker.onTick.add((function(t, n) {
                                e.arcsData.filter((function(t) {
                                    return t.__threeObj && t.__threeObj.children.length && t.__threeObj.children[0].material && t.__threeObj.children[0].__dashAnimateStep
                                })).forEach((function(t) {
                                    var e = t.__threeObj.children[0],
                                        r = e.__dashAnimateStep * n,
                                        i = e.material.uniforms.dashTranslate.value % 1e9;
                                    e.material.uniforms.dashTranslate.value = i + r
                                }))
                            }))
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.arcStartLat),
                                n = (0, u.default)(t.arcStartLng),
                                r = (0, u.default)(t.arcEndLat),
                                i = (0, u.default)(t.arcEndLng),
                                o = (0, u.default)(t.arcAltitude),
                                s = (0, u.default)(t.arcAltitudeAutoScale),
                                c = (0, u.default)(t.arcStroke),
                                h = (0, u.default)(t.arcColor),
                                d = (0, u.default)(t.arcDashLength),
                                f = (0, u.default)(t.arcDashGap),
                                p = (0, u.default)(t.arcDashInitialGap),
                                g = (0, u.default)(t.arcDashAnimateTime),
                                v = new xt.ShaderMaterial(D(D({}, Mt), {}, {
                                    transparent: !0,
                                    blending: xt.NormalBlending
                                }));
                            pt(t.arcsData, t.scene, {
                                createObj: function() {
                                    var t = new xt.Group;
                                    return t.__globeObjType = "arc", t
                                },
                                updateObj: function(u, _) {
                                    var y = c(_),
                                        x = null != y;
                                    if (!u.children.length || x !== ("Mesh" === u.children[0].type)) {
                                        $(u);
                                        var b = x ? new xt.Mesh : new xt.Line(new xt.BufferGeometry);
                                        b.material = v.clone(), u.add(b)
                                    }
                                    var M = u.children[0];
                                    Object.assign(M.material.uniforms, {
                                        dashSize: {
                                            value: d(_)
                                        },
                                        gapSize: {
                                            value: f(_)
                                        },
                                        dashOffset: {
                                            value: p(_)
                                        }
                                    });
                                    var w = g(_);
                                    M.__dashAnimateStep = w > 0 ? 1e3 / w : 0;
                                    var S = function(t, e) {
                                            var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                                                i = e + 1;
                                            if (t instanceof Array || t instanceof Function) {
                                                var a = t instanceof Array ? (0, m.default)().domain(t.map((function(e, n) {
                                                    return n / (t.length - 1)
                                                }))).range(t) : t;
                                                n = function(t) {
                                                    return ht(a(t), !0, !0)
                                                }
                                            } else {
                                                var o = ht(t, !0, !0);
                                                n = function() {
                                                    return o
                                                }
                                            }
                                            for (var s = [], l = 0, A = i; l < A; l++)
                                                for (var c = n(l / (A - 1)), u = 0; u < r; u++) s.push(c);
                                            return ft(s, 4)
                                        }(h(_), t.arcCurveResolution, x ? t.arcCircularResolution + 1 : 1),
                                        E = function(t) {
                                            for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = [], i = 0, a = t + 1; i < a; i++)
                                                for (var o = i / (a - 1), s = 0; s < e; s++) r.push(o);
                                            return n && r.reverse(), ft(r, 1)
                                        }(t.arcCurveResolution, x ? t.arcCircularResolution + 1 : 1, !0);
                                    M.geometry.setAttribute("vertexColor", S), M.geometry.setAttribute("vertexRelDistance", E);
                                    var T = function(e) {
                                            var n = _.__currentTargetD = e,
                                                r = n.stroke,
                                                i = function(t) {
                                                    var e = t.alt,
                                                        n = t.altAutoScale,
                                                        r = t.startLat,
                                                        i = t.startLng,
                                                        a = t.endLat,
                                                        o = function(t) {
                                                            var e = G(t, 3),
                                                                n = e[0],
                                                                r = rt(e[1], n, e[2]),
                                                                i = r.x,
                                                                a = r.y,
                                                                o = r.z;
                                                            return new xt.Vector3(i, a, o)
                                                        },
                                                        s = [i, r],
                                                        c = [t.endLng, a],
                                                        u = e;
                                                    if (null == u && (u = (0, l.default)(s, c) / 2 * n), u) {
                                                        var h = (0, A.default)(s, c),
                                                            d = G([.25, .75].map((function(t) {
                                                                return [].concat(j(h(t)), [1.5 * u])
                                                            })), 2),
                                                            f = d[0],
                                                            p = d[1],
                                                            m = function(t, e, n) {
                                                                if (P()) return Reflect.construct.apply(null, arguments);
                                                                var r = [null];
                                                                r.push.apply(r, e);
                                                                var i = new(t.bind.apply(t, r));
                                                                return n && F(i, n.prototype), i
                                                            }(xt.CubicBezierCurve3, j([s, f, p, c].map(o)));
                                                        return m
                                                    }
                                                    return function(t, e) {
                                                        var n = t.angleTo(e),
                                                            r = 0 === n ? function() {
                                                                return t.clone()
                                                            } : function(r) {
                                                                return (new xt.Vector3).addVectors(t.clone().multiplyScalar(Math.sin((1 - r) * n)), e.clone().multiplyScalar(Math.sin(r * n))).divideScalar(Math.sin(n))
                                                            },
                                                            i = new xt.Curve;
                                                        return i.getPoint = r, i
                                                    }.apply(void 0, j([
                                                        [].concat(s, [.001]), [].concat(c, [.001])
                                                    ].map(o)))
                                                }(function(t, e) {
                                                    if (null == t) return {};
                                                    var n, r, i = function(t, e) {
                                                        if (null == t) return {};
                                                        var n, r, i = {},
                                                            a = Object.keys(t);
                                                        for (r = 0; r < a.length; r++) n = a[r], e.indexOf(n) >= 0 || (i[n] = t[n]);
                                                        return i
                                                    }(t, e);
                                                    if (Object.getOwnPropertySymbols) {
                                                        var a = Object.getOwnPropertySymbols(t);
                                                        for (r = 0; r < a.length; r++) n = a[r], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
                                                    }
                                                    return i
                                                }(n, yt));
                                            x ? (M.geometry && M.geometry.dispose(), M.geometry = new xt.TubeGeometry(i, t.arcCurveResolution, r / 2, t.arcCircularResolution), M.geometry.setAttribute("vertexColor", S), M.geometry.setAttribute("vertexRelDistance", E)) : M.geometry.setFromPoints(i.getPoints(t.arcCurveResolution))
                                        },
                                        C = {
                                            stroke: y,
                                            alt: o(_),
                                            altAutoScale: +s(_),
                                            startLat: +e(_),
                                            startLng: +n(_),
                                            endLat: +r(_),
                                            endLng: +i(_)
                                        },
                                        R = _.__currentTargetD || Object.assign({}, C, {
                                            altAutoScale: -.001
                                        });
                                    Object.keys(C).some((function(t) {
                                        return R[t] !== C[t]
                                    })) && (!t.arcsTransitionDuration || t.arcsTransitionDuration < 0 ? T(C) : new a.Tween(R).to(C, t.arcsTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(T).start())
                                }
                            })
                        }
                    }),
                    St = window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        Color: r.Color,
                        DoubleSide: r.DoubleSide,
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        Object3D: r.Object3D
                    },
                    Et = Object.assign({}, c),
                    Tt = Et.BufferGeometryUtils || Et,
                    Ct = (0, i.default)({
                        props: {
                            hexBinPointsData: {
                                default: []
                            },
                            hexBinPointLat: {
                                default: "lat"
                            },
                            hexBinPointLng: {
                                default: "lng"
                            },
                            hexBinPointWeight: {
                                default: 1
                            },
                            hexBinResolution: {
                                default: 4
                            },
                            hexMargin: {
                                default: .2
                            },
                            hexTopCurvatureResolution: {
                                default: 5
                            },
                            hexTopColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            hexSideColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            hexAltitude: {
                                default: function(t) {
                                    return .01 * t.sumWeight
                                }
                            },
                            hexBinMerge: {
                                default: !1
                            },
                            hexTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.hexBinPointLat),
                                n = (0, u.default)(t.hexBinPointLng),
                                r = (0, u.default)(t.hexBinPointWeight),
                                i = (0, u.default)(t.hexAltitude),
                                o = (0, u.default)(t.hexTopColor),
                                s = (0, u.default)(t.hexSideColor),
                                l = (0, u.default)(t.hexMargin),
                                A = (0, v.default)(t.hexBinPointsData.map((function(r) {
                                    return D(D({}, r), {}, {
                                        h3Idx: (0, _.latLngToCell)(e(r), n(r), t.hexBinResolution)
                                    })
                                })), "h3Idx"),
                                c = Object.entries(A).map((function(t) {
                                    var e = G(t, 2),
                                        n = e[0],
                                        i = e[1];
                                    return {
                                        h3Idx: n,
                                        points: i,
                                        sumWeight: i.reduce((function(t, e) {
                                            return t + +r(e)
                                        }), 0)
                                    }
                                })),
                                h = {};
                            if (pt(c, t.hexBinMerge ? new St.Object3D : t.scene, {
                                    createObj: function(t) {
                                        var e = new St.Mesh;
                                        e.__hexCenter = (0, _.cellToLatLng)(t.h3Idx), e.__hexGeoJson = (0, _.cellToBoundary)(t.h3Idx, !0).reverse();
                                        var n = e.__hexCenter[1];
                                        return e.__hexGeoJson.forEach((function(t) {
                                            var e = t[0];
                                            Math.abs(n - e) > 170 && (t[0] += n > e ? 360 : -360)
                                        })), e.__globeObjType = "hexbin", e
                                    },
                                    updateObj: function(e, n) {
                                        var r = Math.max(0, Math.min(1, +l(n))),
                                            A = G(e.__hexCenter, 2),
                                            c = A[0],
                                            u = A[1],
                                            d = 0 === r ? e.__hexGeoJson : e.__hexGeoJson.map((function(t) {
                                                var e = G(t, 2),
                                                    n = e[0],
                                                    i = e[1];
                                                return [
                                                    [n, u],
                                                    [i, c]
                                                ].map((function(t) {
                                                    var e, n, i = G(t, 2);
                                                    return e = i[0], n = i[1], e - (e - n) * r
                                                }))
                                            })),
                                            f = t.hexTopCurvatureResolution;
                                        e.geometry && e.geometry.dispose(), e.geometry = new g.ConicPolygonGeometry([d], 0, et, !1, !0, !0, f);
                                        var p = {
                                                alt: +i(n)
                                            },
                                            m = function(t) {
                                                var n = (e.__currentTargetD = t).alt;
                                                e.scale.x = e.scale.y = e.scale.z = 1 + n
                                            },
                                            v = e.__currentTargetD || Object.assign({}, p, {
                                                alt: -.001
                                            });
                                        if (Object.keys(p).some((function(t) {
                                                return v[t] !== p[t]
                                            })) && (t.hexBinMerge || !t.hexTransitionDuration || t.hexTransitionDuration < 0 ? m(p) : new a.Tween(v).to(p, t.hexTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(m).start()), !t.hexBinMerge) {
                                            var _ = s(n),
                                                y = o(n);
                                            [_, y].forEach((function(t) {
                                                if (!h.hasOwnProperty(t)) {
                                                    var e = ut(t);
                                                    h[t] = new St.MeshLambertMaterial({
                                                        color: ct(t),
                                                        transparent: e < 1,
                                                        opacity: e,
                                                        side: St.DoubleSide
                                                    })
                                                }
                                            })), e.material = [_, y].map((function(t) {
                                                return h[t]
                                            }))
                                        }
                                    },
                                    idAccessor: function(t) {
                                        return t.h3Idx
                                    }
                                }), t.hexBinMerge) {
                                var d = c.length ? (Tt.mergeGeometries || Tt.mergeBufferGeometries)(c.map((function(t) {
                                        var e = t.__threeObj;
                                        t.__threeObj = void 0;
                                        var n = e.geometry.toNonIndexed();
                                        e.updateMatrix(), n.applyMatrix4(e.matrix);
                                        var r = ht(o(t)),
                                            i = ht(s(t)),
                                            a = n.getAttribute("position").count,
                                            l = n.groups[0].count;
                                        return n.setAttribute("color", ft(j(new Array(a)).map((function(t, e) {
                                            return e >= l ? r : i
                                        })), 4)), n
                                    }))) : new St.BufferGeometry,
                                    f = new St.Mesh(d, new St.MeshLambertMaterial({
                                        color: 16777215,
                                        transparent: !0,
                                        vertexColors: !0,
                                        side: St.DoubleSide
                                    }));
                                f.__globeObjType = "hexBinPoints", f.__data = c, $(t.scene), t.scene.add(f)
                            }
                        }
                    }),
                    Rt = function(t) {
                        return t * t
                    },
                    Pt = Math.sqrt(2 * Math.PI),
                    Lt = window.THREE ? window.THREE : {
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        SphereGeometry: r.SphereGeometry
                    },
                    Dt = new WeakSet,
                    It = new WeakMap,
                    Ot = new WeakMap,
                    Bt = new WeakMap,
                    qt = function() {
                        function t(e, n) {
                            var r;
                            O(this, t), Q(this, r = Dt), r.add(this), Z(this, It, {
                                writable: !0,
                                value: void 0
                            }), Z(this, Ot, {
                                writable: !0,
                                value: void 0
                            }), Z(this, Bt, {
                                writable: !0,
                                value: void 0
                            }), X(this, It, e), X(this, Ot, M()), W(this, Ot).init(e.map((function(t) {
                                return [t.x, t.y, t.z]
                            })).flat()), X(this, Bt, function(t, e, n) {
                                if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
                                return n
                            }(this, Dt, Ut).call(this, rt(0, 0), rt(0, Math.min(180, n))))
                        }
                        return q(t, [{
                            key: "getNearPoints",
                            value: function(t, e, n) {
                                var r = this;
                                return W(this, Ot).intersectSphere(t, e, n, W(this, Bt)).map((function(t) {
                                    return W(r, It)[t / 3]
                                }))
                            }
                        }]), t
                    }();

                function Ut(t, e) {
                    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2) + Math.pow(t.z - e.z, 2))
                }
                var Nt = function(t) {
                        var e = (0, h.default)((0, y.default)(t));
                        return e.opacity = Math.cbrt(t), e.formatRgb()
                    },
                    kt = (0, i.default)({
                        props: {
                            heatmapsData: {
                                default: []
                            },
                            heatmapPoints: {
                                default: function(t) {
                                    return t
                                }
                            },
                            heatmapPointLat: {
                                default: function(t) {
                                    return t[0]
                                }
                            },
                            heatmapPointLng: {
                                default: function(t) {
                                    return t[1]
                                }
                            },
                            heatmapPointWeight: {
                                default: 1
                            },
                            heatmapBandwidth: {
                                default: 4
                            },
                            heatmapColorFn: {
                                default: function() {
                                    return Nt
                                }
                            },
                            heatmapColorSaturation: {
                                default: 1.5
                            },
                            heatmapBaseAltitude: {
                                default: .01
                            },
                            heatmapTopAltitude: {},
                            heatmapsTransitionDuration: {
                                default: 0,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.heatmapPoints),
                                n = (0, u.default)(t.heatmapPointLat),
                                r = (0, u.default)(t.heatmapPointLng),
                                i = (0, u.default)(t.heatmapPointWeight),
                                o = (0, u.default)(t.heatmapBandwidth),
                                s = (0, u.default)(t.heatmapColorFn),
                                l = (0, u.default)(t.heatmapColorSaturation),
                                A = (0, u.default)(t.heatmapBaseAltitude),
                                c = (0, u.default)(t.heatmapTopAltitude);
                            pt(t.heatmapsData, t.scene, {
                                createObj: function(t) {
                                    var e = new Lt.Mesh(new Lt.SphereGeometry(et), new Lt.MeshLambertMaterial({
                                        vertexColors: !0,
                                        transparent: !0
                                    }));
                                    return e.__globeObjType = "heatmap", e
                                },
                                updateObj: function(u, h) {
                                    var d = o(h),
                                        f = s(h),
                                        p = l(h),
                                        g = A(h),
                                        v = c(h),
                                        _ = e(h).map((function(t) {
                                            var e = n(t),
                                                a = r(t),
                                                o = rt(e, a);
                                            return {
                                                x: o.x,
                                                y: o.y,
                                                z: o.z,
                                                lat: e,
                                                lng: a,
                                                weight: i(t)
                                            }
                                        })),
                                        y = Math.max(.1, d / 3.5),
                                        M = Math.ceil(360 / (y || -1));
                                    u.geometry.parameters.widthSegments !== M && (u.geometry.dispose(), u.geometry = new Lt.SphereGeometry(et, M, M / 2));
                                    var w = function(t) {
                                            for (var e = t.itemSize, n = [], r = 0; r < t.count; r++) n.push(t.array.slice(r * e, (r + 1) * e));
                                            return n
                                        }(u.geometry.getAttribute("position")),
                                        S = w.map((function(t) {
                                            var e = G(t, 3),
                                                n = it({
                                                    x: e[0],
                                                    y: e[1],
                                                    z: e[2]
                                                });
                                            return [n.lng, n.lat]
                                        })),
                                        E = new qt(_, 3.5 * d),
                                        T = S.map((function(t, e) {
                                            var n = G(w[e], 3),
                                                r = n[0],
                                                i = n[1],
                                                a = n[2];
                                            return function(t) {
                                                var e = G(t, 2),
                                                    n = e[0],
                                                    r = e[1],
                                                    i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                                                    a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                                                    o = a.lngAccessor,
                                                    s = void 0 === o ? function(t) {
                                                        return t[0]
                                                    } : o,
                                                    l = a.latAccessor,
                                                    A = void 0 === l ? function(t) {
                                                        return t[1]
                                                    } : l,
                                                    c = a.weightAccessor,
                                                    u = void 0 === c ? function() {
                                                        return 1
                                                    } : c,
                                                    h = a.bandwidth,
                                                    d = [n, r],
                                                    f = h * Math.PI / 180;
                                                return (0, x.default)(i.map((function(t) {
                                                    var e = u(t);
                                                    if (!e) return 0;
                                                    var n, r, i, a, o, l, c, h, p, m, g, v, _ = (n = d, r = [s(t), A(t)], i = Math.sqrt, a = Math.cos, o = function(t) {
                                                        return t * Math.PI / 180
                                                    }, l = function(t) {
                                                        return Rt(Math.sin(t / 2))
                                                    }, c = o(n[1]), h = o(r[1]), p = o(n[0]), m = o(r[0]), 2 * Math.asin(i(l(h - c) + a(c) * a(h) * l(m - p))));
                                                    return g = _, v = f, Math.exp(-Rt(g / v) / 2) / (v * Pt) * e
                                                })))
                                            }(t, E.getNearPoints(r, i, a), {
                                                latAccessor: function(t) {
                                                    return t.lat
                                                },
                                                lngAccessor: function(t) {
                                                    return t.lng
                                                },
                                                weightAccessor: function(t) {
                                                    return t.weight
                                                },
                                                bandwidth: d
                                            })
                                        })),
                                        C = function(t) {
                                            var e = u.__currentTargetD = t,
                                                n = e.kdeVals,
                                                r = e.topAlt,
                                                i = e.saturation,
                                                a = (0, b.default)(n.map(Math.abs)) || 1e-15;
                                            u.geometry.setAttribute("color", ft(n.map((function(t) {
                                                return ht(f(t / a * i))
                                            })), 4));
                                            var o = (0, m.default)([0, a], [g, r || g]);
                                            u.geometry.setAttribute("position", ft(n.map((function(t, e) {
                                                var n = G(S[e], 2),
                                                    r = n[0],
                                                    i = rt(n[1], r, o(Math.abs(t)));
                                                return [i.x, i.y, i.z]
                                            })), 3))
                                        },
                                        R = {
                                            kdeVals: T,
                                            topAlt: v,
                                            saturation: p
                                        },
                                        P = u.__currentTargetD || Object.assign({}, R, {
                                            kdeVals: T.map((function() {
                                                return 0
                                            })),
                                            topAlt: v ? g : v,
                                            saturation: .5
                                        });
                                    P.kdeVals.length !== T.length && (P.kdeVals = T.slice()), Object.keys(R).some((function(t) {
                                        return P[t] !== R[t]
                                    })) && (!t.heatmapsTransitionDuration || t.heatmapsTransitionDuration < 0 ? C(R) : new a.Tween(P).to(R, t.heatmapsTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(C).start())
                                }
                            })
                        }
                    }),
                    Ft = window.THREE ? window.THREE : {
                        DoubleSide: r.DoubleSide,
                        Group: r.Group,
                        LineBasicMaterial: r.LineBasicMaterial,
                        LineSegments: r.LineSegments,
                        Mesh: r.Mesh,
                        MeshBasicMaterial: r.MeshBasicMaterial
                    },
                    zt = (0, i.default)({
                        props: {
                            polygonsData: {
                                default: []
                            },
                            polygonGeoJsonGeometry: {
                                default: "geometry"
                            },
                            polygonSideColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            polygonSideMaterial: {},
                            polygonCapColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            polygonCapMaterial: {},
                            polygonStrokeColor: {},
                            polygonAltitude: {
                                default: .01
                            },
                            polygonCapCurvatureResolution: {
                                default: 5
                            },
                            polygonsTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.polygonGeoJsonGeometry),
                                n = (0, u.default)(t.polygonAltitude),
                                r = (0, u.default)(t.polygonCapCurvatureResolution),
                                i = (0, u.default)(t.polygonCapColor),
                                s = (0, u.default)(t.polygonCapMaterial),
                                l = (0, u.default)(t.polygonSideColor),
                                A = (0, u.default)(t.polygonSideMaterial),
                                c = (0, u.default)(t.polygonStrokeColor),
                                h = [];
                            t.polygonsData.forEach((function(t) {
                                var a = {
                                        data: t,
                                        capColor: i(t),
                                        capMaterial: s(t),
                                        sideColor: l(t),
                                        sideMaterial: A(t),
                                        strokeColor: c(t),
                                        altitude: +n(t),
                                        capCurvatureResolution: +r(t)
                                    },
                                    o = e(t),
                                    u = t.__id || "".concat(Math.round(1e9 * Math.random()));
                                t.__id = u, "Polygon" === o.type ? h.push(D({
                                    id: "".concat(u, "_0"),
                                    coords: o.coordinates
                                }, a)) : "MultiPolygon" === o.type ? h.push.apply(h, j(o.coordinates.map((function(t, e) {
                                    return D({
                                        id: "".concat(u, "_").concat(e),
                                        coords: t
                                    }, a)
                                })))) : console.warn("Unsupported GeoJson geometry type: ".concat(o.type, ". Skipping geometry..."))
                            })), pt(h, t.scene, {
                                idAccessor: function(t) {
                                    return t.id
                                },
                                createObj: function() {
                                    var t = new Ft.Group;
                                    return t.__defaultSideMaterial = new Ft.MeshBasicMaterial({
                                        side: Ft.DoubleSide,
                                        depthWrite: !0
                                    }), t.__defaultCapMaterial = new Ft.MeshBasicMaterial({
                                        side: Ft.DoubleSide,
                                        depthWrite: !0
                                    }), t.add(new Ft.Mesh(void 0, [t.__defaultSideMaterial, t.__defaultCapMaterial])), t.add(new Ft.LineSegments(void 0, new Ft.LineBasicMaterial)), t.__globeObjType = "polygon", t
                                },
                                updateObj: function(e, n) {
                                    var r = n.coords,
                                        i = n.capColor,
                                        s = n.capMaterial,
                                        l = n.sideColor,
                                        A = n.sideMaterial,
                                        c = n.strokeColor,
                                        u = n.altitude,
                                        h = n.capCurvatureResolution,
                                        d = G(e.children, 2),
                                        f = d[0],
                                        p = d[1],
                                        m = !!c;
                                    if (p.visible = m, function(t, e) {
                                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function() {
                                                return function(t, e) {
                                                    return t === e
                                                }
                                            };
                                            return Object.entries(e).every((function(e) {
                                                var r = G(e, 2),
                                                    i = r[0],
                                                    a = r[1];
                                                return t.hasOwnProperty(i) && n(i)(t[i], a)
                                            }))
                                        }(f.geometry.parameters || {}, {
                                            polygonGeoJson: r,
                                            curvatureResolution: h
                                        }) || (f.geometry && f.geometry.dispose(), f.geometry = new g.ConicPolygonGeometry(r, 0, et, !1, !0, !0, h)), !m || p.geometry.parameters && p.geometry.parameters.geoJson.coordinates === r && p.geometry.parameters.resolution === h || (p.geometry && p.geometry.dispose(), p.geometry = new o.GeoJsonGeometry({
                                            type: "Polygon",
                                            coordinates: r
                                        }, et, h)), f.material[0] = A || e.__defaultSideMaterial, f.material[1] = s || e.__defaultCapMaterial, [!A && l, !s && i].forEach((function(t, e) {
                                            if (t) {
                                                var n = f.material[e],
                                                    r = ut(t);
                                                n.color.set(ct(t)), n.transparent = r < 1, n.opacity = r
                                            }
                                        })), m) {
                                        var v = p.material,
                                            _ = ut(c);
                                        v.color.set(ct(c)), v.transparent = _ < 1, v.opacity = _
                                    }
                                    var y = {
                                            alt: u
                                        },
                                        x = function(t) {
                                            var n = (e.__currentTargetD = t).alt;
                                            f.scale.x = f.scale.y = f.scale.z = 1 + n, m && (p.scale.x = p.scale.y = p.scale.z = 1 + n + 1e-4)
                                        },
                                        b = e.__currentTargetD || Object.assign({}, y, {
                                            alt: -.001
                                        });
                                    Object.keys(y).some((function(t) {
                                        return b[t] !== y[t]
                                    })) && (!t.polygonsTransitionDuration || t.polygonsTransitionDuration < 0 || b.alt === y.alt ? x(y) : new a.Tween(b).to(y, t.polygonsTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(x).start())
                                }
                            })
                        }
                    }),
                    Gt = window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        CircleGeometry: r.CircleGeometry,
                        DoubleSide: r.DoubleSide,
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        Vector3: r.Vector3
                    },
                    jt = Object.assign({}, c),
                    Vt = jt.BufferGeometryUtils || jt,
                    Ht = (0, i.default)({
                        props: {
                            hexPolygonsData: {
                                default: []
                            },
                            hexPolygonGeoJsonGeometry: {
                                default: "geometry"
                            },
                            hexPolygonColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            hexPolygonAltitude: {
                                default: .001
                            },
                            hexPolygonResolution: {
                                default: 3
                            },
                            hexPolygonMargin: {
                                default: .2
                            },
                            hexPolygonUseDots: {
                                default: !1
                            },
                            hexPolygonCurvatureResolution: {
                                default: 5
                            },
                            hexPolygonDotResolution: {
                                default: 12
                            },
                            hexPolygonsTransitionDuration: {
                                default: 0,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.hexPolygonGeoJsonGeometry),
                                n = (0, u.default)(t.hexPolygonColor),
                                i = (0, u.default)(t.hexPolygonAltitude),
                                o = (0, u.default)(t.hexPolygonResolution),
                                s = (0, u.default)(t.hexPolygonMargin),
                                l = (0, u.default)(t.hexPolygonUseDots),
                                A = (0, u.default)(t.hexPolygonCurvatureResolution),
                                c = (0, u.default)(t.hexPolygonDotResolution);
                            pt(t.hexPolygonsData, t.scene, {
                                createObj: function(t) {
                                    var e = new Gt.Mesh(void 0, new Gt.MeshLambertMaterial({
                                        side: Gt.DoubleSide
                                    }));
                                    return e.__globeObjType = "hexPolygon", e
                                },
                                updateObj: function(u, h) {
                                    var d = e(h),
                                        f = o(h),
                                        p = i(h),
                                        m = Math.max(0, Math.min(1, +s(h))),
                                        v = l(h),
                                        y = A(h),
                                        x = c(h),
                                        b = n(h),
                                        M = ut(b);
                                    u.material.color.set(ct(b)), u.material.transparent = M < 1, u.material.opacity = M;
                                    var w = {
                                            alt: p,
                                            margin: m,
                                            curvatureResolution: y
                                        },
                                        S = {
                                            geoJson: d,
                                            h3Res: f
                                        },
                                        E = u.__currentTargetD || Object.assign({}, w, {
                                            alt: -.001
                                        }),
                                        T = u.__currentMemD || S;
                                    if (Object.keys(w).some((function(t) {
                                            return E[t] !== w[t]
                                        })) || Object.keys(S).some((function(t) {
                                            return T[t] !== S[t]
                                        }))) {
                                        u.__currentMemD = S;
                                        var C = [];
                                        "Polygon" === d.type ? (0, _.polygonToCells)(d.coordinates, f, !0).forEach((function(t) {
                                            return C.push(t)
                                        })) : "MultiPolygon" === d.type ? d.coordinates.forEach((function(t) {
                                            return (0, _.polygonToCells)(t, f, !0).forEach((function(t) {
                                                return C.push(t)
                                            }))
                                        })) : console.warn("Unsupported GeoJson geometry type: ".concat(d.type, ". Skipping geometry..."));
                                        var R = C.map((function(t) {
                                                var e = (0, _.cellToLatLng)(t),
                                                    n = (0, _.cellToBoundary)(t, !0).reverse(),
                                                    r = e[1];
                                                return n.forEach((function(t) {
                                                    var e = t[0];
                                                    Math.abs(r - e) > 170 && (t[0] += r > e ? 360 : -360)
                                                })), {
                                                    h3Idx: t,
                                                    hexCenter: e,
                                                    hexGeoJson: n
                                                }
                                            })),
                                            P = function(t) {
                                                var e = u.__currentTargetD = t,
                                                    n = e.alt,
                                                    i = e.margin,
                                                    a = e.curvatureResolution;
                                                u.geometry && u.geometry.dispose(), u.geometry = R.length ? (Vt.mergeGeometries || Vt.mergeBufferGeometries)(R.map((function(t) {
                                                    var e = G(t.hexCenter, 2),
                                                        o = e[0],
                                                        s = e[1];
                                                    if (v) {
                                                        var l = rt(o, s, n),
                                                            A = rt(t.hexGeoJson[0][1], t.hexGeoJson[0][0], n),
                                                            c = .85 * (1 - i) * new Gt.Vector3(l.x, l.y, l.z).distanceTo(new Gt.Vector3(A.x, A.y, A.z)),
                                                            u = new r.CircleGeometry(c, x);
                                                        return u.rotateX(at(-o)), u.rotateY(at(s)), u.translate(l.x, l.y, l.z), u
                                                    }
                                                    var h = 0 === i ? t.hexGeoJson : t.hexGeoJson.map((function(t) {
                                                        var e = G(t, 2),
                                                            n = e[0],
                                                            r = e[1];
                                                        return [
                                                            [n, s],
                                                            [r, o]
                                                        ].map((function(t) {
                                                            var e, n, r = G(t, 2);
                                                            return e = r[0], n = r[1], e - (e - n) * i
                                                        }))
                                                    }));
                                                    return new g.ConicPolygonGeometry([h], et, et * (1 + n), !1, !0, !1, a)
                                                }))) : new Gt.BufferGeometry
                                            };
                                        !t.hexPolygonsTransitionDuration || t.hexPolygonsTransitionDuration < 0 ? P(w) : new a.Tween(E).to(w, t.hexPolygonsTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(P).start()
                                    }
                                }
                            })
                        }
                    }),
                    Wt = window.THREE ? window.THREE : {
                        Vector3: r.Vector3
                    };
                var Xt = window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry,
                        Color: r.Color,
                        Group: r.Group,
                        Line: r.Line,
                        NormalBlending: r.NormalBlending,
                        ShaderMaterial: r.ShaderMaterial,
                        Vector3: r.Vector3
                    },
                    Yt = p.default || p,
                    Qt = {
                        uniforms: {
                            dashOffset: {
                                value: 0
                            },
                            dashSize: {
                                value: 1
                            },
                            gapSize: {
                                value: 0
                            },
                            dashTranslate: {
                                value: 0
                            }
                        },
                        vertexShader: "\n    uniform float dashTranslate;\n\n    attribute vec4 vertexColor;\n    varying vec4 vColor;\n\n    attribute float vertexRelDistance;\n    varying float vRelDistance;\n\n    void main() {\n      // pass through colors and distances\n      vColor = vertexColor;\n      vRelDistance = vertexRelDistance + dashTranslate;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",
                        fragmentShader: "\n    uniform float dashOffset;\n    uniform float dashSize;\n    uniform float gapSize;\n\n    varying vec4 vColor;\n    varying float vRelDistance;\n\n    void main() {\n      // ignore pixels in the gap\n      if (vRelDistance < dashOffset) discard;\n      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;\n\n      // set px color: [r, g, b, a], interpolated between vertices\n      gl_FragColor = vColor;\n    }\n  "
                    },
                    Zt = (0, i.default)({
                        props: {
                            pathsData: {
                                default: []
                            },
                            pathPoints: {
                                default: function(t) {
                                    return t
                                }
                            },
                            pathPointLat: {
                                default: function(t) {
                                    return t[0]
                                }
                            },
                            pathPointLng: {
                                default: function(t) {
                                    return t[1]
                                }
                            },
                            pathPointAlt: {
                                default: .001
                            },
                            pathResolution: {
                                default: 2
                            },
                            pathColor: {
                                default: function() {
                                    return "#ffffaa"
                                }
                            },
                            pathStroke: {},
                            pathDashLength: {
                                default: 1
                            },
                            pathDashGap: {
                                default: 0
                            },
                            pathDashInitialGap: {
                                default: 0
                            },
                            pathDashAnimateTime: {
                                default: 0
                            },
                            pathTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            },
                            rendererSize: {}
                        },
                        methods: {
                            pauseAnimation: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.pause()
                            },
                            resumeAnimation: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.resume()
                            },
                            _destructor: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.dispose()
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t, e.ticker = new Yt, e.ticker.onTick.add((function(t, n) {
                                e.pathsData.filter((function(t) {
                                    return t.__threeObj && t.__threeObj.children.length && t.__threeObj.children[0].material && t.__threeObj.children[0].__dashAnimateStep
                                })).forEach((function(t) {
                                    var e = t.__threeObj.children[0],
                                        r = e.__dashAnimateStep * n;
                                    if ("Line" === e.type) {
                                        var i = e.material.uniforms.dashTranslate.value % 1e9;
                                        e.material.uniforms.dashTranslate.value = i + r
                                    } else if ("Line2" === e.type) {
                                        for (var a = e.material.dashOffset - r, o = e.material.dashSize + e.material.gapSize; a <= -o;) a += o;
                                        e.material.dashOffset = a
                                    }
                                }))
                            }))
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.pathPoints),
                                n = (0, u.default)(t.pathPointLat),
                                r = (0, u.default)(t.pathPointLng),
                                i = (0, u.default)(t.pathPointAlt),
                                o = (0, u.default)(t.pathStroke),
                                s = (0, u.default)(t.pathColor),
                                l = (0, u.default)(t.pathDashLength),
                                A = (0, u.default)(t.pathDashGap),
                                c = (0, u.default)(t.pathDashInitialGap),
                                h = (0, u.default)(t.pathDashAnimateTime),
                                d = new Xt.ShaderMaterial(D(D({}, Qt), {}, {
                                    transparent: !0,
                                    blending: Xt.NormalBlending
                                }));

                            function f(t, e) {
                                var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                                    i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                    a = e + 1;
                                if (t instanceof Array || t instanceof Function) {
                                    var o = t instanceof Array ? (0, m.default)().domain(t.map((function(e, n) {
                                        return n / (t.length - 1)
                                    }))).range(t) : t;
                                    n = function(t) {
                                        return ht(o(t), i, !0)
                                    }
                                } else {
                                    var s = ht(t, i, !0);
                                    n = function() {
                                        return s
                                    }
                                }
                                for (var l = [], A = 0, c = a; A < c; A++)
                                    for (var u = n(A / (c - 1)), h = 0; h < r; h++) l.push(u);
                                return ft(l, i ? 4 : 3)
                            }
                            pt(t.pathsData, t.scene, {
                                createObj: function() {
                                    var t = new Xt.Group;
                                    return t.__globeObjType = "path", t
                                },
                                updateObj: function(u, p) {
                                    var m = o(p),
                                        g = null != m;
                                    if (!u.children.length || g === ("Line" === u.children[0].type)) {
                                        $(u);
                                        var v = g ? new w.Line2(new w.LineGeometry, new w.LineMaterial) : new Xt.Line(new Xt.BufferGeometry, d.clone());
                                        u.add(v)
                                    }
                                    var _, y, x = u.children[0],
                                        b = function(t, e, n, r, i) {
                                            var a = function(t, e, n) {
                                                for (var r = [], i = 1; i <= n; i++) r.push(t + (e - t) * i / (n + 1));
                                                return r
                                            };
                                            return function() {
                                                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                                                    e = [],
                                                    n = null;
                                                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((function(r) {
                                                    if (n) {
                                                        for (; Math.abs(n[1] - r[1]) > 180;) n[1] += 360 * (n[1] < r[1] ? 1 : -1);
                                                        var i = Math.sqrt(Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2));
                                                        if (i > t)
                                                            for (var o = Math.floor(i / t), s = a(n[0], r[0], o), l = a(n[1], r[1], o), A = a(n[2], r[2], o), c = 0, u = s.length; c < u; c++) e.push([s[c], l[c], A[c]])
                                                    }
                                                    e.push(n = r)
                                                })), e
                                            }(t.map((function(t) {
                                                return [e(t), n(t), r(t)]
                                            })), i).map((function(t) {
                                                var e = G(t, 3),
                                                    n = rt(e[0], e[1], e[2]),
                                                    r = n.x,
                                                    i = n.y,
                                                    a = n.z;
                                                return new Xt.Vector3(r, i, a)
                                            }))
                                        }(e(p), n, r, i, t.pathResolution),
                                        M = h(p);
                                    if (x.__dashAnimateStep = M > 0 ? 1e3 / M : 0, g) {
                                        x.material.resolution = t.rendererSize;
                                        var E = l(p),
                                            T = A(p),
                                            C = c(p);
                                        x.material.dashed = T > 0, x.material.dashed ? x.material.defines.USE_DASH = "" : delete x.material.defines.USE_DASH, x.material.dashed && (x.material.dashScale = 1 / (y = 0, b.forEach((function(t) {
                                            _ && (y += _.distanceTo(t)), _ = t
                                        })), y), x.material.dashSize = E, x.material.gapSize = T, x.material.dashOffset = -C);
                                        var R = s(p);
                                        if (R instanceof Array) {
                                            var P = f(s(p), b.length - 1, 1, !1);
                                            x.geometry.setColors(P.array), x.material.vertexColors = !0
                                        } else {
                                            var L = R,
                                                D = ut(L);
                                            x.material.color = new Xt.Color(ct(L)), x.material.transparent = D < 1, x.material.opacity = D, x.material.vertexColors = !1
                                        }
                                        x.material.needsUpdate = !0
                                    } else {
                                        Object.assign(x.material.uniforms, {
                                            dashSize: {
                                                value: l(p)
                                            },
                                            gapSize: {
                                                value: A(p)
                                            },
                                            dashOffset: {
                                                value: c(p)
                                            }
                                        });
                                        var I = f(s(p), b.length),
                                            O = function(t) {
                                                for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = [], i = 0, a = t + 1; i < a; i++)
                                                    for (var o = i / (a - 1), s = 0; s < e; s++) r.push(o);
                                                return n && r.reverse(), ft(r, 1)
                                            }(b.length, 1, !0);
                                        x.geometry.setAttribute("vertexColor", I), x.geometry.setAttribute("vertexRelDistance", O)
                                    }
                                    var B, q, U, N, k = (B = p.__currentTargetD && p.__currentTargetD.points || [b[0]], q = b, U = Math.max(B.length, q.length), N = S.default.apply(void 0, j([B, q].map((function(t) {
                                            return t.map((function(t) {
                                                return [t.x, t.y, t.z]
                                            }))
                                        })).map((function(t) {
                                            return function(t, e) {
                                                var n = t[t.length - 1];
                                                return [].concat(j(t), j(j(new Array(e - t.length)).map((function() {
                                                    return n
                                                }))))
                                            }(t, U)
                                        })))), function(t) {
                                            return 0 === t ? B : 1 === t ? q : N(t).map((function(t) {
                                                var e = G(t, 3),
                                                    n = e[0],
                                                    r = e[1],
                                                    i = e[2];
                                                return new Wt.Vector3(n, r, i)
                                            }))
                                        }),
                                        F = function(t) {
                                            var e, n = p.__currentTargetD = t,
                                                r = n.stroke,
                                                i = n.interpolK,
                                                a = p.__currentTargetD.points = k(i);
                                            g ? (x.geometry.setPositions((e = []).concat.apply(e, j(a.map((function(t) {
                                                return [t.x, t.y, t.z]
                                            }))))), x.material.linewidth = r, x.material.dashed && x.computeLineDistances()) : (x.geometry.setFromPoints(a), x.geometry.computeBoundingSphere())
                                        },
                                        z = {
                                            stroke: m,
                                            interpolK: 1
                                        },
                                        V = Object.assign({}, p.__currentTargetD || z, {
                                            interpolK: 0
                                        });
                                    Object.keys(z).some((function(t) {
                                        return V[t] !== z[t]
                                    })) && (!t.pathTransitionDuration || t.pathTransitionDuration < 0 ? F(z) : new a.Tween(V).to(z, t.pathTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(F).start())
                                }
                            })
                        }
                    }),
                    Jt = window.THREE ? window.THREE : {
                        Euler: r.Euler,
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        SphereGeometry: r.SphereGeometry
                    },
                    Kt = (0, i.default)({
                        props: {
                            tilesData: {
                                default: []
                            },
                            tileLat: {
                                default: "lat"
                            },
                            tileLng: {
                                default: "lng"
                            },
                            tileAltitude: {
                                default: .01
                            },
                            tileWidth: {
                                default: 1
                            },
                            tileHeight: {
                                default: 1
                            },
                            tileUseGlobeProjection: {
                                default: !0
                            },
                            tileMaterial: {
                                default: function() {
                                    return new Jt.MeshLambertMaterial({
                                        color: "#ffbb88",
                                        opacity: .4,
                                        transparent: !0
                                    })
                                }
                            },
                            tileCurvatureResolution: {
                                default: 5
                            },
                            tilesTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.tileLat),
                                n = (0, u.default)(t.tileLng),
                                r = (0, u.default)(t.tileAltitude),
                                i = (0, u.default)(t.tileWidth),
                                o = (0, u.default)(t.tileHeight),
                                s = (0, u.default)(t.tileUseGlobeProjection),
                                l = (0, u.default)(t.tileMaterial),
                                A = (0, u.default)(t.tileCurvatureResolution);
                            pt(t.tilesData, t.scene, {
                                createObj: function() {
                                    var t = new Jt.Mesh;
                                    return t.__globeObjType = "tile", t
                                },
                                updateObj: function(c, u) {
                                    c.material = l(u);
                                    var h = s(u),
                                        d = A(u),
                                        f = function(t) {
                                            var e = c.__currentTargetD = t,
                                                n = e.lat,
                                                r = e.lng,
                                                i = e.alt,
                                                a = e.width,
                                                o = e.height,
                                                s = $t(r),
                                                l = $t(-n);
                                            c.geometry && c.geometry.dispose(), c.geometry = new Jt.SphereGeometry(et * (1 + i), Math.ceil(a / (d || -1)), Math.ceil(o / (d || -1)), $t(90 - a / 2) + (h ? s : 0), $t(a), $t(90 - o / 2) + (h ? l : 0), $t(o)), h || c.setRotationFromEuler(new Jt.Euler(l, s, 0, "YXZ"))
                                        },
                                        p = {
                                            lat: +e(u),
                                            lng: +n(u),
                                            alt: +r(u),
                                            width: +i(u),
                                            height: +o(u)
                                        },
                                        m = c.__currentTargetD || Object.assign({}, p, {
                                            width: 0,
                                            height: 0
                                        });
                                    Object.keys(p).some((function(t) {
                                        return m[t] !== p[t]
                                    })) && (!t.tilesTransitionDuration || t.tilesTransitionDuration < 0 ? f(p) : new a.Tween(m).to(p, t.tilesTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(f).start())
                                }
                            })
                        }
                    }),
                    $t = function(t) {
                        return t * Math.PI / 180
                    },
                    te = D(D({}, window.THREE ? window.THREE : {
                        CircleGeometry: r.CircleGeometry,
                        DoubleSide: r.DoubleSide,
                        Group: r.Group,
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        TextGeometry: E.TextGeometry,
                        Vector3: r.Vector3
                    }), {}, {
                        Font: T.Font,
                        TextGeometry: E.TextGeometry
                    }),
                    ee = (0, i.default)({
                        props: {
                            labelsData: {
                                default: []
                            },
                            labelLat: {
                                default: "lat"
                            },
                            labelLng: {
                                default: "lng"
                            },
                            labelAltitude: {
                                default: 0
                            },
                            labelText: {
                                default: "text"
                            },
                            labelSize: {
                                default: .5
                            },
                            labelTypeFace: {
                                default: {
                                    glyphs: {
                                        0: {
                                            x_min: 73,
                                            x_max: 715,
                                            ha: 792,
                                            o: "m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "
                                        },
                                        1: {
                                            x_min: 215.671875,
                                            x_max: 574,
                                            ha: 792,
                                            o: "m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "
                                        },
                                        2: {
                                            x_min: 59,
                                            x_max: 731,
                                            ha: 792,
                                            o: "m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "
                                        },
                                        3: {
                                            x_min: 54,
                                            x_max: 737,
                                            ha: 792,
                                            o: "m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "
                                        },
                                        4: {
                                            x_min: 48,
                                            x_max: 742.453125,
                                            ha: 792,
                                            o: "m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "
                                        },
                                        5: {
                                            x_min: 54.171875,
                                            x_max: 738,
                                            ha: 792,
                                            o: "m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "
                                        },
                                        6: {
                                            x_min: 53,
                                            x_max: 739,
                                            ha: 792,
                                            o: "m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "
                                        },
                                        7: {
                                            x_min: 58.71875,
                                            x_max: 730.953125,
                                            ha: 792,
                                            o: "m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "
                                        },
                                        8: {
                                            x_min: 55,
                                            x_max: 736,
                                            ha: 792,
                                            o: "m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "
                                        },
                                        9: {
                                            x_min: 53,
                                            x_max: 739,
                                            ha: 792,
                                            o: "m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "
                                        },
                                        ο: {
                                            x_min: 0,
                                            x_max: 712,
                                            ha: 815,
                                            o: "m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "
                                        },
                                        S: {
                                            x_min: 0,
                                            x_max: 788,
                                            ha: 890,
                                            o: "m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "
                                        },
                                        "¦": {
                                            x_min: 343,
                                            x_max: 449,
                                            ha: 792,
                                            o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "
                                        },
                                        "/": {
                                            x_min: 183.25,
                                            x_max: 608.328125,
                                            ha: 792,
                                            o: "m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "
                                        },
                                        Τ: {
                                            x_min: -.4375,
                                            x_max: 777.453125,
                                            ha: 839,
                                            o: "m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "
                                        },
                                        y: {
                                            x_min: 0,
                                            x_max: 684.78125,
                                            ha: 771,
                                            o: "m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "
                                        },
                                        Π: {
                                            x_min: 0,
                                            x_max: 803,
                                            ha: 917,
                                            o: "m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "
                                        },
                                        ΐ: {
                                            x_min: -111,
                                            x_max: 339,
                                            ha: 361,
                                            o: "m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "
                                        },
                                        g: {
                                            x_min: 0,
                                            x_max: 686,
                                            ha: 838,
                                            o: "m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "
                                        },
                                        "²": {
                                            x_min: 0,
                                            x_max: 442,
                                            ha: 539,
                                            o: "m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "
                                        },
                                        "–": {
                                            x_min: 0,
                                            x_max: 705.5625,
                                            ha: 803,
                                            o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "
                                        },
                                        Κ: {
                                            x_min: 0,
                                            x_max: 819.5625,
                                            ha: 893,
                                            o: "m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "
                                        },
                                        ƒ: {
                                            x_min: -46.265625,
                                            x_max: 392,
                                            ha: 513,
                                            o: "m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "
                                        },
                                        e: {
                                            x_min: 0,
                                            x_max: 714,
                                            ha: 813,
                                            o: "m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "
                                        },
                                        ό: {
                                            x_min: 0,
                                            x_max: 712,
                                            ha: 815,
                                            o: "m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "
                                        },
                                        J: {
                                            x_min: 0,
                                            x_max: 588,
                                            ha: 699,
                                            o: "m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "
                                        },
                                        "»": {
                                            x_min: -1,
                                            x_max: 503,
                                            ha: 601,
                                            o: "m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "
                                        },
                                        "©": {
                                            x_min: -3,
                                            x_max: 1008,
                                            ha: 1106,
                                            o: "m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "
                                        },
                                        ώ: {
                                            x_min: 0,
                                            x_max: 922,
                                            ha: 1030,
                                            o: "m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "
                                        },
                                        "^": {
                                            x_min: 193.0625,
                                            x_max: 598.609375,
                                            ha: 792,
                                            o: "m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "
                                        },
                                        "«": {
                                            x_min: 0,
                                            x_max: 507.203125,
                                            ha: 604,
                                            o: "m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "
                                        },
                                        D: {
                                            x_min: 0,
                                            x_max: 828,
                                            ha: 935,
                                            o: "m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "
                                        },
                                        "∙": {
                                            x_min: 0,
                                            x_max: 142,
                                            ha: 239,
                                            o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "
                                        },
                                        ÿ: {
                                            x_min: 0,
                                            x_max: 47,
                                            ha: 125,
                                            o: "m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "
                                        },
                                        w: {
                                            x_min: 0,
                                            x_max: 1009.71875,
                                            ha: 1100,
                                            o: "m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "
                                        },
                                        $: {
                                            x_min: 0,
                                            x_max: 700,
                                            ha: 793,
                                            o: "m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "
                                        },
                                        "\\": {
                                            x_min: -.015625,
                                            x_max: 425.0625,
                                            ha: 522,
                                            o: "m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "
                                        },
                                        µ: {
                                            x_min: 0,
                                            x_max: 697.21875,
                                            ha: 747,
                                            o: "m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "
                                        },
                                        Ι: {
                                            x_min: 42,
                                            x_max: 181,
                                            ha: 297,
                                            o: "m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "
                                        },
                                        Ύ: {
                                            x_min: 0,
                                            x_max: 1144.5,
                                            ha: 1214,
                                            o: "m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "
                                        },
                                        "’": {
                                            x_min: 0,
                                            x_max: 139,
                                            ha: 236,
                                            o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "
                                        },
                                        Ν: {
                                            x_min: 0,
                                            x_max: 801,
                                            ha: 915,
                                            o: "m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "
                                        },
                                        "-": {
                                            x_min: 8.71875,
                                            x_max: 350.390625,
                                            ha: 478,
                                            o: "m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "
                                        },
                                        Q: {
                                            x_min: 0,
                                            x_max: 968,
                                            ha: 1072,
                                            o: "m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "
                                        },
                                        ς: {
                                            x_min: 1,
                                            x_max: 676.28125,
                                            ha: 740,
                                            o: "m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "
                                        },
                                        M: {
                                            x_min: 0,
                                            x_max: 954,
                                            ha: 1067,
                                            o: "m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "
                                        },
                                        Ψ: {
                                            x_min: 0,
                                            x_max: 1006,
                                            ha: 1094,
                                            o: "m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "
                                        },
                                        C: {
                                            x_min: 0,
                                            x_max: 886,
                                            ha: 944,
                                            o: "m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "
                                        },
                                        "!": {
                                            x_min: 0,
                                            x_max: 138,
                                            ha: 236,
                                            o: "m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "
                                        },
                                        "{": {
                                            x_min: 0,
                                            x_max: 480.5625,
                                            ha: 578,
                                            o: "m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "
                                        },
                                        X: {
                                            x_min: -.015625,
                                            x_max: 854.15625,
                                            ha: 940,
                                            o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "
                                        },
                                        "#": {
                                            x_min: 0,
                                            x_max: 963.890625,
                                            ha: 1061,
                                            o: "m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "
                                        },
                                        ι: {
                                            x_min: 42,
                                            x_max: 284,
                                            ha: 361,
                                            o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "
                                        },
                                        Ά: {
                                            x_min: 0,
                                            x_max: 906.953125,
                                            ha: 982,
                                            o: "m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "
                                        },
                                        ")": {
                                            x_min: 0,
                                            x_max: 318,
                                            ha: 415,
                                            o: "m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "
                                        },
                                        ε: {
                                            x_min: 0,
                                            x_max: 634.71875,
                                            ha: 714,
                                            o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "
                                        },
                                        Δ: {
                                            x_min: 0,
                                            x_max: 952.78125,
                                            ha: 1028,
                                            o: "m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "
                                        },
                                        "}": {
                                            x_min: 0,
                                            x_max: 481,
                                            ha: 578,
                                            o: "m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "
                                        },
                                        "‰": {
                                            x_min: -3,
                                            x_max: 1672,
                                            ha: 1821,
                                            o: "m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "
                                        },
                                        a: {
                                            x_min: 0,
                                            x_max: 698.609375,
                                            ha: 794,
                                            o: "m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "
                                        },
                                        "—": {
                                            x_min: 0,
                                            x_max: 941.671875,
                                            ha: 1039,
                                            o: "m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "
                                        },
                                        "=": {
                                            x_min: 8.71875,
                                            x_max: 780.953125,
                                            ha: 792,
                                            o: "m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "
                                        },
                                        N: {
                                            x_min: 0,
                                            x_max: 801,
                                            ha: 914,
                                            o: "m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "
                                        },
                                        ρ: {
                                            x_min: 0,
                                            x_max: 712,
                                            ha: 797,
                                            o: "m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "
                                        },
                                        "¯": {
                                            x_min: 0,
                                            x_max: 941.671875,
                                            ha: 938,
                                            o: "m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "
                                        },
                                        Z: {
                                            x_min: 0,
                                            x_max: 779,
                                            ha: 849,
                                            o: "m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "
                                        },
                                        u: {
                                            x_min: 0,
                                            x_max: 617,
                                            ha: 729,
                                            o: "m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "
                                        },
                                        k: {
                                            x_min: 0,
                                            x_max: 612.484375,
                                            ha: 697,
                                            o: "m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "
                                        },
                                        Η: {
                                            x_min: 0,
                                            x_max: 803,
                                            ha: 917,
                                            o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "
                                        },
                                        Α: {
                                            x_min: 0,
                                            x_max: 906.953125,
                                            ha: 985,
                                            o: "m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "
                                        },
                                        s: {
                                            x_min: 0,
                                            x_max: 604,
                                            ha: 697,
                                            o: "m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "
                                        },
                                        B: {
                                            x_min: 0,
                                            x_max: 778,
                                            ha: 876,
                                            o: "m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "
                                        },
                                        "…": {
                                            x_min: 0,
                                            x_max: 614,
                                            ha: 708,
                                            o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "
                                        },
                                        "?": {
                                            x_min: 0,
                                            x_max: 607,
                                            ha: 704,
                                            o: "m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "
                                        },
                                        H: {
                                            x_min: 0,
                                            x_max: 803,
                                            ha: 915,
                                            o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "
                                        },
                                        ν: {
                                            x_min: 0,
                                            x_max: 675,
                                            ha: 761,
                                            o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "
                                        },
                                        c: {
                                            x_min: 1,
                                            x_max: 701.390625,
                                            ha: 775,
                                            o: "m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "
                                        },
                                        "¶": {
                                            x_min: 0,
                                            x_max: 566.671875,
                                            ha: 678,
                                            o: "m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "
                                        },
                                        β: {
                                            x_min: 0,
                                            x_max: 660,
                                            ha: 745,
                                            o: "m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "
                                        },
                                        Μ: {
                                            x_min: 0,
                                            x_max: 954,
                                            ha: 1068,
                                            o: "m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "
                                        },
                                        Ό: {
                                            x_min: .109375,
                                            x_max: 1120,
                                            ha: 1217,
                                            o: "m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "
                                        },
                                        Ή: {
                                            x_min: 0,
                                            x_max: 1158,
                                            ha: 1275,
                                            o: "m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "
                                        },
                                        "•": {
                                            x_min: 0,
                                            x_max: 663.890625,
                                            ha: 775,
                                            o: "m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "
                                        },
                                        "¥": {
                                            x_min: .1875,
                                            x_max: 819.546875,
                                            ha: 886,
                                            o: "m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "
                                        },
                                        "(": {
                                            x_min: 0,
                                            x_max: 318.0625,
                                            ha: 415,
                                            o: "m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "
                                        },
                                        U: {
                                            x_min: 0,
                                            x_max: 796,
                                            ha: 904,
                                            o: "m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "
                                        },
                                        γ: {
                                            x_min: .5,
                                            x_max: 744.953125,
                                            ha: 822,
                                            o: "m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "
                                        },
                                        α: {
                                            x_min: 0,
                                            x_max: 765.5625,
                                            ha: 809,
                                            o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "
                                        },
                                        F: {
                                            x_min: 0,
                                            x_max: 683.328125,
                                            ha: 717,
                                            o: "m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "
                                        },
                                        "­": {
                                            x_min: 0,
                                            x_max: 705.5625,
                                            ha: 803,
                                            o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "
                                        },
                                        ":": {
                                            x_min: 0,
                                            x_max: 142,
                                            ha: 239,
                                            o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "
                                        },
                                        Χ: {
                                            x_min: 0,
                                            x_max: 854.171875,
                                            ha: 935,
                                            o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "
                                        },
                                        "*": {
                                            x_min: 116,
                                            x_max: 674,
                                            ha: 792,
                                            o: "m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "
                                        },
                                        "†": {
                                            x_min: 0,
                                            x_max: 777,
                                            ha: 835,
                                            o: "m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "
                                        },
                                        "°": {
                                            x_min: 0,
                                            x_max: 347,
                                            ha: 444,
                                            o: "m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "
                                        },
                                        V: {
                                            x_min: 0,
                                            x_max: 862.71875,
                                            ha: 940,
                                            o: "m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "
                                        },
                                        Ξ: {
                                            x_min: 0,
                                            x_max: 734.71875,
                                            ha: 763,
                                            o: "m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "
                                        },
                                        " ": {
                                            x_min: 0,
                                            x_max: 0,
                                            ha: 853
                                        },
                                        Ϋ: {
                                            x_min: .328125,
                                            x_max: 819.515625,
                                            ha: 889,
                                            o: "m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "
                                        },
                                        "”": {
                                            x_min: 0,
                                            x_max: 347,
                                            ha: 454,
                                            o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "
                                        },
                                        "@": {
                                            x_min: 0,
                                            x_max: 1260,
                                            ha: 1357,
                                            o: "m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "
                                        },
                                        Ί: {
                                            x_min: 0,
                                            x_max: 499,
                                            ha: 613,
                                            o: "m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "
                                        },
                                        i: {
                                            x_min: 14,
                                            x_max: 136,
                                            ha: 275,
                                            o: "m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "
                                        },
                                        Β: {
                                            x_min: 0,
                                            x_max: 778,
                                            ha: 877,
                                            o: "m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "
                                        },
                                        υ: {
                                            x_min: 0,
                                            x_max: 617,
                                            ha: 725,
                                            o: "m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "
                                        },
                                        "]": {
                                            x_min: 0,
                                            x_max: 275,
                                            ha: 372,
                                            o: "m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "
                                        },
                                        m: {
                                            x_min: 0,
                                            x_max: 1019,
                                            ha: 1128,
                                            o: "m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "
                                        },
                                        χ: {
                                            x_min: 8.328125,
                                            x_max: 780.5625,
                                            ha: 815,
                                            o: "m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "
                                        },
                                        ί: {
                                            x_min: 42,
                                            x_max: 326.71875,
                                            ha: 361,
                                            o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "
                                        },
                                        Ζ: {
                                            x_min: 0,
                                            x_max: 779.171875,
                                            ha: 850,
                                            o: "m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "
                                        },
                                        R: {
                                            x_min: 0,
                                            x_max: 781.953125,
                                            ha: 907,
                                            o: "m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "
                                        },
                                        o: {
                                            x_min: 0,
                                            x_max: 713,
                                            ha: 821,
                                            o: "m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "
                                        },
                                        K: {
                                            x_min: 0,
                                            x_max: 819.46875,
                                            ha: 906,
                                            o: "m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "
                                        },
                                        ",": {
                                            x_min: 0,
                                            x_max: 142,
                                            ha: 239,
                                            o: "m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "
                                        },
                                        d: {
                                            x_min: 0,
                                            x_max: 683,
                                            ha: 796,
                                            o: "m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "
                                        },
                                        "¨": {
                                            x_min: -109,
                                            x_max: 247,
                                            ha: 232,
                                            o: "m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "
                                        },
                                        E: {
                                            x_min: 0,
                                            x_max: 736.109375,
                                            ha: 789,
                                            o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "
                                        },
                                        Y: {
                                            x_min: 0,
                                            x_max: 820,
                                            ha: 886,
                                            o: "m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "
                                        },
                                        '"': {
                                            x_min: 0,
                                            x_max: 299,
                                            ha: 396,
                                            o: "m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "
                                        },
                                        "‹": {
                                            x_min: 17.984375,
                                            x_max: 773.609375,
                                            ha: 792,
                                            o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "
                                        },
                                        "„": {
                                            x_min: 0,
                                            x_max: 364,
                                            ha: 467,
                                            o: "m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "
                                        },
                                        δ: {
                                            x_min: 1,
                                            x_max: 710,
                                            ha: 810,
                                            o: "m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "
                                        },
                                        έ: {
                                            x_min: 0,
                                            x_max: 634.71875,
                                            ha: 714,
                                            o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "
                                        },
                                        ω: {
                                            x_min: 0,
                                            x_max: 922,
                                            ha: 1031,
                                            o: "m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "
                                        },
                                        "´": {
                                            x_min: 0,
                                            x_max: 96,
                                            ha: 251,
                                            o: "m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "
                                        },
                                        "±": {
                                            x_min: 11,
                                            x_max: 781,
                                            ha: 792,
                                            o: "m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "
                                        },
                                        "|": {
                                            x_min: 343,
                                            x_max: 449,
                                            ha: 792,
                                            o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "
                                        },
                                        ϋ: {
                                            x_min: 0,
                                            x_max: 617,
                                            ha: 725,
                                            o: "m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "
                                        },
                                        "§": {
                                            x_min: 0,
                                            x_max: 593,
                                            ha: 690,
                                            o: "m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "
                                        },
                                        b: {
                                            x_min: 0,
                                            x_max: 685,
                                            ha: 783,
                                            o: "m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "
                                        },
                                        q: {
                                            x_min: 0,
                                            x_max: 683,
                                            ha: 876,
                                            o: "m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "
                                        },
                                        Ω: {
                                            x_min: -.171875,
                                            x_max: 969.5625,
                                            ha: 1068,
                                            o: "m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "
                                        },
                                        ύ: {
                                            x_min: 0,
                                            x_max: 617,
                                            ha: 725,
                                            o: "m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "
                                        },
                                        z: {
                                            x_min: -.015625,
                                            x_max: 613.890625,
                                            ha: 697,
                                            o: "m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "
                                        },
                                        "™": {
                                            x_min: 0,
                                            x_max: 894,
                                            ha: 1e3,
                                            o: "m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "
                                        },
                                        ή: {
                                            x_min: .78125,
                                            x_max: 697,
                                            ha: 810,
                                            o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "
                                        },
                                        Θ: {
                                            x_min: 0,
                                            x_max: 960,
                                            ha: 1056,
                                            o: "m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "
                                        },
                                        "®": {
                                            x_min: -3,
                                            x_max: 1008,
                                            ha: 1106,
                                            o: "m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "
                                        },
                                        "~": {
                                            x_min: 0,
                                            x_max: 833,
                                            ha: 931,
                                            o: "m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "
                                        },
                                        Ε: {
                                            x_min: 0,
                                            x_max: 736.21875,
                                            ha: 778,
                                            o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "
                                        },
                                        "³": {
                                            x_min: 0,
                                            x_max: 450,
                                            ha: 547,
                                            o: "m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "
                                        },
                                        "[": {
                                            x_min: 0,
                                            x_max: 273.609375,
                                            ha: 371,
                                            o: "m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "
                                        },
                                        L: {
                                            x_min: 0,
                                            x_max: 645.828125,
                                            ha: 696,
                                            o: "m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "
                                        },
                                        σ: {
                                            x_min: 0,
                                            x_max: 803.390625,
                                            ha: 894,
                                            o: "m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "
                                        },
                                        ζ: {
                                            x_min: 0,
                                            x_max: 573,
                                            ha: 642,
                                            o: "m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "
                                        },
                                        θ: {
                                            x_min: 0,
                                            x_max: 674,
                                            ha: 778,
                                            o: "m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "
                                        },
                                        Ο: {
                                            x_min: 0,
                                            x_max: 958,
                                            ha: 1054,
                                            o: "m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "
                                        },
                                        Γ: {
                                            x_min: 0,
                                            x_max: 705.28125,
                                            ha: 749,
                                            o: "m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "
                                        },
                                        " ": {
                                            x_min: 0,
                                            x_max: 0,
                                            ha: 375
                                        },
                                        "%": {
                                            x_min: -3,
                                            x_max: 1089,
                                            ha: 1186,
                                            o: "m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "
                                        },
                                        P: {
                                            x_min: 0,
                                            x_max: 726,
                                            ha: 806,
                                            o: "m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "
                                        },
                                        Έ: {
                                            x_min: 0,
                                            x_max: 1078.21875,
                                            ha: 1118,
                                            o: "m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "
                                        },
                                        Ώ: {
                                            x_min: .125,
                                            x_max: 1136.546875,
                                            ha: 1235,
                                            o: "m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "
                                        },
                                        _: {
                                            x_min: 0,
                                            x_max: 705.5625,
                                            ha: 803,
                                            o: "m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "
                                        },
                                        Ϊ: {
                                            x_min: -110,
                                            x_max: 246,
                                            ha: 275,
                                            o: "m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "
                                        },
                                        "+": {
                                            x_min: 23,
                                            x_max: 768,
                                            ha: 792,
                                            o: "m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "
                                        },
                                        "½": {
                                            x_min: 0,
                                            x_max: 1050,
                                            ha: 1149,
                                            o: "m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "
                                        },
                                        Ρ: {
                                            x_min: 0,
                                            x_max: 720,
                                            ha: 783,
                                            o: "m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "
                                        },
                                        "'": {
                                            x_min: 0,
                                            x_max: 139,
                                            ha: 236,
                                            o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "
                                        },
                                        ª: {
                                            x_min: 0,
                                            x_max: 350,
                                            ha: 397,
                                            o: "m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "
                                        },
                                        "΅": {
                                            x_min: 0,
                                            x_max: 450,
                                            ha: 553,
                                            o: "m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "
                                        },
                                        T: {
                                            x_min: 0,
                                            x_max: 777,
                                            ha: 835,
                                            o: "m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "
                                        },
                                        Φ: {
                                            x_min: 0,
                                            x_max: 915,
                                            ha: 997,
                                            o: "m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "
                                        },
                                        "⁋": {
                                            x_min: 0,
                                            x_max: 0,
                                            ha: 694
                                        },
                                        j: {
                                            x_min: -77.78125,
                                            x_max: 167,
                                            ha: 349,
                                            o: "m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "
                                        },
                                        Σ: {
                                            x_min: 0,
                                            x_max: 756.953125,
                                            ha: 819,
                                            o: "m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "
                                        },
                                        "›": {
                                            x_min: 18.0625,
                                            x_max: 774,
                                            ha: 792,
                                            o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "
                                        },
                                        "<": {
                                            x_min: 17.984375,
                                            x_max: 773.609375,
                                            ha: 792,
                                            o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "
                                        },
                                        "£": {
                                            x_min: 0,
                                            x_max: 704.484375,
                                            ha: 801,
                                            o: "m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "
                                        },
                                        t: {
                                            x_min: 0,
                                            x_max: 367,
                                            ha: 458,
                                            o: "m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "
                                        },
                                        "¬": {
                                            x_min: 0,
                                            x_max: 706,
                                            ha: 803,
                                            o: "m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "
                                        },
                                        λ: {
                                            x_min: 0,
                                            x_max: 750,
                                            ha: 803,
                                            o: "m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "
                                        },
                                        W: {
                                            x_min: 0,
                                            x_max: 1263.890625,
                                            ha: 1351,
                                            o: "m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "
                                        },
                                        ">": {
                                            x_min: 18.0625,
                                            x_max: 774,
                                            ha: 792,
                                            o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "
                                        },
                                        v: {
                                            x_min: 0,
                                            x_max: 675.15625,
                                            ha: 761,
                                            o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "
                                        },
                                        τ: {
                                            x_min: .28125,
                                            x_max: 644.5,
                                            ha: 703,
                                            o: "m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "
                                        },
                                        ξ: {
                                            x_min: 0,
                                            x_max: 624.9375,
                                            ha: 699,
                                            o: "m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "
                                        },
                                        "&": {
                                            x_min: -3,
                                            x_max: 894.25,
                                            ha: 992,
                                            o: "m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "
                                        },
                                        Λ: {
                                            x_min: 0,
                                            x_max: 862.5,
                                            ha: 942,
                                            o: "m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "
                                        },
                                        I: {
                                            x_min: 41,
                                            x_max: 180,
                                            ha: 293,
                                            o: "m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "
                                        },
                                        G: {
                                            x_min: 0,
                                            x_max: 921,
                                            ha: 1011,
                                            o: "m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "
                                        },
                                        ΰ: {
                                            x_min: 0,
                                            x_max: 617,
                                            ha: 725,
                                            o: "m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "
                                        },
                                        "`": {
                                            x_min: 0,
                                            x_max: 138.890625,
                                            ha: 236,
                                            o: "m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "
                                        },
                                        "·": {
                                            x_min: 0,
                                            x_max: 142,
                                            ha: 239,
                                            o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "
                                        },
                                        Υ: {
                                            x_min: .328125,
                                            x_max: 819.515625,
                                            ha: 889,
                                            o: "m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "
                                        },
                                        r: {
                                            x_min: 0,
                                            x_max: 355.5625,
                                            ha: 432,
                                            o: "m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "
                                        },
                                        x: {
                                            x_min: 0,
                                            x_max: 675,
                                            ha: 764,
                                            o: "m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "
                                        },
                                        μ: {
                                            x_min: 0,
                                            x_max: 696.609375,
                                            ha: 747,
                                            o: "m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "
                                        },
                                        h: {
                                            x_min: 0,
                                            x_max: 615,
                                            ha: 724,
                                            o: "m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "
                                        },
                                        ".": {
                                            x_min: 0,
                                            x_max: 142,
                                            ha: 239,
                                            o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "
                                        },
                                        φ: {
                                            x_min: -2,
                                            x_max: 878,
                                            ha: 974,
                                            o: "m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "
                                        },
                                        ";": {
                                            x_min: 0,
                                            x_max: 142,
                                            ha: 239,
                                            o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "
                                        },
                                        f: {
                                            x_min: 0,
                                            x_max: 378,
                                            ha: 472,
                                            o: "m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "
                                        },
                                        "“": {
                                            x_min: 1,
                                            x_max: 348.21875,
                                            ha: 454,
                                            o: "m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "
                                        },
                                        A: {
                                            x_min: .03125,
                                            x_max: 906.953125,
                                            ha: 1008,
                                            o: "m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "
                                        },
                                        "‘": {
                                            x_min: 1,
                                            x_max: 139.890625,
                                            ha: 236,
                                            o: "m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "
                                        },
                                        ϊ: {
                                            x_min: -70,
                                            x_max: 283,
                                            ha: 361,
                                            o: "m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "
                                        },
                                        π: {
                                            x_min: -.21875,
                                            x_max: 773.21875,
                                            ha: 857,
                                            o: "m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "
                                        },
                                        ά: {
                                            x_min: 0,
                                            x_max: 765.5625,
                                            ha: 809,
                                            o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "
                                        },
                                        O: {
                                            x_min: 0,
                                            x_max: 958,
                                            ha: 1057,
                                            o: "m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "
                                        },
                                        n: {
                                            x_min: 0,
                                            x_max: 615,
                                            ha: 724,
                                            o: "m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "
                                        },
                                        l: {
                                            x_min: 41,
                                            x_max: 166,
                                            ha: 279,
                                            o: "m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "
                                        },
                                        "¤": {
                                            x_min: 40.09375,
                                            x_max: 728.796875,
                                            ha: 825,
                                            o: "m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "
                                        },
                                        κ: {
                                            x_min: 0,
                                            x_max: 632.328125,
                                            ha: 679,
                                            o: "m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "
                                        },
                                        p: {
                                            x_min: 0,
                                            x_max: 685,
                                            ha: 786,
                                            o: "m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "
                                        },
                                        "‡": {
                                            x_min: 0,
                                            x_max: 777,
                                            ha: 835,
                                            o: "m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "
                                        },
                                        ψ: {
                                            x_min: 0,
                                            x_max: 808,
                                            ha: 907,
                                            o: "m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "
                                        },
                                        η: {
                                            x_min: .78125,
                                            x_max: 697,
                                            ha: 810,
                                            o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "
                                        }
                                    },
                                    cssFontWeight: "normal",
                                    ascender: 1189,
                                    underlinePosition: -100,
                                    cssFontStyle: "normal",
                                    boundingBox: {
                                        yMin: -334,
                                        xMin: -111,
                                        yMax: 1189,
                                        xMax: 1672
                                    },
                                    resolution: 1e3,
                                    original_font_information: {
                                        postscript_name: "Helvetiker-Regular",
                                        version_string: "Version 1.00 2004 initial release",
                                        vendor_url: "http://www.magenta.gr/",
                                        full_font_name: "Helvetiker",
                                        font_family_name: "Helvetiker",
                                        copyright: "Copyright (c) Μagenta ltd, 2004",
                                        description: "",
                                        trademark: "",
                                        designer: "",
                                        designer_url: "",
                                        unique_font_identifier: "Μagenta ltd:Helvetiker:22-10-104",
                                        license_url: "http://www.ellak.gr/fonts/MgOpen/license.html",
                                        license_description: 'Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license ("Fonts") and associated documentation files (the "Font Software"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word "MgOpen", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the "MgOpen" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.',
                                        manufacturer_name: "Μagenta ltd",
                                        font_sub_family_name: "Regular"
                                    },
                                    descender: -334,
                                    familyName: "Helvetiker",
                                    lineHeight: 1522,
                                    underlineThickness: 50
                                },
                                onChange: function(t, e) {
                                    e.font = new te.Font(t)
                                }
                            },
                            labelColor: {
                                default: function() {
                                    return "lightgrey"
                                }
                            },
                            labelRotation: {
                                default: 0
                            },
                            labelResolution: {
                                default: 3
                            },
                            labelIncludeDot: {
                                default: !0
                            },
                            labelDotRadius: {
                                default: .1
                            },
                            labelDotOrientation: {
                                default: function() {
                                    return "bottom"
                                }
                            },
                            labelsTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.labelLat),
                                n = (0, u.default)(t.labelLng),
                                i = (0, u.default)(t.labelAltitude),
                                o = (0, u.default)(t.labelText),
                                s = (0, u.default)(t.labelSize),
                                l = (0, u.default)(t.labelRotation),
                                A = (0, u.default)(t.labelColor),
                                c = (0, u.default)(t.labelIncludeDot),
                                h = (0, u.default)(t.labelDotRadius),
                                d = (0, u.default)(t.labelDotOrientation),
                                f = new Set(["right", "top", "bottom"]),
                                p = 2 * Math.PI * et / 360,
                                m = new te.CircleGeometry(1, 16);
                            pt(t.labelsData, t.scene, {
                                createObj: function() {
                                    var t = new te.MeshLambertMaterial;
                                    t.side = r.DoubleSide;
                                    var e = new te.Group;
                                    return e.add(new te.Mesh(m, t)), e.add(new te.Mesh(void 0, t)), e.__globeObjType = "label", e
                                },
                                updateObj: function(r, u) {
                                    var m = G(r.children, 2),
                                        g = m[0],
                                        v = m[1],
                                        _ = A(u),
                                        y = ut(_);
                                    v.material.color.set(ct(_)), v.material.transparent = y < 1, v.material.opacity = y;
                                    var x = c(u),
                                        b = d(u);
                                    !x || !f.has(b) && (b = "bottom");
                                    var M = x ? +h(u) * p : 1e-12;
                                    g.scale.x = g.scale.y = M;
                                    var w = +s(u) * p;
                                    if (v.geometry && v.geometry.dispose(), v.geometry = new te.TextGeometry(o(u), {
                                            font: t.font,
                                            size: w,
                                            height: 0,
                                            curveSegments: t.labelResolution
                                        }), "right" !== b && v.geometry.center(), x) {
                                        var S = M + w / 2;
                                        "right" === b && (v.position.x = S), v.position.y = {
                                            right: -w / 2,
                                            top: S + w / 2,
                                            bottom: -S - w / 2
                                        } [b]
                                    }
                                    var E = function(e) {
                                            var n = r.__currentTargetD = e,
                                                i = n.lat,
                                                a = n.lng,
                                                o = n.alt,
                                                s = n.rot,
                                                l = n.scale;
                                            Object.assign(r.position, rt(i, a, o)), r.lookAt(t.scene.localToWorld(new te.Vector3(0, 0, 0))), r.rotateY(Math.PI), r.rotateZ(-s * Math.PI / 180), r.scale.x = r.scale.y = r.scale.z = l
                                        },
                                        T = {
                                            lat: +e(u),
                                            lng: +n(u),
                                            alt: +i(u),
                                            rot: +l(u),
                                            scale: 1
                                        },
                                        C = r.__currentTargetD || Object.assign({}, T, {
                                            scale: 1e-12
                                        });
                                    Object.keys(T).some((function(t) {
                                        return C[t] !== T[t]
                                    })) && (!t.labelsTransitionDuration || t.labelsTransitionDuration < 0 ? E(T) : new a.Tween(C).to(T, t.labelsTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(E).start())
                                }
                            })
                        }
                    }),
                    ne = function(t) {
                        function e() {
                            var t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32;
                            O(this, e), (t = R(this, e)).type = "CircleLineGeometry", t.parameters = {
                                radius: n,
                                segmentCount: r
                            };
                            for (var i = [], a = 0; a <= r; a++) {
                                var o = (a / r - .25) * Math.PI * 2;
                                i.push({
                                    x: Math.cos(o) * n,
                                    y: Math.sin(o) * n,
                                    z: 0
                                })
                            }
                            return t.setFromPoints(i), t
                        }
                        return N(e, t), q(e)
                    }((window.THREE ? window.THREE : {
                        BufferGeometry: r.BufferGeometry
                    }).BufferGeometry),
                    re = window.THREE ? window.THREE : {
                        Color: r.Color,
                        Group: r.Group,
                        Line: r.Line,
                        LineBasicMaterial: r.LineBasicMaterial,
                        Vector3: r.Vector3
                    },
                    ie = p.default || p,
                    ae = (0, i.default)({
                        props: {
                            ringsData: {
                                default: []
                            },
                            ringLat: {
                                default: "lat"
                            },
                            ringLng: {
                                default: "lng"
                            },
                            ringAltitude: {
                                default: .0015
                            },
                            ringColor: {
                                default: function() {
                                    return "#ffffaa"
                                },
                                triggerUpdate: !1
                            },
                            ringResolution: {
                                default: 64,
                                triggerUpdate: !1
                            },
                            ringMaxRadius: {
                                default: 2,
                                triggerUpdate: !1
                            },
                            ringPropagationSpeed: {
                                default: 1,
                                triggerUpdate: !1
                            },
                            ringRepeatPeriod: {
                                default: 700,
                                triggerUpdate: !1
                            }
                        },
                        methods: {
                            pauseAnimation: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.pause()
                            },
                            resumeAnimation: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.resume()
                            },
                            _destructor: function(t) {
                                var e;
                                null === (e = t.ticker) || void 0 === e || e.dispose()
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t, e.ticker = new ie, e.ticker.onTick.add((function(t) {
                                if (e.ringsData.length) {
                                    var n = (0, u.default)(e.ringColor),
                                        r = (0, u.default)(e.ringAltitude),
                                        i = (0, u.default)(e.ringMaxRadius),
                                        o = (0, u.default)(e.ringPropagationSpeed),
                                        s = (0, u.default)(e.ringRepeatPeriod);
                                    e.ringsData.filter((function(t) {
                                        return t.__threeObj
                                    })).forEach((function(l) {
                                        var A, c, u = l.__threeObj;
                                        if ((u.__nextRingTime || 0) <= t) {
                                            var h = s(l) / 1e3;
                                            u.__nextRingTime = t + (h <= 0 ? 1 / 0 : h);
                                            var d, f = new re.Line(new ne(1, e.ringResolution), new re.LineBasicMaterial),
                                                p = n(l),
                                                g = p instanceof Array || p instanceof Function;
                                            g ? p instanceof Array ? (d = (0, m.default)().domain(p.map((function(t, e) {
                                                return e / (p.length - 1)
                                            }))).range(p), f.material.transparent = p.some((function(t) {
                                                return ut(t) < 1
                                            }))) : (d = p, f.material.transparent = !0) : (f.material.color = new re.Color(ct(p)), A = f.material, c = ut(p), A.opacity = c, A.transparent = c < 1, A.depthWrite = c >= 1);
                                            var v = et * (1 + r(l)),
                                                _ = i(l),
                                                y = _ * Math.PI / 180,
                                                x = o(l),
                                                b = x <= 0,
                                                M = function(t) {
                                                    var e = t.t,
                                                        n = (b ? 1 - e : e) * y;
                                                    if (f.scale.x = f.scale.y = v * Math.sin(n), f.position.z = v * (1 - Math.cos(n)), g) {
                                                        var r = d(e);
                                                        f.material.color = new re.Color(ct(r)), f.material.transparent && (f.material.opacity = ut(r))
                                                    }
                                                };
                                            if (0 === x) M({
                                                t: 0
                                            }), u.add(f);
                                            else {
                                                var w = 1e3 * Math.abs(_ / x);
                                                new a.Tween({
                                                    t: 0
                                                }).to({
                                                    t: 1
                                                }, w).onUpdate(M).onStart((function() {
                                                    return u.add(f)
                                                })).onComplete((function() {
                                                    u.remove(f), K(f)
                                                })).start()
                                            }
                                        }
                                    }))
                                }
                            }))
                        },
                        update: function(t) {
                            var e = (0, u.default)(t.ringLat),
                                n = (0, u.default)(t.ringLng),
                                r = (0, u.default)(t.ringAltitude),
                                i = t.scene.localToWorld(new re.Vector3(0, 0, 0));
                            pt(t.ringsData, t.scene, {
                                createObj: function() {
                                    var t = new re.Group;
                                    return t.__globeObjType = "ring", t
                                },
                                updateObj: function(t, a) {
                                    var o = e(a),
                                        s = n(a),
                                        l = r(a);
                                    Object.assign(t.position, rt(o, s, l)), t.lookAt(i)
                                }
                            }, {
                                removeDelay: 3e4
                            })
                        }
                    }),
                    oe = D(D({}, window.THREE ? window.THREE : {}), {}, {
                        CSS2DObject: C.CSS2DObject
                    }),
                    se = (0, i.default)({
                        props: {
                            htmlElementsData: {
                                default: []
                            },
                            htmlLat: {
                                default: "lat"
                            },
                            htmlLng: {
                                default: "lng"
                            },
                            htmlAltitude: {
                                default: 0
                            },
                            htmlElement: {},
                            htmlTransitionDuration: {
                                default: 1e3,
                                triggerUpdate: !1
                            },
                            isBehindGlobe: {
                                onChange: function() {
                                    this.updateObjVisibility()
                                },
                                triggerUpdate: !1
                            }
                        },
                        methods: {
                            updateObjVisibility: function(t, e) {
                                (e ? [e] : t.htmlElementsData.map((function(t) {
                                    return t.__threeObj
                                })).filter((function(t) {
                                    return t
                                }))).forEach((function(e) {
                                    return e.visible = !t.isBehindGlobe || !t.isBehindGlobe(e.position)
                                }))
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t, e) {
                            var n = this,
                                r = (0, u.default)(t.htmlLat),
                                i = (0, u.default)(t.htmlLng),
                                o = (0, u.default)(t.htmlAltitude),
                                s = (0, u.default)(t.htmlElement);
                            pt(t.htmlElementsData, t.scene, {
                                purge: e.hasOwnProperty("htmlElement"),
                                createObj: function(t) {
                                    var e = s(t),
                                        n = new oe.CSS2DObject(e);
                                    return n.__globeObjType = "html", n
                                },
                                updateObj: function(e, s) {
                                    var l = function(t) {
                                            var r = e.__currentTargetD = t,
                                                i = r.alt,
                                                a = r.lat,
                                                o = r.lng;
                                            Object.assign(e.position, rt(a, o, i)), n.updateObjVisibility(e)
                                        },
                                        A = {
                                            lat: +r(s),
                                            lng: +i(s),
                                            alt: +o(s)
                                        };
                                    !t.htmlTransitionDuration || t.htmlTransitionDuration < 0 || !e.__currentTargetD ? l(A) : new a.Tween(e.__currentTargetD).to(A, t.htmlTransitionDuration).easing(a.Easing.Quadratic.InOut).onUpdate(l).start()
                                }
                            })
                        }
                    }),
                    le = window.THREE ? window.THREE : {
                        Euler: r.Euler,
                        Group: r.Group,
                        Mesh: r.Mesh,
                        MeshLambertMaterial: r.MeshLambertMaterial,
                        SphereGeometry: r.SphereGeometry
                    },
                    Ae = (0, i.default)({
                        props: {
                            objectsData: {
                                default: []
                            },
                            objectLat: {
                                default: "lat"
                            },
                            objectLng: {
                                default: "lng"
                            },
                            objectAltitude: {
                                default: .01
                            },
                            objectFacesSurface: {
                                default: !0
                            },
                            objectRotation: {},
                            objectThreeObject: {
                                default: new le.Mesh(new le.SphereGeometry(1, 16, 8), new le.MeshLambertMaterial({
                                    color: "#ffffaa",
                                    transparent: !0,
                                    opacity: .7
                                }))
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t, e) {
                            var n = (0, u.default)(t.objectLat),
                                i = (0, u.default)(t.objectLng),
                                a = (0, u.default)(t.objectAltitude),
                                o = (0, u.default)(t.objectFacesSurface),
                                s = (0, u.default)(t.objectRotation),
                                l = (0, u.default)(t.objectThreeObject);
                            pt(t.objectsData, t.scene, {
                                purge: e.hasOwnProperty("objectThreeObject"),
                                createObj: function(e) {
                                    var n = l(e);
                                    t.objectThreeObject === n && (n = n.clone());
                                    var r = new le.Group;
                                    return r.add(n), r.__globeObjType = "object", r
                                },
                                updateObj: function(t, e) {
                                    var l = +n(e),
                                        A = +i(e),
                                        c = +a(e);
                                    Object.assign(t.position, rt(l, A, c)), o(e) ? t.setRotationFromEuler(new r.Euler(at(-l), at(A), 0, "YXZ")) : t.rotation.set(0, 0, 0);
                                    var u = t.children[0],
                                        h = s(e);
                                    h && u.setRotationFromEuler(new r.Euler(at(h.x || 0), at(h.y || 0), at(h.z || 0)))
                                }
                            })
                        }
                    }),
                    ce = (0, i.default)({
                        props: {
                            customLayerData: {
                                default: []
                            },
                            customThreeObject: {},
                            customThreeObjectUpdate: {
                                triggerUpdate: !1
                            }
                        },
                        init: function(t, e) {
                            $(t), e.scene = t
                        },
                        update: function(t, e) {
                            t.customThreeObjectUpdate || $(t.scene);
                            var n = (0, u.default)(t.customThreeObject),
                                r = (0, u.default)(t.customThreeObjectUpdate);
                            pt(t.customLayerData, t.scene, {
                                purge: e.hasOwnProperty("customThreeObject"),
                                createObj: function(e) {
                                    var r = n(e, et);
                                    return r && (t.customThreeObject === r && (r = r.clone()), r.__globeObjType = "custom"), r
                                },
                                updateObj: function(t, e) {
                                    return r(t, e, et)
                                }
                            })
                        }
                    }),
                    ue = window.THREE ? window.THREE : {
                        Group: r.Group,
                        Vector2: r.Vector2,
                        Vector3: r.Vector3
                    },
                    he = ["globeLayer", "pointsLayer", "arcsLayer", "hexBinLayer", "heatmapsLayer", "polygonsLayer", "hexedPolygonsLayer", "pathsLayer", "tilesLayer", "labelsLayer", "ringsLayer", "htmlElementsLayer", "objectsLayer", "customLayer"],
                    de = tt("globeLayer", At),
                    fe = Object.assign.apply(Object, j(["globeImageUrl", "bumpImageUrl", "showGlobe", "showGraticules", "showAtmosphere", "atmosphereColor", "atmosphereAltitude"].map((function(t) {
                        return U({}, t, de.linkProp(t))
                    })))),
                    pe = Object.assign.apply(Object, j(["globeMaterial"].map((function(t) {
                        return U({}, t, de.linkMethod(t))
                    })))),
                    me = tt("pointsLayer", _t),
                    ge = Object.assign.apply(Object, j(["pointsData", "pointLat", "pointLng", "pointColor", "pointAltitude", "pointRadius", "pointResolution", "pointsMerge", "pointsTransitionDuration"].map((function(t) {
                        return U({}, t, me.linkProp(t))
                    })))),
                    ve = tt("arcsLayer", wt),
                    _e = Object.assign.apply(Object, j(["arcsData", "arcStartLat", "arcStartLng", "arcEndLat", "arcEndLng", "arcColor", "arcAltitude", "arcAltitudeAutoScale", "arcStroke", "arcCurveResolution", "arcCircularResolution", "arcDashLength", "arcDashGap", "arcDashInitialGap", "arcDashAnimateTime", "arcsTransitionDuration"].map((function(t) {
                        return U({}, t, ve.linkProp(t))
                    })))),
                    ye = tt("hexBinLayer", Ct),
                    xe = Object.assign.apply(Object, j(["hexBinPointsData", "hexBinPointLat", "hexBinPointLng", "hexBinPointWeight", "hexBinResolution", "hexMargin", "hexTopCurvatureResolution", "hexTopColor", "hexSideColor", "hexAltitude", "hexBinMerge", "hexTransitionDuration"].map((function(t) {
                        return U({}, t, ye.linkProp(t))
                    })))),
                    be = tt("heatmapsLayer", kt),
                    Me = Object.assign.apply(Object, j(["heatmapsData", "heatmapPoints", "heatmapPointLat", "heatmapPointLng", "heatmapPointWeight", "heatmapBandwidth", "heatmapColorFn", "heatmapColorSaturation", "heatmapBaseAltitude", "heatmapTopAltitude", "heatmapsTransitionDuration"].map((function(t) {
                        return U({}, t, be.linkProp(t))
                    })))),
                    we = tt("hexedPolygonsLayer", Ht),
                    Se = Object.assign.apply(Object, j(["hexPolygonsData", "hexPolygonGeoJsonGeometry", "hexPolygonColor", "hexPolygonAltitude", "hexPolygonResolution", "hexPolygonMargin", "hexPolygonUseDots", "hexPolygonCurvatureResolution", "hexPolygonDotResolution", "hexPolygonsTransitionDuration"].map((function(t) {
                        return U({}, t, we.linkProp(t))
                    })))),
                    Ee = tt("polygonsLayer", zt),
                    Te = Object.assign.apply(Object, j(["polygonsData", "polygonGeoJsonGeometry", "polygonCapColor", "polygonCapMaterial", "polygonSideColor", "polygonSideMaterial", "polygonStrokeColor", "polygonAltitude", "polygonCapCurvatureResolution", "polygonsTransitionDuration"].map((function(t) {
                        return U({}, t, Ee.linkProp(t))
                    })))),
                    Ce = tt("pathsLayer", Zt),
                    Re = Object.assign.apply(Object, j(["pathsData", "pathPoints", "pathPointLat", "pathPointLng", "pathPointAlt", "pathResolution", "pathColor", "pathStroke", "pathDashLength", "pathDashGap", "pathDashInitialGap", "pathDashAnimateTime", "pathTransitionDuration"].map((function(t) {
                        return U({}, t, Ce.linkProp(t))
                    })))),
                    Pe = tt("tilesLayer", Kt),
                    Le = Object.assign.apply(Object, j(["tilesData", "tileLat", "tileLng", "tileAltitude", "tileWidth", "tileHeight", "tileUseGlobeProjection", "tileMaterial", "tileCurvatureResolution", "tilesTransitionDuration"].map((function(t) {
                        return U({}, t, Pe.linkProp(t))
                    })))),
                    De = tt("labelsLayer", ee),
                    Ie = Object.assign.apply(Object, j(["labelsData", "labelLat", "labelLng", "labelAltitude", "labelRotation", "labelText", "labelSize", "labelTypeFace", "labelColor", "labelResolution", "labelIncludeDot", "labelDotRadius", "labelDotOrientation", "labelsTransitionDuration"].map((function(t) {
                        return U({}, t, De.linkProp(t))
                    })))),
                    Oe = tt("ringsLayer", ae),
                    Be = Object.assign.apply(Object, j(["ringsData", "ringLat", "ringLng", "ringAltitude", "ringColor", "ringResolution", "ringMaxRadius", "ringPropagationSpeed", "ringRepeatPeriod"].map((function(t) {
                        return U({}, t, Oe.linkProp(t))
                    })))),
                    qe = tt("htmlElementsLayer", se),
                    Ue = Object.assign.apply(Object, j(["htmlElementsData", "htmlLat", "htmlLng", "htmlAltitude", "htmlElement", "htmlTransitionDuration"].map((function(t) {
                        return U({}, t, qe.linkProp(t))
                    })))),
                    Ne = tt("objectsLayer", Ae),
                    ke = Object.assign.apply(Object, j(["objectsData", "objectLat", "objectLng", "objectAltitude", "objectRotation", "objectFacesSurface", "objectThreeObject"].map((function(t) {
                        return U({}, t, Ne.linkProp(t))
                    })))),
                    Fe = tt("customLayer", ce),
                    ze = Object.assign.apply(Object, j(["customLayerData", "customThreeObject", "customThreeObjectUpdate"].map((function(t) {
                        return U({}, t, Fe.linkProp(t))
                    })))),
                    Ge = function(t) {
                        var e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                            n = function(n) {
                                function r() {
                                    var n;
                                    O(this, r);
                                    for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++) a[o] = arguments[o];
                                    return (n = R(this, r, [].concat(a))).__kapsuleInstance = t.apply(void 0, a).apply(void 0, [].concat(j(e ? [z(n)] : []), a)), n
                                }
                                return N(r, n), q(r)
                            }(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Object);
                        return Object.keys(t()).forEach((function(t) {
                            return n.prototype[t] = function() {
                                var e, n = (e = this.__kapsuleInstance)[t].apply(e, arguments);
                                return n === this.__kapsuleInstance ? this : n
                            }
                        })), n
                    }((0, i.default)({
                        props: D(D(D(D(D(D(D(D(D(D(D(D(D(D({
                            onGlobeReady: {
                                triggerUpdate: !1
                            },
                            rendererSize: {
                                default: new ue.Vector2(window.innerWidth, window.innerHeight),
                                onChange: function(t, e) {
                                    e.pathsLayer.rendererSize(t)
                                },
                                triggerUpdate: !1
                            }
                        }, fe), ge), _e), xe), Me), Te), Se), Re), Le), Ie), Be), Ue), ke), ze),
                        methods: D({
                            getGlobeRadius: nt,
                            getCoords: function(t) {
                                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                                return rt.apply(void 0, n)
                            },
                            toGeoCoords: function(t) {
                                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                                return it.apply(void 0, n)
                            },
                            setPointOfView: function(t, e, n) {
                                var r = void 0;
                                if (e) {
                                    var i, a, o, s = nt(),
                                        l = n ? e.clone().sub(n) : e;
                                    r = function(t) {
                                        void 0 === i && (i = l.length()), void 0 === a && (a = Math.sqrt(Math.pow(i, 2) - Math.pow(s, 2))), void 0 === o && (o = Math.acos(a / i));
                                        var e = l.distanceTo(t);
                                        if (e < a) return !1;
                                        var n = t.length();
                                        return Math.acos((Math.pow(i, 2) + Math.pow(e, 2) - Math.pow(n, 2)) / (2 * i * e)) < o
                                    }
                                }
                                t.layersThatNeedBehindGlobeChecker.forEach((function(t) {
                                    return t.isBehindGlobe(r)
                                }))
                            },
                            pauseAnimation: function(t) {
                                return null !== t.animationFrameRequestId && (cancelAnimationFrame(t.animationFrameRequestId), t.animationFrameRequestId = null), t.pausableLayers.forEach((function(t) {
                                    var e;
                                    return null === (e = t.pauseAnimation) || void 0 === e ? void 0 : e.call(t)
                                })), this
                            },
                            resumeAnimation: function(t) {
                                return null === t.animationFrameRequestId && this._animationCycle(), t.pausableLayers.forEach((function(t) {
                                    var e;
                                    return null === (e = t.resumeAnimation) || void 0 === e ? void 0 : e.call(t)
                                })), this
                            },
                            _animationCycle: function(t) {
                                t.animationFrameRequestId = requestAnimationFrame(this._animationCycle), a.update()
                            },
                            _destructor: function(t) {
                                this.pauseAnimation(), t.destructableLayers.forEach((function(t) {
                                    return t._destructor()
                                }))
                            }
                        }, pe),
                        stateInit: function() {
                            var t = {
                                globeLayer: At(),
                                pointsLayer: _t(),
                                arcsLayer: wt(),
                                hexBinLayer: Ct(),
                                heatmapsLayer: kt(),
                                polygonsLayer: zt(),
                                hexedPolygonsLayer: Ht(),
                                pathsLayer: Zt(),
                                tilesLayer: Kt(),
                                labelsLayer: ee(),
                                ringsLayer: ae(),
                                htmlElementsLayer: se(),
                                objectsLayer: Ae(),
                                customLayer: ce()
                            };
                            return D(D({}, t), {}, {
                                layersThatNeedBehindGlobeChecker: Object.values(t).filter((function(t) {
                                    return t.hasOwnProperty("isBehindGlobe")
                                })),
                                destructableLayers: Object.values(t).filter((function(t) {
                                    return t.hasOwnProperty("_destructor")
                                })),
                                pausableLayers: Object.values(t).filter((function(t) {
                                    return t.hasOwnProperty("pauseAnimation")
                                }))
                            })
                        },
                        init: function(t, e, n) {
                            var r = n.animateIn,
                                i = void 0 === r || r,
                                o = n.waitForGlobeReady,
                                s = void 0 === o || o;
                            $(t), e.scene = t, e.scene.visible = !1, he.forEach((function(t) {
                                var n = new ue.Group;
                                e.scene.add(n), e[t](n)
                            }));
                            var l = function() {
                                if (i) {
                                    e.scene.scale.set(1e-6, 1e-6, 1e-6), new a.Tween({
                                        k: 1e-6
                                    }).to({
                                        k: 1
                                    }, 600).easing(a.Easing.Quadratic.Out).onUpdate((function(t) {
                                        var n = t.k;
                                        return e.scene.scale.set(n, n, n)
                                    })).start();
                                    var t = new ue.Vector3(0, 1, 0);
                                    new a.Tween({
                                        rot: 2 * Math.PI
                                    }).to({
                                        rot: 0
                                    }, 1200).easing(a.Easing.Quintic.Out).onUpdate((function(n) {
                                        var r = n.rot;
                                        return e.scene.setRotationFromAxisAngle(t, r)
                                    })).start()
                                }
                                e.scene.visible = !0, e.onGlobeReady && e.onGlobeReady()
                            };
                            s ? e.globeLayer.onReady(l) : l(), this._animationCycle()
                        },
                        update: function(t) {}
                    }), (window.THREE ? window.THREE : {
                        Group: r.Group
                    }).Group, !0)
            },
            "./node_modules/three/build/three.module.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    ACESFilmicToneMapping: () => it,
                    AddEquation: () => M,
                    AddOperation: () => $,
                    AdditiveAnimationBlendMode: () => ke,
                    AdditiveBlending: () => _,
                    AgXToneMapping: () => ot,
                    AlphaFormat: () => Ft,
                    AlwaysCompare: () => En,
                    AlwaysDepth: () => V,
                    AlwaysStencilFunc: () => vn,
                    AmbientLight: () => hd,
                    AnimationAction: () => ef,
                    AnimationClip: () => qh,
                    AnimationLoader: () => Hh,
                    AnimationMixer: () => rf,
                    AnimationObjectGroup: () => tf,
                    AnimationUtils: () => Mh,
                    ArcCurve: () => Gc,
                    ArrayCamera: () => Wl,
                    ArrowHelper: () => Zf,
                    AttachedBindMode: () => lt,
                    Audio: () => kd,
                    AudioAnalyser: () => Hd,
                    AudioContext: () => Ed,
                    AudioListener: () => Nd,
                    AudioLoader: () => Td,
                    AxesHelper: () => Jf,
                    BackSide: () => p,
                    BasicDepthPacking: () => je,
                    BasicShadowMap: () => c,
                    BatchedMesh: () => pc,
                    Bone: () => kA,
                    BooleanKeyframeTrack: () => Rh,
                    Box2: () => gf,
                    Box3: () => qr,
                    Box3Helper: () => Hf,
                    BoxGeometry: () => Xa,
                    BoxHelper: () => Vf,
                    BufferAttribute: () => ca,
                    BufferGeometry: () => Ta,
                    BufferGeometryLoader: () => _d,
                    ByteType: () => Pt,
                    Cache: () => Nh,
                    Camera: () => $a,
                    CameraHelper: () => zf,
                    CanvasTexture: () => kc,
                    CapsuleGeometry: () => Au,
                    CatmullRomCurve3: () => Yc,
                    CineonToneMapping: () => rt,
                    CircleGeometry: () => cu,
                    ClampToEdgeWrapping: () => gt,
                    Clock: () => Dd,
                    Color: () => Ki,
                    ColorKeyframeTrack: () => Ph,
                    ColorManagement: () => pr,
                    CompressedArrayTexture: () => Uc,
                    CompressedCubeTexture: () => Nc,
                    CompressedTexture: () => qc,
                    CompressedTextureLoader: () => Wh,
                    ConeGeometry: () => hu,
                    ConstantAlphaFactor: () => z,
                    ConstantColorFactor: () => k,
                    CubeCamera: () => ao,
                    CubeReflectionMapping: () => ut,
                    CubeRefractionMapping: () => ht,
                    CubeTexture: () => oo,
                    CubeTextureLoader: () => Yh,
                    CubeUVReflectionMapping: () => pt,
                    CubicBezierCurve: () => Kc,
                    CubicBezierCurve3: () => $c,
                    CubicInterpolant: () => Sh,
                    CullFaceBack: () => s,
                    CullFaceFront: () => l,
                    CullFaceFrontBack: () => A,
                    CullFaceNone: () => o,
                    Curve: () => Fc,
                    CurvePath: () => ou,
                    CustomBlending: () => b,
                    CustomToneMapping: () => at,
                    CylinderGeometry: () => uu,
                    Cylindrical: () => pf,
                    Data3DTexture: () => Pr,
                    DataArrayTexture: () => Cr,
                    DataTexture: () => FA,
                    DataTextureLoader: () => Qh,
                    DataUtils: () => sa,
                    DecrementStencilOp: () => sn,
                    DecrementWrapStencilOp: () => An,
                    DefaultLoadingManager: () => Fh,
                    DepthFormat: () => Vt,
                    DepthStencilFormat: () => Ht,
                    DepthTexture: () => es,
                    DetachedBindMode: () => At,
                    DirectionalLight: () => ud,
                    DirectionalLightHelper: () => Nf,
                    DiscreteInterpolant: () => Th,
                    DisplayP3ColorSpace: () => Ze,
                    DodecahedronGeometry: () => fu,
                    DoubleSide: () => m,
                    DstAlphaFactor: () => O,
                    DstColorFactor: () => q,
                    DynamicCopyUsage: () => On,
                    DynamicDrawUsage: () => Cn,
                    DynamicReadUsage: () => Ln,
                    EdgesGeometry: () => _u,
                    EllipseCurve: () => zc,
                    EqualCompare: () => xn,
                    EqualDepth: () => X,
                    EqualStencilFunc: () => dn,
                    EquirectangularReflectionMapping: () => dt,
                    EquirectangularRefractionMapping: () => ft,
                    Euler: () => _i,
                    EventDispatcher: () => zn,
                    ExtrudeGeometry: () => Yu,
                    FileLoader: () => Vh,
                    Float16BufferAttribute: () => va,
                    Float32BufferAttribute: () => _a,
                    FloatType: () => Bt,
                    Fog: () => aA,
                    FogExp2: () => iA,
                    FramebufferTexture: () => Bc,
                    FrontSide: () => f,
                    Frustum: () => po,
                    GLBufferAttribute: () => Af,
                    GLSL1: () => qn,
                    GLSL3: () => Un,
                    GreaterCompare: () => Mn,
                    GreaterDepth: () => Q,
                    GreaterEqualCompare: () => Sn,
                    GreaterEqualDepth: () => Y,
                    GreaterEqualStencilFunc: () => gn,
                    GreaterStencilFunc: () => pn,
                    GridHelper: () => If,
                    Group: () => Xl,
                    HalfFloatType: () => qt,
                    HemisphereLight: () => Kh,
                    HemisphereLightHelper: () => Df,
                    IcosahedronGeometry: () => Zu,
                    ImageBitmapLoader: () => wd,
                    ImageLoader: () => Xh,
                    ImageUtils: () => _r,
                    IncrementStencilOp: () => on,
                    IncrementWrapStencilOp: () => ln,
                    InstancedBufferAttribute: () => VA,
                    InstancedBufferGeometry: () => vd,
                    InstancedInterleavedBuffer: () => lf,
                    InstancedMesh: () => KA,
                    Int16BufferAttribute: () => fa,
                    Int32BufferAttribute: () => ma,
                    Int8BufferAttribute: () => ua,
                    IntType: () => It,
                    InterleavedBuffer: () => sA,
                    InterleavedBufferAttribute: () => AA,
                    Interpolant: () => wh,
                    InterpolateDiscrete: () => De,
                    InterpolateLinear: () => Ie,
                    InterpolateSmooth: () => Oe,
                    InvertStencilOp: () => cn,
                    KeepStencilOp: () => rn,
                    KeyframeTrack: () => Ch,
                    LOD: () => CA,
                    LatheGeometry: () => lu,
                    Layers: () => yi,
                    LessCompare: () => yn,
                    LessDepth: () => H,
                    LessEqualCompare: () => bn,
                    LessEqualDepth: () => W,
                    LessEqualStencilFunc: () => fn,
                    LessStencilFunc: () => hn,
                    Light: () => Jh,
                    LightProbe: () => pd,
                    Line: () => bc,
                    Line3: () => yf,
                    LineBasicMaterial: () => mc,
                    LineCurve: () => tu,
                    LineCurve3: () => eu,
                    LineDashedMaterial: () => gh,
                    LineLoop: () => Ec,
                    LineSegments: () => Sc,
                    LinearDisplayP3ColorSpace: () => Je,
                    LinearFilter: () => wt,
                    LinearInterpolant: () => Eh,
                    LinearMipMapLinearFilter: () => Ct,
                    LinearMipMapNearestFilter: () => Et,
                    LinearMipmapLinearFilter: () => Tt,
                    LinearMipmapNearestFilter: () => St,
                    LinearSRGBColorSpace: () => Qe,
                    LinearToneMapping: () => et,
                    LinearTransfer: () => Ke,
                    Loader: () => zh,
                    LoaderUtils: () => gd,
                    LoadingManager: () => kh,
                    LoopOnce: () => Re,
                    LoopPingPong: () => Le,
                    LoopRepeat: () => Pe,
                    LuminanceAlphaFormat: () => jt,
                    LuminanceFormat: () => Gt,
                    MOUSE: () => i,
                    Material: () => ea,
                    MaterialLoader: () => md,
                    MathUtils: () => tr,
                    Matrix3: () => nr,
                    Matrix4: () => Ai,
                    MaxEquation: () => T,
                    Mesh: () => Ha,
                    MeshBasicMaterial: () => na,
                    MeshDepthMaterial: () => Fl,
                    MeshDistanceMaterial: () => zl,
                    MeshLambertMaterial: () => ph,
                    MeshMatcapMaterial: () => mh,
                    MeshNormalMaterial: () => fh,
                    MeshPhongMaterial: () => hh,
                    MeshPhysicalMaterial: () => uh,
                    MeshStandardMaterial: () => ch,
                    MeshToonMaterial: () => dh,
                    MinEquation: () => E,
                    MirroredRepeatWrapping: () => vt,
                    MixOperation: () => K,
                    MultiplyBlending: () => x,
                    MultiplyOperation: () => J,
                    NearestFilter: () => _t,
                    NearestMipMapLinearFilter: () => Mt,
                    NearestMipMapNearestFilter: () => xt,
                    NearestMipmapLinearFilter: () => bt,
                    NearestMipmapNearestFilter: () => yt,
                    NeutralToneMapping: () => st,
                    NeverCompare: () => _n,
                    NeverDepth: () => j,
                    NeverStencilFunc: () => un,
                    NoBlending: () => g,
                    NoColorSpace: () => Xe,
                    NoToneMapping: () => tt,
                    NormalAnimationBlendMode: () => Ne,
                    NormalBlending: () => v,
                    NotEqualCompare: () => wn,
                    NotEqualDepth: () => Z,
                    NotEqualStencilFunc: () => mn,
                    NumberKeyframeTrack: () => Lh,
                    Object3D: () => qi,
                    ObjectLoader: () => yd,
                    ObjectSpaceNormalMap: () => We,
                    OctahedronGeometry: () => Ju,
                    OneFactor: () => R,
                    OneMinusConstantAlphaFactor: () => G,
                    OneMinusConstantColorFactor: () => F,
                    OneMinusDstAlphaFactor: () => B,
                    OneMinusDstColorFactor: () => U,
                    OneMinusSrcAlphaFactor: () => I,
                    OneMinusSrcColorFactor: () => L,
                    OrthographicCamera: () => Lo,
                    P3Primaries: () => en,
                    PCFShadowMap: () => u,
                    PCFSoftShadowMap: () => h,
                    PMREMGenerator: () => zo,
                    Path: () => su,
                    PerspectiveCamera: () => ro,
                    Plane: () => uo,
                    PlaneGeometry: () => vo,
                    PlaneHelper: () => Wf,
                    PointLight: () => Ad,
                    PointLightHelper: () => Cf,
                    Points: () => Dc,
                    PointsMaterial: () => Tc,
                    PolarGridHelper: () => Of,
                    PolyhedronGeometry: () => du,
                    PositionalAudio: () => Vd,
                    PropertyBinding: () => $d,
                    PropertyMixer: () => Wd,
                    QuadraticBezierCurve: () => nu,
                    QuadraticBezierCurve3: () => ru,
                    Quaternion: () => Dr,
                    QuaternionKeyframeTrack: () => Ih,
                    QuaternionLinearInterpolant: () => Dh,
                    RED_GREEN_RGTC2_Format: () => Te,
                    RED_RGTC1_Format: () => Se,
                    REVISION: () => r,
                    RGBADepthPacking: () => Ve,
                    RGBAFormat: () => zt,
                    RGBAIntegerFormat: () => Zt,
                    RGBA_ASTC_10x10_Format: () => _e,
                    RGBA_ASTC_10x5_Format: () => me,
                    RGBA_ASTC_10x6_Format: () => ge,
                    RGBA_ASTC_10x8_Format: () => ve,
                    RGBA_ASTC_12x10_Format: () => ye,
                    RGBA_ASTC_12x12_Format: () => xe,
                    RGBA_ASTC_4x4_Format: () => le,
                    RGBA_ASTC_5x4_Format: () => Ae,
                    RGBA_ASTC_5x5_Format: () => ce,
                    RGBA_ASTC_6x5_Format: () => ue,
                    RGBA_ASTC_6x6_Format: () => he,
                    RGBA_ASTC_8x5_Format: () => de,
                    RGBA_ASTC_8x6_Format: () => fe,
                    RGBA_ASTC_8x8_Format: () => pe,
                    RGBA_BPTC_Format: () => be,
                    RGBA_ETC2_EAC_Format: () => se,
                    RGBA_PVRTC_2BPPV1_Format: () => ie,
                    RGBA_PVRTC_4BPPV1_Format: () => re,
                    RGBA_S3TC_DXT1_Format: () => Kt,
                    RGBA_S3TC_DXT3_Format: () => $t,
                    RGBA_S3TC_DXT5_Format: () => te,
                    RGB_BPTC_SIGNED_Format: () => Me,
                    RGB_BPTC_UNSIGNED_Format: () => we,
                    RGB_ETC1_Format: () => ae,
                    RGB_ETC2_Format: () => oe,
                    RGB_PVRTC_2BPPV1_Format: () => ne,
                    RGB_PVRTC_4BPPV1_Format: () => ee,
                    RGB_S3TC_DXT1_Format: () => Jt,
                    RGFormat: () => Yt,
                    RGIntegerFormat: () => Qt,
                    RawShaderMaterial: () => Ah,
                    Ray: () => li,
                    Raycaster: () => uf,
                    Rec709Primaries: () => tn,
                    RectAreaLight: () => dd,
                    RedFormat: () => Wt,
                    RedIntegerFormat: () => Xt,
                    ReinhardToneMapping: () => nt,
                    RenderTarget: () => Er,
                    RepeatWrapping: () => mt,
                    ReplaceStencilOp: () => an,
                    ReverseSubtractEquation: () => S,
                    RingGeometry: () => Ku,
                    SIGNED_RED_GREEN_RGTC2_Format: () => Ce,
                    SIGNED_RED_RGTC1_Format: () => Ee,
                    SRGBColorSpace: () => Ye,
                    SRGBTransfer: () => $e,
                    Scene: () => oA,
                    ShaderChunk: () => _o,
                    ShaderLib: () => xo,
                    ShaderMaterial: () => Ka,
                    ShadowMaterial: () => lh,
                    Shape: () => yu,
                    ShapeGeometry: () => $u,
                    ShapePath: () => Kf,
                    ShapeUtils: () => Hu,
                    ShortType: () => Lt,
                    Skeleton: () => jA,
                    SkeletonHelper: () => Ef,
                    SkinnedMesh: () => NA,
                    Source: () => xr,
                    Sphere: () => ti,
                    SphereGeometry: () => th,
                    Spherical: () => ff,
                    SphericalHarmonics3: () => fd,
                    SplineCurve: () => iu,
                    SpotLight: () => id,
                    SpotLightHelper: () => bf,
                    Sprite: () => wA,
                    SpriteMaterial: () => cA,
                    SrcAlphaFactor: () => D,
                    SrcAlphaSaturateFactor: () => N,
                    SrcColorFactor: () => P,
                    StaticCopyUsage: () => In,
                    StaticDrawUsage: () => Tn,
                    StaticReadUsage: () => Pn,
                    StereoCamera: () => Ld,
                    StreamCopyUsage: () => Bn,
                    StreamDrawUsage: () => Rn,
                    StreamReadUsage: () => Dn,
                    StringKeyframeTrack: () => Oh,
                    SubtractEquation: () => w,
                    SubtractiveBlending: () => y,
                    TOUCH: () => a,
                    TangentSpaceNormalMap: () => He,
                    TetrahedronGeometry: () => eh,
                    Texture: () => wr,
                    TextureLoader: () => Zh,
                    TorusGeometry: () => nh,
                    TorusKnotGeometry: () => rh,
                    Triangle: () => Xi,
                    TriangleFanDrawMode: () => Ge,
                    TriangleStripDrawMode: () => ze,
                    TrianglesDrawMode: () => Fe,
                    TubeGeometry: () => ih,
                    UVMapping: () => ct,
                    Uint16BufferAttribute: () => pa,
                    Uint32BufferAttribute: () => ga,
                    Uint8BufferAttribute: () => ha,
                    Uint8ClampedBufferAttribute: () => da,
                    Uniform: () => af,
                    UniformsGroup: () => sf,
                    UniformsLib: () => yo,
                    UniformsUtils: () => Ja,
                    UnsignedByteType: () => Rt,
                    UnsignedInt248Type: () => kt,
                    UnsignedIntType: () => Ot,
                    UnsignedShort4444Type: () => Ut,
                    UnsignedShort5551Type: () => Nt,
                    UnsignedShortType: () => Dt,
                    VSMShadowMap: () => d,
                    Vector2: () => er,
                    Vector3: () => Ir,
                    Vector4: () => Sr,
                    VectorKeyframeTrack: () => Bh,
                    VideoTexture: () => Oc,
                    WebGL1Renderer: () => rA,
                    WebGL3DRenderTarget: () => Lr,
                    WebGLArrayRenderTarget: () => Rr,
                    WebGLCoordinateSystem: () => kn,
                    WebGLCubeRenderTarget: () => so,
                    WebGLMultipleRenderTargets: () => $f,
                    WebGLRenderTarget: () => Tr,
                    WebGLRenderer: () => nA,
                    WebGLUtils: () => Hl,
                    WebGPUCoordinateSystem: () => Fn,
                    WireframeGeometry: () => ah,
                    WrapAroundEnding: () => Ue,
                    ZeroCurvatureEnding: () => Be,
                    ZeroFactor: () => C,
                    ZeroSlopeEnding: () => qe,
                    ZeroStencilOp: () => nn,
                    _SRGBAFormat: () => Nn,
                    createCanvasElement: () => lr
                });
                const r = "162",
                    i = {
                        LEFT: 0,
                        MIDDLE: 1,
                        RIGHT: 2,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2
                    },
                    a = {
                        ROTATE: 0,
                        PAN: 1,
                        DOLLY_PAN: 2,
                        DOLLY_ROTATE: 3
                    },
                    o = 0,
                    s = 1,
                    l = 2,
                    A = 3,
                    c = 0,
                    u = 1,
                    h = 2,
                    d = 3,
                    f = 0,
                    p = 1,
                    m = 2,
                    g = 0,
                    v = 1,
                    _ = 2,
                    y = 3,
                    x = 4,
                    b = 5,
                    M = 100,
                    w = 101,
                    S = 102,
                    E = 103,
                    T = 104,
                    C = 200,
                    R = 201,
                    P = 202,
                    L = 203,
                    D = 204,
                    I = 205,
                    O = 206,
                    B = 207,
                    q = 208,
                    U = 209,
                    N = 210,
                    k = 211,
                    F = 212,
                    z = 213,
                    G = 214,
                    j = 0,
                    V = 1,
                    H = 2,
                    W = 3,
                    X = 4,
                    Y = 5,
                    Q = 6,
                    Z = 7,
                    J = 0,
                    K = 1,
                    $ = 2,
                    tt = 0,
                    et = 1,
                    nt = 2,
                    rt = 3,
                    it = 4,
                    at = 5,
                    ot = 6,
                    st = 7,
                    lt = "attached",
                    At = "detached",
                    ct = 300,
                    ut = 301,
                    ht = 302,
                    dt = 303,
                    ft = 304,
                    pt = 306,
                    mt = 1e3,
                    gt = 1001,
                    vt = 1002,
                    _t = 1003,
                    yt = 1004,
                    xt = 1004,
                    bt = 1005,
                    Mt = 1005,
                    wt = 1006,
                    St = 1007,
                    Et = 1007,
                    Tt = 1008,
                    Ct = 1008,
                    Rt = 1009,
                    Pt = 1010,
                    Lt = 1011,
                    Dt = 1012,
                    It = 1013,
                    Ot = 1014,
                    Bt = 1015,
                    qt = 1016,
                    Ut = 1017,
                    Nt = 1018,
                    kt = 1020,
                    Ft = 1021,
                    zt = 1023,
                    Gt = 1024,
                    jt = 1025,
                    Vt = 1026,
                    Ht = 1027,
                    Wt = 1028,
                    Xt = 1029,
                    Yt = 1030,
                    Qt = 1031,
                    Zt = 1033,
                    Jt = 33776,
                    Kt = 33777,
                    $t = 33778,
                    te = 33779,
                    ee = 35840,
                    ne = 35841,
                    re = 35842,
                    ie = 35843,
                    ae = 36196,
                    oe = 37492,
                    se = 37496,
                    le = 37808,
                    Ae = 37809,
                    ce = 37810,
                    ue = 37811,
                    he = 37812,
                    de = 37813,
                    fe = 37814,
                    pe = 37815,
                    me = 37816,
                    ge = 37817,
                    ve = 37818,
                    _e = 37819,
                    ye = 37820,
                    xe = 37821,
                    be = 36492,
                    Me = 36494,
                    we = 36495,
                    Se = 36283,
                    Ee = 36284,
                    Te = 36285,
                    Ce = 36286,
                    Re = 2200,
                    Pe = 2201,
                    Le = 2202,
                    De = 2300,
                    Ie = 2301,
                    Oe = 2302,
                    Be = 2400,
                    qe = 2401,
                    Ue = 2402,
                    Ne = 2500,
                    ke = 2501,
                    Fe = 0,
                    ze = 1,
                    Ge = 2,
                    je = 3200,
                    Ve = 3201,
                    He = 0,
                    We = 1,
                    Xe = "",
                    Ye = "srgb",
                    Qe = "srgb-linear",
                    Ze = "display-p3",
                    Je = "display-p3-linear",
                    Ke = "linear",
                    $e = "srgb",
                    tn = "rec709",
                    en = "p3",
                    nn = 0,
                    rn = 7680,
                    an = 7681,
                    on = 7682,
                    sn = 7683,
                    ln = 34055,
                    An = 34056,
                    cn = 5386,
                    un = 512,
                    hn = 513,
                    dn = 514,
                    fn = 515,
                    pn = 516,
                    mn = 517,
                    gn = 518,
                    vn = 519,
                    _n = 512,
                    yn = 513,
                    xn = 514,
                    bn = 515,
                    Mn = 516,
                    wn = 517,
                    Sn = 518,
                    En = 519,
                    Tn = 35044,
                    Cn = 35048,
                    Rn = 35040,
                    Pn = 35045,
                    Ln = 35049,
                    Dn = 35041,
                    In = 35046,
                    On = 35050,
                    Bn = 35042,
                    qn = "100",
                    Un = "300 es",
                    Nn = 1035,
                    kn = 2e3,
                    Fn = 2001;
                class zn {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                    }
                    hasEventListener(t, e) {
                        if (void 0 === this._listeners) return !1;
                        const n = this._listeners;
                        return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                    }
                    removeEventListener(t, e) {
                        if (void 0 === this._listeners) return;
                        const n = this._listeners[t];
                        if (void 0 !== n) {
                            const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                        }
                    }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
                            t.target = null
                        }
                    }
                }
                const Gn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                let jn = 1234567;
                const Vn = Math.PI / 180,
                    Hn = 180 / Math.PI;

                function Wn() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0;
                    return (Gn[255 & t] + Gn[t >> 8 & 255] + Gn[t >> 16 & 255] + Gn[t >> 24 & 255] + "-" + Gn[255 & e] + Gn[e >> 8 & 255] + "-" + Gn[e >> 16 & 15 | 64] + Gn[e >> 24 & 255] + "-" + Gn[63 & n | 128] + Gn[n >> 8 & 255] + "-" + Gn[n >> 16 & 255] + Gn[n >> 24 & 255] + Gn[255 & r] + Gn[r >> 8 & 255] + Gn[r >> 16 & 255] + Gn[r >> 24 & 255]).toLowerCase()
                }

                function Xn(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                }

                function Yn(t, e) {
                    return (t % e + e) % e
                }

                function Qn(t, e, n) {
                    return (1 - n) * t + n * e
                }

                function Zn(t) {
                    return 0 == (t & t - 1) && 0 !== t
                }

                function Jn(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }

                function Kn(t, e) {
                    switch (e.constructor) {
                        case Float32Array:
                            return t;
                        case Uint32Array:
                            return t / 4294967295;
                        case Uint16Array:
                            return t / 65535;
                        case Uint8Array:
                            return t / 255;
                        case Int32Array:
                            return Math.max(t / 2147483647, -1);
                        case Int16Array:
                            return Math.max(t / 32767, -1);
                        case Int8Array:
                            return Math.max(t / 127, -1);
                        default:
                            throw new Error("Invalid component type.")
                    }
                }

                function $n(t, e) {
                    switch (e.constructor) {
                        case Float32Array:
                            return t;
                        case Uint32Array:
                            return Math.round(4294967295 * t);
                        case Uint16Array:
                            return Math.round(65535 * t);
                        case Uint8Array:
                            return Math.round(255 * t);
                        case Int32Array:
                            return Math.round(2147483647 * t);
                        case Int16Array:
                            return Math.round(32767 * t);
                        case Int8Array:
                            return Math.round(127 * t);
                        default:
                            throw new Error("Invalid component type.")
                    }
                }
                const tr = {
                    DEG2RAD: Vn,
                    RAD2DEG: Hn,
                    generateUUID: Wn,
                    clamp: Xn,
                    euclideanModulo: Yn,
                    mapLinear: function(t, e, n, r, i) {
                        return r + (t - e) * (i - r) / (n - e)
                    },
                    inverseLerp: function(t, e, n) {
                        return t !== e ? (n - t) / (e - t) : 0
                    },
                    lerp: Qn,
                    damp: function(t, e, n, r) {
                        return Qn(t, e, 1 - Math.exp(-n * r))
                    },
                    pingpong: function(t, e = 1) {
                        return e - Math.abs(Yn(t, 2 * e) - e)
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    seededRandom: function(t) {
                        void 0 !== t && (jn = t);
                        let e = jn += 1831565813;
                        return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
                    },
                    degToRad: function(t) {
                        return t * Vn
                    },
                    radToDeg: function(t) {
                        return t * Hn
                    },
                    isPowerOfTwo: Zn,
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: Jn,
                    setQuaternionFromProperEuler: function(t, e, n, r, i) {
                        const a = Math.cos,
                            o = Math.sin,
                            s = a(n / 2),
                            l = o(n / 2),
                            A = a((e + r) / 2),
                            c = o((e + r) / 2),
                            u = a((e - r) / 2),
                            h = o((e - r) / 2),
                            d = a((r - e) / 2),
                            f = o((r - e) / 2);
                        switch (i) {
                            case "XYX":
                                t.set(s * c, l * u, l * h, s * A);
                                break;
                            case "YZY":
                                t.set(l * h, s * c, l * u, s * A);
                                break;
                            case "ZXZ":
                                t.set(l * u, l * h, s * c, s * A);
                                break;
                            case "XZX":
                                t.set(s * c, l * f, l * d, s * A);
                                break;
                            case "YXY":
                                t.set(l * d, s * c, l * f, s * A);
                                break;
                            case "ZYZ":
                                t.set(l * f, l * d, s * c, s * A);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                        }
                    },
                    normalize: $n,
                    denormalize: Kn
                };
                class er {
                    constructor(t = 0, e = 0) {
                        er.prototype.isVector2 = !0, this.x = t, this.y = e
                    }
                    get width() {
                        return this.x
                    }
                    set width(t) {
                        this.x = t
                    }
                    get height() {
                        return this.y
                    }
                    set height(t) {
                        this.y = t
                    }
                    set(t, e) {
                        return this.x = t, this.y = e, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this
                    }
                    add(t) {
                        return this.x += t.x, this.y += t.y, this
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this
                    }
                    sub(t) {
                        return this.x -= t.x, this.y -= t.y, this
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this
                    }
                    divide(t) {
                        return this.x /= t.x, this.y /= t.y, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(Xn(n, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }
                    fromArray(t, e = 0) {
                        return this.x = t[e], this.y = t[e + 1], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.x, t[e + 1] = this.y, t
                    }
                    fromBufferAttribute(t, e) {
                        return this.x = t.getX(e), this.y = t.getY(e), this
                    }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            r = Math.sin(e),
                            i = this.x - t.x,
                            a = this.y - t.y;
                        return this.x = i * n - a * r + t.x, this.y = i * r + a * n + t.y, this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this
                    }*[Symbol.iterator]() {
                        yield this.x, yield this.y
                    }
                }
                class nr {
                    constructor(t, e, n, r, i, a, o, s, l) {
                        nr.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, r, i, a, o, s, l)
                    }
                    set(t, e, n, r, i, a, o, s, l) {
                        const A = this.elements;
                        return A[0] = t, A[1] = r, A[2] = o, A[3] = e, A[4] = i, A[5] = s, A[6] = n, A[7] = a, A[8] = l, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                    }
                    extractBasis(t, e, n) {
                        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                    }
                    setFromMatrix4(t) {
                        const e = t.elements;
                        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            r = e.elements,
                            i = this.elements,
                            a = n[0],
                            o = n[3],
                            s = n[6],
                            l = n[1],
                            A = n[4],
                            c = n[7],
                            u = n[2],
                            h = n[5],
                            d = n[8],
                            f = r[0],
                            p = r[3],
                            m = r[6],
                            g = r[1],
                            v = r[4],
                            _ = r[7],
                            y = r[2],
                            x = r[5],
                            b = r[8];
                        return i[0] = a * f + o * g + s * y, i[3] = a * p + o * v + s * x, i[6] = a * m + o * _ + s * b, i[1] = l * f + A * g + c * y, i[4] = l * p + A * v + c * x, i[7] = l * m + A * _ + c * b, i[2] = u * f + h * g + d * y, i[5] = u * p + h * v + d * x, i[8] = u * m + h * _ + d * b, this
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            r = t[2],
                            i = t[3],
                            a = t[4],
                            o = t[5],
                            s = t[6],
                            l = t[7],
                            A = t[8];
                        return e * a * A - e * o * l - n * i * A + n * o * s + r * i * l - r * a * s
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            r = t[2],
                            i = t[3],
                            a = t[4],
                            o = t[5],
                            s = t[6],
                            l = t[7],
                            A = t[8],
                            c = A * a - o * l,
                            u = o * s - A * i,
                            h = l * i - a * s,
                            d = e * c + n * u + r * h;
                        if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const f = 1 / d;
                        return t[0] = c * f, t[1] = (r * l - A * n) * f, t[2] = (o * n - r * a) * f, t[3] = u * f, t[4] = (A * e - r * s) * f, t[5] = (r * i - o * e) * f, t[6] = h * f, t[7] = (n * s - l * e) * f, t[8] = (a * e - n * i) * f, this
                    }
                    transpose() {
                        let t;
                        const e = this.elements;
                        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose()
                    }
                    transposeIntoArray(t) {
                        const e = this.elements;
                        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                    }
                    setUvTransform(t, e, n, r, i, a, o) {
                        const s = Math.cos(i),
                            l = Math.sin(i);
                        return this.set(n * s, n * l, -n * (s * a + l * o) + a + t, -r * l, r * s, -r * (-l * a + s * o) + o + e, 0, 0, 1), this
                    }
                    scale(t, e) {
                        return this.premultiply(rr.makeScale(t, e)), this
                    }
                    rotate(t) {
                        return this.premultiply(rr.makeRotation(-t)), this
                    }
                    translate(t, e) {
                        return this.premultiply(rr.makeTranslation(t, e)), this
                    }
                    makeTranslation(t, e) {
                        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
                    }
                    makeRotation(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
                    }
                    makeScale(t, e) {
                        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                        return this
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                    }
                    clone() {
                        return (new this.constructor).fromArray(this.elements)
                    }
                }
                const rr = new nr;

                function ir(t) {
                    for (let e = t.length - 1; e >= 0; --e)
                        if (t[e] >= 65535) return !0;
                    return !1
                }
                const ar = {
                    Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                };

                function or(t, e) {
                    return new ar[t](e)
                }

                function sr(t) {
                    return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                }

                function lr() {
                    const t = sr("canvas");
                    return t.style.display = "block", t
                }
                const Ar = {};

                function cr(t) {
                    t in Ar || (Ar[t] = !0, console.warn(t))
                }
                const ur = (new nr).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
                    hr = (new nr).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
                    dr = {
                        [Qe]: {
                            transfer: Ke,
                            primaries: tn,
                            toReference: t => t,
                            fromReference: t => t
                        },
                        [Ye]: {
                            transfer: $e,
                            primaries: tn,
                            toReference: t => t.convertSRGBToLinear(),
                            fromReference: t => t.convertLinearToSRGB()
                        },
                        [Je]: {
                            transfer: Ke,
                            primaries: en,
                            toReference: t => t.applyMatrix3(hr),
                            fromReference: t => t.applyMatrix3(ur)
                        },
                        [Ze]: {
                            transfer: $e,
                            primaries: en,
                            toReference: t => t.convertSRGBToLinear().applyMatrix3(hr),
                            fromReference: t => t.applyMatrix3(ur).convertLinearToSRGB()
                        }
                    },
                    fr = new Set([Qe, Je]),
                    pr = {
                        enabled: !0,
                        _workingColorSpace: Qe,
                        get workingColorSpace() {
                            return this._workingColorSpace
                        },
                        set workingColorSpace(t) {
                            if (!fr.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
                            this._workingColorSpace = t
                        },
                        convert: function(t, e, n) {
                            if (!1 === this.enabled || e === n || !e || !n) return t;
                            const r = dr[e].toReference;
                            return (0, dr[n].fromReference)(r(t))
                        },
                        fromWorkingColorSpace: function(t, e) {
                            return this.convert(t, this._workingColorSpace, e)
                        },
                        toWorkingColorSpace: function(t, e) {
                            return this.convert(t, e, this._workingColorSpace)
                        },
                        getPrimaries: function(t) {
                            return dr[t].primaries
                        },
                        getTransfer: function(t) {
                            return t === Xe ? Ke : dr[t].transfer
                        }
                    };

                function mr(t) {
                    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                }

                function gr(t) {
                    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                }
                let vr;
                class _r {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === vr && (vr = sr("canvas")), vr.width = t.width, vr.height = t.height;
                            const n = vr.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = vr
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                    static sRGBToLinear(t) {
                        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                            const e = sr("canvas");
                            e.width = t.width, e.height = t.height;
                            const n = e.getContext("2d");
                            n.drawImage(t, 0, 0, t.width, t.height);
                            const r = n.getImageData(0, 0, t.width, t.height),
                                i = r.data;
                            for (let t = 0; t < i.length; t++) i[t] = 255 * mr(i[t] / 255);
                            return n.putImageData(r, 0, 0), e
                        }
                        if (t.data) {
                            const e = t.data.slice(0);
                            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * mr(e[t] / 255)) : e[t] = mr(e[t]);
                            return {
                                data: e,
                                width: t.width,
                                height: t.height
                            }
                        }
                        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                    }
                }
                let yr = 0;
                class xr {
                    constructor(t = null) {
                        this.isSource = !0, Object.defineProperty(this, "id", {
                            value: yr++
                        }), this.uuid = Wn(), this.data = t, this.dataReady = !0, this.version = 0
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                        const n = {
                                uuid: this.uuid,
                                url: ""
                            },
                            r = this.data;
                        if (null !== r) {
                            let t;
                            if (Array.isArray(r)) {
                                t = [];
                                for (let e = 0, n = r.length; e < n; e++) r[e].isDataTexture ? t.push(br(r[e].image)) : t.push(br(r[e]))
                            } else t = br(r);
                            n.url = t
                        }
                        return e || (t.images[this.uuid] = n), n
                    }
                }

                function br(t) {
                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? _r.getDataURL(t) : t.data ? {
                        data: Array.from(t.data),
                        width: t.width,
                        height: t.height,
                        type: t.data.constructor.name
                    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                }
                let Mr = 0;
                class wr extends zn {
                    constructor(t = wr.DEFAULT_IMAGE, e = wr.DEFAULT_MAPPING, n = gt, r = gt, i = wt, a = Tt, o = zt, s = Rt, l = wr.DEFAULT_ANISOTROPY, A = Xe) {
                        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                            value: Mr++
                        }), this.uuid = Wn(), this.name = "", this.source = new xr(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new er(0, 0), this.repeat = new er(1, 1), this.center = new er(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new nr, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = A, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(t = null) {
                        this.source.data = t
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                        const n = {
                            metadata: {
                                version: 4.6,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(t).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(t) {
                        if (this.mapping !== ct) return t;
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case mt:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case gt:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case vt:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case mt:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case gt:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case vt:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        return this.flipY && (t.y = 1 - t.y), t
                    }
                    set needsUpdate(t) {
                        !0 === t && (this.version++, this.source.needsUpdate = !0)
                    }
                }
                wr.DEFAULT_IMAGE = null, wr.DEFAULT_MAPPING = ct, wr.DEFAULT_ANISOTROPY = 1;
                class Sr {
                    constructor(t = 0, e = 0, n = 0, r = 1) {
                        Sr.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = r
                    }
                    get width() {
                        return this.z
                    }
                    set width(t) {
                        this.z = t
                    }
                    get height() {
                        return this.w
                    }
                    set height(t) {
                        this.w = t
                    }
                    set(t, e, n, r) {
                        return this.x = t, this.y = e, this.z = n, this.w = r, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this.z = t, this.w = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setZ(t) {
                        return this.z = t, this
                    }
                    setW(t) {
                        return this.w = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                    }
                    add(t) {
                        return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this.z += t, this.w += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                    }
                    sub(t) {
                        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = this.w,
                            a = t.elements;
                        return this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const e = Math.sqrt(1 - t.w * t.w);
                        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, r, i;
                        const a = .01,
                            o = .1,
                            s = t.elements,
                            l = s[0],
                            A = s[4],
                            c = s[8],
                            u = s[1],
                            h = s[5],
                            d = s[9],
                            f = s[2],
                            p = s[6],
                            m = s[10];
                        if (Math.abs(A - u) < a && Math.abs(c - f) < a && Math.abs(d - p) < a) {
                            if (Math.abs(A + u) < o && Math.abs(c + f) < o && Math.abs(d + p) < o && Math.abs(l + h + m - 3) < o) return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (l + 1) / 2,
                                s = (h + 1) / 2,
                                g = (m + 1) / 2,
                                v = (A + u) / 4,
                                _ = (c + f) / 4,
                                y = (d + p) / 4;
                            return t > s && t > g ? t < a ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = v / n, i = _ / n) : s > g ? s < a ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(s), n = v / r, i = y / r) : g < a ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(g), n = _ / i, r = y / i), this.set(n, r, i, e), this
                        }
                        let g = Math.sqrt((p - d) * (p - d) + (c - f) * (c - f) + (u - A) * (u - A));
                        return Math.abs(g) < .001 && (g = 1), this.x = (p - d) / g, this.y = (c - f) / g, this.z = (u - A) / g, this.w = Math.acos((l + h + m - 1) / 2), this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    }
                    fromArray(t, e = 0) {
                        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                    }
                    fromBufferAttribute(t, e) {
                        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                    }*[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z, yield this.w
                    }
                }
                class Er extends zn {
                    constructor(t = 1, e = 1, n = {}) {
                        super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new Sr(0, 0, t, e), this.scissorTest = !1, this.viewport = new Sr(0, 0, t, e);
                        const r = {
                            width: t,
                            height: e,
                            depth: 1
                        };
                        n = Object.assign({
                            generateMipmaps: !1,
                            internalFormat: null,
                            minFilter: wt,
                            depthBuffer: !0,
                            stencilBuffer: !1,
                            depthTexture: null,
                            samples: 0,
                            count: 1
                        }, n);
                        const i = new wr(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                        i.flipY = !1, i.generateMipmaps = n.generateMipmaps, i.internalFormat = n.internalFormat, this.textures = [];
                        const a = n.count;
                        for (let t = 0; t < a; t++) this.textures[t] = i.clone(), this.textures[t].isRenderTargetTexture = !0;
                        this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
                    }
                    get texture() {
                        return this.textures[0]
                    }
                    set texture(t) {
                        this.textures[0] = t
                    }
                    setSize(t, e, n = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t, this.height = e, this.depth = n;
                            for (let r = 0, i = this.textures.length; r < i; r++) this.textures[r].image.width = t, this.textures[r].image.height = e, this.textures[r].image.depth = n;
                            this.dispose()
                        }
                        this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
                        for (let e = 0, n = t.textures.length; e < n; e++) this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0;
                        const e = Object.assign({}, t.texture.image);
                        return this.texture.source = new xr(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                class Tr extends Er {
                    constructor(t = 1, e = 1, n = {}) {
                        super(t, e, n), this.isWebGLRenderTarget = !0
                    }
                }
                class Cr extends wr {
                    constructor(t = null, e = 1, n = 1, r = 1) {
                        super(null), this.isDataArrayTexture = !0, this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: r
                        }, this.magFilter = _t, this.minFilter = _t, this.wrapR = gt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                }
                class Rr extends Tr {
                    constructor(t = 1, e = 1, n = 1, r = {}) {
                        super(t, e, r), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new Cr(null, t, e, n), this.texture.isRenderTargetTexture = !0
                    }
                }
                class Pr extends wr {
                    constructor(t = null, e = 1, n = 1, r = 1) {
                        super(null), this.isData3DTexture = !0, this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: r
                        }, this.magFilter = _t, this.minFilter = _t, this.wrapR = gt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                }
                class Lr extends Tr {
                    constructor(t = 1, e = 1, n = 1, r = {}) {
                        super(t, e, r), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Pr(null, t, e, n), this.texture.isRenderTargetTexture = !0
                    }
                }
                class Dr {
                    constructor(t = 0, e = 0, n = 0, r = 1) {
                        this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = r
                    }
                    static slerpFlat(t, e, n, r, i, a, o) {
                        let s = n[r + 0],
                            l = n[r + 1],
                            A = n[r + 2],
                            c = n[r + 3];
                        const u = i[a + 0],
                            h = i[a + 1],
                            d = i[a + 2],
                            f = i[a + 3];
                        if (0 === o) return t[e + 0] = s, t[e + 1] = l, t[e + 2] = A, void(t[e + 3] = c);
                        if (1 === o) return t[e + 0] = u, t[e + 1] = h, t[e + 2] = d, void(t[e + 3] = f);
                        if (c !== f || s !== u || l !== h || A !== d) {
                            let t = 1 - o;
                            const e = s * u + l * h + A * d + c * f,
                                n = e >= 0 ? 1 : -1,
                                r = 1 - e * e;
                            if (r > Number.EPSILON) {
                                const i = Math.sqrt(r),
                                    a = Math.atan2(i, e * n);
                                t = Math.sin(t * a) / i, o = Math.sin(o * a) / i
                            }
                            const i = o * n;
                            if (s = s * t + u * i, l = l * t + h * i, A = A * t + d * i, c = c * t + f * i, t === 1 - o) {
                                const t = 1 / Math.sqrt(s * s + l * l + A * A + c * c);
                                s *= t, l *= t, A *= t, c *= t
                            }
                        }
                        t[e] = s, t[e + 1] = l, t[e + 2] = A, t[e + 3] = c
                    }
                    static multiplyQuaternionsFlat(t, e, n, r, i, a) {
                        const o = n[r],
                            s = n[r + 1],
                            l = n[r + 2],
                            A = n[r + 3],
                            c = i[a],
                            u = i[a + 1],
                            h = i[a + 2],
                            d = i[a + 3];
                        return t[e] = o * d + A * c + s * h - l * u, t[e + 1] = s * d + A * u + l * c - o * h, t[e + 2] = l * d + A * h + o * u - s * c, t[e + 3] = A * d - o * c - s * u - l * h, t
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t, this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(t) {
                        this._w = t, this._onChangeCallback()
                    }
                    set(t, e, n, r) {
                        return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    }
                    copy(t) {
                        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                    }
                    setFromEuler(t, e = !0) {
                        const n = t._x,
                            r = t._y,
                            i = t._z,
                            a = t._order,
                            o = Math.cos,
                            s = Math.sin,
                            l = o(n / 2),
                            A = o(r / 2),
                            c = o(i / 2),
                            u = s(n / 2),
                            h = s(r / 2),
                            d = s(i / 2);
                        switch (a) {
                            case "XYZ":
                                this._x = u * A * c + l * h * d, this._y = l * h * c - u * A * d, this._z = l * A * d + u * h * c, this._w = l * A * c - u * h * d;
                                break;
                            case "YXZ":
                                this._x = u * A * c + l * h * d, this._y = l * h * c - u * A * d, this._z = l * A * d - u * h * c, this._w = l * A * c + u * h * d;
                                break;
                            case "ZXY":
                                this._x = u * A * c - l * h * d, this._y = l * h * c + u * A * d, this._z = l * A * d + u * h * c, this._w = l * A * c - u * h * d;
                                break;
                            case "ZYX":
                                this._x = u * A * c - l * h * d, this._y = l * h * c + u * A * d, this._z = l * A * d - u * h * c, this._w = l * A * c + u * h * d;
                                break;
                            case "YZX":
                                this._x = u * A * c + l * h * d, this._y = l * h * c + u * A * d, this._z = l * A * d - u * h * c, this._w = l * A * c - u * h * d;
                                break;
                            case "XZY":
                                this._x = u * A * c - l * h * d, this._y = l * h * c - u * A * d, this._z = l * A * d + u * h * c, this._w = l * A * c + u * h * d;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                        }
                        return !0 === e && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            r = Math.sin(n);
                        return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            r = e[4],
                            i = e[8],
                            a = e[1],
                            o = e[5],
                            s = e[9],
                            l = e[2],
                            A = e[6],
                            c = e[10],
                            u = n + o + c;
                        if (u > 0) {
                            const t = .5 / Math.sqrt(u + 1);
                            this._w = .25 / t, this._x = (A - s) * t, this._y = (i - l) * t, this._z = (a - r) * t
                        } else if (n > o && n > c) {
                            const t = 2 * Math.sqrt(1 + n - o - c);
                            this._w = (A - s) / t, this._x = .25 * t, this._y = (r + a) / t, this._z = (i + l) / t
                        } else if (o > c) {
                            const t = 2 * Math.sqrt(1 + o - n - c);
                            this._w = (i - l) / t, this._x = (r + a) / t, this._y = .25 * t, this._z = (s + A) / t
                        } else {
                            const t = 2 * Math.sqrt(1 + c - n - o);
                            this._w = (a - r) / t, this._x = (i + l) / t, this._y = (s + A) / t, this._z = .25 * t
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(t, e) {
                        let n = t.dot(e) + 1;
                        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                    }
                    angleTo(t) {
                        return 2 * Math.acos(Math.abs(Xn(this.dot(t), -1, 1)))
                    }
                    rotateTowards(t, e) {
                        const n = this.angleTo(t);
                        if (0 === n) return this;
                        const r = Math.min(1, e / n);
                        return this.slerp(t, r), this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                    }
                    dot(t) {
                        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let t = this.length();
                        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                    }
                    multiply(t) {
                        return this.multiplyQuaternions(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyQuaternions(t, this)
                    }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            r = t._y,
                            i = t._z,
                            a = t._w,
                            o = e._x,
                            s = e._y,
                            l = e._z,
                            A = e._w;
                        return this._x = n * A + a * o + r * l - i * s, this._y = r * A + a * s + i * o - n * l, this._z = i * A + a * l + n * s - r * o, this._w = a * A - n * o - r * s - i * l, this._onChangeCallback(), this
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            r = this._y,
                            i = this._z,
                            a = this._w;
                        let o = a * t._w + n * t._x + r * t._y + i * t._z;
                        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this;
                        const s = 1 - o * o;
                        if (s <= Number.EPSILON) {
                            const t = 1 - e;
                            return this._w = t * a + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this
                        }
                        const l = Math.sqrt(s),
                            A = Math.atan2(l, o),
                            c = Math.sin((1 - e) * A) / l,
                            u = Math.sin(e * A) / l;
                        return this._w = a * c + this._w * u, this._x = n * c + this._x * u, this._y = r * c + this._y * u, this._z = i * c + this._z * u, this._onChangeCallback(), this
                    }
                    slerpQuaternions(t, e, n) {
                        return this.copy(t).slerp(e, n)
                    }
                    random() {
                        const t = 2 * Math.PI * Math.random(),
                            e = 2 * Math.PI * Math.random(),
                            n = Math.random(),
                            r = Math.sqrt(1 - n),
                            i = Math.sqrt(n);
                        return this.set(r * Math.sin(t), r * Math.cos(t), i * Math.sin(e), i * Math.cos(e))
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                    }
                    fromArray(t, e = 0) {
                        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                    }
                    fromBufferAttribute(t, e) {
                        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
                    }
                    toJSON() {
                        return this.toArray()
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t, this
                    }
                    _onChangeCallback() {}*[Symbol.iterator]() {
                        yield this._x, yield this._y, yield this._z, yield this._w
                    }
                }
                class Ir {
                    constructor(t = 0, e = 0, n = 0) {
                        Ir.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
                    }
                    set(t, e, n) {
                        return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this.z = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setZ(t) {
                        return this.z = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this
                    }
                    add(t) {
                        return this.x += t.x, this.y += t.y, this.z += t.z, this
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this.z += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                    }
                    sub(t) {
                        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this
                    }
                    multiplyVectors(t, e) {
                        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                    }
                    applyEuler(t) {
                        return this.applyQuaternion(Br.setFromEuler(t))
                    }
                    applyAxisAngle(t, e) {
                        return this.applyQuaternion(Br.setFromAxisAngle(t, e))
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.elements;
                        return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.elements,
                            a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                        return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a, this
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.x,
                            a = t.y,
                            o = t.z,
                            s = t.w,
                            l = 2 * (a * r - o * n),
                            A = 2 * (o * e - i * r),
                            c = 2 * (i * n - a * e);
                        return this.x = e + s * l + a * c - o * A, this.y = n + s * A + o * l - i * c, this.z = r + s * c + i * A - a * l, this
                    }
                    project(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                    unproject(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.elements;
                        return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
                    }
                    divide(t) {
                        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
                    }
                    cross(t) {
                        return this.crossVectors(this, t)
                    }
                    crossVectors(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z,
                            a = e.x,
                            o = e.y,
                            s = e.z;
                        return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this
                    }
                    projectOnVector(t) {
                        const e = t.lengthSq();
                        if (0 === e) return this.set(0, 0, 0);
                        const n = t.dot(this) / e;
                        return this.copy(t).multiplyScalar(n)
                    }
                    projectOnPlane(t) {
                        return Or.copy(this).projectOnVector(t), this.sub(Or)
                    }
                    reflect(t) {
                        return this.sub(Or.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(Xn(n, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            r = this.z - t.z;
                        return e * e + n * n + r * r
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                    setFromSphericalCoords(t, e, n) {
                        const r = Math.sin(e) * t;
                        return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                    setFromCylindricalCoords(t, e, n) {
                        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                    }
                    setFromMatrixPosition(t) {
                        const e = t.elements;
                        return this.x = e[12], this.y = e[13], this.z = e[14], this
                    }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            r = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = n, this.z = r, this
                    }
                    setFromMatrixColumn(t, e) {
                        return this.fromArray(t.elements, 4 * e)
                    }
                    setFromMatrix3Column(t, e) {
                        return this.fromArray(t.elements, 3 * e)
                    }
                    setFromEuler(t) {
                        return this.x = t._x, this.y = t._y, this.z = t._z, this
                    }
                    setFromColor(t) {
                        return this.x = t.r, this.y = t.g, this.z = t.b, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                    fromArray(t, e = 0) {
                        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                    }
                    fromBufferAttribute(t, e) {
                        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                    }
                    randomDirection() {
                        const t = Math.random() * Math.PI * 2,
                            e = 2 * Math.random() - 1,
                            n = Math.sqrt(1 - e * e);
                        return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this
                    }*[Symbol.iterator]() {
                        yield this.x, yield this.y, yield this.z
                    }
                }
                const Or = new Ir,
                    Br = new Dr;
                class qr {
                    constructor(t = new Ir(1 / 0, 1 / 0, 1 / 0), e = new Ir(-1 / 0, -1 / 0, -1 / 0)) {
                        this.isBox3 = !0, this.min = t, this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                    setFromArray(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(Nr.fromArray(t, e));
                        return this
                    }
                    setFromBufferAttribute(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(Nr.fromBufferAttribute(t, e));
                        return this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = Nr.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    }
                    setFromObject(t, e = !1) {
                        return this.makeEmpty(), this.expandByObject(t, e)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(t) {
                        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                    expandByObject(t, e = !1) {
                        t.updateWorldMatrix(!1, !1);
                        const n = t.geometry;
                        if (void 0 !== n) {
                            const r = n.getAttribute("position");
                            if (!0 === e && void 0 !== r && !0 !== t.isInstancedMesh)
                                for (let e = 0, n = r.count; e < n; e++) !0 === t.isMesh ? t.getVertexPosition(e, Nr) : Nr.fromBufferAttribute(r, e), Nr.applyMatrix4(t.matrixWorld), this.expandByPoint(Nr);
                            else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), kr.copy(t.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), kr.copy(n.boundingBox)), kr.applyMatrix4(t.matrixWorld), this.union(kr)
                        }
                        const r = t.children;
                        for (let t = 0, n = r.length; t < n; t++) this.expandByObject(r[t], e);
                        return this
                    }
                    containsPoint(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                    }
                    getParameter(t, e) {
                        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                    }
                    intersectsSphere(t) {
                        return this.clampPoint(t.center, Nr), Nr.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                    intersectsPlane(t) {
                        let e, n;
                        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                    }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(Wr), Xr.subVectors(this.max, Wr), Fr.subVectors(t.a, Wr), zr.subVectors(t.b, Wr), Gr.subVectors(t.c, Wr), jr.subVectors(zr, Fr), Vr.subVectors(Gr, zr), Hr.subVectors(Fr, Gr);
                        let e = [0, -jr.z, jr.y, 0, -Vr.z, Vr.y, 0, -Hr.z, Hr.y, jr.z, 0, -jr.x, Vr.z, 0, -Vr.x, Hr.z, 0, -Hr.x, -jr.y, jr.x, 0, -Vr.y, Vr.x, 0, -Hr.y, Hr.x, 0];
                        return !!Zr(e, Fr, zr, Gr, Xr) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Zr(e, Fr, zr, Gr, Xr) && (Yr.crossVectors(jr, Vr), e = [Yr.x, Yr.y, Yr.z], Zr(e, Fr, zr, Gr, Xr)))
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return this.clampPoint(t, Nr).distanceTo(t)
                    }
                    getBoundingSphere(t) {
                        return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(Nr).length()), t
                    }
                    intersect(t) {
                        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                    applyMatrix4(t) {
                        return this.isEmpty() || (Ur[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ur[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ur[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ur[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ur[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ur[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ur[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ur[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ur)), this
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                const Ur = [new Ir, new Ir, new Ir, new Ir, new Ir, new Ir, new Ir, new Ir],
                    Nr = new Ir,
                    kr = new qr,
                    Fr = new Ir,
                    zr = new Ir,
                    Gr = new Ir,
                    jr = new Ir,
                    Vr = new Ir,
                    Hr = new Ir,
                    Wr = new Ir,
                    Xr = new Ir,
                    Yr = new Ir,
                    Qr = new Ir;

                function Zr(t, e, n, r, i) {
                    for (let a = 0, o = t.length - 3; a <= o; a += 3) {
                        Qr.fromArray(t, a);
                        const o = i.x * Math.abs(Qr.x) + i.y * Math.abs(Qr.y) + i.z * Math.abs(Qr.z),
                            s = e.dot(Qr),
                            l = n.dot(Qr),
                            A = r.dot(Qr);
                        if (Math.max(-Math.max(s, l, A), Math.min(s, l, A)) > o) return !1
                    }
                    return !0
                }
                const Jr = new qr,
                    Kr = new Ir,
                    $r = new Ir;
                class ti {
                    constructor(t = new Ir, e = -1) {
                        this.isSphere = !0, this.center = t, this.radius = e
                    }
                    set(t, e) {
                        return this.center.copy(t), this.radius = e, this
                    }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e ? n.copy(e) : Jr.setFromPoints(t).getCenter(n);
                        let r = 0;
                        for (let e = 0, i = t.length; e < i; e++) r = Math.max(r, n.distanceToSquared(t[e]));
                        return this.radius = Math.sqrt(r), this
                    }
                    copy(t) {
                        return this.center.copy(t.center), this.radius = t.radius, this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0), this.radius = -1, this
                    }
                    containsPoint(t) {
                        return t.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(t) {
                        return t.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(t) {
                        const e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e
                    }
                    intersectsBox(t) {
                        return t.intersectsSphere(this)
                    }
                    intersectsPlane(t) {
                        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(t, e) {
                        const n = this.center.distanceToSquared(t);
                        return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                    }
                    getBoundingBox(t) {
                        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                    }
                    applyMatrix4(t) {
                        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                    }
                    translate(t) {
                        return this.center.add(t), this
                    }
                    expandByPoint(t) {
                        if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                        Kr.subVectors(t, this.center);
                        const e = Kr.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = .5 * (t - this.radius);
                            this.center.addScaledVector(Kr, n / t), this.radius += n
                        }
                        return this
                    }
                    union(t) {
                        return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : ($r.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Kr.copy(t.center).add($r)), this.expandByPoint(Kr.copy(t.center).sub($r))), this)
                    }
                    equals(t) {
                        return t.center.equals(this.center) && t.radius === this.radius
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const ei = new Ir,
                    ni = new Ir,
                    ri = new Ir,
                    ii = new Ir,
                    ai = new Ir,
                    oi = new Ir,
                    si = new Ir;
                class li {
                    constructor(t = new Ir, e = new Ir(0, 0, -1)) {
                        this.origin = t, this.direction = e
                    }
                    set(t, e) {
                        return this.origin.copy(t), this.direction.copy(e), this
                    }
                    copy(t) {
                        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                    }
                    at(t, e) {
                        return e.copy(this.origin).addScaledVector(this.direction, t)
                    }
                    lookAt(t) {
                        return this.direction.copy(t).sub(this.origin).normalize(), this
                    }
                    recast(t) {
                        return this.origin.copy(this.at(t, ei)), this
                    }
                    closestPointToPoint(t, e) {
                        e.subVectors(t, this.origin);
                        const n = e.dot(this.direction);
                        return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
                    }
                    distanceToPoint(t) {
                        return Math.sqrt(this.distanceSqToPoint(t))
                    }
                    distanceSqToPoint(t) {
                        const e = ei.subVectors(t, this.origin).dot(this.direction);
                        return e < 0 ? this.origin.distanceToSquared(t) : (ei.copy(this.origin).addScaledVector(this.direction, e), ei.distanceToSquared(t))
                    }
                    distanceSqToSegment(t, e, n, r) {
                        ni.copy(t).add(e).multiplyScalar(.5), ri.copy(e).sub(t).normalize(), ii.copy(this.origin).sub(ni);
                        const i = .5 * t.distanceTo(e),
                            a = -this.direction.dot(ri),
                            o = ii.dot(this.direction),
                            s = -ii.dot(ri),
                            l = ii.lengthSq(),
                            A = Math.abs(1 - a * a);
                        let c, u, h, d;
                        if (A > 0)
                            if (c = a * s - o, u = a * o - s, d = i * A, c >= 0)
                                if (u >= -d)
                                    if (u <= d) {
                                        const t = 1 / A;
                                        c *= t, u *= t, h = c * (c + a * u + 2 * o) + u * (a * c + u + 2 * s) + l
                                    } else u = i, c = Math.max(0, -(a * u + o)), h = -c * c + u * (u + 2 * s) + l;
                        else u = -i, c = Math.max(0, -(a * u + o)), h = -c * c + u * (u + 2 * s) + l;
                        else u <= -d ? (c = Math.max(0, -(-a * i + o)), u = c > 0 ? -i : Math.min(Math.max(-i, -s), i), h = -c * c + u * (u + 2 * s) + l) : u <= d ? (c = 0, u = Math.min(Math.max(-i, -s), i), h = u * (u + 2 * s) + l) : (c = Math.max(0, -(a * i + o)), u = c > 0 ? i : Math.min(Math.max(-i, -s), i), h = -c * c + u * (u + 2 * s) + l);
                        else u = a > 0 ? -i : i, c = Math.max(0, -(a * u + o)), h = -c * c + u * (u + 2 * s) + l;
                        return n && n.copy(this.origin).addScaledVector(this.direction, c), r && r.copy(ni).addScaledVector(ri, u), h
                    }
                    intersectSphere(t, e) {
                        ei.subVectors(t.center, this.origin);
                        const n = ei.dot(this.direction),
                            r = ei.dot(ei) - n * n,
                            i = t.radius * t.radius;
                        if (r > i) return null;
                        const a = Math.sqrt(i - r),
                            o = n - a,
                            s = n + a;
                        return s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e)
                    }
                    intersectsSphere(t) {
                        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                    }
                    distanceToPlane(t) {
                        const e = t.normal.dot(this.direction);
                        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                        const n = -(this.origin.dot(t.normal) + t.constant) / e;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(t, e) {
                        const n = this.distanceToPlane(t);
                        return null === n ? null : this.at(n, e)
                    }
                    intersectsPlane(t) {
                        const e = t.distanceToPoint(this.origin);
                        return 0 === e || t.normal.dot(this.direction) * e < 0
                    }
                    intersectBox(t, e) {
                        let n, r, i, a, o, s;
                        const l = 1 / this.direction.x,
                            A = 1 / this.direction.y,
                            c = 1 / this.direction.z,
                            u = this.origin;
                        return l >= 0 ? (n = (t.min.x - u.x) * l, r = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, r = (t.min.x - u.x) * l), A >= 0 ? (i = (t.min.y - u.y) * A, a = (t.max.y - u.y) * A) : (i = (t.max.y - u.y) * A, a = (t.min.y - u.y) * A), n > a || i > r ? null : ((i > n || isNaN(n)) && (n = i), (a < r || isNaN(r)) && (r = a), c >= 0 ? (o = (t.min.z - u.z) * c, s = (t.max.z - u.z) * c) : (o = (t.max.z - u.z) * c, s = (t.min.z - u.z) * c), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
                    }
                    intersectsBox(t) {
                        return null !== this.intersectBox(t, ei)
                    }
                    intersectTriangle(t, e, n, r, i) {
                        ai.subVectors(e, t), oi.subVectors(n, t), si.crossVectors(ai, oi);
                        let a, o = this.direction.dot(si);
                        if (o > 0) {
                            if (r) return null;
                            a = 1
                        } else {
                            if (!(o < 0)) return null;
                            a = -1, o = -o
                        }
                        ii.subVectors(this.origin, t);
                        const s = a * this.direction.dot(oi.crossVectors(ii, oi));
                        if (s < 0) return null;
                        const l = a * this.direction.dot(ai.cross(ii));
                        if (l < 0) return null;
                        if (s + l > o) return null;
                        const A = -a * ii.dot(si);
                        return A < 0 ? null : this.at(A / o, i)
                    }
                    applyMatrix4(t) {
                        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                    }
                    equals(t) {
                        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class Ai {
                    constructor(t, e, n, r, i, a, o, s, l, A, c, u, h, d, f, p) {
                        Ai.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, r, i, a, o, s, l, A, c, u, h, d, f, p)
                    }
                    set(t, e, n, r, i, a, o, s, l, A, c, u, h, d, f, p) {
                        const m = this.elements;
                        return m[0] = t, m[4] = e, m[8] = n, m[12] = r, m[1] = i, m[5] = a, m[9] = o, m[13] = s, m[2] = l, m[6] = A, m[10] = c, m[14] = u, m[3] = h, m[7] = d, m[11] = f, m[15] = p, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    clone() {
                        return (new Ai).fromArray(this.elements)
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                    }
                    setFromMatrix3(t) {
                        const e = t.elements;
                        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                    }
                    extractBasis(t, e, n) {
                        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                    }
                    makeBasis(t, e, n) {
                        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                    }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            r = 1 / ci.setFromMatrixColumn(t, 0).length(),
                            i = 1 / ci.setFromMatrixColumn(t, 1).length(),
                            a = 1 / ci.setFromMatrixColumn(t, 2).length();
                        return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromEuler(t) {
                        const e = this.elements,
                            n = t.x,
                            r = t.y,
                            i = t.z,
                            a = Math.cos(n),
                            o = Math.sin(n),
                            s = Math.cos(r),
                            l = Math.sin(r),
                            A = Math.cos(i),
                            c = Math.sin(i);
                        if ("XYZ" === t.order) {
                            const t = a * A,
                                n = a * c,
                                r = o * A,
                                i = o * c;
                            e[0] = s * A, e[4] = -s * c, e[8] = l, e[1] = n + r * l, e[5] = t - i * l, e[9] = -o * s, e[2] = i - t * l, e[6] = r + n * l, e[10] = a * s
                        } else if ("YXZ" === t.order) {
                            const t = s * A,
                                n = s * c,
                                r = l * A,
                                i = l * c;
                            e[0] = t + i * o, e[4] = r * o - n, e[8] = a * l, e[1] = a * c, e[5] = a * A, e[9] = -o, e[2] = n * o - r, e[6] = i + t * o, e[10] = a * s
                        } else if ("ZXY" === t.order) {
                            const t = s * A,
                                n = s * c,
                                r = l * A,
                                i = l * c;
                            e[0] = t - i * o, e[4] = -a * c, e[8] = r + n * o, e[1] = n + r * o, e[5] = a * A, e[9] = i - t * o, e[2] = -a * l, e[6] = o, e[10] = a * s
                        } else if ("ZYX" === t.order) {
                            const t = a * A,
                                n = a * c,
                                r = o * A,
                                i = o * c;
                            e[0] = s * A, e[4] = r * l - n, e[8] = t * l + i, e[1] = s * c, e[5] = i * l + t, e[9] = n * l - r, e[2] = -l, e[6] = o * s, e[10] = a * s
                        } else if ("YZX" === t.order) {
                            const t = a * s,
                                n = a * l,
                                r = o * s,
                                i = o * l;
                            e[0] = s * A, e[4] = i - t * c, e[8] = r * c + n, e[1] = c, e[5] = a * A, e[9] = -o * A, e[2] = -l * A, e[6] = n * c + r, e[10] = t - i * c
                        } else if ("XZY" === t.order) {
                            const t = a * s,
                                n = a * l,
                                r = o * s,
                                i = o * l;
                            e[0] = s * A, e[4] = -c, e[8] = l * A, e[1] = t * c + i, e[5] = a * A, e[9] = n * c - r, e[2] = r * c - n, e[6] = o * A, e[10] = i * c + t
                        }
                        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(hi, t, di)
                    }
                    lookAt(t, e, n) {
                        const r = this.elements;
                        return mi.subVectors(t, e), 0 === mi.lengthSq() && (mi.z = 1), mi.normalize(), fi.crossVectors(n, mi), 0 === fi.lengthSq() && (1 === Math.abs(n.z) ? mi.x += 1e-4 : mi.z += 1e-4, mi.normalize(), fi.crossVectors(n, mi)), fi.normalize(), pi.crossVectors(mi, fi), r[0] = fi.x, r[4] = pi.x, r[8] = mi.x, r[1] = fi.y, r[5] = pi.y, r[9] = mi.y, r[2] = fi.z, r[6] = pi.z, r[10] = mi.z, this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            r = e.elements,
                            i = this.elements,
                            a = n[0],
                            o = n[4],
                            s = n[8],
                            l = n[12],
                            A = n[1],
                            c = n[5],
                            u = n[9],
                            h = n[13],
                            d = n[2],
                            f = n[6],
                            p = n[10],
                            m = n[14],
                            g = n[3],
                            v = n[7],
                            _ = n[11],
                            y = n[15],
                            x = r[0],
                            b = r[4],
                            M = r[8],
                            w = r[12],
                            S = r[1],
                            E = r[5],
                            T = r[9],
                            C = r[13],
                            R = r[2],
                            P = r[6],
                            L = r[10],
                            D = r[14],
                            I = r[3],
                            O = r[7],
                            B = r[11],
                            q = r[15];
                        return i[0] = a * x + o * S + s * R + l * I, i[4] = a * b + o * E + s * P + l * O, i[8] = a * M + o * T + s * L + l * B, i[12] = a * w + o * C + s * D + l * q, i[1] = A * x + c * S + u * R + h * I, i[5] = A * b + c * E + u * P + h * O, i[9] = A * M + c * T + u * L + h * B, i[13] = A * w + c * C + u * D + h * q, i[2] = d * x + f * S + p * R + m * I, i[6] = d * b + f * E + p * P + m * O, i[10] = d * M + f * T + p * L + m * B, i[14] = d * w + f * C + p * D + m * q, i[3] = g * x + v * S + _ * R + y * I, i[7] = g * b + v * E + _ * P + y * O, i[11] = g * M + v * T + _ * L + y * B, i[15] = g * w + v * C + _ * D + y * q, this
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            r = t[8],
                            i = t[12],
                            a = t[1],
                            o = t[5],
                            s = t[9],
                            l = t[13],
                            A = t[2],
                            c = t[6],
                            u = t[10],
                            h = t[14];
                        return t[3] * (+i * s * c - r * l * c - i * o * u + n * l * u + r * o * h - n * s * h) + t[7] * (+e * s * h - e * l * u + i * a * u - r * a * h + r * l * A - i * s * A) + t[11] * (+e * l * c - e * o * h - i * a * c + n * a * h + i * o * A - n * l * A) + t[15] * (-r * o * A - e * s * c + e * o * u + r * a * c - n * a * u + n * s * A)
                    }
                    transpose() {
                        const t = this.elements;
                        let e;
                        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                    }
                    setPosition(t, e, n) {
                        const r = this.elements;
                        return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            r = t[2],
                            i = t[3],
                            a = t[4],
                            o = t[5],
                            s = t[6],
                            l = t[7],
                            A = t[8],
                            c = t[9],
                            u = t[10],
                            h = t[11],
                            d = t[12],
                            f = t[13],
                            p = t[14],
                            m = t[15],
                            g = c * p * l - f * u * l + f * s * h - o * p * h - c * s * m + o * u * m,
                            v = d * u * l - A * p * l - d * s * h + a * p * h + A * s * m - a * u * m,
                            _ = A * f * l - d * c * l + d * o * h - a * f * h - A * o * m + a * c * m,
                            y = d * c * s - A * f * s - d * o * u + a * f * u + A * o * p - a * c * p,
                            x = e * g + n * v + r * _ + i * y;
                        if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const b = 1 / x;
                        return t[0] = g * b, t[1] = (f * u * i - c * p * i - f * r * h + n * p * h + c * r * m - n * u * m) * b, t[2] = (o * p * i - f * s * i + f * r * l - n * p * l - o * r * m + n * s * m) * b, t[3] = (c * s * i - o * u * i - c * r * l + n * u * l + o * r * h - n * s * h) * b, t[4] = v * b, t[5] = (A * p * i - d * u * i + d * r * h - e * p * h - A * r * m + e * u * m) * b, t[6] = (d * s * i - a * p * i - d * r * l + e * p * l + a * r * m - e * s * m) * b, t[7] = (a * u * i - A * s * i + A * r * l - e * u * l - a * r * h + e * s * h) * b, t[8] = _ * b, t[9] = (d * c * i - A * f * i - d * n * h + e * f * h + A * n * m - e * c * m) * b, t[10] = (a * f * i - d * o * i + d * n * l - e * f * l - a * n * m + e * o * m) * b, t[11] = (A * o * i - a * c * i - A * n * l + e * c * l + a * n * h - e * o * h) * b, t[12] = y * b, t[13] = (A * f * r - d * c * r + d * n * u - e * f * u - A * n * p + e * c * p) * b, t[14] = (d * o * r - a * f * r - d * n * s + e * f * s + a * n * p - e * o * p) * b, t[15] = (a * c * r - A * o * r + A * n * s - e * c * s - a * n * u + e * o * u) * b, this
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            r = t.y,
                            i = t.z;
                        return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, r))
                    }
                    makeTranslation(t, e, n) {
                        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                    }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            r = Math.sin(e),
                            i = 1 - n,
                            a = t.x,
                            o = t.y,
                            s = t.z,
                            l = i * a,
                            A = i * o;
                        return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, A * o + n, A * s - r * a, 0, l * s - r * o, A * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this
                    }
                    makeScale(t, e, n) {
                        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                    }
                    makeShear(t, e, n, r, i, a) {
                        return this.set(1, n, i, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1), this
                    }
                    compose(t, e, n) {
                        const r = this.elements,
                            i = e._x,
                            a = e._y,
                            o = e._z,
                            s = e._w,
                            l = i + i,
                            A = a + a,
                            c = o + o,
                            u = i * l,
                            h = i * A,
                            d = i * c,
                            f = a * A,
                            p = a * c,
                            m = o * c,
                            g = s * l,
                            v = s * A,
                            _ = s * c,
                            y = n.x,
                            x = n.y,
                            b = n.z;
                        return r[0] = (1 - (f + m)) * y, r[1] = (h + _) * y, r[2] = (d - v) * y, r[3] = 0, r[4] = (h - _) * x, r[5] = (1 - (u + m)) * x, r[6] = (p + g) * x, r[7] = 0, r[8] = (d + v) * b, r[9] = (p - g) * b, r[10] = (1 - (u + f)) * b, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
                    }
                    decompose(t, e, n) {
                        const r = this.elements;
                        let i = ci.set(r[0], r[1], r[2]).length();
                        const a = ci.set(r[4], r[5], r[6]).length(),
                            o = ci.set(r[8], r[9], r[10]).length();
                        this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], ui.copy(this);
                        const s = 1 / i,
                            l = 1 / a,
                            A = 1 / o;
                        return ui.elements[0] *= s, ui.elements[1] *= s, ui.elements[2] *= s, ui.elements[4] *= l, ui.elements[5] *= l, ui.elements[6] *= l, ui.elements[8] *= A, ui.elements[9] *= A, ui.elements[10] *= A, e.setFromRotationMatrix(ui), n.x = i, n.y = a, n.z = o, this
                    }
                    makePerspective(t, e, n, r, i, a, o = kn) {
                        const s = this.elements,
                            l = 2 * i / (e - t),
                            A = 2 * i / (n - r),
                            c = (e + t) / (e - t),
                            u = (n + r) / (n - r);
                        let h, d;
                        if (o === kn) h = -(a + i) / (a - i), d = -2 * a * i / (a - i);
                        else {
                            if (o !== Fn) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
                            h = -a / (a - i), d = -a * i / (a - i)
                        }
                        return s[0] = l, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = A, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
                    }
                    makeOrthographic(t, e, n, r, i, a, o = kn) {
                        const s = this.elements,
                            l = 1 / (e - t),
                            A = 1 / (n - r),
                            c = 1 / (a - i),
                            u = (e + t) * l,
                            h = (n + r) * A;
                        let d, f;
                        if (o === kn) d = (a + i) * c, f = -2 * c;
                        else {
                            if (o !== Fn) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
                            d = i * c, f = -1 * c
                        }
                        return s[0] = 2 * l, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * A, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = f, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                        return this
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                    }
                }
                const ci = new Ir,
                    ui = new Ai,
                    hi = new Ir(0, 0, 0),
                    di = new Ir(1, 1, 1),
                    fi = new Ir,
                    pi = new Ir,
                    mi = new Ir,
                    gi = new Ai,
                    vi = new Dr;
                class _i {
                    constructor(t = 0, e = 0, n = 0, r = _i.DEFAULT_ORDER) {
                        this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = r
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t, this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(t) {
                        this._order = t, this._onChangeCallback()
                    }
                    set(t, e, n, r = this._order) {
                        return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    }
                    copy(t) {
                        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const r = t.elements,
                            i = r[0],
                            a = r[4],
                            o = r[8],
                            s = r[1],
                            l = r[5],
                            A = r[9],
                            c = r[2],
                            u = r[6],
                            h = r[10];
                        switch (e) {
                            case "XYZ":
                                this._y = Math.asin(Xn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-A, h), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(u, l), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-Xn(A, -1, 1)), Math.abs(A) < .9999999 ? (this._y = Math.atan2(o, h), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-c, i), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(Xn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, h), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, i));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-Xn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, h), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-a, l));
                                break;
                            case "YZX":
                                this._z = Math.asin(Xn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-A, l), this._y = Math.atan2(-c, i)) : (this._x = 0, this._y = Math.atan2(o, h));
                                break;
                            case "XZY":
                                this._z = Math.asin(-Xn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-A, h), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                        }
                        return this._order = e, !0 === n && this._onChangeCallback(), this
                    }
                    setFromQuaternion(t, e, n) {
                        return gi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(gi, e, n)
                    }
                    setFromVector3(t, e = this._order) {
                        return this.set(t.x, t.y, t.z, e)
                    }
                    reorder(t) {
                        return vi.setFromEuler(this), this.setFromQuaternion(vi, t)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                    fromArray(t) {
                        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t, this
                    }
                    _onChangeCallback() {}*[Symbol.iterator]() {
                        yield this._x, yield this._y, yield this._z, yield this._order
                    }
                }
                _i.DEFAULT_ORDER = "XYZ";
                class yi {
                    constructor() {
                        this.mask = 1
                    }
                    set(t) {
                        this.mask = (1 << t | 0) >>> 0
                    }
                    enable(t) {
                        this.mask |= 1 << t | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(t) {
                        this.mask ^= 1 << t | 0
                    }
                    disable(t) {
                        this.mask &= ~(1 << t | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(t) {
                        return 0 != (this.mask & t.mask)
                    }
                    isEnabled(t) {
                        return 0 != (this.mask & (1 << t | 0))
                    }
                }
                let xi = 0;
                const bi = new Ir,
                    Mi = new Dr,
                    wi = new Ai,
                    Si = new Ir,
                    Ei = new Ir,
                    Ti = new Ir,
                    Ci = new Dr,
                    Ri = new Ir(1, 0, 0),
                    Pi = new Ir(0, 1, 0),
                    Li = new Ir(0, 0, 1),
                    Di = {
                        type: "added"
                    },
                    Ii = {
                        type: "removed"
                    },
                    Oi = {
                        type: "childadded",
                        child: null
                    },
                    Bi = {
                        type: "childremoved",
                        child: null
                    };
                class qi extends zn {
                    constructor() {
                        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                            value: xi++
                        }), this.uuid = Wn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qi.DEFAULT_UP.clone();
                        const t = new Ir,
                            e = new _i,
                            n = new Dr,
                            r = new Ir(1, 1, 1);
                        e._onChange((function() {
                            n.setFromEuler(e, !1)
                        })), n._onChange((function() {
                            e.setFromQuaternion(n, void 0, !1)
                        })), Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: t
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: e
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: r
                            },
                            modelViewMatrix: {
                                value: new Ai
                            },
                            normalMatrix: {
                                value: new nr
                            }
                        }), this.matrix = new Ai, this.matrixWorld = new Ai, this.matrixAutoUpdate = qi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new yi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeShadow() {}
                    onAfterShadow() {}
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t), this
                    }
                    setRotationFromAxisAngle(t, e) {
                        this.quaternion.setFromAxisAngle(t, e)
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0)
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t)
                    }
                    rotateOnAxis(t, e) {
                        return Mi.setFromAxisAngle(t, e), this.quaternion.multiply(Mi), this
                    }
                    rotateOnWorldAxis(t, e) {
                        return Mi.setFromAxisAngle(t, e), this.quaternion.premultiply(Mi), this
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(Ri, t)
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(Pi, t)
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(Li, t)
                    }
                    translateOnAxis(t, e) {
                        return bi.copy(t).applyQuaternion(this.quaternion), this.position.add(bi.multiplyScalar(e)), this
                    }
                    translateX(t) {
                        return this.translateOnAxis(Ri, t)
                    }
                    translateY(t) {
                        return this.translateOnAxis(Pi, t)
                    }
                    translateZ(t) {
                        return this.translateOnAxis(Li, t)
                    }
                    localToWorld(t) {
                        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(t) {
                        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(wi.copy(this.matrixWorld).invert())
                    }
                    lookAt(t, e, n) {
                        t.isVector3 ? Si.copy(t) : Si.set(t, e, n);
                        const r = this.parent;
                        this.updateWorldMatrix(!0, !1), Ei.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? wi.lookAt(Ei, Si, this.up) : wi.lookAt(Si, Ei, this.up), this.quaternion.setFromRotationMatrix(wi), r && (wi.extractRotation(r.matrixWorld), Mi.setFromRotationMatrix(wi), this.quaternion.premultiply(Mi.invert()))
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                            return this
                        }
                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Di), Oi.child = t, this.dispatchEvent(Oi), Oi.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                            return this
                        }
                        const e = this.children.indexOf(t);
                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ii), Bi.child = t, this.dispatchEvent(Bi), Bi.child = null), this
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return null !== t && t.remove(this), this
                    }
                    clear() {
                        return this.remove(...this.children)
                    }
                    attach(t) {
                        return this.updateWorldMatrix(!0, !1), wi.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), wi.multiply(t.parent.matrixWorld)), t.applyMatrix4(wi), this.add(t), t.updateWorldMatrix(!1, !0), this
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t)
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t)
                    }
                    getObjectByProperty(t, e) {
                        if (this[t] === e) return this;
                        for (let n = 0, r = this.children.length; n < r; n++) {
                            const r = this.children[n].getObjectByProperty(t, e);
                            if (void 0 !== r) return r
                        }
                    }
                    getObjectsByProperty(t, e, n = []) {
                        this[t] === e && n.push(this);
                        const r = this.children;
                        for (let i = 0, a = r.length; i < a; i++) r[i].getObjectsByProperty(t, e, n);
                        return n
                    }
                    getWorldPosition(t) {
                        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(t) {
                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ei, t, Ti), t
                    }
                    getWorldScale(t) {
                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ei, Ci, t), t
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(e[8], e[9], e[10]).normalize()
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const e = this.children;
                        for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
                    }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                        const e = this.children;
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            !0 !== r.matrixWorldAutoUpdate && !0 !== t || r.updateMatrixWorld(t)
                        }
                    }
                    updateWorldMatrix(t, e) {
                        const n = this.parent;
                        if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                            const t = this.children;
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                            }
                        }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                            nodes: {}
                        }, n.metadata = {
                            version: 4.6,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const r = {};

                        function i(e, n) {
                            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                        }
                        if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((t => ({
                                boxInitialized: t.boxInitialized,
                                boxMin: t.box.min.toArray(),
                                boxMax: t.box.max.toArray(),
                                sphereInitialized: t.sphereInitialized,
                                sphereRadius: t.sphere.radius,
                                sphereCenter: t.sphere.center.toArray()
                            }))), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(t), null !== this.boundingSphere && (r.boundingSphere = {
                                center: r.boundingSphere.center.toArray(),
                                radius: r.boundingSphere.radius
                            }), null !== this.boundingBox && (r.boundingBox = {
                                min: r.boundingBox.min.toArray(),
                                max: r.boundingBox.max.toArray()
                            })), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            r.geometry = i(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, r = n.length; e < r; e++) {
                                        const r = n[e];
                                        i(t.shapes, r)
                                    } else i(t.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
                                r.material = e
                            } else r.material = i(t.materials, this.material);
                        if (this.children.length > 0) {
                            r.children = [];
                            for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
                        }
                        if (this.animations.length > 0) {
                            r.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                r.animations.push(i(t.animations, n))
                            }
                        }
                        if (e) {
                            const e = a(t.geometries),
                                r = a(t.materials),
                                i = a(t.textures),
                                o = a(t.images),
                                s = a(t.shapes),
                                l = a(t.skeletons),
                                A = a(t.animations),
                                c = a(t.nodes);
                            e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), s.length > 0 && (n.shapes = s), l.length > 0 && (n.skeletons = l), A.length > 0 && (n.animations = A), c.length > 0 && (n.nodes = c)
                        }
                        return n.object = r, n;

                        function a(t) {
                            const e = [];
                            for (const n in t) {
                                const r = t[n];
                                delete r.metadata, e.push(r)
                            }
                            return e
                        }
                    }
                    clone(t) {
                        return (new this.constructor).copy(this, t)
                    }
                    copy(t, e = !0) {
                        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone())
                            }
                        return this
                    }
                }
                qi.DEFAULT_UP = new Ir(0, 1, 0), qi.DEFAULT_MATRIX_AUTO_UPDATE = !0, qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                const Ui = new Ir,
                    Ni = new Ir,
                    ki = new Ir,
                    Fi = new Ir,
                    zi = new Ir,
                    Gi = new Ir,
                    ji = new Ir,
                    Vi = new Ir,
                    Hi = new Ir,
                    Wi = new Ir;
                class Xi {
                    constructor(t = new Ir, e = new Ir, n = new Ir) {
                        this.a = t, this.b = e, this.c = n
                    }
                    static getNormal(t, e, n, r) {
                        r.subVectors(n, e), Ui.subVectors(t, e), r.cross(Ui);
                        const i = r.lengthSq();
                        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                    }
                    static getBarycoord(t, e, n, r, i) {
                        Ui.subVectors(r, e), Ni.subVectors(n, e), ki.subVectors(t, e);
                        const a = Ui.dot(Ui),
                            o = Ui.dot(Ni),
                            s = Ui.dot(ki),
                            l = Ni.dot(Ni),
                            A = Ni.dot(ki),
                            c = a * l - o * o;
                        if (0 === c) return i.set(0, 0, 0), null;
                        const u = 1 / c,
                            h = (l * s - o * A) * u,
                            d = (a * A - o * s) * u;
                        return i.set(1 - h - d, d, h)
                    }
                    static containsPoint(t, e, n, r) {
                        return null !== this.getBarycoord(t, e, n, r, Fi) && Fi.x >= 0 && Fi.y >= 0 && Fi.x + Fi.y <= 1
                    }
                    static getInterpolation(t, e, n, r, i, a, o, s) {
                        return null === this.getBarycoord(t, e, n, r, Fi) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(i, Fi.x), s.addScaledVector(a, Fi.y), s.addScaledVector(o, Fi.z), s)
                    }
                    static isFrontFacing(t, e, n, r) {
                        return Ui.subVectors(n, e), Ni.subVectors(t, e), Ui.cross(Ni).dot(r) < 0
                    }
                    set(t, e, n) {
                        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                    }
                    setFromPointsAndIndices(t, e, n, r) {
                        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
                    }
                    setFromAttributeAndIndices(t, e, n, r) {
                        return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                    }
                    getArea() {
                        return Ui.subVectors(this.c, this.b), Ni.subVectors(this.a, this.b), .5 * Ui.cross(Ni).length()
                    }
                    getMidpoint(t) {
                        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(t) {
                        return Xi.getNormal(this.a, this.b, this.c, t)
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(t, e) {
                        return Xi.getBarycoord(t, this.a, this.b, this.c, e)
                    }
                    getInterpolation(t, e, n, r, i) {
                        return Xi.getInterpolation(t, this.a, this.b, this.c, e, n, r, i)
                    }
                    containsPoint(t) {
                        return Xi.containsPoint(t, this.a, this.b, this.c)
                    }
                    isFrontFacing(t) {
                        return Xi.isFrontFacing(this.a, this.b, this.c, t)
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this)
                    }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            r = this.b,
                            i = this.c;
                        let a, o;
                        zi.subVectors(r, n), Gi.subVectors(i, n), Vi.subVectors(t, n);
                        const s = zi.dot(Vi),
                            l = Gi.dot(Vi);
                        if (s <= 0 && l <= 0) return e.copy(n);
                        Hi.subVectors(t, r);
                        const A = zi.dot(Hi),
                            c = Gi.dot(Hi);
                        if (A >= 0 && c <= A) return e.copy(r);
                        const u = s * c - A * l;
                        if (u <= 0 && s >= 0 && A <= 0) return a = s / (s - A), e.copy(n).addScaledVector(zi, a);
                        Wi.subVectors(t, i);
                        const h = zi.dot(Wi),
                            d = Gi.dot(Wi);
                        if (d >= 0 && h <= d) return e.copy(i);
                        const f = h * l - s * d;
                        if (f <= 0 && l >= 0 && d <= 0) return o = l / (l - d), e.copy(n).addScaledVector(Gi, o);
                        const p = A * d - h * c;
                        if (p <= 0 && c - A >= 0 && h - d >= 0) return ji.subVectors(i, r), o = (c - A) / (c - A + (h - d)), e.copy(r).addScaledVector(ji, o);
                        const m = 1 / (p + f + u);
                        return a = f * m, o = u * m, e.copy(n).addScaledVector(zi, a).addScaledVector(Gi, o)
                    }
                    equals(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }
                const Yi = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    },
                    Qi = {
                        h: 0,
                        s: 0,
                        l: 0
                    },
                    Zi = {
                        h: 0,
                        s: 0,
                        l: 0
                    };

                function Ji(t, e, n) {
                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                }
                class Ki {
                    constructor(t, e, n) {
                        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
                    }
                    set(t, e, n) {
                        if (void 0 === e && void 0 === n) {
                            const e = t;
                            e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                        } else this.setRGB(t, e, n);
                        return this
                    }
                    setScalar(t) {
                        return this.r = t, this.g = t, this.b = t, this
                    }
                    setHex(t, e = Ye) {
                        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, pr.toWorkingColorSpace(this, e), this
                    }
                    setRGB(t, e, n, r = pr.workingColorSpace) {
                        return this.r = t, this.g = e, this.b = n, pr.toWorkingColorSpace(this, r), this
                    }
                    setHSL(t, e, n, r = pr.workingColorSpace) {
                        if (t = Yn(t, 1), e = Xn(e, 0, 1), n = Xn(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                        else {
                            const r = n <= .5 ? n * (1 + e) : n + e - n * e,
                                i = 2 * n - r;
                            this.r = Ji(i, r, t + 1 / 3), this.g = Ji(i, r, t), this.b = Ji(i, r, t - 1 / 3)
                        }
                        return pr.toWorkingColorSpace(this, r), this
                    }
                    setStyle(t, e = Ye) {
                        function n(e) {
                            void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                        }
                        let r;
                        if (r = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                            let i;
                            const a = r[1],
                                o = r[2];
                            switch (a) {
                                case "rgb":
                                case "rgba":
                                    if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(i[4]), this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, e);
                                    if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(i[4]), this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, e);
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(i[4]), this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, e);
                                    break;
                                default:
                                    console.warn("THREE.Color: Unknown color model " + t)
                            }
                        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const n = r[1],
                                i = n.length;
                            if (3 === i) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, e);
                            if (6 === i) return this.setHex(parseInt(n, 16), e);
                            console.warn("THREE.Color: Invalid hex color " + t)
                        } else if (t && t.length > 0) return this.setColorName(t, e);
                        return this
                    }
                    setColorName(t, e = Ye) {
                        const n = Yi[t.toLowerCase()];
                        return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b)
                    }
                    copy(t) {
                        return this.r = t.r, this.g = t.g, this.b = t.b, this
                    }
                    copySRGBToLinear(t) {
                        return this.r = mr(t.r), this.g = mr(t.g), this.b = mr(t.b), this
                    }
                    copyLinearToSRGB(t) {
                        return this.r = gr(t.r), this.g = gr(t.g), this.b = gr(t.b), this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this), this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this), this
                    }
                    getHex(t = Ye) {
                        return pr.fromWorkingColorSpace($i.copy(this), t), 65536 * Math.round(Xn(255 * $i.r, 0, 255)) + 256 * Math.round(Xn(255 * $i.g, 0, 255)) + Math.round(Xn(255 * $i.b, 0, 255))
                    }
                    getHexString(t = Ye) {
                        return ("000000" + this.getHex(t).toString(16)).slice(-6)
                    }
                    getHSL(t, e = pr.workingColorSpace) {
                        pr.fromWorkingColorSpace($i.copy(this), e);
                        const n = $i.r,
                            r = $i.g,
                            i = $i.b,
                            a = Math.max(n, r, i),
                            o = Math.min(n, r, i);
                        let s, l;
                        const A = (o + a) / 2;
                        if (o === a) s = 0, l = 0;
                        else {
                            const t = a - o;
                            switch (l = A <= .5 ? t / (a + o) : t / (2 - a - o), a) {
                                case n:
                                    s = (r - i) / t + (r < i ? 6 : 0);
                                    break;
                                case r:
                                    s = (i - n) / t + 2;
                                    break;
                                case i:
                                    s = (n - r) / t + 4
                            }
                            s /= 6
                        }
                        return t.h = s, t.s = l, t.l = A, t
                    }
                    getRGB(t, e = pr.workingColorSpace) {
                        return pr.fromWorkingColorSpace($i.copy(this), e), t.r = $i.r, t.g = $i.g, t.b = $i.b, t
                    }
                    getStyle(t = Ye) {
                        pr.fromWorkingColorSpace($i.copy(this), t);
                        const e = $i.r,
                            n = $i.g,
                            r = $i.b;
                        return t !== Ye ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*r)})`
                    }
                    offsetHSL(t, e, n) {
                        return this.getHSL(Qi), this.setHSL(Qi.h + t, Qi.s + e, Qi.l + n)
                    }
                    add(t) {
                        return this.r += t.r, this.g += t.g, this.b += t.b, this
                    }
                    addColors(t, e) {
                        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                    }
                    addScalar(t) {
                        return this.r += t, this.g += t, this.b += t, this
                    }
                    sub(t) {
                        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                    }
                    multiply(t) {
                        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                    }
                    multiplyScalar(t) {
                        return this.r *= t, this.g *= t, this.b *= t, this
                    }
                    lerp(t, e) {
                        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                    }
                    lerpColors(t, e, n) {
                        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                    }
                    lerpHSL(t, e) {
                        this.getHSL(Qi), t.getHSL(Zi);
                        const n = Qn(Qi.h, Zi.h, e),
                            r = Qn(Qi.s, Zi.s, e),
                            i = Qn(Qi.l, Zi.l, e);
                        return this.setHSL(n, r, i), this
                    }
                    setFromVector3(t) {
                        return this.r = t.x, this.g = t.y, this.b = t.z, this
                    }
                    applyMatrix3(t) {
                        const e = this.r,
                            n = this.g,
                            r = this.b,
                            i = t.elements;
                        return this.r = i[0] * e + i[3] * n + i[6] * r, this.g = i[1] * e + i[4] * n + i[7] * r, this.b = i[2] * e + i[5] * n + i[8] * r, this
                    }
                    equals(t) {
                        return t.r === this.r && t.g === this.g && t.b === this.b
                    }
                    fromArray(t, e = 0) {
                        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                    }
                    fromBufferAttribute(t, e) {
                        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
                    }
                    toJSON() {
                        return this.getHex()
                    }*[Symbol.iterator]() {
                        yield this.r, yield this.g, yield this.b
                    }
                }
                const $i = new Ki;
                Ki.NAMES = Yi;
                let ta = 0;
                class ea extends zn {
                    constructor() {
                        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                            value: ta++
                        }), this.uuid = Wn(), this.name = "", this.type = "Material", this.blending = v, this.side = f, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = D, this.blendDst = I, this.blendEquation = M, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ki(0, 0, 0), this.blendAlpha = 0, this.depthFunc = W, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = vn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = rn, this.stencilZFail = rn, this.stencilZPass = rn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(t) {
                        this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                    }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) {
                                    console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                                    continue
                                }
                                const r = this[e];
                                void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.6,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };

                        function r(t) {
                            const e = [];
                            for (const n in t) {
                                const r = t[n];
                                delete r.metadata, e.push(r)
                            }
                            return e
                        }
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== v && (n.blending = this.blending), this.side !== f && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), this.blendSrc !== D && (n.blendSrc = this.blendSrc), this.blendDst !== I && (n.blendDst = this.blendDst), this.blendEquation !== M && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), this.depthFunc !== W && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== vn && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== rn && (n.stencilFail = this.stencilFail), this.stencilZFail !== rn && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== rn && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
                            const e = r(t.textures),
                                i = r(t.images);
                            e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
                        }
                        return n
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
                        }
                        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                }
                class na extends ea {
                    constructor(t) {
                        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ki(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new _i, this.combine = J, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
                    }
                }
                const ra = ia();

                function ia() {
                    const t = new ArrayBuffer(4),
                        e = new Float32Array(t),
                        n = new Uint32Array(t),
                        r = new Uint32Array(512),
                        i = new Uint32Array(512);
                    for (let t = 0; t < 256; ++t) {
                        const e = t - 127;
                        e < -27 ? (r[t] = 0, r[256 | t] = 32768, i[t] = 24, i[256 | t] = 24) : e < -14 ? (r[t] = 1024 >> -e - 14, r[256 | t] = 1024 >> -e - 14 | 32768, i[t] = -e - 1, i[256 | t] = -e - 1) : e <= 15 ? (r[t] = e + 15 << 10, r[256 | t] = e + 15 << 10 | 32768, i[t] = 13, i[256 | t] = 13) : e < 128 ? (r[t] = 31744, r[256 | t] = 64512, i[t] = 24, i[256 | t] = 24) : (r[t] = 31744, r[256 | t] = 64512, i[t] = 13, i[256 | t] = 13)
                    }
                    const a = new Uint32Array(2048),
                        o = new Uint32Array(64),
                        s = new Uint32Array(64);
                    for (let t = 1; t < 1024; ++t) {
                        let e = t << 13,
                            n = 0;
                        for (; 0 == (8388608 & e);) e <<= 1, n -= 8388608;
                        e &= -8388609, n += 947912704, a[t] = e | n
                    }
                    for (let t = 1024; t < 2048; ++t) a[t] = 939524096 + (t - 1024 << 13);
                    for (let t = 1; t < 31; ++t) o[t] = t << 23;
                    o[31] = 1199570944, o[32] = 2147483648;
                    for (let t = 33; t < 63; ++t) o[t] = 2147483648 + (t - 32 << 23);
                    o[63] = 3347054592;
                    for (let t = 1; t < 64; ++t) 32 !== t && (s[t] = 1024);
                    return {
                        floatView: e,
                        uint32View: n,
                        baseTable: r,
                        shiftTable: i,
                        mantissaTable: a,
                        exponentTable: o,
                        offsetTable: s
                    }
                }

                function aa(t) {
                    Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = Xn(t, -65504, 65504), ra.floatView[0] = t;
                    const e = ra.uint32View[0],
                        n = e >> 23 & 511;
                    return ra.baseTable[n] + ((8388607 & e) >> ra.shiftTable[n])
                }

                function oa(t) {
                    const e = t >> 10;
                    return ra.uint32View[0] = ra.mantissaTable[ra.offsetTable[e] + (1023 & t)] + ra.exponentTable[e], ra.floatView[0]
                }
                const sa = {
                        toHalfFloat: aa,
                        fromHalfFloat: oa
                    },
                    la = new Ir,
                    Aa = new er;
                class ca {
                    constructor(t, e, n = !1) {
                        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = Tn, this._updateRange = {
                            offset: 0,
                            count: -1
                        }, this.updateRanges = [], this.gpuType = Bt, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    get updateRange() {
                        return cr("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    addUpdateRange(t, e) {
                        this.updateRanges.push({
                            start: t,
                            count: e
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(t) {
                        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
                    }
                    copyAt(t, e, n) {
                        t *= this.itemSize, n *= e.itemSize;
                        for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
                        return this
                    }
                    copyArray(t) {
                        return this.array.set(t), this
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Aa.fromBufferAttribute(this, e), Aa.applyMatrix3(t), this.setXY(e, Aa.x, Aa.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) la.fromBufferAttribute(this, e), la.applyMatrix3(t), this.setXYZ(e, la.x, la.y, la.z);
                        return this
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.count; e < n; e++) la.fromBufferAttribute(this, e), la.applyMatrix4(t), this.setXYZ(e, la.x, la.y, la.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++) la.fromBufferAttribute(this, e), la.applyNormalMatrix(t), this.setXYZ(e, la.x, la.y, la.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++) la.fromBufferAttribute(this, e), la.transformDirection(t), this.setXYZ(e, la.x, la.y, la.z);
                        return this
                    }
                    set(t, e = 0) {
                        return this.array.set(t, e), this
                    }
                    getComponent(t, e) {
                        let n = this.array[t * this.itemSize + e];
                        return this.normalized && (n = Kn(n, this.array)), n
                    }
                    setComponent(t, e, n) {
                        return this.normalized && (n = $n(n, this.array)), this.array[t * this.itemSize + e] = n, this
                    }
                    getX(t) {
                        let e = this.array[t * this.itemSize];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setX(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize] = e, this
                    }
                    getY(t) {
                        let e = this.array[t * this.itemSize + 1];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setY(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize + 1] = e, this
                    }
                    getZ(t) {
                        let e = this.array[t * this.itemSize + 2];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setZ(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize + 2] = e, this
                    }
                    getW(t) {
                        let e = this.array[t * this.itemSize + 3];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setW(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize + 3] = e, this
                    }
                    setXY(t, e, n) {
                        return t *= this.itemSize, this.normalized && (e = $n(e, this.array), n = $n(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
                    }
                    setXYZ(t, e, n, r) {
                        return t *= this.itemSize, this.normalized && (e = $n(e, this.array), n = $n(n, this.array), r = $n(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
                    }
                    setXYZW(t, e, n, r, i) {
                        return t *= this.itemSize, this.normalized && (e = $n(e, this.array), n = $n(n, this.array), r = $n(r, this.array), i = $n(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t, this
                    }
                    clone() {
                        return new this.constructor(this.array, this.itemSize).copy(this)
                    }
                    toJSON() {
                        const t = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        return "" !== this.name && (t.name = this.name), this.usage !== Tn && (t.usage = this.usage), t
                    }
                }
                class ua extends ca {
                    constructor(t, e, n) {
                        super(new Int8Array(t), e, n)
                    }
                }
                class ha extends ca {
                    constructor(t, e, n) {
                        super(new Uint8Array(t), e, n)
                    }
                }
                class da extends ca {
                    constructor(t, e, n) {
                        super(new Uint8ClampedArray(t), e, n)
                    }
                }
                class fa extends ca {
                    constructor(t, e, n) {
                        super(new Int16Array(t), e, n)
                    }
                }
                class pa extends ca {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n)
                    }
                }
                class ma extends ca {
                    constructor(t, e, n) {
                        super(new Int32Array(t), e, n)
                    }
                }
                class ga extends ca {
                    constructor(t, e, n) {
                        super(new Uint32Array(t), e, n)
                    }
                }
                class va extends ca {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n), this.isFloat16BufferAttribute = !0
                    }
                    getX(t) {
                        let e = oa(this.array[t * this.itemSize]);
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setX(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize] = aa(e), this
                    }
                    getY(t) {
                        let e = oa(this.array[t * this.itemSize + 1]);
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setY(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize + 1] = aa(e), this
                    }
                    getZ(t) {
                        let e = oa(this.array[t * this.itemSize + 2]);
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setZ(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize + 2] = aa(e), this
                    }
                    getW(t) {
                        let e = oa(this.array[t * this.itemSize + 3]);
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setW(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.array[t * this.itemSize + 3] = aa(e), this
                    }
                    setXY(t, e, n) {
                        return t *= this.itemSize, this.normalized && (e = $n(e, this.array), n = $n(n, this.array)), this.array[t + 0] = aa(e), this.array[t + 1] = aa(n), this
                    }
                    setXYZ(t, e, n, r) {
                        return t *= this.itemSize, this.normalized && (e = $n(e, this.array), n = $n(n, this.array), r = $n(r, this.array)), this.array[t + 0] = aa(e), this.array[t + 1] = aa(n), this.array[t + 2] = aa(r), this
                    }
                    setXYZW(t, e, n, r, i) {
                        return t *= this.itemSize, this.normalized && (e = $n(e, this.array), n = $n(n, this.array), r = $n(r, this.array), i = $n(i, this.array)), this.array[t + 0] = aa(e), this.array[t + 1] = aa(n), this.array[t + 2] = aa(r), this.array[t + 3] = aa(i), this
                    }
                }
                class _a extends ca {
                    constructor(t, e, n) {
                        super(new Float32Array(t), e, n)
                    }
                }
                let ya = 0;
                const xa = new Ai,
                    ba = new qi,
                    Ma = new Ir,
                    wa = new qr,
                    Sa = new qr,
                    Ea = new Ir;
                class Ta extends zn {
                    constructor() {
                        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                            value: ya++
                        }), this.uuid = Wn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        }, this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(t) {
                        return Array.isArray(t) ? this.index = new(ir(t) ? ga : pa)(t, 1) : this.index = t, this
                    }
                    getAttribute(t) {
                        return this.attributes[t]
                    }
                    setAttribute(t, e) {
                        return this.attributes[t] = e, this
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t], this
                    }
                    hasAttribute(t) {
                        return void 0 !== this.attributes[t]
                    }
                    addGroup(t, e, n = 0) {
                        this.groups.push({
                            start: t,
                            count: e,
                            materialIndex: n
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(t, e) {
                        this.drawRange.start = t, this.drawRange.count = e
                    }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = (new nr).getNormalMatrix(t);
                            n.applyNormalMatrix(e), n.needsUpdate = !0
                        }
                        const r = this.attributes.tangent;
                        return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(t) {
                        return xa.makeRotationFromQuaternion(t), this.applyMatrix4(xa), this
                    }
                    rotateX(t) {
                        return xa.makeRotationX(t), this.applyMatrix4(xa), this
                    }
                    rotateY(t) {
                        return xa.makeRotationY(t), this.applyMatrix4(xa), this
                    }
                    rotateZ(t) {
                        return xa.makeRotationZ(t), this.applyMatrix4(xa), this
                    }
                    translate(t, e, n) {
                        return xa.makeTranslation(t, e, n), this.applyMatrix4(xa), this
                    }
                    scale(t, e, n) {
                        return xa.makeScale(t, e, n), this.applyMatrix4(xa), this
                    }
                    lookAt(t) {
                        return ba.lookAt(t), ba.updateMatrix(), this.applyMatrix4(ba.matrix), this
                    }
                    center() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(Ma).negate(), this.translate(Ma.x, Ma.y, Ma.z), this
                    }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, r = t.length; n < r; n++) {
                            const r = t[n];
                            e.push(r.x, r.y, r.z || 0)
                        }
                        return this.setAttribute("position", new _a(e, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new qr);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new Ir(-1 / 0, -1 / 0, -1 / 0), new Ir(1 / 0, 1 / 0, 1 / 0));
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    wa.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ea.addVectors(this.boundingBox.min, wa.min), this.boundingBox.expandByPoint(Ea), Ea.addVectors(this.boundingBox.max, wa.max), this.boundingBox.expandByPoint(Ea)) : (this.boundingBox.expandByPoint(wa.min), this.boundingBox.expandByPoint(wa.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new ti);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new Ir, 1 / 0);
                        if (t) {
                            const n = this.boundingSphere.center;
                            if (wa.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    Sa.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ea.addVectors(wa.min, Sa.min), wa.expandByPoint(Ea), Ea.addVectors(wa.max, Sa.max), wa.expandByPoint(Ea)) : (wa.expandByPoint(Sa.min), wa.expandByPoint(Sa.max))
                                }
                            wa.getCenter(n);
                            let r = 0;
                            for (let e = 0, i = t.count; e < i; e++) Ea.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(Ea));
                            if (e)
                                for (let i = 0, a = e.length; i < a; i++) {
                                    const a = e[i],
                                        o = this.morphTargetsRelative;
                                    for (let e = 0, i = a.count; e < i; e++) Ea.fromBufferAttribute(a, e), o && (Ma.fromBufferAttribute(t, e), Ea.add(Ma)), r = Math.max(r, n.distanceToSquared(Ea))
                                }
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = e.position,
                            r = e.normal,
                            i = e.uv;
                        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new ca(new Float32Array(4 * n.count), 4));
                        const a = this.getAttribute("tangent"),
                            o = [],
                            s = [];
                        for (let t = 0; t < n.count; t++) o[t] = new Ir, s[t] = new Ir;
                        const l = new Ir,
                            A = new Ir,
                            c = new Ir,
                            u = new er,
                            h = new er,
                            d = new er,
                            f = new Ir,
                            p = new Ir;

                        function m(t, e, r) {
                            l.fromBufferAttribute(n, t), A.fromBufferAttribute(n, e), c.fromBufferAttribute(n, r), u.fromBufferAttribute(i, t), h.fromBufferAttribute(i, e), d.fromBufferAttribute(i, r), A.sub(l), c.sub(l), h.sub(u), d.sub(u);
                            const a = 1 / (h.x * d.y - d.x * h.y);
                            isFinite(a) && (f.copy(A).multiplyScalar(d.y).addScaledVector(c, -h.y).multiplyScalar(a), p.copy(c).multiplyScalar(h.x).addScaledVector(A, -d.x).multiplyScalar(a), o[t].add(f), o[e].add(f), o[r].add(f), s[t].add(p), s[e].add(p), s[r].add(p))
                        }
                        let g = this.groups;
                        0 === g.length && (g = [{
                            start: 0,
                            count: t.count
                        }]);
                        for (let e = 0, n = g.length; e < n; ++e) {
                            const n = g[e],
                                r = n.start;
                            for (let e = r, i = r + n.count; e < i; e += 3) m(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
                        }
                        const v = new Ir,
                            _ = new Ir,
                            y = new Ir,
                            x = new Ir;

                        function b(t) {
                            y.fromBufferAttribute(r, t), x.copy(y);
                            const e = o[t];
                            v.copy(e), v.sub(y.multiplyScalar(y.dot(e))).normalize(), _.crossVectors(x, e);
                            const n = _.dot(s[t]) < 0 ? -1 : 1;
                            a.setXYZW(t, v.x, v.y, v.z, n)
                        }
                        for (let e = 0, n = g.length; e < n; ++e) {
                            const n = g[e],
                                r = n.start;
                            for (let e = r, i = r + n.count; e < i; e += 3) b(t.getX(e + 0)), b(t.getX(e + 1)), b(t.getX(e + 2))
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n) n = new ca(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                            const r = new Ir,
                                i = new Ir,
                                a = new Ir,
                                o = new Ir,
                                s = new Ir,
                                l = new Ir,
                                A = new Ir,
                                c = new Ir;
                            if (t)
                                for (let u = 0, h = t.count; u < h; u += 3) {
                                    const h = t.getX(u + 0),
                                        d = t.getX(u + 1),
                                        f = t.getX(u + 2);
                                    r.fromBufferAttribute(e, h), i.fromBufferAttribute(e, d), a.fromBufferAttribute(e, f), A.subVectors(a, i), c.subVectors(r, i), A.cross(c), o.fromBufferAttribute(n, h), s.fromBufferAttribute(n, d), l.fromBufferAttribute(n, f), o.add(A), s.add(A), l.add(A), n.setXYZ(h, o.x, o.y, o.z), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(f, l.x, l.y, l.z)
                                } else
                                    for (let t = 0, o = e.count; t < o; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), a.fromBufferAttribute(e, t + 2), A.subVectors(a, i), c.subVectors(r, i), A.cross(c), n.setXYZ(t + 0, A.x, A.y, A.z), n.setXYZ(t + 1, A.x, A.y, A.z), n.setXYZ(t + 2, A.x, A.y, A.z);
                            this.normalizeNormals(), n.needsUpdate = !0
                        }
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let e = 0, n = t.count; e < n; e++) Ea.fromBufferAttribute(t, e), Ea.normalize(), t.setXYZ(e, Ea.x, Ea.y, Ea.z)
                    }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                r = t.itemSize,
                                i = t.normalized,
                                a = new n.constructor(e.length * r);
                            let o = 0,
                                s = 0;
                            for (let i = 0, l = e.length; i < l; i++) {
                                o = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
                                for (let t = 0; t < r; t++) a[s++] = n[o++]
                            }
                            return new ca(a, r, i)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        const e = new Ta,
                            n = this.index.array,
                            r = this.attributes;
                        for (const i in r) {
                            const a = t(r[i], n);
                            e.setAttribute(i, a)
                        }
                        const i = this.morphAttributes;
                        for (const r in i) {
                            const a = [],
                                o = i[r];
                            for (let e = 0, r = o.length; e < r; e++) {
                                const r = t(o[e], n);
                                a.push(r)
                            }
                            e.morphAttributes[r] = a
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const a = this.groups;
                        for (let t = 0, n = a.length; t < n; t++) {
                            const n = a[t];
                            e.addGroup(n.start, n.count, n.materialIndex)
                        }
                        return e
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.6,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                            const e = this.parameters;
                            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        const e = this.index;
                        null !== e && (t.data.index = {
                            type: e.array.constructor.name,
                            array: Array.prototype.slice.call(e.array)
                        });
                        const n = this.attributes;
                        for (const e in n) {
                            const r = n[e];
                            t.data.attributes[e] = r.toJSON(t.data)
                        }
                        const r = {};
                        let i = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                a = [];
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                a.push(r.toJSON(t.data))
                            }
                            a.length > 0 && (r[e] = a, i = !0)
                        }
                        i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const a = this.groups;
                        a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
                        const o = this.boundingSphere;
                        return null !== o && (t.data.boundingSphere = {
                            center: o.center.toArray(),
                            radius: o.radius
                        }), t
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const r = t.attributes;
                        for (const t in r) {
                            const n = r[t];
                            this.setAttribute(t, n.clone(e))
                        }
                        const i = t.morphAttributes;
                        for (const t in i) {
                            const n = [],
                                r = i[t];
                            for (let t = 0, i = r.length; t < i; t++) n.push(r[t].clone(e));
                            this.morphAttributes[t] = n
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const a = t.groups;
                        for (let t = 0, e = a.length; t < e; t++) {
                            const e = a[t];
                            this.addGroup(e.start, e.count, e.materialIndex)
                        }
                        const o = t.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const s = t.boundingSphere;
                        return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                const Ca = new Ai,
                    Ra = new li,
                    Pa = new ti,
                    La = new Ir,
                    Da = new Ir,
                    Ia = new Ir,
                    Oa = new Ir,
                    Ba = new Ir,
                    qa = new Ir,
                    Ua = new er,
                    Na = new er,
                    ka = new er,
                    Fa = new Ir,
                    za = new Ir,
                    Ga = new Ir,
                    ja = new Ir,
                    Va = new Ir;
                class Ha extends qi {
                    constructor(t = new Ta, e = new na) {
                        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t, e) {
                        return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                }
                            }
                        }
                    }
                    getVertexPosition(t, e) {
                        const n = this.geometry,
                            r = n.attributes.position,
                            i = n.morphAttributes.position,
                            a = n.morphTargetsRelative;
                        e.fromBufferAttribute(r, t);
                        const o = this.morphTargetInfluences;
                        if (i && o) {
                            qa.set(0, 0, 0);
                            for (let n = 0, r = i.length; n < r; n++) {
                                const r = o[n],
                                    s = i[n];
                                0 !== r && (Ba.fromBufferAttribute(s, t), a ? qa.addScaledVector(Ba, r) : qa.addScaledVector(Ba.sub(e), r))
                            }
                            e.add(qa)
                        }
                        return e
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            r = this.material,
                            i = this.matrixWorld;
                        if (void 0 !== r) {
                            if (null === n.boundingSphere && n.computeBoundingSphere(), Pa.copy(n.boundingSphere), Pa.applyMatrix4(i), Ra.copy(t.ray).recast(t.near), !1 === Pa.containsPoint(Ra.origin)) {
                                if (null === Ra.intersectSphere(Pa, La)) return;
                                if (Ra.origin.distanceToSquared(La) > (t.far - t.near) ** 2) return
                            }
                            Ca.copy(i).invert(), Ra.copy(t.ray).applyMatrix4(Ca), null !== n.boundingBox && !1 === Ra.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, Ra)
                        }
                    }
                    _computeIntersections(t, e, n) {
                        let r;
                        const i = this.geometry,
                            a = this.material,
                            o = i.index,
                            s = i.attributes.position,
                            l = i.attributes.uv,
                            A = i.attributes.uv1,
                            c = i.attributes.normal,
                            u = i.groups,
                            h = i.drawRange;
                        if (null !== o)
                            if (Array.isArray(a))
                                for (let i = 0, s = u.length; i < s; i++) {
                                    const s = u[i],
                                        d = a[s.materialIndex];
                                    for (let i = Math.max(s.start, h.start), a = Math.min(o.count, Math.min(s.start + s.count, h.start + h.count)); i < a; i += 3) r = Wa(this, d, t, n, l, A, c, o.getX(i), o.getX(i + 1), o.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = s.materialIndex, e.push(r))
                                } else
                                    for (let i = Math.max(0, h.start), s = Math.min(o.count, h.start + h.count); i < s; i += 3) r = Wa(this, a, t, n, l, A, c, o.getX(i), o.getX(i + 1), o.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), e.push(r));
                            else if (void 0 !== s)
                            if (Array.isArray(a))
                                for (let i = 0, o = u.length; i < o; i++) {
                                    const o = u[i],
                                        d = a[o.materialIndex];
                                    for (let i = Math.max(o.start, h.start), a = Math.min(s.count, Math.min(o.start + o.count, h.start + h.count)); i < a; i += 3) r = Wa(this, d, t, n, l, A, c, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = o.materialIndex, e.push(r))
                                } else
                                    for (let i = Math.max(0, h.start), o = Math.min(s.count, h.start + h.count); i < o; i += 3) r = Wa(this, a, t, n, l, A, c, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), e.push(r))
                    }
                }

                function Wa(t, e, n, r, i, a, o, s, l, A) {
                    t.getVertexPosition(s, Da), t.getVertexPosition(l, Ia), t.getVertexPosition(A, Oa);
                    const c = function(t, e, n, r, i, a, o, s) {
                        let l;
                        if (l = e.side === p ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, e.side === f, s), null === l) return null;
                        Va.copy(s), Va.applyMatrix4(t.matrixWorld);
                        const A = n.ray.origin.distanceTo(Va);
                        return A < n.near || A > n.far ? null : {
                            distance: A,
                            point: Va.clone(),
                            object: t
                        }
                    }(t, e, n, r, Da, Ia, Oa, ja);
                    if (c) {
                        i && (Ua.fromBufferAttribute(i, s), Na.fromBufferAttribute(i, l), ka.fromBufferAttribute(i, A), c.uv = Xi.getInterpolation(ja, Da, Ia, Oa, Ua, Na, ka, new er)), a && (Ua.fromBufferAttribute(a, s), Na.fromBufferAttribute(a, l), ka.fromBufferAttribute(a, A), c.uv1 = Xi.getInterpolation(ja, Da, Ia, Oa, Ua, Na, ka, new er)), o && (Fa.fromBufferAttribute(o, s), za.fromBufferAttribute(o, l), Ga.fromBufferAttribute(o, A), c.normal = Xi.getInterpolation(ja, Da, Ia, Oa, Fa, za, Ga, new Ir), c.normal.dot(r.direction) > 0 && c.normal.multiplyScalar(-1));
                        const t = {
                            a: s,
                            b: l,
                            c: A,
                            normal: new Ir,
                            materialIndex: 0
                        };
                        Xi.getNormal(Da, Ia, Oa, t.normal), c.face = t
                    }
                    return c
                }
                class Xa extends Ta {
                    constructor(t = 1, e = 1, n = 1, r = 1, i = 1, a = 1) {
                        super(), this.type = "BoxGeometry", this.parameters = {
                            width: t,
                            height: e,
                            depth: n,
                            widthSegments: r,
                            heightSegments: i,
                            depthSegments: a
                        };
                        const o = this;
                        r = Math.floor(r), i = Math.floor(i), a = Math.floor(a);
                        const s = [],
                            l = [],
                            A = [],
                            c = [];
                        let u = 0,
                            h = 0;

                        function d(t, e, n, r, i, a, d, f, p, m, g) {
                            const v = a / p,
                                _ = d / m,
                                y = a / 2,
                                x = d / 2,
                                b = f / 2,
                                M = p + 1,
                                w = m + 1;
                            let S = 0,
                                E = 0;
                            const T = new Ir;
                            for (let a = 0; a < w; a++) {
                                const o = a * _ - x;
                                for (let s = 0; s < M; s++) {
                                    const u = s * v - y;
                                    T[t] = u * r, T[e] = o * i, T[n] = b, l.push(T.x, T.y, T.z), T[t] = 0, T[e] = 0, T[n] = f > 0 ? 1 : -1, A.push(T.x, T.y, T.z), c.push(s / p), c.push(1 - a / m), S += 1
                                }
                            }
                            for (let t = 0; t < m; t++)
                                for (let e = 0; e < p; e++) {
                                    const n = u + e + M * t,
                                        r = u + e + M * (t + 1),
                                        i = u + (e + 1) + M * (t + 1),
                                        a = u + (e + 1) + M * t;
                                    s.push(n, r, a), s.push(r, i, a), E += 6
                                }
                            o.addGroup(h, E, g), h += E, u += S
                        }
                        d("z", "y", "x", -1, -1, n, e, t, a, i, 0), d("z", "y", "x", 1, -1, n, e, -t, a, i, 1), d("x", "z", "y", 1, 1, t, n, e, r, a, 2), d("x", "z", "y", 1, -1, t, n, -e, r, a, 3), d("x", "y", "z", 1, -1, t, e, n, r, i, 4), d("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(s), this.setAttribute("position", new _a(l, 3)), this.setAttribute("normal", new _a(A, 3)), this.setAttribute("uv", new _a(c, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new Xa(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                    }
                }

                function Ya(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const r in t[n]) {
                            const i = t[n][r];
                            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][r] = null) : e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                        }
                    }
                    return e
                }

                function Qa(t) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const r = Ya(t[n]);
                        for (const t in r) e[t] = r[t]
                    }
                    return e
                }

                function Za(t) {
                    return null === t.getRenderTarget() ? t.outputColorSpace : pr.workingColorSpace
                }
                const Ja = {
                    clone: Ya,
                    merge: Qa
                };
                class Ka extends ea {
                    constructor(t) {
                        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1,
                            clipCullDistance: !1,
                            multiDraw: !1
                        }, this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv1: [0, 0]
                        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ya(t.uniforms), this.uniformsGroups = function(t) {
                            const e = [];
                            for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                            return e
                        }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion, e.uniforms = {};
                        for (const n in this.uniforms) {
                            const r = this.uniforms[n].value;
                            r && r.isTexture ? e.uniforms[n] = {
                                type: "t",
                                value: r.toJSON(t).uuid
                            } : r && r.isColor ? e.uniforms[n] = {
                                type: "c",
                                value: r.getHex()
                            } : r && r.isVector2 ? e.uniforms[n] = {
                                type: "v2",
                                value: r.toArray()
                            } : r && r.isVector3 ? e.uniforms[n] = {
                                type: "v3",
                                value: r.toArray()
                            } : r && r.isVector4 ? e.uniforms[n] = {
                                type: "v4",
                                value: r.toArray()
                            } : r && r.isMatrix3 ? e.uniforms[n] = {
                                type: "m3",
                                value: r.toArray()
                            } : r && r.isMatrix4 ? e.uniforms[n] = {
                                type: "m4",
                                value: r.toArray()
                            } : e.uniforms[n] = {
                                value: r
                            }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                        const n = {};
                        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n), e
                    }
                }
                class $a extends qi {
                    constructor() {
                        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ai, this.projectionMatrix = new Ai, this.projectionMatrixInverse = new Ai, this.coordinateSystem = kn
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
                    }
                    getWorldDirection(t) {
                        return super.getWorldDirection(t).negate()
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(t, e) {
                        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const to = new Ir,
                    eo = new er,
                    no = new er;
                class ro extends $a {
                    constructor(t = 50, e = 1, n = .1, r = 2e3) {
                        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                    }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * Hn * Math.atan(e), this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const t = Math.tan(.5 * Vn * this.fov);
                        return .5 * this.getFilmHeight() / t
                    }
                    getEffectiveFOV() {
                        return 2 * Hn * Math.atan(Math.tan(.5 * Vn * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    getViewBounds(t, e, n) {
                        to.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(to.x, to.y).multiplyScalar(-t / to.z), to.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(to.x, to.y).multiplyScalar(-t / to.z)
                    }
                    getViewSize(t, e) {
                        return this.getViewBounds(t, eo, no), e.subVectors(no, eo)
                    }
                    setViewOffset(t, e, n, r, i, a) {
                        this.aspect = t / e, null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(.5 * Vn * this.fov) / this.zoom,
                            n = 2 * e,
                            r = this.aspect * n,
                            i = -.5 * r;
                        const a = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = a.fullWidth,
                                o = a.fullHeight;
                            i += a.offsetX * r / t, e -= a.offsetY * n / o, r *= a.width / t, n *= a.height / o
                        }
                        const o = this.filmOffset;
                        0 !== o && (i += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                    }
                }
                const io = -90;
                class ao extends qi {
                    constructor(t, e, n) {
                        super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                        const r = new ro(io, 1, t, e);
                        r.layers = this.layers, this.add(r);
                        const i = new ro(io, 1, t, e);
                        i.layers = this.layers, this.add(i);
                        const a = new ro(io, 1, t, e);
                        a.layers = this.layers, this.add(a);
                        const o = new ro(io, 1, t, e);
                        o.layers = this.layers, this.add(o);
                        const s = new ro(io, 1, t, e);
                        s.layers = this.layers, this.add(s);
                        const l = new ro(io, 1, t, e);
                        l.layers = this.layers, this.add(l)
                    }
                    updateCoordinateSystem() {
                        const t = this.coordinateSystem,
                            e = this.children.concat(),
                            [n, r, i, a, o, s] = e;
                        for (const t of e) this.remove(t);
                        if (t === kn) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), i.up.set(0, 0, -1), i.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), s.up.set(0, 1, 0), s.lookAt(0, 0, -1);
                        else {
                            if (t !== Fn) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                            n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), i.up.set(0, 0, 1), i.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), s.up.set(0, -1, 0), s.lookAt(0, 0, -1)
                        }
                        for (const t of e) this.add(t), t.updateMatrixWorld()
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const {
                            renderTarget: n,
                            activeMipmapLevel: r
                        } = this;
                        this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
                        const [i, a, o, s, l, A] = this.children, c = t.getRenderTarget(), u = t.getActiveCubeFace(), h = t.getActiveMipmapLevel(), d = t.xr.enabled;
                        t.xr.enabled = !1;
                        const f = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, r), t.render(e, i), t.setRenderTarget(n, 1, r), t.render(e, a), t.setRenderTarget(n, 2, r), t.render(e, o), t.setRenderTarget(n, 3, r), t.render(e, s), t.setRenderTarget(n, 4, r), t.render(e, l), n.texture.generateMipmaps = f, t.setRenderTarget(n, 5, r), t.render(e, A), t.setRenderTarget(c, u, h), t.xr.enabled = d, n.texture.needsPMREMUpdate = !0
                    }
                }
                class oo extends wr {
                    constructor(t, e, n, r, i, a, o, s, l, A) {
                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : ut, n, r, i, a, o, s, l, A), this.isCubeTexture = !0, this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(t) {
                        this.image = t
                    }
                }
                class so extends Tr {
                    constructor(t = 1, e = {}) {
                        super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                        const n = {
                                width: t,
                                height: t,
                                depth: 1
                            },
                            r = [n, n, n, n, n, n];
                        this.texture = new oo(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : wt
                    }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                        const n = {
                                tEquirect: {
                                    value: null
                                }
                            },
                            r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            a = new Xa(5, 5, 5),
                            o = new Ka({
                                name: "CubemapFromEquirect",
                                uniforms: Ya(n),
                                vertexShader: r,
                                fragmentShader: i,
                                side: p,
                                blending: g
                            });
                        o.uniforms.tEquirect.value = e;
                        const s = new Ha(a, o),
                            l = e.minFilter;
                        return e.minFilter === Tt && (e.minFilter = wt), new ao(1, 10, this).update(t, s), e.minFilter = l, s.geometry.dispose(), s.material.dispose(), this
                    }
                    clear(t, e, n, r) {
                        const i = t.getRenderTarget();
                        for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, n, r);
                        t.setRenderTarget(i)
                    }
                }
                const lo = new Ir,
                    Ao = new Ir,
                    co = new nr;
                class uo {
                    constructor(t = new Ir(1, 0, 0), e = 0) {
                        this.isPlane = !0, this.normal = t, this.constant = e
                    }
                    set(t, e) {
                        return this.normal.copy(t), this.constant = e, this
                    }
                    setComponents(t, e, n, r) {
                        return this.normal.set(t, e, n), this.constant = r, this
                    }
                    setFromNormalAndCoplanarPoint(t, e) {
                        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                    }
                    setFromCoplanarPoints(t, e, n) {
                        const r = lo.subVectors(n, e).cross(Ao.subVectors(t, e)).normalize();
                        return this.setFromNormalAndCoplanarPoint(r, t), this
                    }
                    copy(t) {
                        return this.normal.copy(t.normal), this.constant = t.constant, this
                    }
                    normalize() {
                        const t = 1 / this.normal.length();
                        return this.normal.multiplyScalar(t), this.constant *= t, this
                    }
                    negate() {
                        return this.constant *= -1, this.normal.negate(), this
                    }
                    distanceToPoint(t) {
                        return this.normal.dot(t) + this.constant
                    }
                    distanceToSphere(t) {
                        return this.distanceToPoint(t.center) - t.radius
                    }
                    projectPoint(t, e) {
                        return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
                    }
                    intersectLine(t, e) {
                        const n = t.delta(lo),
                            r = this.normal.dot(n);
                        if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                        const i = -(t.start.dot(this.normal) + this.constant) / r;
                        return i < 0 || i > 1 ? null : e.copy(t.start).addScaledVector(n, i)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) {
                        return t.intersectsPlane(this)
                    }
                    intersectsSphere(t) {
                        return t.intersectsPlane(this)
                    }
                    coplanarPoint(t) {
                        return t.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(t, e) {
                        const n = e || co.getNormalMatrix(t),
                            r = this.coplanarPoint(lo).applyMatrix4(t),
                            i = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -r.dot(i), this
                    }
                    translate(t) {
                        return this.constant -= t.dot(this.normal), this
                    }
                    equals(t) {
                        return t.normal.equals(this.normal) && t.constant === this.constant
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const ho = new ti,
                    fo = new Ir;
                class po {
                    constructor(t = new uo, e = new uo, n = new uo, r = new uo, i = new uo, a = new uo) {
                        this.planes = [t, e, n, r, i, a]
                    }
                    set(t, e, n, r, i, a) {
                        const o = this.planes;
                        return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this
                    }
                    copy(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(t, e = kn) {
                        const n = this.planes,
                            r = t.elements,
                            i = r[0],
                            a = r[1],
                            o = r[2],
                            s = r[3],
                            l = r[4],
                            A = r[5],
                            c = r[6],
                            u = r[7],
                            h = r[8],
                            d = r[9],
                            f = r[10],
                            p = r[11],
                            m = r[12],
                            g = r[13],
                            v = r[14],
                            _ = r[15];
                        if (n[0].setComponents(s - i, u - l, p - h, _ - m).normalize(), n[1].setComponents(s + i, u + l, p + h, _ + m).normalize(), n[2].setComponents(s + a, u + A, p + d, _ + g).normalize(), n[3].setComponents(s - a, u - A, p - d, _ - g).normalize(), n[4].setComponents(s - o, u - c, p - f, _ - v).normalize(), e === kn) n[5].setComponents(s + o, u + c, p + f, _ + v).normalize();
                        else {
                            if (e !== Fn) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                            n[5].setComponents(o, c, f, v).normalize()
                        }
                        return this
                    }
                    intersectsObject(t) {
                        if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), ho.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                        else {
                            const e = t.geometry;
                            null === e.boundingSphere && e.computeBoundingSphere(), ho.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                        }
                        return this.intersectsSphere(ho)
                    }
                    intersectsSprite(t) {
                        return ho.center.set(0, 0, 0), ho.radius = .7071067811865476, ho.applyMatrix4(t.matrixWorld), this.intersectsSphere(ho)
                    }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            r = -t.radius;
                        for (let t = 0; t < 6; t++)
                            if (e[t].distanceToPoint(n) < r) return !1;
                        return !0
                    }
                    intersectsBox(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const r = e[n];
                            if (fo.x = r.normal.x > 0 ? t.max.x : t.min.x, fo.y = r.normal.y > 0 ? t.max.y : t.min.y, fo.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(fo) < 0) return !1
                        }
                        return !0
                    }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }

                function mo() {
                    let t = null,
                        e = !1,
                        n = null,
                        r = null;

                    function i(e, a) {
                        n(e, a), r = t.requestAnimationFrame(i)
                    }
                    return {
                        start: function() {
                            !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
                        },
                        stop: function() {
                            t.cancelAnimationFrame(r), e = !1
                        },
                        setAnimationLoop: function(t) {
                            n = t
                        },
                        setContext: function(e) {
                            t = e
                        }
                    }
                }

                function go(t, e) {
                    const n = e.isWebGL2,
                        r = new WeakMap;
                    return {
                        get: function(t) {
                            return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                        },
                        remove: function(e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = r.get(e);
                            n && (t.deleteBuffer(n.buffer), r.delete(e))
                        },
                        update: function(e, i) {
                            if (e.isGLBufferAttribute) {
                                const t = r.get(e);
                                return void((!t || t.version < e.version) && r.set(e, {
                                    buffer: e.buffer,
                                    type: e.type,
                                    bytesPerElement: e.elementSize,
                                    version: e.version
                                }))
                            }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const a = r.get(e);
                            if (void 0 === a) r.set(e, function(e, r) {
                                const i = e.array,
                                    a = e.usage,
                                    o = i.byteLength,
                                    s = t.createBuffer();
                                let l;
                                if (t.bindBuffer(r, s), t.bufferData(r, i, a), e.onUploadCallback(), i instanceof Float32Array) l = t.FLOAT;
                                else if (i instanceof Uint16Array)
                                    if (e.isFloat16BufferAttribute) {
                                        if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                        l = t.HALF_FLOAT
                                    } else l = t.UNSIGNED_SHORT;
                                else if (i instanceof Int16Array) l = t.SHORT;
                                else if (i instanceof Uint32Array) l = t.UNSIGNED_INT;
                                else if (i instanceof Int32Array) l = t.INT;
                                else if (i instanceof Int8Array) l = t.BYTE;
                                else if (i instanceof Uint8Array) l = t.UNSIGNED_BYTE;
                                else {
                                    if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                    l = t.UNSIGNED_BYTE
                                }
                                return {
                                    buffer: s,
                                    type: l,
                                    bytesPerElement: i.BYTES_PER_ELEMENT,
                                    version: e.version,
                                    size: o
                                }
                            }(e, i));
                            else if (a.version < e.version) {
                                if (a.size !== e.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                                ! function(e, r, i) {
                                    const a = r.array,
                                        o = r._updateRange,
                                        s = r.updateRanges;
                                    if (t.bindBuffer(i, e), -1 === o.count && 0 === s.length && t.bufferSubData(i, 0, a), 0 !== s.length) {
                                        for (let e = 0, r = s.length; e < r; e++) {
                                            const r = s[e];
                                            n ? t.bufferSubData(i, r.start * a.BYTES_PER_ELEMENT, a, r.start, r.count) : t.bufferSubData(i, r.start * a.BYTES_PER_ELEMENT, a.subarray(r.start, r.start + r.count))
                                        }
                                        r.clearUpdateRanges()
                                    } - 1 !== o.count && (n ? t.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : t.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1), r.onUploadCallback()
                                }(a.buffer, e, i), a.version = e.version
                            }
                        }
                    }
                }
                class vo extends Ta {
                    constructor(t = 1, e = 1, n = 1, r = 1) {
                        super(), this.type = "PlaneGeometry", this.parameters = {
                            width: t,
                            height: e,
                            widthSegments: n,
                            heightSegments: r
                        };
                        const i = t / 2,
                            a = e / 2,
                            o = Math.floor(n),
                            s = Math.floor(r),
                            l = o + 1,
                            A = s + 1,
                            c = t / o,
                            u = e / s,
                            h = [],
                            d = [],
                            f = [],
                            p = [];
                        for (let t = 0; t < A; t++) {
                            const e = t * u - a;
                            for (let n = 0; n < l; n++) {
                                const r = n * c - i;
                                d.push(r, -e, 0), f.push(0, 0, 1), p.push(n / o), p.push(1 - t / s)
                            }
                        }
                        for (let t = 0; t < s; t++)
                            for (let e = 0; e < o; e++) {
                                const n = e + l * t,
                                    r = e + l * (t + 1),
                                    i = e + 1 + l * (t + 1),
                                    a = e + 1 + l * t;
                                h.push(n, r, a), h.push(r, i, a)
                            }
                        this.setIndex(h), this.setAttribute("position", new _a(d, 3)), this.setAttribute("normal", new _a(f, 3)), this.setAttribute("uv", new _a(p, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new vo(t.width, t.height, t.widthSegments, t.heightSegments)
                    }
                }
                const _o = {
                        alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                        alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                        batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                        iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
                        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                        lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                        map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                        morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                        normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                        iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                        opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                        shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, vec3(1, 1, 1), g);\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                        uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                        uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                        uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
                    },
                    yo = {
                        common: {
                            diffuse: {
                                value: new Ki(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            mapTransform: {
                                value: new nr
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaMapTransform: {
                                value: new nr
                            },
                            alphaTest: {
                                value: 0
                            }
                        },
                        specularmap: {
                            specularMap: {
                                value: null
                            },
                            specularMapTransform: {
                                value: new nr
                            }
                        },
                        envmap: {
                            envMap: {
                                value: null
                            },
                            envMapRotation: {
                                value: new nr
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            reflectivity: {
                                value: 1
                            },
                            ior: {
                                value: 1.5
                            },
                            refractionRatio: {
                                value: .98
                            }
                        },
                        aomap: {
                            aoMap: {
                                value: null
                            },
                            aoMapIntensity: {
                                value: 1
                            },
                            aoMapTransform: {
                                value: new nr
                            }
                        },
                        lightmap: {
                            lightMap: {
                                value: null
                            },
                            lightMapIntensity: {
                                value: 1
                            },
                            lightMapTransform: {
                                value: new nr
                            }
                        },
                        bumpmap: {
                            bumpMap: {
                                value: null
                            },
                            bumpMapTransform: {
                                value: new nr
                            },
                            bumpScale: {
                                value: 1
                            }
                        },
                        normalmap: {
                            normalMap: {
                                value: null
                            },
                            normalMapTransform: {
                                value: new nr
                            },
                            normalScale: {
                                value: new er(1, 1)
                            }
                        },
                        displacementmap: {
                            displacementMap: {
                                value: null
                            },
                            displacementMapTransform: {
                                value: new nr
                            },
                            displacementScale: {
                                value: 1
                            },
                            displacementBias: {
                                value: 0
                            }
                        },
                        emissivemap: {
                            emissiveMap: {
                                value: null
                            },
                            emissiveMapTransform: {
                                value: new nr
                            }
                        },
                        metalnessmap: {
                            metalnessMap: {
                                value: null
                            },
                            metalnessMapTransform: {
                                value: new nr
                            }
                        },
                        roughnessmap: {
                            roughnessMap: {
                                value: null
                            },
                            roughnessMapTransform: {
                                value: new nr
                            }
                        },
                        gradientmap: {
                            gradientMap: {
                                value: null
                            }
                        },
                        fog: {
                            fogDensity: {
                                value: 25e-5
                            },
                            fogNear: {
                                value: 1
                            },
                            fogFar: {
                                value: 2e3
                            },
                            fogColor: {
                                value: new Ki(16777215)
                            }
                        },
                        lights: {
                            ambientLightColor: {
                                value: []
                            },
                            lightProbe: {
                                value: []
                            },
                            directionalLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    color: {}
                                }
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            directionalShadowMap: {
                                value: []
                            },
                            directionalShadowMatrix: {
                                value: []
                            },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {}
                                }
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            spotLightMap: {
                                value: []
                            },
                            spotShadowMap: {
                                value: []
                            },
                            spotLightMatrix: {
                                value: []
                            },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {}
                                }
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {}
                                }
                            },
                            pointShadowMap: {
                                value: []
                            },
                            pointShadowMatrix: {
                                value: []
                            },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {}
                                }
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {}
                                }
                            },
                            ltc_1: {
                                value: null
                            },
                            ltc_2: {
                                value: null
                            }
                        },
                        points: {
                            diffuse: {
                                value: new Ki(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            size: {
                                value: 1
                            },
                            scale: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaMapTransform: {
                                value: new nr
                            },
                            alphaTest: {
                                value: 0
                            },
                            uvTransform: {
                                value: new nr
                            }
                        },
                        sprite: {
                            diffuse: {
                                value: new Ki(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            center: {
                                value: new er(.5, .5)
                            },
                            rotation: {
                                value: 0
                            },
                            map: {
                                value: null
                            },
                            mapTransform: {
                                value: new nr
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaMapTransform: {
                                value: new nr
                            },
                            alphaTest: {
                                value: 0
                            }
                        }
                    },
                    xo = {
                        basic: {
                            uniforms: Qa([yo.common, yo.specularmap, yo.envmap, yo.aomap, yo.lightmap, yo.fog]),
                            vertexShader: _o.meshbasic_vert,
                            fragmentShader: _o.meshbasic_frag
                        },
                        lambert: {
                            uniforms: Qa([yo.common, yo.specularmap, yo.envmap, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.fog, yo.lights, {
                                emissive: {
                                    value: new Ki(0)
                                }
                            }]),
                            vertexShader: _o.meshlambert_vert,
                            fragmentShader: _o.meshlambert_frag
                        },
                        phong: {
                            uniforms: Qa([yo.common, yo.specularmap, yo.envmap, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.fog, yo.lights, {
                                emissive: {
                                    value: new Ki(0)
                                },
                                specular: {
                                    value: new Ki(1118481)
                                },
                                shininess: {
                                    value: 30
                                }
                            }]),
                            vertexShader: _o.meshphong_vert,
                            fragmentShader: _o.meshphong_frag
                        },
                        standard: {
                            uniforms: Qa([yo.common, yo.envmap, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.roughnessmap, yo.metalnessmap, yo.fog, yo.lights, {
                                emissive: {
                                    value: new Ki(0)
                                },
                                roughness: {
                                    value: 1
                                },
                                metalness: {
                                    value: 0
                                },
                                envMapIntensity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: _o.meshphysical_vert,
                            fragmentShader: _o.meshphysical_frag
                        },
                        toon: {
                            uniforms: Qa([yo.common, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.gradientmap, yo.fog, yo.lights, {
                                emissive: {
                                    value: new Ki(0)
                                }
                            }]),
                            vertexShader: _o.meshtoon_vert,
                            fragmentShader: _o.meshtoon_frag
                        },
                        matcap: {
                            uniforms: Qa([yo.common, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.fog, {
                                matcap: {
                                    value: null
                                }
                            }]),
                            vertexShader: _o.meshmatcap_vert,
                            fragmentShader: _o.meshmatcap_frag
                        },
                        points: {
                            uniforms: Qa([yo.points, yo.fog]),
                            vertexShader: _o.points_vert,
                            fragmentShader: _o.points_frag
                        },
                        dashed: {
                            uniforms: Qa([yo.common, yo.fog, {
                                scale: {
                                    value: 1
                                },
                                dashSize: {
                                    value: 1
                                },
                                totalSize: {
                                    value: 2
                                }
                            }]),
                            vertexShader: _o.linedashed_vert,
                            fragmentShader: _o.linedashed_frag
                        },
                        depth: {
                            uniforms: Qa([yo.common, yo.displacementmap]),
                            vertexShader: _o.depth_vert,
                            fragmentShader: _o.depth_frag
                        },
                        normal: {
                            uniforms: Qa([yo.common, yo.bumpmap, yo.normalmap, yo.displacementmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: _o.meshnormal_vert,
                            fragmentShader: _o.meshnormal_frag
                        },
                        sprite: {
                            uniforms: Qa([yo.sprite, yo.fog]),
                            vertexShader: _o.sprite_vert,
                            fragmentShader: _o.sprite_frag
                        },
                        background: {
                            uniforms: {
                                uvTransform: {
                                    value: new nr
                                },
                                t2D: {
                                    value: null
                                },
                                backgroundIntensity: {
                                    value: 1
                                }
                            },
                            vertexShader: _o.background_vert,
                            fragmentShader: _o.background_frag
                        },
                        backgroundCube: {
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                flipEnvMap: {
                                    value: -1
                                },
                                backgroundBlurriness: {
                                    value: 0
                                },
                                backgroundIntensity: {
                                    value: 1
                                },
                                backgroundRotation: {
                                    value: new nr
                                }
                            },
                            vertexShader: _o.backgroundCube_vert,
                            fragmentShader: _o.backgroundCube_frag
                        },
                        cube: {
                            uniforms: {
                                tCube: {
                                    value: null
                                },
                                tFlip: {
                                    value: -1
                                },
                                opacity: {
                                    value: 1
                                }
                            },
                            vertexShader: _o.cube_vert,
                            fragmentShader: _o.cube_frag
                        },
                        equirect: {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: _o.equirect_vert,
                            fragmentShader: _o.equirect_frag
                        },
                        distanceRGBA: {
                            uniforms: Qa([yo.common, yo.displacementmap, {
                                referencePosition: {
                                    value: new Ir
                                },
                                nearDistance: {
                                    value: 1
                                },
                                farDistance: {
                                    value: 1e3
                                }
                            }]),
                            vertexShader: _o.distanceRGBA_vert,
                            fragmentShader: _o.distanceRGBA_frag
                        },
                        shadow: {
                            uniforms: Qa([yo.lights, yo.fog, {
                                color: {
                                    value: new Ki(0)
                                },
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: _o.shadow_vert,
                            fragmentShader: _o.shadow_frag
                        }
                    };
                xo.physical = {
                    uniforms: Qa([xo.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatMapTransform: {
                            value: new nr
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        clearcoatNormalMapTransform: {
                            value: new nr
                        },
                        clearcoatNormalScale: {
                            value: new er(1, 1)
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatRoughnessMapTransform: {
                            value: new nr
                        },
                        iridescence: {
                            value: 0
                        },
                        iridescenceMap: {
                            value: null
                        },
                        iridescenceMapTransform: {
                            value: new nr
                        },
                        iridescenceIOR: {
                            value: 1.3
                        },
                        iridescenceThicknessMinimum: {
                            value: 100
                        },
                        iridescenceThicknessMaximum: {
                            value: 400
                        },
                        iridescenceThicknessMap: {
                            value: null
                        },
                        iridescenceThicknessMapTransform: {
                            value: new nr
                        },
                        sheen: {
                            value: 0
                        },
                        sheenColor: {
                            value: new Ki(0)
                        },
                        sheenColorMap: {
                            value: null
                        },
                        sheenColorMapTransform: {
                            value: new nr
                        },
                        sheenRoughness: {
                            value: 1
                        },
                        sheenRoughnessMap: {
                            value: null
                        },
                        sheenRoughnessMapTransform: {
                            value: new nr
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionMapTransform: {
                            value: new nr
                        },
                        transmissionSamplerSize: {
                            value: new er
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        thicknessMapTransform: {
                            value: new nr
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new Ki(0)
                        },
                        specularColor: {
                            value: new Ki(1, 1, 1)
                        },
                        specularColorMap: {
                            value: null
                        },
                        specularColorMapTransform: {
                            value: new nr
                        },
                        specularIntensity: {
                            value: 1
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularIntensityMapTransform: {
                            value: new nr
                        },
                        anisotropyVector: {
                            value: new er
                        },
                        anisotropyMap: {
                            value: null
                        },
                        anisotropyMapTransform: {
                            value: new nr
                        }
                    }]),
                    vertexShader: _o.meshphysical_vert,
                    fragmentShader: _o.meshphysical_frag
                };
                const bo = {
                        r: 0,
                        b: 0,
                        g: 0
                    },
                    Mo = new _i,
                    wo = new Ai;

                function So(t, e, n, r, i, a, o) {
                    const s = new Ki(0);
                    let l, A, c = !0 === a ? 0 : 1,
                        u = null,
                        h = 0,
                        d = null;

                    function m(e, n) {
                        e.getRGB(bo, Za(t)), r.buffers.color.setClear(bo.r, bo.g, bo.b, n, o)
                    }
                    return {
                        getClearColor: function() {
                            return s
                        },
                        setClearColor: function(t, e = 1) {
                            s.set(t), c = e, m(s, c)
                        },
                        getClearAlpha: function() {
                            return c
                        },
                        setClearAlpha: function(t) {
                            c = t, m(s, c)
                        },
                        render: function(a, g) {
                            let v = !1,
                                _ = !0 === g.isScene ? g.background : null;
                            _ && _.isTexture && (_ = (g.backgroundBlurriness > 0 ? n : e).get(_)), null === _ ? m(s, c) : _ && _.isColor && (m(_, 1), v = !0);
                            const y = t.xr.getEnvironmentBlendMode();
                            "additive" === y ? r.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === y && r.buffers.color.setClear(0, 0, 0, 0, o), (t.autoClear || v) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), _ && (_.isCubeTexture || _.mapping === pt) ? (void 0 === A && (A = new Ha(new Xa(1, 1, 1), new Ka({
                                name: "BackgroundCubeMaterial",
                                uniforms: Ya(xo.backgroundCube.uniforms),
                                vertexShader: xo.backgroundCube.vertexShader,
                                fragmentShader: xo.backgroundCube.fragmentShader,
                                side: p,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), A.geometry.deleteAttribute("normal"), A.geometry.deleteAttribute("uv"), A.onBeforeRender = function(t, e, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }, Object.defineProperty(A.material, "envMap", {
                                get: function() {
                                    return this.uniforms.envMap.value
                                }
                            }), i.update(A)), Mo.copy(g.backgroundRotation), Mo.x *= -1, Mo.y *= -1, Mo.z *= -1, _.isCubeTexture && !1 === _.isRenderTargetTexture && (Mo.y *= -1, Mo.z *= -1), A.material.uniforms.envMap.value = _, A.material.uniforms.flipEnvMap.value = _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1, A.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, A.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, A.material.uniforms.backgroundRotation.value.setFromMatrix4(wo.makeRotationFromEuler(Mo)), A.material.toneMapped = pr.getTransfer(_.colorSpace) !== $e, u === _ && h === _.version && d === t.toneMapping || (A.material.needsUpdate = !0, u = _, h = _.version, d = t.toneMapping), A.layers.enableAll(), a.unshift(A, A.geometry, A.material, 0, 0, null)) : _ && _.isTexture && (void 0 === l && (l = new Ha(new vo(2, 2), new Ka({
                                name: "BackgroundMaterial",
                                uniforms: Ya(xo.background.uniforms),
                                vertexShader: xo.background.vertexShader,
                                fragmentShader: xo.background.fragmentShader,
                                side: f,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                                get: function() {
                                    return this.uniforms.t2D.value
                                }
                            }), i.update(l)), l.material.uniforms.t2D.value = _, l.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, l.material.toneMapped = pr.getTransfer(_.colorSpace) !== $e, !0 === _.matrixAutoUpdate && _.updateMatrix(), l.material.uniforms.uvTransform.value.copy(_.matrix), u === _ && h === _.version && d === t.toneMapping || (l.material.needsUpdate = !0, u = _, h = _.version, d = t.toneMapping), l.layers.enableAll(), a.unshift(l, l.geometry, l.material, 0, 0, null))
                        }
                    }
                }

                function Eo(t, e, n, r) {
                    const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                        a = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                        o = r.isWebGL2 || null !== a,
                        s = {},
                        l = d(null);
                    let A = l,
                        c = !1;

                    function u(e) {
                        return r.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e)
                    }

                    function h(e) {
                        return r.isWebGL2 ? t.deleteVertexArray(e) : a.deleteVertexArrayOES(e)
                    }

                    function d(t) {
                        const e = [],
                            n = [],
                            r = [];
                        for (let t = 0; t < i; t++) e[t] = 0, n[t] = 0, r[t] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: e,
                            enabledAttributes: n,
                            attributeDivisors: r,
                            object: t,
                            attributes: {},
                            index: null
                        }
                    }

                    function f() {
                        const t = A.newAttributes;
                        for (let e = 0, n = t.length; e < n; e++) t[e] = 0
                    }

                    function p(t) {
                        m(t, 0)
                    }

                    function m(n, i) {
                        const a = A.newAttributes,
                            o = A.enabledAttributes,
                            s = A.attributeDivisors;
                        a[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), s[n] !== i && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i)
                    }

                    function g() {
                        const e = A.newAttributes,
                            n = A.enabledAttributes;
                        for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
                    }

                    function v(e, n, r, i, a, o, s) {
                        !0 === s ? t.vertexAttribIPointer(e, n, r, a, o) : t.vertexAttribPointer(e, n, r, i, a, o)
                    }

                    function _() {
                        y(), c = !0, A !== l && (A = l, u(A.object))
                    }

                    function y() {
                        l.geometry = null, l.program = null, l.wireframe = !1
                    }
                    return {
                        setup: function(i, l, h, _, y) {
                            let x = !1;
                            if (o) {
                                const e = function(e, n, i) {
                                    const o = !0 === i.wireframe;
                                    let l = s[e.id];
                                    void 0 === l && (l = {}, s[e.id] = l);
                                    let A = l[n.id];
                                    void 0 === A && (A = {}, l[n.id] = A);
                                    let c = A[o];
                                    return void 0 === c && (c = d(r.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES()), A[o] = c), c
                                }(_, h, l);
                                A !== e && (A = e, u(A.object)), x = function(t, e, n, r) {
                                    const i = A.attributes,
                                        a = e.attributes;
                                    let o = 0;
                                    const s = n.getAttributes();
                                    for (const e in s)
                                        if (s[e].location >= 0) {
                                            const n = i[e];
                                            let r = a[e];
                                            if (void 0 === r && ("instanceMatrix" === e && t.instanceMatrix && (r = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (r = t.instanceColor)), void 0 === n) return !0;
                                            if (n.attribute !== r) return !0;
                                            if (r && n.data !== r.data) return !0;
                                            o++
                                        } return A.attributesNum !== o || A.index !== r
                                }(i, _, h, y), x && function(t, e, n, r) {
                                    const i = {},
                                        a = e.attributes;
                                    let o = 0;
                                    const s = n.getAttributes();
                                    for (const e in s)
                                        if (s[e].location >= 0) {
                                            let n = a[e];
                                            void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                            const r = {};
                                            r.attribute = n, n && n.data && (r.data = n.data), i[e] = r, o++
                                        } A.attributes = i, A.attributesNum = o, A.index = r
                                }(i, _, h, y)
                            } else {
                                const t = !0 === l.wireframe;
                                A.geometry === _.id && A.program === h.id && A.wireframe === t || (A.geometry = _.id, A.program = h.id, A.wireframe = t, x = !0)
                            }
                            null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER), (x || c) && (c = !1, function(i, a, o, s) {
                                if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                                f();
                                const l = s.attributes,
                                    A = o.getAttributes(),
                                    c = a.defaultAttributeValues;
                                for (const e in A) {
                                    const a = A[e];
                                    if (a.location >= 0) {
                                        let o = l[e];
                                        if (void 0 === o && ("instanceMatrix" === e && i.instanceMatrix && (o = i.instanceMatrix), "instanceColor" === e && i.instanceColor && (o = i.instanceColor)), void 0 !== o) {
                                            const e = o.normalized,
                                                l = o.itemSize,
                                                A = n.get(o);
                                            if (void 0 === A) continue;
                                            const c = A.buffer,
                                                u = A.type,
                                                h = A.bytesPerElement,
                                                d = !0 === r.isWebGL2 && (u === t.INT || u === t.UNSIGNED_INT || o.gpuType === It);
                                            if (o.isInterleavedBufferAttribute) {
                                                const n = o.data,
                                                    r = n.stride,
                                                    A = o.offset;
                                                if (n.isInstancedInterleavedBuffer) {
                                                    for (let t = 0; t < a.locationSize; t++) m(a.location + t, n.meshPerAttribute);
                                                    !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)
                                                } else
                                                    for (let t = 0; t < a.locationSize; t++) p(a.location + t);
                                                t.bindBuffer(t.ARRAY_BUFFER, c);
                                                for (let t = 0; t < a.locationSize; t++) v(a.location + t, l / a.locationSize, u, e, r * h, (A + l / a.locationSize * t) * h, d)
                                            } else {
                                                if (o.isInstancedBufferAttribute) {
                                                    for (let t = 0; t < a.locationSize; t++) m(a.location + t, o.meshPerAttribute);
                                                    !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)
                                                } else
                                                    for (let t = 0; t < a.locationSize; t++) p(a.location + t);
                                                t.bindBuffer(t.ARRAY_BUFFER, c);
                                                for (let t = 0; t < a.locationSize; t++) v(a.location + t, l / a.locationSize, u, e, l * h, l / a.locationSize * t * h, d)
                                            }
                                        } else if (void 0 !== c) {
                                            const n = c[e];
                                            if (void 0 !== n) switch (n.length) {
                                                case 2:
                                                    t.vertexAttrib2fv(a.location, n);
                                                    break;
                                                case 3:
                                                    t.vertexAttrib3fv(a.location, n);
                                                    break;
                                                case 4:
                                                    t.vertexAttrib4fv(a.location, n);
                                                    break;
                                                default:
                                                    t.vertexAttrib1fv(a.location, n)
                                            }
                                        }
                                    }
                                }
                                g()
                            }(i, l, h, _), null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer))
                        },
                        reset: _,
                        resetDefaultState: y,
                        dispose: function() {
                            _();
                            for (const t in s) {
                                const e = s[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n) h(n[t].object), delete n[t];
                                    delete e[t]
                                }
                                delete s[t]
                            }
                        },
                        releaseStatesOfGeometry: function(t) {
                            if (void 0 === s[t.id]) return;
                            const e = s[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) h(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete s[t.id]
                        },
                        releaseStatesOfProgram: function(t) {
                            for (const e in s) {
                                const n = s[e];
                                if (void 0 === n[t.id]) continue;
                                const r = n[t.id];
                                for (const t in r) h(r[t].object), delete r[t];
                                delete n[t.id]
                            }
                        },
                        initAttributes: f,
                        enableAttribute: p,
                        disableUnusedAttributes: g
                    }
                }

                function To(t, e, n, r) {
                    const i = r.isWebGL2;
                    let a;
                    this.setMode = function(t) {
                        a = t
                    }, this.render = function(e, r) {
                        t.drawArrays(a, e, r), n.update(r, a, 1)
                    }, this.renderInstances = function(r, o, s) {
                        if (0 === s) return;
                        let l, A;
                        if (i) l = t, A = "drawArraysInstanced";
                        else if (l = e.get("ANGLE_instanced_arrays"), A = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[A](a, r, o, s), n.update(o, a, s)
                    }, this.renderMultiDraw = function(t, r, i) {
                        if (0 === i) return;
                        const o = e.get("WEBGL_multi_draw");
                        if (null === o)
                            for (let e = 0; e < i; e++) this.render(t[e], r[e]);
                        else {
                            o.multiDrawArraysWEBGL(a, t, 0, r, 0, i);
                            let e = 0;
                            for (let t = 0; t < i; t++) e += r[t];
                            n.update(e, a, 1)
                        }
                    }
                }

                function Co(t, e, n) {
                    let r;

                    function i(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                    }
                    const a = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
                    let o = void 0 !== n.precision ? n.precision : "highp";
                    const s = i(o);
                    s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
                    const l = a || e.has("WEBGL_draw_buffers"),
                        A = !0 === n.logarithmicDepthBuffer,
                        c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                        u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                        h = t.getParameter(t.MAX_TEXTURE_SIZE),
                        d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                        f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                        p = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                        m = t.getParameter(t.MAX_VARYING_VECTORS),
                        g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                        v = u > 0,
                        _ = a || e.has("OES_texture_float");
                    return {
                        isWebGL2: a,
                        drawBuffers: l,
                        getMaxAnisotropy: function() {
                            if (void 0 !== r) return r;
                            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                const n = e.get("EXT_texture_filter_anisotropic");
                                r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else r = 0;
                            return r
                        },
                        getMaxPrecision: i,
                        precision: o,
                        logarithmicDepthBuffer: A,
                        maxTextures: c,
                        maxVertexTextures: u,
                        maxTextureSize: h,
                        maxCubemapSize: d,
                        maxAttributes: f,
                        maxVertexUniforms: p,
                        maxVaryings: m,
                        maxFragmentUniforms: g,
                        vertexTextures: v,
                        floatFragmentTextures: _,
                        floatVertexTextures: v && _,
                        maxSamples: a ? t.getParameter(t.MAX_SAMPLES) : 0
                    }
                }

                function Ro(t) {
                    const e = this;
                    let n = null,
                        r = 0,
                        i = !1,
                        a = !1;
                    const o = new uo,
                        s = new nr,
                        l = {
                            value: null,
                            needsUpdate: !1
                        };

                    function A(t, n, r, i) {
                        const a = null !== t ? t.length : 0;
                        let A = null;
                        if (0 !== a) {
                            if (A = l.value, !0 !== i || null === A) {
                                const e = r + 4 * a,
                                    i = n.matrixWorldInverse;
                                s.getNormalMatrix(i), (null === A || A.length < e) && (A = new Float32Array(e));
                                for (let e = 0, n = r; e !== a; ++e, n += 4) o.copy(t[e]).applyMatrix4(i, s), o.normal.toArray(A, n), A[n + 3] = o.constant
                            }
                            l.value = A, l.needsUpdate = !0
                        }
                        return e.numPlanes = a, e.numIntersection = 0, A
                    }
                    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e) {
                        const n = 0 !== t.length || e || 0 !== r || i;
                        return i = e, r = t.length, n
                    }, this.beginShadows = function() {
                        a = !0, A(null)
                    }, this.endShadows = function() {
                        a = !1
                    }, this.setGlobalState = function(t, e) {
                        n = A(t, e, 0)
                    }, this.setState = function(o, s, c) {
                        const u = o.clippingPlanes,
                            h = o.clipIntersection,
                            d = o.clipShadows,
                            f = t.get(o);
                        if (!i || null === u || 0 === u.length || a && !d) a ? A(null) : (l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0);
                        else {
                            const t = a ? 0 : r,
                                e = 4 * t;
                            let i = f.clippingState || null;
                            l.value = i, i = A(u, s, e, c);
                            for (let t = 0; t !== e; ++t) i[t] = n[t];
                            f.clippingState = i, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += t
                        }
                    }
                }

                function Po(t) {
                    let e = new WeakMap;

                    function n(t, e) {
                        return e === dt ? t.mapping = ut : e === ft && (t.mapping = ht), t
                    }

                    function r(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", r);
                        const i = e.get(n);
                        void 0 !== i && (e.delete(n), i.dispose())
                    }
                    return {
                        get: function(i) {
                            if (i && i.isTexture) {
                                const a = i.mapping;
                                if (a === dt || a === ft) {
                                    if (e.has(i)) return n(e.get(i).texture, i.mapping);
                                    {
                                        const a = i.image;
                                        if (a && a.height > 0) {
                                            const o = new so(a.height);
                                            return o.fromEquirectangularTexture(t, i), e.set(i, o), i.addEventListener("dispose", r), n(o.texture, i.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return i
                        },
                        dispose: function() {
                            e = new WeakMap
                        }
                    }
                }
                class Lo extends $a {
                    constructor(t = -1, e = 1, n = 1, r = -1, i = .1, a = 2e3) {
                        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = a, this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                    }
                    setViewOffset(t, e, n, r, i, a) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            r = (this.top + this.bottom) / 2;
                        let i = n - t,
                            a = n + t,
                            o = r + e,
                            s = r - e;
                        if (null !== this.view && this.view.enabled) {
                            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            i += t * this.view.offsetX, a = i + t * this.view.width, o -= e * this.view.offsetY, s = o - e * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                    }
                }
                const Do = [.125, .215, .35, .446, .526, .582],
                    Io = new Lo,
                    Oo = new Ki;
                let Bo = null,
                    qo = 0,
                    Uo = 0;
                const No = (1 + Math.sqrt(5)) / 2,
                    ko = 1 / No,
                    Fo = [new Ir(1, 1, 1), new Ir(-1, 1, 1), new Ir(1, 1, -1), new Ir(-1, 1, -1), new Ir(0, No, ko), new Ir(0, No, -ko), new Ir(ko, 0, No), new Ir(-ko, 0, No), new Ir(No, ko, 0), new Ir(-No, ko, 0)];
                class zo {
                    constructor(t) {
                        this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(t, e = 0, n = .1, r = 100) {
                        Bo = this._renderer.getRenderTarget(), qo = this._renderer.getActiveCubeFace(), Uo = this._renderer.getActiveMipmapLevel(), this._setSize(256);
                        const i = this._allocateTargets();
                        return i.depthBuffer = !0, this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i
                    }
                    fromEquirectangular(t, e = null) {
                        return this._fromTexture(t, e)
                    }
                    fromCubemap(t, e = null) {
                        return this._fromTexture(t, e)
                    }
                    compileCubemapShader() {
                        null === this._cubemapMaterial && (this._cubemapMaterial = Ho(), this._compileMaterial(this._cubemapMaterial))
                    }
                    compileEquirectangularShader() {
                        null === this._equirectMaterial && (this._equirectMaterial = Vo(), this._compileMaterial(this._equirectMaterial))
                    }
                    dispose() {
                        this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                    }
                    _setSize(t) {
                        this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                        for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
                    }
                    _cleanup(t) {
                        this._renderer.setRenderTarget(Bo, qo, Uo), t.scissorTest = !1, jo(t, 0, 0, t.width, t.height)
                    }
                    _fromTexture(t, e) {
                        t.mapping === ut || t.mapping === ht ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Bo = this._renderer.getRenderTarget(), qo = this._renderer.getActiveCubeFace(), Uo = this._renderer.getActiveMipmapLevel();
                        const n = e || this._allocateTargets();
                        return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
                    }
                    _allocateTargets() {
                        const t = 3 * Math.max(this._cubeSize, 112),
                            e = 4 * this._cubeSize,
                            n = {
                                magFilter: wt,
                                minFilter: wt,
                                generateMipmaps: !1,
                                type: qt,
                                format: zt,
                                colorSpace: Qe,
                                depthBuffer: !1
                            },
                            r = Go(t, e, n);
                        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                            null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Go(t, e, n);
                            const {
                                _lodMax: r
                            } = this;
                            ({
                                sizeLods: this._sizeLods,
                                lodPlanes: this._lodPlanes,
                                sigmas: this._sigmas
                            } = function(t) {
                                const e = [],
                                    n = [],
                                    r = [];
                                let i = t;
                                const a = t - 4 + 1 + Do.length;
                                for (let o = 0; o < a; o++) {
                                    const a = Math.pow(2, i);
                                    n.push(a);
                                    let s = 1 / a;
                                    o > t - 4 ? s = Do[o - t + 4 - 1] : 0 === o && (s = 0), r.push(s);
                                    const l = 1 / (a - 2),
                                        A = -l,
                                        c = 1 + l,
                                        u = [A, A, c, A, c, c, A, A, c, c, A, c],
                                        h = 6,
                                        d = 6,
                                        f = 3,
                                        p = 2,
                                        m = 1,
                                        g = new Float32Array(f * d * h),
                                        v = new Float32Array(p * d * h),
                                        _ = new Float32Array(m * d * h);
                                    for (let t = 0; t < h; t++) {
                                        const e = t % 3 * 2 / 3 - 1,
                                            n = t > 2 ? 0 : -1,
                                            r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                        g.set(r, f * d * t), v.set(u, p * d * t);
                                        const i = [t, t, t, t, t, t];
                                        _.set(i, m * d * t)
                                    }
                                    const y = new Ta;
                                    y.setAttribute("position", new ca(g, f)), y.setAttribute("uv", new ca(v, p)), y.setAttribute("faceIndex", new ca(_, m)), e.push(y), i > 4 && i--
                                }
                                return {
                                    lodPlanes: e,
                                    sizeLods: n,
                                    sigmas: r
                                }
                            }(r)), this._blurMaterial = function(t, e, n) {
                                const r = new Float32Array(20),
                                    i = new Ir(0, 1, 0);
                                return new Ka({
                                    name: "SphericalGaussianBlur",
                                    defines: {
                                        n: 20,
                                        CUBEUV_TEXEL_WIDTH: 1 / e,
                                        CUBEUV_TEXEL_HEIGHT: 1 / n,
                                        CUBEUV_MAX_MIP: `${t}.0`
                                    },
                                    uniforms: {
                                        envMap: {
                                            value: null
                                        },
                                        samples: {
                                            value: 1
                                        },
                                        weights: {
                                            value: r
                                        },
                                        latitudinal: {
                                            value: !1
                                        },
                                        dTheta: {
                                            value: 0
                                        },
                                        mipInt: {
                                            value: 0
                                        },
                                        poleAxis: {
                                            value: i
                                        }
                                    },
                                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                    blending: g,
                                    depthTest: !1,
                                    depthWrite: !1
                                })
                            }(r, t, e)
                        }
                        return r
                    }
                    _compileMaterial(t) {
                        const e = new Ha(this._lodPlanes[0], t);
                        this._renderer.compile(e, Io)
                    }
                    _sceneToCubeUV(t, e, n, r) {
                        const i = new ro(90, 1, e, n),
                            a = [1, -1, 1, 1, 1, 1],
                            o = [1, 1, 1, -1, -1, -1],
                            s = this._renderer,
                            l = s.autoClear,
                            A = s.toneMapping;
                        s.getClearColor(Oo), s.toneMapping = tt, s.autoClear = !1;
                        const c = new na({
                                name: "PMREM.Background",
                                side: p,
                                depthWrite: !1,
                                depthTest: !1
                            }),
                            u = new Ha(new Xa, c);
                        let h = !1;
                        const d = t.background;
                        d ? d.isColor && (c.color.copy(d), t.background = null, h = !0) : (c.color.copy(Oo), h = !0);
                        for (let e = 0; e < 6; e++) {
                            const n = e % 3;
                            0 === n ? (i.up.set(0, a[e], 0), i.lookAt(o[e], 0, 0)) : 1 === n ? (i.up.set(0, 0, a[e]), i.lookAt(0, o[e], 0)) : (i.up.set(0, a[e], 0), i.lookAt(0, 0, o[e]));
                            const l = this._cubeSize;
                            jo(r, n * l, e > 2 ? l : 0, l, l), s.setRenderTarget(r), h && s.render(u, i), s.render(t, i)
                        }
                        u.geometry.dispose(), u.material.dispose(), s.toneMapping = A, s.autoClear = l, t.background = d
                    }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer,
                            r = t.mapping === ut || t.mapping === ht;
                        r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Ho()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Vo());
                        const i = r ? this._cubemapMaterial : this._equirectMaterial,
                            a = new Ha(this._lodPlanes[0], i);
                        i.uniforms.envMap.value = t;
                        const o = this._cubeSize;
                        jo(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(a, Io)
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let e = 1; e < this._lodPlanes.length; e++) {
                            const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                                r = Fo[(e - 1) % Fo.length];
                            this._blur(t, e - 1, e, n, r)
                        }
                        e.autoClear = n
                    }
                    _blur(t, e, n, r, i) {
                        const a = this._pingPongRenderTarget;
                        this._halfBlur(t, a, e, n, r, "latitudinal", i), this._halfBlur(a, t, n, n, r, "longitudinal", i)
                    }
                    _halfBlur(t, e, n, r, i, a, o) {
                        const s = this._renderer,
                            l = this._blurMaterial;
                        "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                        const A = new Ha(this._lodPlanes[r], l),
                            c = l.uniforms,
                            u = this._sizeLods[n] - 1,
                            h = isFinite(i) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                            d = i / h,
                            f = isFinite(i) ? 1 + Math.floor(3 * d) : 20;
                        f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                        const p = [];
                        let m = 0;
                        for (let t = 0; t < 20; ++t) {
                            const e = t / d,
                                n = Math.exp(-e * e / 2);
                            p.push(n), 0 === t ? m += n : t < f && (m += 2 * n)
                        }
                        for (let t = 0; t < p.length; t++) p[t] = p[t] / m;
                        c.envMap.value = t.texture, c.samples.value = f, c.weights.value = p, c.latitudinal.value = "latitudinal" === a, o && (c.poleAxis.value = o);
                        const {
                            _lodMax: g
                        } = this;
                        c.dTheta.value = h, c.mipInt.value = g - n;
                        const v = this._sizeLods[r];
                        jo(e, 3 * v * (r > g - 4 ? r - g + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), s.setRenderTarget(e), s.render(A, Io)
                    }
                }

                function Go(t, e, n) {
                    const r = new Tr(t, e, n);
                    return r.texture.mapping = pt, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
                }

                function jo(t, e, n, r, i) {
                    t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
                }

                function Vo() {
                    return new Ka({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                        blending: g,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function Ho() {
                    return new Ka({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                        blending: g,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function Wo(t) {
                    let e = new WeakMap,
                        n = null;

                    function r(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", r);
                        const i = e.get(n);
                        void 0 !== i && (e.delete(n), i.dispose())
                    }
                    return {
                        get: function(i) {
                            if (i && i.isTexture) {
                                const a = i.mapping,
                                    o = a === dt || a === ft,
                                    s = a === ut || a === ht;
                                if (o || s) {
                                    if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                        i.needsPMREMUpdate = !1;
                                        let r = e.get(i);
                                        return null === n && (n = new zo(t)), r = o ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r), e.set(i, r), r.texture
                                    }
                                    if (e.has(i)) return e.get(i).texture;
                                    {
                                        const a = i.image;
                                        if (o && a && a.height > 0 || s && a && function(t) {
                                                let e = 0;
                                                for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                return 6 === e
                                            }(a)) {
                                            null === n && (n = new zo(t));
                                            const a = o ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                            return e.set(i, a), i.addEventListener("dispose", r), a.texture
                                        }
                                        return null
                                    }
                                }
                            }
                            return i
                        },
                        dispose: function() {
                            e = new WeakMap, null !== n && (n.dispose(), n = null)
                        }
                    }
                }

                function Xo(t) {
                    const e = {};

                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let r;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                r = t.getExtension(n)
                        }
                        return e[n] = r, r
                    }
                    return {
                        has: function(t) {
                            return null !== n(t)
                        },
                        init: function(t) {
                            t.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                        },
                        get: function(t) {
                            const e = n(t);
                            return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                        }
                    }
                }

                function Yo(t, e, n, r) {
                    const i = {},
                        a = new WeakMap;

                    function o(t) {
                        const s = t.target;
                        null !== s.index && e.remove(s.index);
                        for (const t in s.attributes) e.remove(s.attributes[t]);
                        for (const t in s.morphAttributes) {
                            const n = s.morphAttributes[t];
                            for (let t = 0, r = n.length; t < r; t++) e.remove(n[t])
                        }
                        s.removeEventListener("dispose", o), delete i[s.id];
                        const l = a.get(s);
                        l && (e.remove(l), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--
                    }

                    function s(t) {
                        const n = [],
                            r = t.index,
                            i = t.attributes.position;
                        let o = 0;
                        if (null !== r) {
                            const t = r.array;
                            o = r.version;
                            for (let e = 0, r = t.length; e < r; e += 3) {
                                const r = t[e + 0],
                                    i = t[e + 1],
                                    a = t[e + 2];
                                n.push(r, i, i, a, a, r)
                            }
                        } else {
                            if (void 0 === i) return;
                            {
                                const t = i.array;
                                o = i.version;
                                for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                                    const t = e + 0,
                                        r = e + 1,
                                        i = e + 2;
                                    n.push(t, r, r, i, i, t)
                                }
                            }
                        }
                        const s = new(ir(n) ? ga : pa)(n, 1);
                        s.version = o;
                        const l = a.get(t);
                        l && e.remove(l), a.set(t, s)
                    }
                    return {
                        get: function(t, e) {
                            return !0 === i[e.id] || (e.addEventListener("dispose", o), i[e.id] = !0, n.memory.geometries++), e
                        },
                        update: function(n) {
                            const r = n.attributes;
                            for (const n in r) e.update(r[n], t.ARRAY_BUFFER);
                            const i = n.morphAttributes;
                            for (const n in i) {
                                const r = i[n];
                                for (let n = 0, i = r.length; n < i; n++) e.update(r[n], t.ARRAY_BUFFER)
                            }
                        },
                        getWireframeAttribute: function(t) {
                            const e = a.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && s(t)
                            } else s(t);
                            return a.get(t)
                        }
                    }
                }

                function Qo(t, e, n, r) {
                    const i = r.isWebGL2;
                    let a, o, s;
                    this.setMode = function(t) {
                        a = t
                    }, this.setIndex = function(t) {
                        o = t.type, s = t.bytesPerElement
                    }, this.render = function(e, r) {
                        t.drawElements(a, r, o, e * s), n.update(r, a, 1)
                    }, this.renderInstances = function(r, l, A) {
                        if (0 === A) return;
                        let c, u;
                        if (i) c = t, u = "drawElementsInstanced";
                        else if (c = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        c[u](a, l, o, r * s, A), n.update(l, a, A)
                    }, this.renderMultiDraw = function(t, r, i) {
                        if (0 === i) return;
                        const l = e.get("WEBGL_multi_draw");
                        if (null === l)
                            for (let e = 0; e < i; e++) this.render(t[e] / s, r[e]);
                        else {
                            l.multiDrawElementsWEBGL(a, r, 0, o, t, 0, i);
                            let e = 0;
                            for (let t = 0; t < i; t++) e += r[t];
                            n.update(e, a, 1)
                        }
                    }
                }

                function Zo(t) {
                    const e = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    return {
                        memory: {
                            geometries: 0,
                            textures: 0
                        },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function() {
                            e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                        },
                        update: function(n, r, i) {
                            switch (e.calls++, r) {
                                case t.TRIANGLES:
                                    e.triangles += i * (n / 3);
                                    break;
                                case t.LINES:
                                    e.lines += i * (n / 2);
                                    break;
                                case t.LINE_STRIP:
                                    e.lines += i * (n - 1);
                                    break;
                                case t.LINE_LOOP:
                                    e.lines += i * n;
                                    break;
                                case t.POINTS:
                                    e.points += i * n;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                            }
                        }
                    }
                }

                function Jo(t, e) {
                    return t[0] - e[0]
                }

                function Ko(t, e) {
                    return Math.abs(e[1]) - Math.abs(t[1])
                }

                function $o(t, e, n) {
                    const r = {},
                        i = new Float32Array(8),
                        a = new WeakMap,
                        o = new Sr,
                        s = [];
                    for (let t = 0; t < 8; t++) s[t] = [t, 0];
                    return {
                        update: function(l, A, c) {
                            const u = l.morphTargetInfluences;
                            if (!0 === e.isWebGL2) {
                                const h = A.morphAttributes.position || A.morphAttributes.normal || A.morphAttributes.color,
                                    d = void 0 !== h ? h.length : 0;
                                let f = a.get(A);
                                if (void 0 === f || f.count !== d) {
                                    void 0 !== f && f.texture.dispose();
                                    const p = void 0 !== A.morphAttributes.position,
                                        m = void 0 !== A.morphAttributes.normal,
                                        g = void 0 !== A.morphAttributes.color,
                                        v = A.morphAttributes.position || [],
                                        _ = A.morphAttributes.normal || [],
                                        y = A.morphAttributes.color || [];
                                    let x = 0;
                                    !0 === p && (x = 1), !0 === m && (x = 2), !0 === g && (x = 3);
                                    let b = A.attributes.position.count * x,
                                        M = 1;
                                    b > e.maxTextureSize && (M = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
                                    const w = new Float32Array(b * M * 4 * d),
                                        S = new Cr(w, b, M, d);
                                    S.type = Bt, S.needsUpdate = !0;
                                    const E = 4 * x;
                                    for (let C = 0; C < d; C++) {
                                        const R = v[C],
                                            P = _[C],
                                            L = y[C],
                                            D = b * M * 4 * C;
                                        for (let I = 0; I < R.count; I++) {
                                            const O = I * E;
                                            !0 === p && (o.fromBufferAttribute(R, I), w[D + O + 0] = o.x, w[D + O + 1] = o.y, w[D + O + 2] = o.z, w[D + O + 3] = 0), !0 === m && (o.fromBufferAttribute(P, I), w[D + O + 4] = o.x, w[D + O + 5] = o.y, w[D + O + 6] = o.z, w[D + O + 7] = 0), !0 === g && (o.fromBufferAttribute(L, I), w[D + O + 8] = o.x, w[D + O + 9] = o.y, w[D + O + 10] = o.z, w[D + O + 11] = 4 === L.itemSize ? o.w : 1)
                                        }
                                    }

                                    function T() {
                                        S.dispose(), a.delete(A), A.removeEventListener("dispose", T)
                                    }
                                    f = {
                                        count: d,
                                        texture: S,
                                        size: new er(b, M)
                                    }, a.set(A, f), A.addEventListener("dispose", T)
                                }
                                if (!0 === l.isInstancedMesh && null !== l.morphTexture) c.getUniforms().setValue(t, "morphTexture", l.morphTexture, n);
                                else {
                                    let B = 0;
                                    for (let U = 0; U < u.length; U++) B += u[U];
                                    const q = A.morphTargetsRelative ? 1 : 1 - B;
                                    c.getUniforms().setValue(t, "morphTargetBaseInfluence", q), c.getUniforms().setValue(t, "morphTargetInfluences", u)
                                }
                                c.getUniforms().setValue(t, "morphTargetsTexture", f.texture, n), c.getUniforms().setValue(t, "morphTargetsTextureSize", f.size)
                            } else {
                                const N = void 0 === u ? 0 : u.length;
                                let k = r[A.id];
                                if (void 0 === k || k.length !== N) {
                                    k = [];
                                    for (let V = 0; V < N; V++) k[V] = [V, 0];
                                    r[A.id] = k
                                }
                                for (let H = 0; H < N; H++) {
                                    const W = k[H];
                                    W[0] = H, W[1] = u[H]
                                }
                                k.sort(Ko);
                                for (let X = 0; X < 8; X++) X < N && k[X][1] ? (s[X][0] = k[X][0], s[X][1] = k[X][1]) : (s[X][0] = Number.MAX_SAFE_INTEGER, s[X][1] = 0);
                                s.sort(Jo);
                                const F = A.morphAttributes.position,
                                    z = A.morphAttributes.normal;
                                let G = 0;
                                for (let Y = 0; Y < 8; Y++) {
                                    const Q = s[Y],
                                        Z = Q[0],
                                        J = Q[1];
                                    Z !== Number.MAX_SAFE_INTEGER && J ? (F && A.getAttribute("morphTarget" + Y) !== F[Z] && A.setAttribute("morphTarget" + Y, F[Z]), z && A.getAttribute("morphNormal" + Y) !== z[Z] && A.setAttribute("morphNormal" + Y, z[Z]), i[Y] = J, G += J) : (F && !0 === A.hasAttribute("morphTarget" + Y) && A.deleteAttribute("morphTarget" + Y), z && !0 === A.hasAttribute("morphNormal" + Y) && A.deleteAttribute("morphNormal" + Y), i[Y] = 0)
                                }
                                const j = A.morphTargetsRelative ? 1 : 1 - G;
                                c.getUniforms().setValue(t, "morphTargetBaseInfluence", j), c.getUniforms().setValue(t, "morphTargetInfluences", i)
                            }
                        }
                    }
                }

                function ts(t, e, n, r) {
                    let i = new WeakMap;

                    function a(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", a), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                    }
                    return {
                        update: function(o) {
                            const s = r.render.frame,
                                l = o.geometry,
                                A = e.get(o, l);
                            if (i.get(A) !== s && (e.update(A), i.set(A, s)), o.isInstancedMesh && (!1 === o.hasEventListener("dispose", a) && o.addEventListener("dispose", a), i.get(o) !== s && (n.update(o.instanceMatrix, t.ARRAY_BUFFER), null !== o.instanceColor && n.update(o.instanceColor, t.ARRAY_BUFFER), i.set(o, s))), o.isSkinnedMesh) {
                                const t = o.skeleton;
                                i.get(t) !== s && (t.update(), i.set(t, s))
                            }
                            return A
                        },
                        dispose: function() {
                            i = new WeakMap
                        }
                    }
                }
                class es extends wr {
                    constructor(t, e, n, r, i, a, o, s, l, A) {
                        if ((A = void 0 !== A ? A : Vt) !== Vt && A !== Ht) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === n && A === Vt && (n = Ot), void 0 === n && A === Ht && (n = kt), super(null, r, i, a, o, s, A, n, l), this.isDepthTexture = !0, this.image = {
                            width: t,
                            height: e
                        }, this.magFilter = void 0 !== o ? o : _t, this.minFilter = void 0 !== s ? s : _t, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
                    }
                    copy(t) {
                        return super.copy(t), this.compareFunction = t.compareFunction, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
                    }
                }
                const ns = new wr,
                    rs = new es(1, 1);
                rs.compareFunction = bn;
                const is = new Cr,
                    as = new Pr,
                    os = new oo,
                    ss = [],
                    ls = [],
                    As = new Float32Array(16),
                    cs = new Float32Array(9),
                    us = new Float32Array(4);

                function hs(t, e, n) {
                    const r = t[0];
                    if (r <= 0 || r > 0) return t;
                    const i = e * n;
                    let a = ss[i];
                    if (void 0 === a && (a = new Float32Array(i), ss[i] = a), 0 !== e) {
                        r.toArray(a, 0);
                        for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(a, i)
                    }
                    return a
                }

                function ds(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, r = t.length; n < r; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0
                }

                function fs(t, e) {
                    for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
                }

                function ps(t, e) {
                    let n = ls[e];
                    void 0 === n && (n = new Int32Array(e), ls[e] = n);
                    for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
                    return n
                }

                function ms(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                }

                function gs(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (ds(n, e)) return;
                        t.uniform2fv(this.addr, e), fs(n, e)
                    }
                }

                function vs(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                    else {
                        if (ds(n, e)) return;
                        t.uniform3fv(this.addr, e), fs(n, e)
                    }
                }

                function _s(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (ds(n, e)) return;
                        t.uniform4fv(this.addr, e), fs(n, e)
                    }
                }

                function ys(t, e) {
                    const n = this.cache,
                        r = e.elements;
                    if (void 0 === r) {
                        if (ds(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), fs(n, e)
                    } else {
                        if (ds(n, r)) return;
                        us.set(r), t.uniformMatrix2fv(this.addr, !1, us), fs(n, r)
                    }
                }

                function xs(t, e) {
                    const n = this.cache,
                        r = e.elements;
                    if (void 0 === r) {
                        if (ds(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), fs(n, e)
                    } else {
                        if (ds(n, r)) return;
                        cs.set(r), t.uniformMatrix3fv(this.addr, !1, cs), fs(n, r)
                    }
                }

                function bs(t, e) {
                    const n = this.cache,
                        r = e.elements;
                    if (void 0 === r) {
                        if (ds(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), fs(n, e)
                    } else {
                        if (ds(n, r)) return;
                        As.set(r), t.uniformMatrix4fv(this.addr, !1, As), fs(n, r)
                    }
                }

                function Ms(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                }

                function ws(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (ds(n, e)) return;
                        t.uniform2iv(this.addr, e), fs(n, e)
                    }
                }

                function Ss(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else {
                        if (ds(n, e)) return;
                        t.uniform3iv(this.addr, e), fs(n, e)
                    }
                }

                function Es(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (ds(n, e)) return;
                        t.uniform4iv(this.addr, e), fs(n, e)
                    }
                }

                function Ts(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                }

                function Cs(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (ds(n, e)) return;
                        t.uniform2uiv(this.addr, e), fs(n, e)
                    }
                }

                function Rs(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else {
                        if (ds(n, e)) return;
                        t.uniform3uiv(this.addr, e), fs(n, e)
                    }
                }

                function Ps(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (ds(n, e)) return;
                        t.uniform4uiv(this.addr, e), fs(n, e)
                    }
                }

                function Ls(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i);
                    const a = this.type === t.SAMPLER_2D_SHADOW ? rs : ns;
                    n.setTexture2D(e || a, i)
                }

                function Ds(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || as, i)
                }

                function Is(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || os, i)
                }

                function Os(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || is, i)
                }

                function Bs(t, e) {
                    t.uniform1fv(this.addr, e)
                }

                function qs(t, e) {
                    const n = hs(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }

                function Us(t, e) {
                    const n = hs(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }

                function Ns(t, e) {
                    const n = hs(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }

                function ks(t, e) {
                    const n = hs(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }

                function Fs(t, e) {
                    const n = hs(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }

                function zs(t, e) {
                    const n = hs(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }

                function Gs(t, e) {
                    t.uniform1iv(this.addr, e)
                }

                function js(t, e) {
                    t.uniform2iv(this.addr, e)
                }

                function Vs(t, e) {
                    t.uniform3iv(this.addr, e)
                }

                function Hs(t, e) {
                    t.uniform4iv(this.addr, e)
                }

                function Ws(t, e) {
                    t.uniform1uiv(this.addr, e)
                }

                function Xs(t, e) {
                    t.uniform2uiv(this.addr, e)
                }

                function Ys(t, e) {
                    t.uniform3uiv(this.addr, e)
                }

                function Qs(t, e) {
                    t.uniform4uiv(this.addr, e)
                }

                function Zs(t, e, n) {
                    const r = this.cache,
                        i = e.length,
                        a = ps(n, i);
                    ds(r, a) || (t.uniform1iv(this.addr, a), fs(r, a));
                    for (let t = 0; t !== i; ++t) n.setTexture2D(e[t] || ns, a[t])
                }

                function Js(t, e, n) {
                    const r = this.cache,
                        i = e.length,
                        a = ps(n, i);
                    ds(r, a) || (t.uniform1iv(this.addr, a), fs(r, a));
                    for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || as, a[t])
                }

                function Ks(t, e, n) {
                    const r = this.cache,
                        i = e.length,
                        a = ps(n, i);
                    ds(r, a) || (t.uniform1iv(this.addr, a), fs(r, a));
                    for (let t = 0; t !== i; ++t) n.setTextureCube(e[t] || os, a[t])
                }

                function $s(t, e, n) {
                    const r = this.cache,
                        i = e.length,
                        a = ps(n, i);
                    ds(r, a) || (t.uniform1iv(this.addr, a), fs(r, a));
                    for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || is, a[t])
                }
                class tl {
                    constructor(t, e, n) {
                        this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = function(t) {
                            switch (t) {
                                case 5126:
                                    return ms;
                                case 35664:
                                    return gs;
                                case 35665:
                                    return vs;
                                case 35666:
                                    return _s;
                                case 35674:
                                    return ys;
                                case 35675:
                                    return xs;
                                case 35676:
                                    return bs;
                                case 5124:
                                case 35670:
                                    return Ms;
                                case 35667:
                                case 35671:
                                    return ws;
                                case 35668:
                                case 35672:
                                    return Ss;
                                case 35669:
                                case 35673:
                                    return Es;
                                case 5125:
                                    return Ts;
                                case 36294:
                                    return Cs;
                                case 36295:
                                    return Rs;
                                case 36296:
                                    return Ps;
                                case 35678:
                                case 36198:
                                case 36298:
                                case 36306:
                                case 35682:
                                    return Ls;
                                case 35679:
                                case 36299:
                                case 36307:
                                    return Ds;
                                case 35680:
                                case 36300:
                                case 36308:
                                case 36293:
                                    return Is;
                                case 36289:
                                case 36303:
                                case 36311:
                                case 36292:
                                    return Os
                            }
                        }(e.type)
                    }
                }
                class el {
                    constructor(t, e, n) {
                        this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = function(t) {
                            switch (t) {
                                case 5126:
                                    return Bs;
                                case 35664:
                                    return qs;
                                case 35665:
                                    return Us;
                                case 35666:
                                    return Ns;
                                case 35674:
                                    return ks;
                                case 35675:
                                    return Fs;
                                case 35676:
                                    return zs;
                                case 5124:
                                case 35670:
                                    return Gs;
                                case 35667:
                                case 35671:
                                    return js;
                                case 35668:
                                case 35672:
                                    return Vs;
                                case 35669:
                                case 35673:
                                    return Hs;
                                case 5125:
                                    return Ws;
                                case 36294:
                                    return Xs;
                                case 36295:
                                    return Ys;
                                case 36296:
                                    return Qs;
                                case 35678:
                                case 36198:
                                case 36298:
                                case 36306:
                                case 35682:
                                    return Zs;
                                case 35679:
                                case 36299:
                                case 36307:
                                    return Js;
                                case 35680:
                                case 36300:
                                case 36308:
                                case 36293:
                                    return Ks;
                                case 36289:
                                case 36303:
                                case 36311:
                                case 36292:
                                    return $s
                            }
                        }(e.type)
                    }
                }
                class nl {
                    constructor(t) {
                        this.id = t, this.seq = [], this.map = {}
                    }
                    setValue(t, e, n) {
                        const r = this.seq;
                        for (let i = 0, a = r.length; i !== a; ++i) {
                            const a = r[i];
                            a.setValue(t, e[a.id], n)
                        }
                    }
                }
                const rl = /(\w+)(\])?(\[|\.)?/g;

                function il(t, e) {
                    t.seq.push(e), t.map[e.id] = e
                }

                function al(t, e, n) {
                    const r = t.name,
                        i = r.length;
                    for (rl.lastIndex = 0;;) {
                        const a = rl.exec(r),
                            o = rl.lastIndex;
                        let s = a[1];
                        const l = "]" === a[2],
                            A = a[3];
                        if (l && (s |= 0), void 0 === A || "[" === A && o + 2 === i) {
                            il(n, void 0 === A ? new tl(s, t, e) : new el(s, t, e));
                            break
                        } {
                            let t = n.map[s];
                            void 0 === t && (t = new nl(s), il(n, t)), n = t
                        }
                    }
                }
                class ol {
                    constructor(t, e) {
                        this.seq = [], this.map = {};
                        const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                        for (let r = 0; r < n; ++r) {
                            const n = t.getActiveUniform(e, r);
                            al(n, t.getUniformLocation(e, n.name), this)
                        }
                    }
                    setValue(t, e, n, r) {
                        const i = this.map[e];
                        void 0 !== i && i.setValue(t, n, r)
                    }
                    setOptional(t, e, n) {
                        const r = e[n];
                        void 0 !== r && this.setValue(t, n, r)
                    }
                    static upload(t, e, n, r) {
                        for (let i = 0, a = e.length; i !== a; ++i) {
                            const a = e[i],
                                o = n[a.id];
                            !1 !== o.needsUpdate && a.setValue(t, o.value, r)
                        }
                    }
                    static seqWithValue(t, e) {
                        const n = [];
                        for (let r = 0, i = t.length; r !== i; ++r) {
                            const i = t[r];
                            i.id in e && n.push(i)
                        }
                        return n
                    }
                }

                function sl(t, e, n) {
                    const r = t.createShader(e);
                    return t.shaderSource(r, n), t.compileShader(r), r
                }
                const ll = 37297;
                let Al = 0;

                function cl(t, e, n) {
                    const r = t.getShaderParameter(e, t.COMPILE_STATUS),
                        i = t.getShaderInfoLog(e).trim();
                    if (r && "" === i) return "";
                    const a = /ERROR: 0:(\d+)/.exec(i);
                    if (a) {
                        const r = parseInt(a[1]);
                        return n.toUpperCase() + "\n\n" + i + "\n\n" + function(t, e) {
                            const n = t.split("\n"),
                                r = [],
                                i = Math.max(e - 6, 0),
                                a = Math.min(e + 6, n.length);
                            for (let t = i; t < a; t++) {
                                const i = t + 1;
                                r.push(`${i===e?">":" "} ${i}: ${n[t]}`)
                            }
                            return r.join("\n")
                        }(t.getShaderSource(e), r)
                    }
                    return i
                }

                function ul(t, e) {
                    const n = function(t) {
                        const e = pr.getPrimaries(pr.workingColorSpace),
                            n = pr.getPrimaries(t);
                        let r;
                        switch (e === n ? r = "" : e === en && n === tn ? r = "LinearDisplayP3ToLinearSRGB" : e === tn && n === en && (r = "LinearSRGBToLinearDisplayP3"), t) {
                            case Qe:
                            case Je:
                                return [r, "LinearTransferOETF"];
                            case Ye:
                            case Ze:
                                return [r, "sRGBTransferOETF"];
                            default:
                                return console.warn("THREE.WebGLProgram: Unsupported color space:", t), [r, "LinearTransferOETF"]
                        }
                    }(e);
                    return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
                }

                function hl(t, e) {
                    let n;
                    switch (e) {
                        case et:
                            n = "Linear";
                            break;
                        case nt:
                            n = "Reinhard";
                            break;
                        case rt:
                            n = "OptimizedCineon";
                            break;
                        case it:
                            n = "ACESFilmic";
                            break;
                        case ot:
                            n = "AgX";
                            break;
                        case st:
                            n = "Neutral";
                            break;
                        case at:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }

                function dl(t) {
                    return "" !== t
                }

                function fl(t, e) {
                    const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
                    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                }

                function pl(t, e) {
                    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                }
                const ml = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function gl(t) {
                    return t.replace(ml, _l)
                }
                const vl = new Map([
                    ["encodings_fragment", "colorspace_fragment"],
                    ["encodings_pars_fragment", "colorspace_pars_fragment"],
                    ["output_fragment", "opaque_fragment"]
                ]);

                function _l(t, e) {
                    let n = _o[e];
                    if (void 0 === n) {
                        const t = vl.get(e);
                        if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
                        n = _o[t], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
                    }
                    return gl(n)
                }
                const yl = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function xl(t) {
                    return t.replace(yl, bl)
                }

                function bl(t, e, n, r) {
                    let i = "";
                    for (let t = parseInt(e); t < parseInt(n); t++) i += r.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                    return i
                }

                function Ml(t) {
                    let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\t`;
                    return t.isWebGL2 && (e += `precision ${t.precision} sampler3D;\n\t\tprecision ${t.precision} sampler2DArray;\n\t\tprecision ${t.precision} sampler2DShadow;\n\t\tprecision ${t.precision} samplerCubeShadow;\n\t\tprecision ${t.precision} sampler2DArrayShadow;\n\t\tprecision ${t.precision} isampler2D;\n\t\tprecision ${t.precision} isampler3D;\n\t\tprecision ${t.precision} isamplerCube;\n\t\tprecision ${t.precision} isampler2DArray;\n\t\tprecision ${t.precision} usampler2D;\n\t\tprecision ${t.precision} usampler3D;\n\t\tprecision ${t.precision} usamplerCube;\n\t\tprecision ${t.precision} usampler2DArray;\n\t\t`), "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                }

                function wl(t, e, n, r) {
                    const i = t.getContext(),
                        a = n.defines;
                    let o = n.vertexShader,
                        s = n.fragmentShader;
                    const l = function(t) {
                            let e = "SHADOWMAP_TYPE_BASIC";
                            return t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === h ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === d && (e = "SHADOWMAP_TYPE_VSM"), e
                        }(n),
                        A = function(t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap) switch (t.envMapMode) {
                                case ut:
                                case ht:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case pt:
                                    e = "ENVMAP_TYPE_CUBE_UV"
                            }
                            return e
                        }(n),
                        c = function(t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            return t.envMap && t.envMapMode === ht && (e = "ENVMAP_MODE_REFRACTION"), e
                        }(n),
                        f = function(t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap) switch (t.combine) {
                                case J:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case K:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case $:
                                    e = "ENVMAP_BLENDING_ADD"
                            }
                            return e
                        }(n),
                        p = function(t) {
                            const e = t.envMapCubeUVHeight;
                            if (null === e) return null;
                            const n = Math.log2(e) - 2,
                                r = 1 / e;
                            return {
                                texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                                texelHeight: r,
                                maxMip: n
                            }
                        }(n),
                        m = n.isWebGL2 ? "" : function(t) {
                            return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || t.alphaToCoverage || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(dl).join("\n")
                        }(n),
                        g = function(t) {
                            return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(dl).join("\n")
                        }(n),
                        v = function(t) {
                            const e = [];
                            for (const n in t) {
                                const r = t[n];
                                !1 !== r && e.push("#define " + n + " " + r)
                            }
                            return e.join("\n")
                        }(a),
                        _ = i.createProgram();
                    let y, x, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(dl).join("\n"), y.length > 0 && (y += "\n"), x = [m, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(dl).join("\n"), x.length > 0 && (x += "\n")) : (y = [Ml(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(dl).join("\n"), x = [m, Ml(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + A : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + f : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== tt ? "#define TONE_MAPPING" : "", n.toneMapping !== tt ? _o.tonemapping_pars_fragment : "", n.toneMapping !== tt ? hl("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", _o.colorspace_pars_fragment, ul("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(dl).join("\n")), o = gl(o), o = fl(o, n), o = pl(o, n), s = gl(s), s = fl(s, n), s = pl(s, n), o = xl(o), s = xl(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", y = [g, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, x = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === Un ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Un ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
                    const M = b + y + o,
                        w = b + x + s,
                        S = sl(i, i.VERTEX_SHADER, M),
                        E = sl(i, i.FRAGMENT_SHADER, w);

                    function T(e) {
                        if (t.debug.checkShaderErrors) {
                            const n = i.getProgramInfoLog(_).trim(),
                                r = i.getShaderInfoLog(S).trim(),
                                a = i.getShaderInfoLog(E).trim();
                            let o = !0,
                                s = !0;
                            if (!1 === i.getProgramParameter(_, i.LINK_STATUS))
                                if (o = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(i, _, S, E);
                                else {
                                    const t = cl(i, S, "vertex"),
                                        r = cl(i, E, "fragment");
                                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(_, i.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + n + "\n" + t + "\n" + r)
                                }
                            else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== r && "" !== a || (s = !1);
                            s && (e.diagnostics = {
                                runnable: o,
                                programLog: n,
                                vertexShader: {
                                    log: r,
                                    prefix: y
                                },
                                fragmentShader: {
                                    log: a,
                                    prefix: x
                                }
                            })
                        }
                        i.deleteShader(S), i.deleteShader(E), C = new ol(i, _), R = function(t, e) {
                            const n = {},
                                r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                            for (let i = 0; i < r; i++) {
                                const r = t.getActiveAttrib(e, i),
                                    a = r.name;
                                let o = 1;
                                r.type === t.FLOAT_MAT2 && (o = 2), r.type === t.FLOAT_MAT3 && (o = 3), r.type === t.FLOAT_MAT4 && (o = 4), n[a] = {
                                    type: r.type,
                                    location: t.getAttribLocation(e, a),
                                    locationSize: o
                                }
                            }
                            return n
                        }(i, _)
                    }
                    let C, R;
                    i.attachShader(_, S), i.attachShader(_, E), void 0 !== n.index0AttributeName ? i.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(_, 0, "position"), i.linkProgram(_), this.getUniforms = function() {
                        return void 0 === C && T(this), C
                    }, this.getAttributes = function() {
                        return void 0 === R && T(this), R
                    };
                    let P = !1 === n.rendererExtensionParallelShaderCompile;
                    return this.isReady = function() {
                        return !1 === P && (P = i.getProgramParameter(_, ll)), P
                    }, this.destroy = function() {
                        r.releaseStatesOfProgram(this), i.deleteProgram(_), this.program = void 0
                    }, this.type = n.shaderType, this.name = n.shaderName, this.id = Al++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = S, this.fragmentShader = E, this
                }
                let Sl = 0;
                class El {
                    constructor() {
                        this.shaderCache = new Map, this.materialCache = new Map
                    }
                    update(t) {
                        const e = t.vertexShader,
                            n = t.fragmentShader,
                            r = this._getShaderStage(e),
                            i = this._getShaderStage(n),
                            a = this._getShaderCacheForMaterial(t);
                        return !1 === a.has(r) && (a.add(r), r.usedTimes++), !1 === a.has(i) && (a.add(i), i.usedTimes++), this
                    }
                    remove(t) {
                        const e = this.materialCache.get(t);
                        for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                        return this.materialCache.delete(t), this
                    }
                    getVertexShaderID(t) {
                        return this._getShaderStage(t.vertexShader).id
                    }
                    getFragmentShaderID(t) {
                        return this._getShaderStage(t.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear(), this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(t) {
                        const e = this.materialCache;
                        let n = e.get(t);
                        return void 0 === n && (n = new Set, e.set(t, n)), n
                    }
                    _getShaderStage(t) {
                        const e = this.shaderCache;
                        let n = e.get(t);
                        return void 0 === n && (n = new Tl(t), e.set(t, n)), n
                    }
                }
                class Tl {
                    constructor(t) {
                        this.id = Sl++, this.code = t, this.usedTimes = 0
                    }
                }

                function Cl(t, e, n, r, i, a, o) {
                    const s = new yi,
                        l = new El,
                        A = new Set,
                        c = [],
                        u = i.isWebGL2,
                        h = i.logarithmicDepthBuffer,
                        d = i.vertexTextures;
                    let f = i.precision;
                    const g = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };

                    function _(t) {
                        return A.add(t), 0 === t ? "uv" : `uv${t}`
                    }
                    return {
                        getParameters: function(a, s, c, y, x) {
                            const b = y.fog,
                                M = x.geometry,
                                w = a.isMeshStandardMaterial ? y.environment : null,
                                S = (a.isMeshStandardMaterial ? n : e).get(a.envMap || w),
                                E = S && S.mapping === pt ? S.image.height : null,
                                T = g[a.type];
                            null !== a.precision && (f = i.getMaxPrecision(a.precision), f !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", f, "instead."));
                            const C = M.morphAttributes.position || M.morphAttributes.normal || M.morphAttributes.color,
                                R = void 0 !== C ? C.length : 0;
                            let P, L, D, I, O = 0;
                            if (void 0 !== M.morphAttributes.position && (O = 1), void 0 !== M.morphAttributes.normal && (O = 2), void 0 !== M.morphAttributes.color && (O = 3), T) {
                                const t = xo[T];
                                P = t.vertexShader, L = t.fragmentShader
                            } else P = a.vertexShader, L = a.fragmentShader, l.update(a), D = l.getVertexShaderID(a), I = l.getFragmentShaderID(a);
                            const B = t.getRenderTarget(),
                                q = !0 === x.isInstancedMesh,
                                U = !0 === x.isBatchedMesh,
                                N = !!a.map,
                                k = !!a.matcap,
                                F = !!S,
                                z = !!a.aoMap,
                                G = !!a.lightMap,
                                j = !!a.bumpMap,
                                V = !!a.normalMap,
                                H = !!a.displacementMap,
                                W = !!a.emissiveMap,
                                X = !!a.metalnessMap,
                                Y = !!a.roughnessMap,
                                Q = a.anisotropy > 0,
                                Z = a.clearcoat > 0,
                                J = a.iridescence > 0,
                                K = a.sheen > 0,
                                $ = a.transmission > 0,
                                et = Q && !!a.anisotropyMap,
                                nt = Z && !!a.clearcoatMap,
                                rt = Z && !!a.clearcoatNormalMap,
                                it = Z && !!a.clearcoatRoughnessMap,
                                at = J && !!a.iridescenceMap,
                                ot = J && !!a.iridescenceThicknessMap,
                                st = K && !!a.sheenColorMap,
                                lt = K && !!a.sheenRoughnessMap,
                                At = !!a.specularMap,
                                ct = !!a.specularColorMap,
                                ut = !!a.specularIntensityMap,
                                ht = $ && !!a.transmissionMap,
                                dt = $ && !!a.thicknessMap,
                                ft = !!a.gradientMap,
                                mt = !!a.alphaMap,
                                gt = a.alphaTest > 0,
                                vt = !!a.alphaHash,
                                _t = !!a.extensions;
                            let yt = tt;
                            a.toneMapped && (null !== B && !0 !== B.isXRRenderTarget || (yt = t.toneMapping));
                            const xt = {
                                isWebGL2: u,
                                shaderID: T,
                                shaderType: a.type,
                                shaderName: a.name,
                                vertexShader: P,
                                fragmentShader: L,
                                defines: a.defines,
                                customVertexShaderID: D,
                                customFragmentShaderID: I,
                                isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                                glslVersion: a.glslVersion,
                                precision: f,
                                batching: U,
                                instancing: q,
                                instancingColor: q && null !== x.instanceColor,
                                instancingMorph: q && null !== x.morphTexture,
                                supportsVertexTextures: d,
                                outputColorSpace: null === B ? t.outputColorSpace : !0 === B.isXRRenderTarget ? B.texture.colorSpace : Qe,
                                alphaToCoverage: !!a.alphaToCoverage,
                                map: N,
                                matcap: k,
                                envMap: F,
                                envMapMode: F && S.mapping,
                                envMapCubeUVHeight: E,
                                aoMap: z,
                                lightMap: G,
                                bumpMap: j,
                                normalMap: V,
                                displacementMap: d && H,
                                emissiveMap: W,
                                normalMapObjectSpace: V && a.normalMapType === We,
                                normalMapTangentSpace: V && a.normalMapType === He,
                                metalnessMap: X,
                                roughnessMap: Y,
                                anisotropy: Q,
                                anisotropyMap: et,
                                clearcoat: Z,
                                clearcoatMap: nt,
                                clearcoatNormalMap: rt,
                                clearcoatRoughnessMap: it,
                                iridescence: J,
                                iridescenceMap: at,
                                iridescenceThicknessMap: ot,
                                sheen: K,
                                sheenColorMap: st,
                                sheenRoughnessMap: lt,
                                specularMap: At,
                                specularColorMap: ct,
                                specularIntensityMap: ut,
                                transmission: $,
                                transmissionMap: ht,
                                thicknessMap: dt,
                                gradientMap: ft,
                                opaque: !1 === a.transparent && a.blending === v && !1 === a.alphaToCoverage,
                                alphaMap: mt,
                                alphaTest: gt,
                                alphaHash: vt,
                                combine: a.combine,
                                mapUv: N && _(a.map.channel),
                                aoMapUv: z && _(a.aoMap.channel),
                                lightMapUv: G && _(a.lightMap.channel),
                                bumpMapUv: j && _(a.bumpMap.channel),
                                normalMapUv: V && _(a.normalMap.channel),
                                displacementMapUv: H && _(a.displacementMap.channel),
                                emissiveMapUv: W && _(a.emissiveMap.channel),
                                metalnessMapUv: X && _(a.metalnessMap.channel),
                                roughnessMapUv: Y && _(a.roughnessMap.channel),
                                anisotropyMapUv: et && _(a.anisotropyMap.channel),
                                clearcoatMapUv: nt && _(a.clearcoatMap.channel),
                                clearcoatNormalMapUv: rt && _(a.clearcoatNormalMap.channel),
                                clearcoatRoughnessMapUv: it && _(a.clearcoatRoughnessMap.channel),
                                iridescenceMapUv: at && _(a.iridescenceMap.channel),
                                iridescenceThicknessMapUv: ot && _(a.iridescenceThicknessMap.channel),
                                sheenColorMapUv: st && _(a.sheenColorMap.channel),
                                sheenRoughnessMapUv: lt && _(a.sheenRoughnessMap.channel),
                                specularMapUv: At && _(a.specularMap.channel),
                                specularColorMapUv: ct && _(a.specularColorMap.channel),
                                specularIntensityMapUv: ut && _(a.specularIntensityMap.channel),
                                transmissionMapUv: ht && _(a.transmissionMap.channel),
                                thicknessMapUv: dt && _(a.thicknessMap.channel),
                                alphaMapUv: mt && _(a.alphaMap.channel),
                                vertexTangents: !!M.attributes.tangent && (V || Q),
                                vertexColors: a.vertexColors,
                                vertexAlphas: !0 === a.vertexColors && !!M.attributes.color && 4 === M.attributes.color.itemSize,
                                pointsUvs: !0 === x.isPoints && !!M.attributes.uv && (N || mt),
                                fog: !!b,
                                useFog: !0 === a.fog,
                                fogExp2: !!b && b.isFogExp2,
                                flatShading: !0 === a.flatShading,
                                sizeAttenuation: !0 === a.sizeAttenuation,
                                logarithmicDepthBuffer: h,
                                skinning: !0 === x.isSkinnedMesh,
                                morphTargets: void 0 !== M.morphAttributes.position,
                                morphNormals: void 0 !== M.morphAttributes.normal,
                                morphColors: void 0 !== M.morphAttributes.color,
                                morphTargetsCount: R,
                                morphTextureStride: O,
                                numDirLights: s.directional.length,
                                numPointLights: s.point.length,
                                numSpotLights: s.spot.length,
                                numSpotLightMaps: s.spotLightMap.length,
                                numRectAreaLights: s.rectArea.length,
                                numHemiLights: s.hemi.length,
                                numDirLightShadows: s.directionalShadowMap.length,
                                numPointLightShadows: s.pointShadowMap.length,
                                numSpotLightShadows: s.spotShadowMap.length,
                                numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                                numLightProbes: s.numLightProbes,
                                numClippingPlanes: o.numPlanes,
                                numClipIntersection: o.numIntersection,
                                dithering: a.dithering,
                                shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                                shadowMapType: t.shadowMap.type,
                                toneMapping: yt,
                                useLegacyLights: t._useLegacyLights,
                                decodeVideoTexture: N && !0 === a.map.isVideoTexture && pr.getTransfer(a.map.colorSpace) === $e,
                                premultipliedAlpha: a.premultipliedAlpha,
                                doubleSided: a.side === m,
                                flipSided: a.side === p,
                                useDepthPacking: a.depthPacking >= 0,
                                depthPacking: a.depthPacking || 0,
                                index0AttributeName: a.index0AttributeName,
                                extensionDerivatives: _t && !0 === a.extensions.derivatives,
                                extensionFragDepth: _t && !0 === a.extensions.fragDepth,
                                extensionDrawBuffers: _t && !0 === a.extensions.drawBuffers,
                                extensionShaderTextureLOD: _t && !0 === a.extensions.shaderTextureLOD,
                                extensionClipCullDistance: _t && !0 === a.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                                extensionMultiDraw: _t && !0 === a.extensions.multiDraw && r.has("WEBGL_multi_draw"),
                                rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
                                rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                                customProgramCacheKey: a.customProgramCacheKey()
                            };
                            return xt.vertexUv1s = A.has(1), xt.vertexUv2s = A.has(2), xt.vertexUv3s = A.has(3), A.clear(), xt
                        },
                        getProgramCacheKey: function(e) {
                            const n = [];
                            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                            return !1 === e.isRawShaderMaterial && (function(t, e) {
                                t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.numLightProbes), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                            }(n, e), function(t, e) {
                                s.disableAll(), e.isWebGL2 && s.enable(0), e.supportsVertexTextures && s.enable(1), e.instancing && s.enable(2), e.instancingColor && s.enable(3), e.instancingMorph && s.enable(4), e.matcap && s.enable(5), e.envMap && s.enable(6), e.normalMapObjectSpace && s.enable(7), e.normalMapTangentSpace && s.enable(8), e.clearcoat && s.enable(9), e.iridescence && s.enable(10), e.alphaTest && s.enable(11), e.vertexColors && s.enable(12), e.vertexAlphas && s.enable(13), e.vertexUv1s && s.enable(14), e.vertexUv2s && s.enable(15), e.vertexUv3s && s.enable(16), e.vertexTangents && s.enable(17), e.anisotropy && s.enable(18), e.alphaHash && s.enable(19), e.batching && s.enable(20), t.push(s.mask), s.disableAll(), e.fog && s.enable(0), e.useFog && s.enable(1), e.flatShading && s.enable(2), e.logarithmicDepthBuffer && s.enable(3), e.skinning && s.enable(4), e.morphTargets && s.enable(5), e.morphNormals && s.enable(6), e.morphColors && s.enable(7), e.premultipliedAlpha && s.enable(8), e.shadowMapEnabled && s.enable(9), e.useLegacyLights && s.enable(10), e.doubleSided && s.enable(11), e.flipSided && s.enable(12), e.useDepthPacking && s.enable(13), e.dithering && s.enable(14), e.transmission && s.enable(15), e.sheen && s.enable(16), e.opaque && s.enable(17), e.pointsUvs && s.enable(18), e.decodeVideoTexture && s.enable(19), e.alphaToCoverage && s.enable(20), t.push(s.mask)
                            }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join()
                        },
                        getUniforms: function(t) {
                            const e = g[t.type];
                            let n;
                            if (e) {
                                const t = xo[e];
                                n = Ja.clone(t.uniforms)
                            } else n = t.uniforms;
                            return n
                        },
                        acquireProgram: function(e, n) {
                            let r;
                            for (let t = 0, e = c.length; t < e; t++) {
                                const e = c[t];
                                if (e.cacheKey === n) {
                                    r = e, ++r.usedTimes;
                                    break
                                }
                            }
                            return void 0 === r && (r = new wl(t, n, e, a), c.push(r)), r
                        },
                        releaseProgram: function(t) {
                            if (0 == --t.usedTimes) {
                                const e = c.indexOf(t);
                                c[e] = c[c.length - 1], c.pop(), t.destroy()
                            }
                        },
                        releaseShaderCache: function(t) {
                            l.remove(t)
                        },
                        programs: c,
                        dispose: function() {
                            l.dispose()
                        }
                    }
                }

                function Rl() {
                    let t = new WeakMap;
                    return {
                        get: function(e) {
                            let n = t.get(e);
                            return void 0 === n && (n = {}, t.set(e, n)), n
                        },
                        remove: function(e) {
                            t.delete(e)
                        },
                        update: function(e, n, r) {
                            t.get(e)[n] = r
                        },
                        dispose: function() {
                            t = new WeakMap
                        }
                    }
                }

                function Pl(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                }

                function Ll(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                }

                function Dl() {
                    const t = [];
                    let e = 0;
                    const n = [],
                        r = [],
                        i = [];

                    function a(n, r, i, a, o, s) {
                        let l = t[e];
                        return void 0 === l ? (l = {
                            id: n.id,
                            object: n,
                            geometry: r,
                            material: i,
                            groupOrder: a,
                            renderOrder: n.renderOrder,
                            z: o,
                            group: s
                        }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = o, l.group = s), e++, l
                    }
                    return {
                        opaque: n,
                        transmissive: r,
                        transparent: i,
                        init: function() {
                            e = 0, n.length = 0, r.length = 0, i.length = 0
                        },
                        push: function(t, e, o, s, l, A) {
                            const c = a(t, e, o, s, l, A);
                            o.transmission > 0 ? r.push(c) : !0 === o.transparent ? i.push(c) : n.push(c)
                        },
                        unshift: function(t, e, o, s, l, A) {
                            const c = a(t, e, o, s, l, A);
                            o.transmission > 0 ? r.unshift(c) : !0 === o.transparent ? i.unshift(c) : n.unshift(c)
                        },
                        finish: function() {
                            for (let n = e, r = t.length; n < r; n++) {
                                const e = t[n];
                                if (null === e.id) break;
                                e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                            }
                        },
                        sort: function(t, e) {
                            n.length > 1 && n.sort(t || Pl), r.length > 1 && r.sort(e || Ll), i.length > 1 && i.sort(e || Ll)
                        }
                    }
                }

                function Il() {
                    let t = new WeakMap;
                    return {
                        get: function(e, n) {
                            const r = t.get(e);
                            let i;
                            return void 0 === r ? (i = new Dl, t.set(e, [i])) : n >= r.length ? (i = new Dl, r.push(i)) : i = r[n], i
                        },
                        dispose: function() {
                            t = new WeakMap
                        }
                    }
                }

                function Ol() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = {
                                        direction: new Ir,
                                        color: new Ki
                                    };
                                    break;
                                case "SpotLight":
                                    n = {
                                        position: new Ir,
                                        direction: new Ir,
                                        color: new Ki,
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        position: new Ir,
                                        color: new Ki,
                                        distance: 0,
                                        decay: 0
                                    };
                                    break;
                                case "HemisphereLight":
                                    n = {
                                        direction: new Ir,
                                        skyColor: new Ki,
                                        groundColor: new Ki
                                    };
                                    break;
                                case "RectAreaLight":
                                    n = {
                                        color: new Ki,
                                        position: new Ir,
                                        halfWidth: new Ir,
                                        halfHeight: new Ir
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }
                let Bl = 0;

                function ql(t, e) {
                    return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
                }

                function Ul(t, e) {
                    const n = new Ol,
                        r = function() {
                            const t = {};
                            return {
                                get: function(e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new er
                                            };
                                            break;
                                        case "PointLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new er,
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3
                                            }
                                    }
                                    return t[e.id] = n, n
                                }
                            }
                        }(),
                        i = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1,
                                numSpotMaps: -1,
                                numLightProbes: -1
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotLightMap: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotLightMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                            numSpotLightShadowsWithMaps: 0,
                            numLightProbes: 0
                        };
                    for (let t = 0; t < 9; t++) i.probe.push(new Ir);
                    const a = new Ir,
                        o = new Ai,
                        s = new Ai;
                    return {
                        setup: function(a, o) {
                            let s = 0,
                                l = 0,
                                A = 0;
                            for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
                            let c = 0,
                                u = 0,
                                h = 0,
                                d = 0,
                                f = 0,
                                p = 0,
                                m = 0,
                                g = 0,
                                v = 0,
                                _ = 0,
                                y = 0;
                            a.sort(ql);
                            const x = !0 === o ? Math.PI : 1;
                            for (let t = 0, e = a.length; t < e; t++) {
                                const e = a[t],
                                    o = e.color,
                                    b = e.intensity,
                                    M = e.distance,
                                    w = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                                if (e.isAmbientLight) s += o.r * b * x, l += o.g * b * x, A += o.b * b * x;
                                else if (e.isLightProbe) {
                                    for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], b);
                                    y++
                                } else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity * x), e.castShadow) {
                                        const t = e.shadow,
                                            n = r.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[c] = n, i.directionalShadowMap[c] = w, i.directionalShadowMatrix[c] = e.shadow.matrix, p++
                                    }
                                    i.directional[c] = t, c++
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(b * x), t.distance = M, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, i.spot[h] = t;
                                    const a = e.shadow;
                                    if (e.map && (i.spotLightMap[v] = e.map, v++, a.updateMatrices(e), e.castShadow && _++), i.spotLightMatrix[h] = a.matrix, e.castShadow) {
                                        const t = r.get(e);
                                        t.shadowBias = a.bias, t.shadowNormalBias = a.normalBias, t.shadowRadius = a.radius, t.shadowMapSize = a.mapSize, i.spotShadow[h] = t, i.spotShadowMap[h] = w, g++
                                    }
                                    h++
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(o).multiplyScalar(b), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[d] = t, d++
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity * x), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = r.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[u] = n, i.pointShadowMap[u] = w, i.pointShadowMatrix[u] = e.shadow.matrix, m++
                                    }
                                    i.point[u] = t, u++
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor.copy(e.color).multiplyScalar(b * x), t.groundColor.copy(e.groundColor).multiplyScalar(b * x), i.hemi[f] = t, f++
                                }
                            }
                            d > 0 && (e.isWebGL2 ? !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = yo.LTC_FLOAT_1, i.rectAreaLTC2 = yo.LTC_FLOAT_2) : (i.rectAreaLTC1 = yo.LTC_HALF_1, i.rectAreaLTC2 = yo.LTC_HALF_2) : !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = yo.LTC_FLOAT_1, i.rectAreaLTC2 = yo.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = yo.LTC_HALF_1, i.rectAreaLTC2 = yo.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = s, i.ambient[1] = l, i.ambient[2] = A;
                            const b = i.hash;
                            b.directionalLength === c && b.pointLength === u && b.spotLength === h && b.rectAreaLength === d && b.hemiLength === f && b.numDirectionalShadows === p && b.numPointShadows === m && b.numSpotShadows === g && b.numSpotMaps === v && b.numLightProbes === y || (i.directional.length = c, i.spot.length = h, i.rectArea.length = d, i.point.length = u, i.hemi.length = f, i.directionalShadow.length = p, i.directionalShadowMap.length = p, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = p, i.pointShadowMatrix.length = m, i.spotLightMatrix.length = g + v - _, i.spotLightMap.length = v, i.numSpotLightShadowsWithMaps = _, i.numLightProbes = y, b.directionalLength = c, b.pointLength = u, b.spotLength = h, b.rectAreaLength = d, b.hemiLength = f, b.numDirectionalShadows = p, b.numPointShadows = m, b.numSpotShadows = g, b.numSpotMaps = v, b.numLightProbes = y, i.version = Bl++)
                        },
                        setupView: function(t, e) {
                            let n = 0,
                                r = 0,
                                l = 0,
                                A = 0,
                                c = 0;
                            const u = e.matrixWorldInverse;
                            for (let e = 0, h = t.length; e < h; e++) {
                                const h = t[e];
                                if (h.isDirectionalLight) {
                                    const t = i.directional[n];
                                    t.direction.setFromMatrixPosition(h.matrixWorld), a.setFromMatrixPosition(h.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(u), n++
                                } else if (h.isSpotLight) {
                                    const t = i.spot[l];
                                    t.position.setFromMatrixPosition(h.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(h.matrixWorld), a.setFromMatrixPosition(h.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(u), l++
                                } else if (h.isRectAreaLight) {
                                    const t = i.rectArea[A];
                                    t.position.setFromMatrixPosition(h.matrixWorld), t.position.applyMatrix4(u), s.identity(), o.copy(h.matrixWorld), o.premultiply(u), s.extractRotation(o), t.halfWidth.set(.5 * h.width, 0, 0), t.halfHeight.set(0, .5 * h.height, 0), t.halfWidth.applyMatrix4(s), t.halfHeight.applyMatrix4(s), A++
                                } else if (h.isPointLight) {
                                    const t = i.point[r];
                                    t.position.setFromMatrixPosition(h.matrixWorld), t.position.applyMatrix4(u), r++
                                } else if (h.isHemisphereLight) {
                                    const t = i.hemi[c];
                                    t.direction.setFromMatrixPosition(h.matrixWorld), t.direction.transformDirection(u), c++
                                }
                            }
                        },
                        state: i
                    }
                }

                function Nl(t, e) {
                    const n = new Ul(t, e),
                        r = [],
                        i = [];
                    return {
                        init: function() {
                            r.length = 0, i.length = 0
                        },
                        state: {
                            lightsArray: r,
                            shadowsArray: i,
                            lights: n
                        },
                        setupLights: function(t) {
                            n.setup(r, t)
                        },
                        setupLightsView: function(t) {
                            n.setupView(r, t)
                        },
                        pushLight: function(t) {
                            r.push(t)
                        },
                        pushShadow: function(t) {
                            i.push(t)
                        }
                    }
                }

                function kl(t, e) {
                    let n = new WeakMap;
                    return {
                        get: function(r, i = 0) {
                            const a = n.get(r);
                            let o;
                            return void 0 === a ? (o = new Nl(t, e), n.set(r, [o])) : i >= a.length ? (o = new Nl(t, e), a.push(o)) : o = a[i], o
                        },
                        dispose: function() {
                            n = new WeakMap
                        }
                    }
                }
                class Fl extends ea {
                    constructor(t) {
                        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = je, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                    }
                }
                class zl extends ea {
                    constructor(t) {
                        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                    }
                }

                function Gl(t, e, n) {
                    let r = new po;
                    const i = new er,
                        a = new er,
                        o = new Sr,
                        s = new Fl({
                            depthPacking: Ve
                        }),
                        l = new zl,
                        A = {},
                        c = n.maxTextureSize,
                        h = {
                            [f]: p,
                            [p]: f,
                            [m]: m
                        },
                        v = new Ka({
                            defines: {
                                VSM_SAMPLES: 8
                            },
                            uniforms: {
                                shadow_pass: {
                                    value: null
                                },
                                resolution: {
                                    value: new er
                                },
                                radius: {
                                    value: 4
                                }
                            },
                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                        }),
                        _ = v.clone();
                    _.defines.HORIZONTAL_PASS = 1;
                    const y = new Ta;
                    y.setAttribute("position", new ca(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    const x = new Ha(y, v),
                        b = this;
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = u;
                    let M = this.type;

                    function w(n, r) {
                        const a = e.update(x);
                        v.defines.VSM_SAMPLES !== n.blurSamples && (v.defines.VSM_SAMPLES = n.blurSamples, _.defines.VSM_SAMPLES = n.blurSamples, v.needsUpdate = !0, _.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Tr(i.x, i.y)), v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, a, v, x, null), _.uniforms.shadow_pass.value = n.mapPass.texture, _.uniforms.resolution.value = n.mapSize, _.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, a, _, x, null)
                    }

                    function S(e, n, r, i) {
                        let a = null;
                        const o = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                        if (void 0 !== o) a = o;
                        else if (a = !0 === r.isPointLight ? l : s, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                            const t = a.uuid,
                                e = n.uuid;
                            let r = A[t];
                            void 0 === r && (r = {}, A[t] = r);
                            let i = r[e];
                            void 0 === i && (i = a.clone(), r[e] = i, n.addEventListener("dispose", T)), a = i
                        }
                        return a.visible = n.visible, a.wireframe = n.wireframe, a.side = i === d ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], a.alphaMap = n.alphaMap, a.alphaTest = n.alphaTest, a.map = n.map, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.clipIntersection = n.clipIntersection, a.displacementMap = n.displacementMap, a.displacementScale = n.displacementScale, a.displacementBias = n.displacementBias, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, !0 === r.isPointLight && !0 === a.isMeshDistanceMaterial && (t.properties.get(a).light = r), a
                    }

                    function E(n, i, a, o, s) {
                        if (!1 === n.visible) return;
                        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === d) && (!n.frustumCulled || r.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                            const r = e.update(n),
                                l = n.material;
                            if (Array.isArray(l)) {
                                const e = r.groups;
                                for (let A = 0, c = e.length; A < c; A++) {
                                    const c = e[A],
                                        u = l[c.materialIndex];
                                    if (u && u.visible) {
                                        const e = S(n, u, o, s);
                                        n.onBeforeShadow(t, n, i, a, r, e, c), t.renderBufferDirect(a, null, r, e, n, c), n.onAfterShadow(t, n, i, a, r, e, c)
                                    }
                                }
                            } else if (l.visible) {
                                const e = S(n, l, o, s);
                                n.onBeforeShadow(t, n, i, a, r, e, null), t.renderBufferDirect(a, null, r, e, n, null), n.onAfterShadow(t, n, i, a, r, e, null)
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++) E(l[t], i, a, o, s)
                    }

                    function T(t) {
                        t.target.removeEventListener("dispose", T);
                        for (const e in A) {
                            const n = A[e],
                                r = t.target.uuid;
                            r in n && (n[r].dispose(), delete n[r])
                        }
                    }
                    this.render = function(e, n, s) {
                        if (!1 === b.enabled) return;
                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            A = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            h = t.state;
                        h.setBlending(g), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                        const f = M !== d && this.type === d,
                            p = M === d && this.type !== d;
                        for (let l = 0, A = e.length; l < A; l++) {
                            const A = e[l],
                                u = A.shadow;
                            if (void 0 === u) {
                                console.warn("THREE.WebGLShadowMap:", A, "has no shadow.");
                                continue
                            }
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                            i.copy(u.mapSize);
                            const m = u.getFrameExtents();
                            if (i.multiply(m), a.copy(u.mapSize), (i.x > c || i.y > c) && (i.x > c && (a.x = Math.floor(c / m.x), i.x = a.x * m.x, u.mapSize.x = a.x), i.y > c && (a.y = Math.floor(c / m.y), i.y = a.y * m.y, u.mapSize.y = a.y)), null === u.map || !0 === f || !0 === p) {
                                const t = this.type !== d ? {
                                    minFilter: _t,
                                    magFilter: _t
                                } : {};
                                null !== u.map && u.map.dispose(), u.map = new Tr(i.x, i.y, t), u.map.texture.name = A.name + ".shadowMap", u.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const g = u.getViewportCount();
                            for (let t = 0; t < g; t++) {
                                const e = u.getViewport(t);
                                o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w), h.viewport(o), u.updateMatrices(A, t), r = u.getFrustum(), E(n, s, u.camera, A, this.type)
                            }!0 !== u.isPointLightShadow && this.type === d && w(u, s), u.needsUpdate = !1
                        }
                        M = this.type, b.needsUpdate = !1, t.setRenderTarget(l, A, u)
                    }
                }

                function jl(t, e, n) {
                    const r = n.isWebGL2,
                        i = new function() {
                            let e = !1;
                            const n = new Sr;
                            let r = null;
                            const i = new Sr(0, 0, 0, 0);
                            return {
                                setMask: function(n) {
                                    r === n || e || (t.colorMask(n, n, n, n), r = n)
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e, r, a, o, s) {
                                    !0 === s && (e *= o, r *= o, a *= o), n.set(e, r, a, o), !1 === i.equals(n) && (t.clearColor(e, r, a, o), i.copy(n))
                                },
                                reset: function() {
                                    e = !1, r = null, i.set(-1, 0, 0, 0)
                                }
                            }
                        },
                        a = new function() {
                            let e = !1,
                                n = null,
                                r = null,
                                i = null;
                            return {
                                setTest: function(e) {
                                    e ? Tt(t.DEPTH_TEST) : Ct(t.DEPTH_TEST)
                                },
                                setMask: function(r) {
                                    n === r || e || (t.depthMask(r), n = r)
                                },
                                setFunc: function(e) {
                                    if (r !== e) {
                                        switch (e) {
                                            case j:
                                                t.depthFunc(t.NEVER);
                                                break;
                                            case V:
                                                t.depthFunc(t.ALWAYS);
                                                break;
                                            case H:
                                                t.depthFunc(t.LESS);
                                                break;
                                            case W:
                                                t.depthFunc(t.LEQUAL);
                                                break;
                                            case X:
                                                t.depthFunc(t.EQUAL);
                                                break;
                                            case Y:
                                                t.depthFunc(t.GEQUAL);
                                                break;
                                            case Q:
                                                t.depthFunc(t.GREATER);
                                                break;
                                            case Z:
                                                t.depthFunc(t.NOTEQUAL);
                                                break;
                                            default:
                                                t.depthFunc(t.LEQUAL)
                                        }
                                        r = e
                                    }
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e) {
                                    i !== e && (t.clearDepth(e), i = e)
                                },
                                reset: function() {
                                    e = !1, n = null, r = null, i = null
                                }
                            }
                        },
                        A = new function() {
                            let e = !1,
                                n = null,
                                r = null,
                                i = null,
                                a = null,
                                o = null,
                                s = null,
                                l = null,
                                A = null;
                            return {
                                setTest: function(n) {
                                    e || (n ? Tt(t.STENCIL_TEST) : Ct(t.STENCIL_TEST))
                                },
                                setMask: function(r) {
                                    n === r || e || (t.stencilMask(r), n = r)
                                },
                                setFunc: function(e, n, o) {
                                    r === e && i === n && a === o || (t.stencilFunc(e, n, o), r = e, i = n, a = o)
                                },
                                setOp: function(e, n, r) {
                                    o === e && s === n && l === r || (t.stencilOp(e, n, r), o = e, s = n, l = r)
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e) {
                                    A !== e && (t.clearStencil(e), A = e)
                                },
                                reset: function() {
                                    e = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, A = null
                                }
                            }
                        },
                        c = new WeakMap,
                        u = new WeakMap;
                    let h = {},
                        d = {},
                        f = new WeakMap,
                        J = [],
                        K = null,
                        $ = !1,
                        tt = null,
                        et = null,
                        nt = null,
                        rt = null,
                        it = null,
                        at = null,
                        ot = null,
                        st = new Ki(0, 0, 0),
                        lt = 0,
                        At = !1,
                        ct = null,
                        ut = null,
                        ht = null,
                        dt = null,
                        ft = null;
                    const pt = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    let mt = !1,
                        gt = 0;
                    const vt = t.getParameter(t.VERSION); - 1 !== vt.indexOf("WebGL") ? (gt = parseFloat(/^WebGL (\d)/.exec(vt)[1]), mt = gt >= 1) : -1 !== vt.indexOf("OpenGL ES") && (gt = parseFloat(/^OpenGL ES (\d)/.exec(vt)[1]), mt = gt >= 2);
                    let _t = null,
                        yt = {};
                    const xt = t.getParameter(t.SCISSOR_BOX),
                        bt = t.getParameter(t.VIEWPORT),
                        Mt = (new Sr).fromArray(xt),
                        wt = (new Sr).fromArray(bt);

                    function St(e, n, i, a) {
                        const o = new Uint8Array(4),
                            s = t.createTexture();
                        t.bindTexture(e, s), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                        for (let s = 0; s < i; s++) !r || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + s, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, o) : t.texImage3D(n, 0, t.RGBA, 1, 1, a, 0, t.RGBA, t.UNSIGNED_BYTE, o);
                        return s
                    }
                    const Et = {};

                    function Tt(e) {
                        !0 !== h[e] && (t.enable(e), h[e] = !0)
                    }

                    function Ct(e) {
                        !1 !== h[e] && (t.disable(e), h[e] = !1)
                    }
                    Et[t.TEXTURE_2D] = St(t.TEXTURE_2D, t.TEXTURE_2D, 1), Et[t.TEXTURE_CUBE_MAP] = St(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (Et[t.TEXTURE_2D_ARRAY] = St(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), Et[t.TEXTURE_3D] = St(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), i.setClear(0, 0, 0, 1), a.setClear(1), A.setClear(0), Tt(t.DEPTH_TEST), a.setFunc(W), Dt(!1), It(s), Tt(t.CULL_FACE), Lt(g);
                    const Rt = {
                        [M]: t.FUNC_ADD,
                        [w]: t.FUNC_SUBTRACT,
                        [S]: t.FUNC_REVERSE_SUBTRACT
                    };
                    if (r) Rt[E] = t.MIN, Rt[T] = t.MAX;
                    else {
                        const t = e.get("EXT_blend_minmax");
                        null !== t && (Rt[E] = t.MIN_EXT, Rt[T] = t.MAX_EXT)
                    }
                    const Pt = {
                        [C]: t.ZERO,
                        [R]: t.ONE,
                        [P]: t.SRC_COLOR,
                        [D]: t.SRC_ALPHA,
                        [N]: t.SRC_ALPHA_SATURATE,
                        [q]: t.DST_COLOR,
                        [O]: t.DST_ALPHA,
                        [L]: t.ONE_MINUS_SRC_COLOR,
                        [I]: t.ONE_MINUS_SRC_ALPHA,
                        [U]: t.ONE_MINUS_DST_COLOR,
                        [B]: t.ONE_MINUS_DST_ALPHA,
                        [k]: t.CONSTANT_COLOR,
                        [F]: t.ONE_MINUS_CONSTANT_COLOR,
                        [z]: t.CONSTANT_ALPHA,
                        [G]: t.ONE_MINUS_CONSTANT_ALPHA
                    };

                    function Lt(e, n, r, i, a, o, s, l, A, c) {
                        if (e !== g) {
                            if (!1 === $ && (Tt(t.BLEND), $ = !0), e === b) a = a || n, o = o || r, s = s || i, n === et && a === it || (t.blendEquationSeparate(Rt[n], Rt[a]), et = n, it = a), r === nt && i === rt && o === at && s === ot || (t.blendFuncSeparate(Pt[r], Pt[i], Pt[o], Pt[s]), nt = r, rt = i, at = o, ot = s), !1 !== l.equals(st) && A === lt || (t.blendColor(l.r, l.g, l.b, A), st.copy(l), lt = A), tt = e, At = !1;
                            else if (e !== tt || c !== At) {
                                if (et === M && it === M || (t.blendEquation(t.FUNC_ADD), et = M, it = M), c) switch (e) {
                                    case v:
                                        t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case _:
                                        t.blendFunc(t.ONE, t.ONE);
                                        break;
                                    case y:
                                        t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                        break;
                                    case x:
                                        t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                } else switch (e) {
                                    case v:
                                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case _:
                                        t.blendFunc(t.SRC_ALPHA, t.ONE);
                                        break;
                                    case y:
                                        t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                        break;
                                    case x:
                                        t.blendFunc(t.ZERO, t.SRC_COLOR);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                }
                                nt = null, rt = null, at = null, ot = null, st.set(0, 0, 0), lt = 0, tt = e, At = c
                            }
                        } else !0 === $ && (Ct(t.BLEND), $ = !1)
                    }

                    function Dt(e) {
                        ct !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), ct = e)
                    }

                    function It(e) {
                        e !== o ? (Tt(t.CULL_FACE), e !== ut && (e === s ? t.cullFace(t.BACK) : e === l ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Ct(t.CULL_FACE), ut = e
                    }

                    function Ot(e, n, r) {
                        e ? (Tt(t.POLYGON_OFFSET_FILL), dt === n && ft === r || (t.polygonOffset(n, r), dt = n, ft = r)) : Ct(t.POLYGON_OFFSET_FILL)
                    }
                    return {
                        buffers: {
                            color: i,
                            depth: a,
                            stencil: A
                        },
                        enable: Tt,
                        disable: Ct,
                        bindFramebuffer: function(e, n) {
                            return d[e] !== n && (t.bindFramebuffer(e, n), d[e] = n, r && (e === t.DRAW_FRAMEBUFFER && (d[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (d[t.DRAW_FRAMEBUFFER] = n)), !0)
                        },
                        drawBuffers: function(r, i) {
                            let a = J,
                                o = !1;
                            if (r) {
                                a = f.get(i), void 0 === a && (a = [], f.set(i, a));
                                const e = r.textures;
                                if (a.length !== e.length || a[0] !== t.COLOR_ATTACHMENT0) {
                                    for (let n = 0, r = e.length; n < r; n++) a[n] = t.COLOR_ATTACHMENT0 + n;
                                    a.length = e.length, o = !0
                                }
                            } else a[0] !== t.BACK && (a[0] = t.BACK, o = !0);
                            if (o)
                                if (n.isWebGL2) t.drawBuffers(a);
                                else {
                                    if (!0 !== e.has("WEBGL_draw_buffers")) throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension");
                                    e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a)
                                }
                        },
                        useProgram: function(e) {
                            return K !== e && (t.useProgram(e), K = e, !0)
                        },
                        setBlending: Lt,
                        setMaterial: function(e, n) {
                            e.side === m ? Ct(t.CULL_FACE) : Tt(t.CULL_FACE);
                            let r = e.side === p;
                            n && (r = !r), Dt(r), e.blending === v && !1 === e.transparent ? Lt(g) : Lt(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.blendColor, e.blendAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), i.setMask(e.colorWrite);
                            const o = e.stencilWrite;
                            A.setTest(o), o && (A.setMask(e.stencilWriteMask), A.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), A.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Ot(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? Tt(t.SAMPLE_ALPHA_TO_COVERAGE) : Ct(t.SAMPLE_ALPHA_TO_COVERAGE)
                        },
                        setFlipSided: Dt,
                        setCullFace: It,
                        setLineWidth: function(e) {
                            e !== ht && (mt && t.lineWidth(e), ht = e)
                        },
                        setPolygonOffset: Ot,
                        setScissorTest: function(e) {
                            e ? Tt(t.SCISSOR_TEST) : Ct(t.SCISSOR_TEST)
                        },
                        activeTexture: function(e) {
                            void 0 === e && (e = t.TEXTURE0 + pt - 1), _t !== e && (t.activeTexture(e), _t = e)
                        },
                        bindTexture: function(e, n, r) {
                            void 0 === r && (r = null === _t ? t.TEXTURE0 + pt - 1 : _t);
                            let i = yt[r];
                            void 0 === i && (i = {
                                type: void 0,
                                texture: void 0
                            }, yt[r] = i), i.type === e && i.texture === n || (_t !== r && (t.activeTexture(r), _t = r), t.bindTexture(e, n || Et[e]), i.type = e, i.texture = n)
                        },
                        unbindTexture: function() {
                            const e = yt[_t];
                            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                        },
                        compressedTexImage2D: function() {
                            try {
                                t.compressedTexImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        compressedTexImage3D: function() {
                            try {
                                t.compressedTexImage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage2D: function() {
                            try {
                                t.texImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage3D: function() {
                            try {
                                t.texImage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        updateUBOMapping: function(e, n) {
                            let r = u.get(n);
                            void 0 === r && (r = new WeakMap, u.set(n, r));
                            let i = r.get(e);
                            void 0 === i && (i = t.getUniformBlockIndex(n, e.name), r.set(e, i))
                        },
                        uniformBlockBinding: function(e, n) {
                            const r = u.get(n).get(e);
                            c.get(n) !== r && (t.uniformBlockBinding(n, r, e.__bindingPointIndex), c.set(n, r))
                        },
                        texStorage2D: function() {
                            try {
                                t.texStorage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texStorage3D: function() {
                            try {
                                t.texStorage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texSubImage2D: function() {
                            try {
                                t.texSubImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texSubImage3D: function() {
                            try {
                                t.texSubImage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        compressedTexSubImage2D: function() {
                            try {
                                t.compressedTexSubImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        compressedTexSubImage3D: function() {
                            try {
                                t.compressedTexSubImage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        scissor: function(e) {
                            !1 === Mt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), Mt.copy(e))
                        },
                        viewport: function(e) {
                            !1 === wt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), wt.copy(e))
                        },
                        reset: function() {
                            t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === r && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, _t = null, yt = {}, d = {}, f = new WeakMap, J = [], K = null, $ = !1, tt = null, et = null, nt = null, rt = null, it = null, at = null, ot = null, st = new Ki(0, 0, 0), lt = 0, At = !1, ct = null, ut = null, ht = null, dt = null, ft = null, Mt.set(0, 0, t.canvas.width, t.canvas.height), wt.set(0, 0, t.canvas.width, t.canvas.height), i.reset(), a.reset(), A.reset()
                        }
                    }
                }

                function Vl(t, e, n, r, i, a, o) {
                    const s = i.isWebGL2,
                        l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                        A = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                        c = new er,
                        u = new WeakMap;
                    let h;
                    const d = new WeakMap;
                    let f = !1;
                    try {
                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                    } catch (t) {}

                    function p(t, e) {
                        return f ? new OffscreenCanvas(t, e) : sr("canvas")
                    }

                    function m(t, e, n, r) {
                        let i = 1;
                        const a = F(t);
                        if ((a.width > r || a.height > r) && (i = r / Math.max(a.width, a.height)), i < 1 || !0 === e) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof VideoFrame && t instanceof VideoFrame) {
                                const r = e ? Jn : Math.floor,
                                    o = r(i * a.width),
                                    s = r(i * a.height);
                                void 0 === h && (h = p(o, s));
                                const l = n ? p(o, s) : h;
                                return l.width = o, l.height = s, l.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + o + "x" + s + ")."), l
                            }
                            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height + ")."), t
                        }
                        return t
                    }

                    function g(t) {
                        const e = F(t);
                        return Zn(e.width) && Zn(e.height)
                    }

                    function v(t, e) {
                        return t.generateMipmaps && e && t.minFilter !== _t && t.minFilter !== wt
                    }

                    function _(e) {
                        t.generateMipmap(e)
                    }

                    function y(n, r, i, a, o = !1) {
                        if (!1 === s) return r;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let l = r;
                        if (r === t.RED && (i === t.FLOAT && (l = t.R32F), i === t.HALF_FLOAT && (l = t.R16F), i === t.UNSIGNED_BYTE && (l = t.R8)), r === t.RED_INTEGER && (i === t.UNSIGNED_BYTE && (l = t.R8UI), i === t.UNSIGNED_SHORT && (l = t.R16UI), i === t.UNSIGNED_INT && (l = t.R32UI), i === t.BYTE && (l = t.R8I), i === t.SHORT && (l = t.R16I), i === t.INT && (l = t.R32I)), r === t.RG && (i === t.FLOAT && (l = t.RG32F), i === t.HALF_FLOAT && (l = t.RG16F), i === t.UNSIGNED_BYTE && (l = t.RG8)), r === t.RG_INTEGER && (i === t.UNSIGNED_BYTE && (l = t.RG8UI), i === t.UNSIGNED_SHORT && (l = t.RG16UI), i === t.UNSIGNED_INT && (l = t.RG32UI), i === t.BYTE && (l = t.RG8I), i === t.SHORT && (l = t.RG16I), i === t.INT && (l = t.RG32I)), r === t.RGBA) {
                            const e = o ? Ke : pr.getTransfer(a);
                            i === t.FLOAT && (l = t.RGBA32F), i === t.HALF_FLOAT && (l = t.RGBA16F), i === t.UNSIGNED_BYTE && (l = e === $e ? t.SRGB8_ALPHA8 : t.RGBA8), i === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), i === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)
                        }
                        return l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
                    }

                    function x(t, e, n) {
                        return !0 === v(t, n) || t.isFramebufferTexture && t.minFilter !== _t && t.minFilter !== wt ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                    }

                    function b(e) {
                        return e === _t || e === yt || e === bt ? t.NEAREST : t.LINEAR
                    }

                    function M(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", M),
                            function(t) {
                                const e = r.get(t);
                                if (void 0 === e.__webglInit) return;
                                const n = t.source,
                                    i = d.get(n);
                                if (i) {
                                    const r = i[e.__cacheKey];
                                    r.usedTimes--, 0 === r.usedTimes && S(t), 0 === Object.keys(i).length && d.delete(n)
                                }
                                r.remove(t)
                            }(e), e.isVideoTexture && u.delete(e)
                    }

                    function w(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", w),
                            function(e) {
                                const n = r.get(e);
                                if (e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                    for (let e = 0; e < 6; e++) {
                                        if (Array.isArray(n.__webglFramebuffer[e]))
                                            for (let r = 0; r < n.__webglFramebuffer[e].length; r++) t.deleteFramebuffer(n.__webglFramebuffer[e][r]);
                                        else t.deleteFramebuffer(n.__webglFramebuffer[e]);
                                        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e])
                                    } else {
                                        if (Array.isArray(n.__webglFramebuffer))
                                            for (let e = 0; e < n.__webglFramebuffer.length; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]);
                                        else t.deleteFramebuffer(n.__webglFramebuffer);
                                        if (n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                                            for (let e = 0; e < n.__webglColorRenderbuffer.length; e++) n.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);
                                        n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                                    }
                                const i = e.textures;
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = r.get(i[e]);
                                    n.__webglTexture && (t.deleteTexture(n.__webglTexture), o.memory.textures--), r.remove(i[e])
                                }
                                r.remove(e)
                            }(n)
                    }

                    function S(e) {
                        const n = r.get(e);
                        t.deleteTexture(n.__webglTexture);
                        const i = e.source;
                        delete d.get(i)[n.__cacheKey], o.memory.textures--
                    }
                    let E = 0;

                    function T(e, i) {
                        const a = r.get(e);
                        if (e.isVideoTexture && function(t) {
                                const e = o.render.frame;
                                u.get(t) !== e && (u.set(t, e), t.update())
                            }(e), !1 === e.isRenderTargetTexture && e.version > 0 && a.__version !== e.version) {
                            const t = e.image;
                            if (null === t) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                            else {
                                if (!1 !== t.complete) return void I(a, e, i);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.bindTexture(t.TEXTURE_2D, a.__webglTexture, t.TEXTURE0 + i)
                    }
                    const C = {
                            [mt]: t.REPEAT,
                            [gt]: t.CLAMP_TO_EDGE,
                            [vt]: t.MIRRORED_REPEAT
                        },
                        R = {
                            [_t]: t.NEAREST,
                            [yt]: t.NEAREST_MIPMAP_NEAREST,
                            [bt]: t.NEAREST_MIPMAP_LINEAR,
                            [wt]: t.LINEAR,
                            [St]: t.LINEAR_MIPMAP_NEAREST,
                            [Tt]: t.LINEAR_MIPMAP_LINEAR
                        },
                        P = {
                            [_n]: t.NEVER,
                            [En]: t.ALWAYS,
                            [yn]: t.LESS,
                            [bn]: t.LEQUAL,
                            [xn]: t.EQUAL,
                            [Sn]: t.GEQUAL,
                            [Mn]: t.GREATER,
                            [wn]: t.NOTEQUAL
                        };

                    function L(n, a, o) {
                        if (a.type !== Bt || !1 !== e.has("OES_texture_float_linear") || a.magFilter !== wt && a.magFilter !== St && a.magFilter !== bt && a.magFilter !== Tt && a.minFilter !== wt && a.minFilter !== St && a.minFilter !== bt && a.minFilter !== Tt || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), o ? (t.texParameteri(n, t.TEXTURE_WRAP_S, C[a.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, C[a.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, C[a.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, R[a.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, R[a.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), a.wrapS === gt && a.wrapT === gt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, b(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, b(a.minFilter)), a.minFilter !== _t && a.minFilter !== wt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), a.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, P[a.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                            if (a.magFilter === _t) return;
                            if (a.minFilter !== bt && a.minFilter !== Tt) return;
                            if (a.type === Bt && !1 === e.has("OES_texture_float_linear")) return;
                            if (!1 === s && a.type === qt && !1 === e.has("OES_texture_half_float_linear")) return;
                            if (a.anisotropy > 1 || r.get(a).__currentAnisotropy) {
                                const o = e.get("EXT_texture_filter_anisotropic");
                                t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy
                            }
                        }
                    }

                    function D(e, n) {
                        let r = !1;
                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", M));
                        const i = n.source;
                        let a = d.get(i);
                        void 0 === a && (a = {}, d.set(i, a));
                        const s = function(t) {
                            const e = [];
                            return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
                        }(n);
                        if (s !== e.__cacheKey) {
                            void 0 === a[s] && (a[s] = {
                                texture: t.createTexture(),
                                usedTimes: 0
                            }, o.memory.textures++, r = !0), a[s].usedTimes++;
                            const i = a[e.__cacheKey];
                            void 0 !== i && (a[e.__cacheKey].usedTimes--, 0 === i.usedTimes && S(n)), e.__cacheKey = s, e.__webglTexture = a[s].texture
                        }
                        return r
                    }

                    function I(e, o, l) {
                        let A = t.TEXTURE_2D;
                        (o.isDataArrayTexture || o.isCompressedArrayTexture) && (A = t.TEXTURE_2D_ARRAY), o.isData3DTexture && (A = t.TEXTURE_3D);
                        const c = D(e, o),
                            u = o.source;
                        n.bindTexture(A, e.__webglTexture, t.TEXTURE0 + l);
                        const h = r.get(u);
                        if (u.version !== h.__version || !0 === c) {
                            n.activeTexture(t.TEXTURE0 + l);
                            const e = pr.getPrimaries(pr.workingColorSpace),
                                r = o.colorSpace === Xe ? null : pr.getPrimaries(o.colorSpace),
                                d = o.colorSpace === Xe || e === r ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                            const f = function(t) {
                                return !s && (t.wrapS !== gt || t.wrapT !== gt || t.minFilter !== _t && t.minFilter !== wt)
                            }(o) && !1 === g(o.image);
                            let p = m(o.image, f, !1, i.maxTextureSize);
                            p = k(o, p);
                            const b = g(p) || s,
                                M = a.convert(o.format, o.colorSpace);
                            let w, S = a.convert(o.type),
                                E = y(o.internalFormat, M, S, o.colorSpace, o.isVideoTexture);
                            L(A, o, b);
                            const T = o.mipmaps,
                                C = s && !0 !== o.isVideoTexture && E !== ae,
                                R = void 0 === h.__version || !0 === c,
                                P = u.dataReady,
                                D = x(o, p, b);
                            if (o.isDepthTexture) E = t.DEPTH_COMPONENT, s ? E = o.type === Bt ? t.DEPTH_COMPONENT32F : o.type === Ot ? t.DEPTH_COMPONENT24 : o.type === kt ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : o.type === Bt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), o.format === Vt && E === t.DEPTH_COMPONENT && o.type !== Dt && o.type !== Ot && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), o.type = Ot, S = a.convert(o.type)), o.format === Ht && E === t.DEPTH_COMPONENT && (E = t.DEPTH_STENCIL, o.type !== kt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), o.type = kt, S = a.convert(o.type))), R && (C ? n.texStorage2D(t.TEXTURE_2D, 1, E, p.width, p.height) : n.texImage2D(t.TEXTURE_2D, 0, E, p.width, p.height, 0, M, S, null));
                            else if (o.isDataTexture)
                                if (T.length > 0 && b) {
                                    C && R && n.texStorage2D(t.TEXTURE_2D, D, E, T[0].width, T[0].height);
                                    for (let e = 0, r = T.length; e < r; e++) w = T[e], C ? P && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, w.width, w.height, M, S, w.data) : n.texImage2D(t.TEXTURE_2D, e, E, w.width, w.height, 0, M, S, w.data);
                                    o.generateMipmaps = !1
                                } else C ? (R && n.texStorage2D(t.TEXTURE_2D, D, E, p.width, p.height), P && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.width, p.height, M, S, p.data)) : n.texImage2D(t.TEXTURE_2D, 0, E, p.width, p.height, 0, M, S, p.data);
                            else if (o.isCompressedTexture)
                                if (o.isCompressedArrayTexture) {
                                    C && R && n.texStorage3D(t.TEXTURE_2D_ARRAY, D, E, T[0].width, T[0].height, p.depth);
                                    for (let e = 0, r = T.length; e < r; e++) w = T[e], o.format !== zt ? null !== M ? C ? P && n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, w.width, w.height, p.depth, M, w.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, E, w.width, w.height, p.depth, 0, w.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? P && n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, w.width, w.height, p.depth, M, S, w.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, E, w.width, w.height, p.depth, 0, M, S, w.data)
                                } else {
                                    C && R && n.texStorage2D(t.TEXTURE_2D, D, E, T[0].width, T[0].height);
                                    for (let e = 0, r = T.length; e < r; e++) w = T[e], o.format !== zt ? null !== M ? C ? P && n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, w.width, w.height, M, w.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, E, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? P && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, w.width, w.height, M, S, w.data) : n.texImage2D(t.TEXTURE_2D, e, E, w.width, w.height, 0, M, S, w.data)
                                }
                            else if (o.isDataArrayTexture) C ? (R && n.texStorage3D(t.TEXTURE_2D_ARRAY, D, E, p.width, p.height, p.depth), P && n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, M, S, p.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, E, p.width, p.height, p.depth, 0, M, S, p.data);
                            else if (o.isData3DTexture) C ? (R && n.texStorage3D(t.TEXTURE_3D, D, E, p.width, p.height, p.depth), P && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, M, S, p.data)) : n.texImage3D(t.TEXTURE_3D, 0, E, p.width, p.height, p.depth, 0, M, S, p.data);
                            else if (o.isFramebufferTexture) {
                                if (R)
                                    if (C) n.texStorage2D(t.TEXTURE_2D, D, E, p.width, p.height);
                                    else {
                                        let e = p.width,
                                            r = p.height;
                                        for (let i = 0; i < D; i++) n.texImage2D(t.TEXTURE_2D, i, E, e, r, 0, M, S, null), e >>= 1, r >>= 1
                                    }
                            } else if (T.length > 0 && b) {
                                if (C && R) {
                                    const e = F(T[0]);
                                    n.texStorage2D(t.TEXTURE_2D, D, E, e.width, e.height)
                                }
                                for (let e = 0, r = T.length; e < r; e++) w = T[e], C ? P && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, M, S, w) : n.texImage2D(t.TEXTURE_2D, e, E, M, S, w);
                                o.generateMipmaps = !1
                            } else if (C) {
                                if (R) {
                                    const e = F(p);
                                    n.texStorage2D(t.TEXTURE_2D, D, E, e.width, e.height)
                                }
                                P && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, M, S, p)
                            } else n.texImage2D(t.TEXTURE_2D, 0, E, M, S, p);
                            v(o, b) && _(A), h.__version = u.version, o.onUpdate && o.onUpdate(o)
                        }
                        e.__version = o.version
                    }

                    function O(e, i, o, s, A, c) {
                        const u = a.convert(o.format, o.colorSpace),
                            h = a.convert(o.type),
                            d = y(o.internalFormat, u, h, o.colorSpace);
                        if (!r.get(i).__hasExternalTextures) {
                            const e = Math.max(1, i.width >> c),
                                r = Math.max(1, i.height >> c);
                            A === t.TEXTURE_3D || A === t.TEXTURE_2D_ARRAY ? n.texImage3D(A, c, d, e, r, i.depth, 0, u, h, null) : n.texImage2D(A, c, d, e, r, 0, u, h, null)
                        }
                        n.bindFramebuffer(t.FRAMEBUFFER, e), N(i) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, s, A, r.get(o).__webglTexture, 0, U(i)) : (A === t.TEXTURE_2D || A >= t.TEXTURE_CUBE_MAP_POSITIVE_X && A <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, s, A, r.get(o).__webglTexture, c), n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }

                    function B(e, n, r) {
                        if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                            let i = !0 === s ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
                            if (r || N(n)) {
                                const e = n.depthTexture;
                                e && e.isDepthTexture && (e.type === Bt ? i = t.DEPTH_COMPONENT32F : e.type === Ot && (i = t.DEPTH_COMPONENT24));
                                const r = U(n);
                                N(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, i, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, r, i, n.width, n.height)
                            } else t.renderbufferStorage(t.RENDERBUFFER, i, n.width, n.height);
                            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            const i = U(n);
                            r && !1 === N(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, i, t.DEPTH24_STENCIL8, n.width, n.height) : N(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                        } else {
                            const e = n.textures;
                            for (let i = 0; i < e.length; i++) {
                                const o = e[i],
                                    s = a.convert(o.format, o.colorSpace),
                                    A = a.convert(o.type),
                                    c = y(o.internalFormat, s, A, o.colorSpace),
                                    u = U(n);
                                r && !1 === N(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, u, c, n.width, n.height) : N(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, u, c, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height)
                            }
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null)
                    }

                    function q(e) {
                        const i = r.get(e),
                            a = !0 === e.isWebGLCubeRenderTarget;
                        if (e.depthTexture && !i.__autoAllocateDepthBuffer) {
                            if (a) throw new Error("target.depthTexture not supported in Cube render targets");
                            ! function(e, i) {
                                if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                if (n.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), T(i.depthTexture, 0);
                                const a = r.get(i.depthTexture).__webglTexture,
                                    o = U(i);
                                if (i.depthTexture.format === Vt) N(i) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0);
                                else {
                                    if (i.depthTexture.format !== Ht) throw new Error("Unknown depthTexture format");
                                    N(i) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0)
                                }
                            }(i.__webglFramebuffer, e)
                        } else if (a) {
                            i.__webglDepthbuffer = [];
                            for (let r = 0; r < 6; r++) n.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), B(i.__webglDepthbuffer[r], e, !1)
                        } else n.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), B(i.__webglDepthbuffer, e, !1);
                        n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }

                    function U(t) {
                        return Math.min(i.maxSamples, t.samples)
                    }

                    function N(t) {
                        const n = r.get(t);
                        return s && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                    }

                    function k(t, n) {
                        const r = t.colorSpace,
                            i = t.format,
                            a = t.type;
                        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === Nn || r !== Qe && r !== Xe && (pr.getTransfer(r) === $e ? !1 === s ? !0 === e.has("EXT_sRGB") && i === zt ? (t.format = Nn, t.minFilter = wt, t.generateMipmaps = !1) : n = _r.sRGBToLinear(n) : i === zt && a === Rt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", r)), n
                    }

                    function F(t) {
                        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement ? (c.width = t.naturalWidth || t.width, c.height = t.naturalHeight || t.height) : "undefined" != typeof VideoFrame && t instanceof VideoFrame ? (c.width = t.displayWidth, c.height = t.displayHeight) : (c.width = t.width, c.height = t.height), c
                    }
                    this.allocateTextureUnit = function() {
                        const t = E;
                        return t >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + i.maxTextures), E += 1, t
                    }, this.resetTextureUnits = function() {
                        E = 0
                    }, this.setTexture2D = T, this.setTexture2DArray = function(e, i) {
                        const a = r.get(e);
                        e.version > 0 && a.__version !== e.version ? I(a, e, i) : n.bindTexture(t.TEXTURE_2D_ARRAY, a.__webglTexture, t.TEXTURE0 + i)
                    }, this.setTexture3D = function(e, i) {
                        const a = r.get(e);
                        e.version > 0 && a.__version !== e.version ? I(a, e, i) : n.bindTexture(t.TEXTURE_3D, a.__webglTexture, t.TEXTURE0 + i)
                    }, this.setTextureCube = function(e, o) {
                        const l = r.get(e);
                        e.version > 0 && l.__version !== e.version ? function(e, o, l) {
                            if (6 !== o.image.length) return;
                            const A = D(e, o),
                                c = o.source;
                            n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + l);
                            const u = r.get(c);
                            if (c.version !== u.__version || !0 === A) {
                                n.activeTexture(t.TEXTURE0 + l);
                                const e = pr.getPrimaries(pr.workingColorSpace),
                                    r = o.colorSpace === Xe ? null : pr.getPrimaries(o.colorSpace),
                                    h = o.colorSpace === Xe || e === r ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                                const d = o.isCompressedTexture || o.image[0].isCompressedTexture,
                                    f = o.image[0] && o.image[0].isDataTexture,
                                    p = [];
                                for (let t = 0; t < 6; t++) p[t] = d || f ? f ? o.image[t].image : o.image[t] : m(o.image[t], !1, !0, i.maxCubemapSize), p[t] = k(o, p[t]);
                                const b = p[0],
                                    M = g(b) || s,
                                    w = a.convert(o.format, o.colorSpace),
                                    S = a.convert(o.type),
                                    E = y(o.internalFormat, w, S, o.colorSpace),
                                    T = s && !0 !== o.isVideoTexture,
                                    C = void 0 === u.__version || !0 === A,
                                    R = c.dataReady;
                                let P, D = x(o, b, M);
                                if (L(t.TEXTURE_CUBE_MAP, o, M), d) {
                                    T && C && n.texStorage2D(t.TEXTURE_CUBE_MAP, D, E, b.width, b.height);
                                    for (let e = 0; e < 6; e++) {
                                        P = p[e].mipmaps;
                                        for (let r = 0; r < P.length; r++) {
                                            const i = P[r];
                                            o.format !== zt ? null !== w ? T ? R && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, i.width, i.height, w, i.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, E, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : T ? R && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, 0, 0, i.width, i.height, w, S, i.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r, E, i.width, i.height, 0, w, S, i.data)
                                        }
                                    }
                                } else {
                                    if (P = o.mipmaps, T && C) {
                                        P.length > 0 && D++;
                                        const e = F(p[0]);
                                        n.texStorage2D(t.TEXTURE_CUBE_MAP, D, E, e.width, e.height)
                                    }
                                    for (let e = 0; e < 6; e++)
                                        if (f) {
                                            T ? R && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, p[e].width, p[e].height, w, S, p[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, E, p[e].width, p[e].height, 0, w, S, p[e].data);
                                            for (let r = 0; r < P.length; r++) {
                                                const i = P[r].image[e].image;
                                                T ? R && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, 0, 0, i.width, i.height, w, S, i.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, E, i.width, i.height, 0, w, S, i.data)
                                            }
                                        } else {
                                            T ? R && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, w, S, p[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, E, w, S, p[e]);
                                            for (let r = 0; r < P.length; r++) {
                                                const i = P[r];
                                                T ? R && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, 0, 0, w, S, i.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, r + 1, E, w, S, i.image[e])
                                            }
                                        }
                                }
                                v(o, M) && _(t.TEXTURE_CUBE_MAP), u.__version = c.version, o.onUpdate && o.onUpdate(o)
                            }
                            e.__version = o.version
                        }(l, e, o) : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + o)
                    }, this.rebindTextures = function(e, n, i) {
                        const a = r.get(e);
                        void 0 !== n && O(a.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== i && q(e)
                    }, this.setupRenderTarget = function(e) {
                        const l = e.texture,
                            A = r.get(e),
                            c = r.get(l);
                        e.addEventListener("dispose", w);
                        const u = e.textures,
                            h = !0 === e.isWebGLCubeRenderTarget,
                            d = u.length > 1,
                            f = g(e) || s;
                        if (d || (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()), c.__version = l.version, o.memory.textures++), h) {
                            A.__webglFramebuffer = [];
                            for (let e = 0; e < 6; e++)
                                if (s && l.mipmaps && l.mipmaps.length > 0) {
                                    A.__webglFramebuffer[e] = [];
                                    for (let n = 0; n < l.mipmaps.length; n++) A.__webglFramebuffer[e][n] = t.createFramebuffer()
                                } else A.__webglFramebuffer[e] = t.createFramebuffer()
                        } else {
                            if (s && l.mipmaps && l.mipmaps.length > 0) {
                                A.__webglFramebuffer = [];
                                for (let e = 0; e < l.mipmaps.length; e++) A.__webglFramebuffer[e] = t.createFramebuffer()
                            } else A.__webglFramebuffer = t.createFramebuffer();
                            if (d)
                                if (i.drawBuffers)
                                    for (let e = 0, n = u.length; e < n; e++) {
                                        const n = r.get(u[e]);
                                        void 0 === n.__webglTexture && (n.__webglTexture = t.createTexture(), o.memory.textures++)
                                    } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                            if (s && e.samples > 0 && !1 === N(e)) {
                                A.__webglMultisampledFramebuffer = t.createFramebuffer(), A.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, A.__webglMultisampledFramebuffer);
                                for (let n = 0; n < u.length; n++) {
                                    const r = u[n];
                                    A.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, A.__webglColorRenderbuffer[n]);
                                    const i = a.convert(r.format, r.colorSpace),
                                        o = a.convert(r.type),
                                        s = y(r.internalFormat, i, o, r.colorSpace, !0 === e.isXRRenderTarget),
                                        l = U(e);
                                    t.renderbufferStorageMultisample(t.RENDERBUFFER, l, s, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, A.__webglColorRenderbuffer[n])
                                }
                                t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (A.__webglDepthRenderbuffer = t.createRenderbuffer(), B(A.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                            }
                        }
                        if (h) {
                            n.bindTexture(t.TEXTURE_CUBE_MAP, c.__webglTexture), L(t.TEXTURE_CUBE_MAP, l, f);
                            for (let n = 0; n < 6; n++)
                                if (s && l.mipmaps && l.mipmaps.length > 0)
                                    for (let r = 0; r < l.mipmaps.length; r++) O(A.__webglFramebuffer[n][r], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                                else O(A.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                            v(l, f) && _(t.TEXTURE_CUBE_MAP), n.unbindTexture()
                        } else if (d) {
                            for (let i = 0, a = u.length; i < a; i++) {
                                const a = u[i],
                                    o = r.get(a);
                                n.bindTexture(t.TEXTURE_2D, o.__webglTexture), L(t.TEXTURE_2D, a, f), O(A.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + i, t.TEXTURE_2D, 0), v(a, f) && _(t.TEXTURE_2D)
                            }
                            n.unbindTexture()
                        } else {
                            let r = t.TEXTURE_2D;
                            if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (s ? r = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(r, c.__webglTexture), L(r, l, f), s && l.mipmaps && l.mipmaps.length > 0)
                                for (let n = 0; n < l.mipmaps.length; n++) O(A.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, r, n);
                            else O(A.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, r, 0);
                            v(l, f) && _(r), n.unbindTexture()
                        }
                        e.depthBuffer && q(e)
                    }, this.updateRenderTargetMipmap = function(e) {
                        const i = g(e) || s,
                            a = e.textures;
                        for (let o = 0, s = a.length; o < s; o++) {
                            const s = a[o];
                            if (v(s, i)) {
                                const i = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                                    a = r.get(s).__webglTexture;
                                n.bindTexture(i, a), _(i), n.unbindTexture()
                            }
                        }
                    }, this.updateMultisampleRenderTarget = function(e) {
                        if (s && e.samples > 0 && !1 === N(e)) {
                            const i = e.textures,
                                a = e.width,
                                o = e.height;
                            let s = t.COLOR_BUFFER_BIT;
                            const l = [],
                                c = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                                u = r.get(e),
                                h = i.length > 1;
                            if (h)
                                for (let e = 0; e < i.length; e++) n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                            n.bindFramebuffer(t.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                            for (let n = 0; n < i.length; n++) {
                                l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
                                const d = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                                if (!1 === d && (e.depthBuffer && (s |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (s |= t.STENCIL_BUFFER_BIT)), h && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, u.__webglColorRenderbuffer[n]), !0 === d && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])), h) {
                                    const e = r.get(i[n]).__webglTexture;
                                    t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                                }
                                t.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, t.NEAREST), A && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l)
                            }
                            if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), h)
                                for (let e = 0; e < i.length; e++) {
                                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, u.__webglColorRenderbuffer[e]);
                                    const a = r.get(i[e]).__webglTexture;
                                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, a, 0)
                                }
                            n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
                        }
                    }, this.setupDepthRenderbuffer = q, this.setupFrameBufferTexture = O, this.useMultisampledRTT = N
                }

                function Hl(t, e, n) {
                    const r = n.isWebGL2;
                    return {
                        convert: function(n, i = Xe) {
                            let a;
                            const o = pr.getTransfer(i);
                            if (n === Rt) return t.UNSIGNED_BYTE;
                            if (n === Ut) return t.UNSIGNED_SHORT_4_4_4_4;
                            if (n === Nt) return t.UNSIGNED_SHORT_5_5_5_1;
                            if (n === Pt) return t.BYTE;
                            if (n === Lt) return t.SHORT;
                            if (n === Dt) return t.UNSIGNED_SHORT;
                            if (n === It) return t.INT;
                            if (n === Ot) return t.UNSIGNED_INT;
                            if (n === Bt) return t.FLOAT;
                            if (n === qt) return r ? t.HALF_FLOAT : (a = e.get("OES_texture_half_float"), null !== a ? a.HALF_FLOAT_OES : null);
                            if (n === Ft) return t.ALPHA;
                            if (n === zt) return t.RGBA;
                            if (n === Gt) return t.LUMINANCE;
                            if (n === jt) return t.LUMINANCE_ALPHA;
                            if (n === Vt) return t.DEPTH_COMPONENT;
                            if (n === Ht) return t.DEPTH_STENCIL;
                            if (n === Nn) return a = e.get("EXT_sRGB"), null !== a ? a.SRGB_ALPHA_EXT : null;
                            if (n === Wt) return t.RED;
                            if (n === Xt) return t.RED_INTEGER;
                            if (n === Yt) return t.RG;
                            if (n === Qt) return t.RG_INTEGER;
                            if (n === Zt) return t.RGBA_INTEGER;
                            if (n === Jt || n === Kt || n === $t || n === te)
                                if (o === $e) {
                                    if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === a) return null;
                                    if (n === Jt) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (n === Kt) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (n === $t) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (n === te) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                } else {
                                    if (a = e.get("WEBGL_compressed_texture_s3tc"), null === a) return null;
                                    if (n === Jt) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                    if (n === Kt) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                    if (n === $t) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                    if (n === te) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                                } if (n === ee || n === ne || n === re || n === ie) {
                                if (a = e.get("WEBGL_compressed_texture_pvrtc"), null === a) return null;
                                if (n === ee) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (n === ne) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (n === re) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (n === ie) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            }
                            if (n === ae) return a = e.get("WEBGL_compressed_texture_etc1"), null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
                            if (n === oe || n === se) {
                                if (a = e.get("WEBGL_compressed_texture_etc"), null === a) return null;
                                if (n === oe) return o === $e ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                                if (n === se) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                            }
                            if (n === le || n === Ae || n === ce || n === ue || n === he || n === de || n === fe || n === pe || n === me || n === ge || n === ve || n === _e || n === ye || n === xe) {
                                if (a = e.get("WEBGL_compressed_texture_astc"), null === a) return null;
                                if (n === le) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (n === Ae) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (n === ce) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (n === ue) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (n === he) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (n === de) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (n === fe) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (n === pe) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (n === me) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (n === ge) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (n === ve) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (n === _e) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (n === ye) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (n === xe) return o === $e ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                            }
                            if (n === be || n === Me || n === we) {
                                if (a = e.get("EXT_texture_compression_bptc"), null === a) return null;
                                if (n === be) return o === $e ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (n === Me) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (n === we) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            }
                            if (n === Se || n === Ee || n === Te || n === Ce) {
                                if (a = e.get("EXT_texture_compression_rgtc"), null === a) return null;
                                if (n === be) return a.COMPRESSED_RED_RGTC1_EXT;
                                if (n === Ee) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (n === Te) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (n === Ce) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            }
                            return n === kt ? r ? t.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
                        }
                    }
                }
                class Wl extends ro {
                    constructor(t = []) {
                        super(), this.isArrayCamera = !0, this.cameras = t
                    }
                }
                class Xl extends qi {
                    constructor() {
                        super(), this.isGroup = !0, this.type = "Group"
                    }
                }
                const Yl = {
                    type: "move"
                };
                class Ql {
                    constructor() {
                        this._targetRay = null, this._grip = null, this._hand = null
                    }
                    getHandSpace() {
                        return null === this._hand && (this._hand = new Xl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                            pinching: !1
                        }), this._hand
                    }
                    getTargetRaySpace() {
                        return null === this._targetRay && (this._targetRay = new Xl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Ir, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Ir), this._targetRay
                    }
                    getGripSpace() {
                        return null === this._grip && (this._grip = new Xl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Ir, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Ir), this._grip
                    }
                    dispatchEvent(t) {
                        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                    }
                    connect(t) {
                        if (t && t.hand) {
                            const e = this._hand;
                            if (e)
                                for (const n of t.hand.values()) this._getHandJoint(e, n)
                        }
                        return this.dispatchEvent({
                            type: "connected",
                            data: t
                        }), this
                    }
                    disconnect(t) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: t
                        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                    }
                    update(t, e, n) {
                        let r = null,
                            i = null,
                            a = null;
                        const o = this._targetRay,
                            s = this._grip,
                            l = this._hand;
                        if (t && "visible-blurred" !== e.session.visibilityState) {
                            if (l && t.hand) {
                                a = !0;
                                for (const r of t.hand.values()) {
                                    const t = e.getJointPose(r, n),
                                        i = this._getHandJoint(l, r);
                                    null !== t && (i.matrix.fromArray(t.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.matrixWorldNeedsUpdate = !0, i.jointRadius = t.radius), i.visible = null !== t
                                }
                                const r = l.joints["index-finger-tip"],
                                    i = l.joints["thumb-tip"],
                                    o = r.position.distanceTo(i.position),
                                    s = .02,
                                    A = .005;
                                l.inputState.pinching && o > s + A ? (l.inputState.pinching = !1, this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !l.inputState.pinching && o <= s - A && (l.inputState.pinching = !0, this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                }))
                            } else null !== s && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1));
                            null !== o && (r = e.getPose(t.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Yl)))
                        }
                        return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this
                    }
                    _getHandJoint(t, e) {
                        if (void 0 === t.joints[e.jointName]) {
                            const n = new Xl;
                            n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
                        }
                        return t.joints[e.jointName]
                    }
                }
                class Zl {
                    constructor() {
                        this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
                    }
                    init(t, e, n) {
                        if (null === this.texture) {
                            const r = new wr;
                            t.properties.get(r).__webglTexture = e.texture, e.depthNear == n.depthNear && e.depthFar == n.depthFar || (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = r
                        }
                    }
                    render(t, e) {
                        if (null !== this.texture) {
                            if (null === this.mesh) {
                                const t = e.cameras[0].viewport,
                                    n = new Ka({
                                        extensions: {
                                            fragDepth: !0
                                        },
                                        vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                        fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                        uniforms: {
                                            depthColor: {
                                                value: this.texture
                                            },
                                            depthWidth: {
                                                value: t.z
                                            },
                                            depthHeight: {
                                                value: t.w
                                            }
                                        }
                                    });
                                this.mesh = new Ha(new vo(20, 20), n)
                            }
                            t.render(this.mesh, e)
                        }
                    }
                    reset() {
                        this.texture = null, this.mesh = null
                    }
                }
                class Jl extends zn {
                    constructor(t, e) {
                        super();
                        const n = this;
                        let r = null,
                            i = 1,
                            a = null,
                            o = "local-floor",
                            s = 1,
                            l = null,
                            A = null,
                            c = null,
                            u = null,
                            h = null,
                            d = null;
                        const f = new Zl,
                            p = e.getContextAttributes();
                        let m = null,
                            g = null;
                        const v = [],
                            _ = [],
                            y = new er;
                        let x = null;
                        const b = new ro;
                        b.layers.enable(1), b.viewport = new Sr;
                        const M = new ro;
                        M.layers.enable(2), M.viewport = new Sr;
                        const w = [b, M],
                            S = new Wl;
                        S.layers.enable(1), S.layers.enable(2);
                        let E = null,
                            T = null;

                        function C(t) {
                            const e = _.indexOf(t.inputSource);
                            if (-1 === e) return;
                            const n = v[e];
                            void 0 !== n && (n.update(t.inputSource, t.frame, l || a), n.dispatchEvent({
                                type: t.type,
                                data: t.inputSource
                            }))
                        }

                        function R() {
                            r.removeEventListener("select", C), r.removeEventListener("selectstart", C), r.removeEventListener("selectend", C), r.removeEventListener("squeeze", C), r.removeEventListener("squeezestart", C), r.removeEventListener("squeezeend", C), r.removeEventListener("end", R), r.removeEventListener("inputsourceschange", P);
                            for (let t = 0; t < v.length; t++) {
                                const e = _[t];
                                null !== e && (_[t] = null, v[t].disconnect(e))
                            }
                            E = null, T = null, f.reset(), t.setRenderTarget(m), h = null, u = null, c = null, r = null, g = null, B.stop(), n.isPresenting = !1, t.setPixelRatio(x), t.setSize(y.width, y.height, !1), n.dispatchEvent({
                                type: "sessionend"
                            })
                        }

                        function P(t) {
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    r = _.indexOf(n);
                                r >= 0 && (_[r] = null, v[r].disconnect(n))
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e];
                                let r = _.indexOf(n);
                                if (-1 === r) {
                                    for (let t = 0; t < v.length; t++) {
                                        if (t >= _.length) {
                                            _.push(n), r = t;
                                            break
                                        }
                                        if (null === _[t]) {
                                            _[t] = n, r = t;
                                            break
                                        }
                                    }
                                    if (-1 === r) break
                                }
                                const i = v[r];
                                i && i.connect(n)
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                            let e = v[t];
                            return void 0 === e && (e = new Ql, v[t] = e), e.getTargetRaySpace()
                        }, this.getControllerGrip = function(t) {
                            let e = v[t];
                            return void 0 === e && (e = new Ql, v[t] = e), e.getGripSpace()
                        }, this.getHand = function(t) {
                            let e = v[t];
                            return void 0 === e && (e = new Ql, v[t] = e), e.getHandSpace()
                        }, this.setFramebufferScaleFactor = function(t) {
                            i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }, this.setReferenceSpaceType = function(t) {
                            o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }, this.getReferenceSpace = function() {
                            return l || a
                        }, this.setReferenceSpace = function(t) {
                            l = t
                        }, this.getBaseLayer = function() {
                            return null !== u ? u : h
                        }, this.getBinding = function() {
                            return c
                        }, this.getFrame = function() {
                            return d
                        }, this.getSession = function() {
                            return r
                        }, this.setSession = async function(A) {
                            if (r = A, null !== r) {
                                if (m = t.getRenderTarget(), r.addEventListener("select", C), r.addEventListener("selectstart", C), r.addEventListener("selectend", C), r.addEventListener("squeeze", C), r.addEventListener("squeezestart", C), r.addEventListener("squeezeend", C), r.addEventListener("end", R), r.addEventListener("inputsourceschange", P), !0 !== p.xrCompatible && await e.makeXRCompatible(), x = t.getPixelRatio(), t.getSize(y), void 0 === r.renderState.layers || !1 === t.capabilities.isWebGL2) {
                                    const n = {
                                        antialias: void 0 !== r.renderState.layers || p.antialias,
                                        alpha: !0,
                                        depth: p.depth,
                                        stencil: p.stencil,
                                        framebufferScaleFactor: i
                                    };
                                    h = new XRWebGLLayer(r, e, n), r.updateRenderState({
                                        baseLayer: h
                                    }), t.setPixelRatio(1), t.setSize(h.framebufferWidth, h.framebufferHeight, !1), g = new Tr(h.framebufferWidth, h.framebufferHeight, {
                                        format: zt,
                                        type: Rt,
                                        colorSpace: t.outputColorSpace,
                                        stencilBuffer: p.stencil
                                    })
                                } else {
                                    let n = null,
                                        a = null,
                                        o = null;
                                    p.depth && (o = p.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = p.stencil ? Ht : Vt, a = p.stencil ? kt : Ot);
                                    const s = {
                                        colorFormat: e.RGBA8,
                                        depthFormat: o,
                                        scaleFactor: i
                                    };
                                    c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(s), r.updateRenderState({
                                        layers: [u]
                                    }), t.setPixelRatio(1), t.setSize(u.textureWidth, u.textureHeight, !1), g = new Tr(u.textureWidth, u.textureHeight, {
                                        format: zt,
                                        type: Rt,
                                        depthTexture: new es(u.textureWidth, u.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                        stencilBuffer: p.stencil,
                                        colorSpace: t.outputColorSpace,
                                        samples: p.antialias ? 4 : 0
                                    }), t.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues
                                }
                                g.isXRRenderTarget = !0, this.setFoveation(s), l = null, a = await r.requestReferenceSpace(o), B.setContext(r), B.start(), n.isPresenting = !0, n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        }, this.getEnvironmentBlendMode = function() {
                            if (null !== r) return r.environmentBlendMode
                        };
                        const L = new Ir,
                            D = new Ir;

                        function I(t, e) {
                            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                        }
                        this.updateCamera = function(t) {
                            if (null === r) return;
                            null !== f.texture && (t.near = f.depthNear, t.far = f.depthFar), S.near = M.near = b.near = t.near, S.far = M.far = b.far = t.far, E === S.near && T === S.far || (r.updateRenderState({
                                depthNear: S.near,
                                depthFar: S.far
                            }), E = S.near, T = S.far, b.near = E, b.far = T, M.near = E, M.far = T, b.updateProjectionMatrix(), M.updateProjectionMatrix(), t.updateProjectionMatrix());
                            const e = t.parent,
                                n = S.cameras;
                            I(S, e);
                            for (let t = 0; t < n.length; t++) I(n[t], e);
                            2 === n.length ? function(t, e, n) {
                                    L.setFromMatrixPosition(e.matrixWorld), D.setFromMatrixPosition(n.matrixWorld);
                                    const r = L.distanceTo(D),
                                        i = e.projectionMatrix.elements,
                                        a = n.projectionMatrix.elements,
                                        o = i[14] / (i[10] - 1),
                                        s = i[14] / (i[10] + 1),
                                        l = (i[9] + 1) / i[5],
                                        A = (i[9] - 1) / i[5],
                                        c = (i[8] - 1) / i[0],
                                        u = (a[8] + 1) / a[0],
                                        h = o * c,
                                        d = o * u,
                                        f = r / (-c + u),
                                        p = f * -c;
                                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(p), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                    const m = o + f,
                                        g = s + f,
                                        v = h - p,
                                        _ = d + (r - p),
                                        y = l * s / g * m,
                                        x = A * s / g * m;
                                    t.projectionMatrix.makePerspective(v, _, y, x, m, g), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                                }(S, b, M) : S.projectionMatrix.copy(b.projectionMatrix),
                                function(t, e, n) {
                                    null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld)), t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0), t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * Hn * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                                }(t, S, e)
                        }, this.getCamera = function() {
                            return S
                        }, this.getFoveation = function() {
                            if (null !== u || null !== h) return s
                        }, this.setFoveation = function(t) {
                            s = t, null !== u && (u.fixedFoveation = t), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = t)
                        }, this.hasDepthSensing = function() {
                            return null !== f.texture
                        };
                        let O = null;
                        const B = new mo;
                        B.setAnimationLoop((function(e, i) {
                            if (A = i.getViewerPose(l || a), d = i, null !== A) {
                                const e = A.views;
                                null !== h && (t.setRenderTargetFramebuffer(g, h.framebuffer), t.setRenderTarget(g));
                                let n = !1;
                                e.length !== S.cameras.length && (S.cameras.length = 0, n = !0);
                                for (let r = 0; r < e.length; r++) {
                                    const i = e[r];
                                    let a = null;
                                    if (null !== h) a = h.getViewport(i);
                                    else {
                                        const e = c.getViewSubImage(u, i);
                                        a = e.viewport, 0 === r && (t.setRenderTargetTextures(g, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                                    }
                                    let o = w[r];
                                    void 0 === o && (o = new ro, o.layers.enable(r), o.viewport = new Sr, w[r] = o), o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale), o.projectionMatrix.fromArray(i.projectionMatrix), o.projectionMatrixInverse.copy(o.projectionMatrix).invert(), o.viewport.set(a.x, a.y, a.width, a.height), 0 === r && (S.matrix.copy(o.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), !0 === n && S.cameras.push(o)
                                }
                                const i = r.enabledFeatures;
                                if (i && i.includes("depth-sensing")) {
                                    const n = c.getDepthInformation(e[0]);
                                    n && n.isValid && n.texture && f.init(t, n, r.renderState)
                                }
                            }
                            for (let t = 0; t < v.length; t++) {
                                const e = _[t],
                                    n = v[t];
                                null !== e && void 0 !== n && n.update(e, i, l || a)
                            }
                            f.render(t, S), O && O(e, i), i.detectedPlanes && n.dispatchEvent({
                                type: "planesdetected",
                                data: i
                            }), d = null
                        })), this.setAnimationLoop = function(t) {
                            O = t
                        }, this.dispose = function() {}
                    }
                }
                const Kl = new _i,
                    $l = new Ai;

                function tA(t, e) {
                    function n(t, e) {
                        !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
                    }

                    function r(r, i) {
                        r.opacity.value = i.opacity, i.color && r.diffuse.value.copy(i.color), i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (r.map.value = i.map, n(i.map, r.mapTransform)), i.alphaMap && (r.alphaMap.value = i.alphaMap, n(i.alphaMap, r.alphaMapTransform)), i.bumpMap && (r.bumpMap.value = i.bumpMap, n(i.bumpMap, r.bumpMapTransform), r.bumpScale.value = i.bumpScale, i.side === p && (r.bumpScale.value *= -1)), i.normalMap && (r.normalMap.value = i.normalMap, n(i.normalMap, r.normalMapTransform), r.normalScale.value.copy(i.normalScale), i.side === p && r.normalScale.value.negate()), i.displacementMap && (r.displacementMap.value = i.displacementMap, n(i.displacementMap, r.displacementMapTransform), r.displacementScale.value = i.displacementScale, r.displacementBias.value = i.displacementBias), i.emissiveMap && (r.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, r.emissiveMapTransform)), i.specularMap && (r.specularMap.value = i.specularMap, n(i.specularMap, r.specularMapTransform)), i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
                        const a = e.get(i),
                            o = a.envMap,
                            s = a.envMapRotation;
                        if (o && (r.envMap.value = o, Kl.copy(s), Kl.x *= -1, Kl.y *= -1, Kl.z *= -1, o.isCubeTexture && !1 === o.isRenderTargetTexture && (Kl.y *= -1, Kl.z *= -1), r.envMapRotation.value.setFromMatrix4($l.makeRotationFromEuler(Kl)), r.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1, r.reflectivity.value = i.reflectivity, r.ior.value = i.ior, r.refractionRatio.value = i.refractionRatio), i.lightMap) {
                            r.lightMap.value = i.lightMap;
                            const e = !0 === t._useLegacyLights ? Math.PI : 1;
                            r.lightMapIntensity.value = i.lightMapIntensity * e, n(i.lightMap, r.lightMapTransform)
                        }
                        i.aoMap && (r.aoMap.value = i.aoMap, r.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, r.aoMapTransform))
                    }
                    return {
                        refreshFogUniforms: function(e, n) {
                            n.color.getRGB(e.fogColor.value, Za(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
                        },
                        refreshMaterialUniforms: function(t, i, a, o, s) {
                            i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(t, i) : i.isMeshToonMaterial ? (r(t, i), function(t, e) {
                                e.gradientMap && (t.gradientMap.value = e.gradientMap)
                            }(t, i)) : i.isMeshPhongMaterial ? (r(t, i), function(t, e) {
                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                            }(t, i)) : i.isMeshStandardMaterial ? (r(t, i), function(t, r) {
                                t.metalness.value = r.metalness, r.metalnessMap && (t.metalnessMap.value = r.metalnessMap, n(r.metalnessMap, t.metalnessMapTransform)), t.roughness.value = r.roughness, r.roughnessMap && (t.roughnessMap.value = r.roughnessMap, n(r.roughnessMap, t.roughnessMapTransform));
                                e.get(r).envMap && (t.envMapIntensity.value = r.envMapIntensity)
                            }(t, i), i.isMeshPhysicalMaterial && function(t, e, r) {
                                t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), e.side === p && t.clearcoatNormalScale.value.negate())), e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = r.texture, t.transmissionSamplerSize.value.set(r.width, r.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform))), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform)), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform))
                            }(t, i, s)) : i.isMeshMatcapMaterial ? (r(t, i), function(t, e) {
                                e.matcap && (t.matcap.value = e.matcap)
                            }(t, i)) : i.isMeshDepthMaterial ? r(t, i) : i.isMeshDistanceMaterial ? (r(t, i), function(t, n) {
                                const r = e.get(n).light;
                                t.referencePosition.value.setFromMatrixPosition(r.matrixWorld), t.nearDistance.value = r.shadow.camera.near, t.farDistance.value = r.shadow.camera.far
                            }(t, i)) : i.isMeshNormalMaterial ? r(t, i) : i.isLineBasicMaterial ? (function(t, e) {
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform))
                            }(t, i), i.isLineDashedMaterial && function(t, e) {
                                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                            }(t, i)) : i.isPointsMaterial ? function(t, e, r, i) {
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * r, t.scale.value = .5 * i, e.map && (t.map.value = e.map, n(e.map, t.uvTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                            }(t, i, a, o) : i.isSpriteMaterial ? function(t, e) {
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                            }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                        }
                    }
                }

                function eA(t, e, n, r) {
                    let i = {},
                        a = {},
                        o = [];
                    const s = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

                    function l(t, e, n, r) {
                        const i = t.value,
                            a = e + "_" + n;
                        if (void 0 === r[a]) return r[a] = "number" == typeof i || "boolean" == typeof i ? i : i.clone(), !0;
                        {
                            const t = r[a];
                            if ("number" == typeof i || "boolean" == typeof i) {
                                if (t !== i) return r[a] = i, !0
                            } else if (!1 === t.equals(i)) return t.copy(i), !0
                        }
                        return !1
                    }

                    function A(t) {
                        const e = {
                            boundary: 0,
                            storage: 0
                        };
                        return "number" == typeof t || "boolean" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e
                    }

                    function c(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", c);
                        const r = o.indexOf(n.__bindingPointIndex);
                        o.splice(r, 1), t.deleteBuffer(i[n.id]), delete i[n.id], delete a[n.id]
                    }
                    return {
                        bind: function(t, e) {
                            const n = e.program;
                            r.uniformBlockBinding(t, n)
                        },
                        update: function(n, u) {
                            let h = i[n.id];
                            void 0 === h && (function(t) {
                                const e = t.uniforms;
                                let n = 0;
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = Array.isArray(e[t]) ? e[t] : [e[t]];
                                    for (let t = 0, e = r.length; t < e; t++) {
                                        const e = r[t],
                                            i = Array.isArray(e.value) ? e.value : [e.value];
                                        for (let t = 0, r = i.length; t < r; t++) {
                                            const r = A(i[t]),
                                                a = n % 16;
                                            0 !== a && 16 - a < r.boundary && (n += 16 - a), e.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), e.__offset = n, n += r.storage
                                        }
                                    }
                                }
                                const r = n % 16;
                                r > 0 && (n += 16 - r), t.__size = n, t.__cache = {}
                            }(n), h = function(e) {
                                const n = function() {
                                    for (let t = 0; t < s; t++)
                                        if (-1 === o.indexOf(t)) return o.push(t), t;
                                    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                                }();
                                e.__bindingPointIndex = n;
                                const r = t.createBuffer(),
                                    i = e.__size,
                                    a = e.usage;
                                return t.bindBuffer(t.UNIFORM_BUFFER, r), t.bufferData(t.UNIFORM_BUFFER, i, a), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, r), r
                            }(n), i[n.id] = h, n.addEventListener("dispose", c));
                            const d = u.program;
                            r.updateUBOMapping(n, d);
                            const f = e.render.frame;
                            a[n.id] !== f && (function(e) {
                                const n = i[e.id],
                                    r = e.uniforms,
                                    a = e.__cache;
                                t.bindBuffer(t.UNIFORM_BUFFER, n);
                                for (let e = 0, n = r.length; e < n; e++) {
                                    const n = Array.isArray(r[e]) ? r[e] : [r[e]];
                                    for (let r = 0, i = n.length; r < i; r++) {
                                        const i = n[r];
                                        if (!0 === l(i, e, r, a)) {
                                            const e = i.__offset,
                                                n = Array.isArray(i.value) ? i.value : [i.value];
                                            let r = 0;
                                            for (let a = 0; a < n.length; a++) {
                                                const o = n[a],
                                                    s = A(o);
                                                "number" == typeof o || "boolean" == typeof o ? (i.__data[0] = o, t.bufferSubData(t.UNIFORM_BUFFER, e + r, i.__data)) : o.isMatrix3 ? (i.__data[0] = o.elements[0], i.__data[1] = o.elements[1], i.__data[2] = o.elements[2], i.__data[3] = 0, i.__data[4] = o.elements[3], i.__data[5] = o.elements[4], i.__data[6] = o.elements[5], i.__data[7] = 0, i.__data[8] = o.elements[6], i.__data[9] = o.elements[7], i.__data[10] = o.elements[8], i.__data[11] = 0) : (o.toArray(i.__data, r), r += s.storage / Float32Array.BYTES_PER_ELEMENT)
                                            }
                                            t.bufferSubData(t.UNIFORM_BUFFER, e, i.__data)
                                        }
                                    }
                                }
                                t.bindBuffer(t.UNIFORM_BUFFER, null)
                            }(n), a[n.id] = f)
                        },
                        dispose: function() {
                            for (const e in i) t.deleteBuffer(i[e]);
                            o = [], i = {}, a = {}
                        }
                    }
                }
                class nA {
                    constructor(t = {}) {
                        const {
                            canvas: e = lr(),
                            context: n = null,
                            depth: i = !0,
                            stencil: a = !0,
                            alpha: o = !1,
                            antialias: s = !1,
                            premultipliedAlpha: l = !0,
                            preserveDrawingBuffer: A = !1,
                            powerPreference: c = "default",
                            failIfMajorPerformanceCaveat: u = !1
                        } = t;
                        let h;
                        this.isWebGLRenderer = !0, h = null !== n ? n.getContextAttributes().alpha : o;
                        const d = new Uint32Array(4),
                            g = new Int32Array(4);
                        let v = null,
                            _ = null;
                        const y = [],
                            x = [];
                        this.domElement = e, this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Ye, this._useLegacyLights = !1, this.toneMapping = tt, this.toneMappingExposure = 1;
                        const b = this;
                        let M = !1,
                            w = 0,
                            S = 0,
                            E = null,
                            T = -1,
                            C = null;
                        const R = new Sr,
                            P = new Sr;
                        let L = null;
                        const D = new Ki(0);
                        let I = 0,
                            O = e.width,
                            B = e.height,
                            q = 1,
                            U = null,
                            N = null;
                        const k = new Sr(0, 0, O, B),
                            F = new Sr(0, 0, O, B);
                        let z = !1;
                        const G = new po;
                        let j = !1,
                            V = !1,
                            H = null;
                        const W = new Ai,
                            X = new er,
                            Y = new Ir,
                            Q = {
                                background: null,
                                fog: null,
                                environment: null,
                                overrideMaterial: null,
                                isScene: !0
                            };

                        function Z() {
                            return null === E ? q : 1
                        }
                        let J, K, $, et, nt, rt, it, at, ot, st, lt, At, ct, ut, ht, dt, ft, pt, mt, gt, vt, _t, yt, xt, bt = n;

                        function Mt(t, n) {
                            for (let r = 0; r < t.length; r++) {
                                const i = t[r],
                                    a = e.getContext(i, n);
                                if (null !== a) return a
                            }
                            return null
                        }
                        try {
                            const t = {
                                alpha: !0,
                                depth: i,
                                stencil: a,
                                antialias: s,
                                premultipliedAlpha: l,
                                preserveDrawingBuffer: A,
                                powerPreference: c,
                                failIfMajorPerformanceCaveat: u
                            };
                            if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${r}`), e.addEventListener("webglcontextlost", Et, !1), e.addEventListener("webglcontextrestored", Ct, !1), e.addEventListener("webglcontextcreationerror", Pt, !1), null === bt) {
                                const e = ["webgl2", "webgl", "experimental-webgl"];
                                if (!0 === b.isWebGL1Renderer && e.shift(), bt = Mt(e, t), null === bt) throw Mt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                            }
                            "undefined" != typeof WebGLRenderingContext && bt instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === bt.getShaderPrecisionFormat && (bt.getShaderPrecisionFormat = function() {
                                return {
                                    rangeMin: 1,
                                    rangeMax: 1,
                                    precision: 1
                                }
                            })
                        } catch (t) {
                            throw console.error("THREE.WebGLRenderer: " + t.message), t
                        }

                        function wt() {
                            J = new Xo(bt), K = new Co(bt, J, t), J.init(K), _t = new Hl(bt, J, K), $ = new jl(bt, J, K), et = new Zo(bt), nt = new Rl, rt = new Vl(bt, J, $, nt, K, _t, et), it = new Po(b), at = new Wo(b), ot = new go(bt, K), yt = new Eo(bt, J, ot, K), st = new Yo(bt, ot, et, yt), lt = new ts(bt, st, ot, et), mt = new $o(bt, K, rt), dt = new Ro(nt), At = new Cl(b, it, at, J, K, yt, dt), ct = new tA(b, nt), ut = new Il, ht = new kl(J, K), pt = new So(b, it, at, $, lt, h, l), ft = new Gl(b, lt, K), xt = new eA(bt, et, K, $), gt = new To(bt, J, et, K), vt = new Qo(bt, J, et, K), et.programs = At.programs, b.capabilities = K, b.extensions = J, b.properties = nt, b.renderLists = ut, b.shadowMap = ft, b.state = $, b.info = et
                        }
                        wt();
                        const St = new Jl(b, bt);

                        function Et(t) {
                            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), M = !0
                        }

                        function Ct() {
                            console.log("THREE.WebGLRenderer: Context Restored."), M = !1;
                            const t = et.autoReset,
                                e = ft.enabled,
                                n = ft.autoUpdate,
                                r = ft.needsUpdate,
                                i = ft.type;
                            wt(), et.autoReset = t, ft.enabled = e, ft.autoUpdate = n, ft.needsUpdate = r, ft.type = i
                        }

                        function Pt(t) {
                            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
                        }

                        function Lt(t) {
                            const e = t.target;
                            e.removeEventListener("dispose", Lt),
                                function(t) {
                                    (function(t) {
                                        const e = nt.get(t).programs;
                                        void 0 !== e && (e.forEach((function(t) {
                                            At.releaseProgram(t)
                                        })), t.isShaderMaterial && At.releaseShaderCache(t))
                                    })(t), nt.remove(t)
                                }(e)
                        }

                        function It(t, e, n) {
                            !0 === t.transparent && t.side === m && !1 === t.forceSinglePass ? (t.side = p, t.needsUpdate = !0, Kt(t, e, n), t.side = f, t.needsUpdate = !0, Kt(t, e, n), t.side = m) : Kt(t, e, n)
                        }
                        this.xr = St, this.getContext = function() {
                            return bt
                        }, this.getContextAttributes = function() {
                            return bt.getContextAttributes()
                        }, this.forceContextLoss = function() {
                            const t = J.get("WEBGL_lose_context");
                            t && t.loseContext()
                        }, this.forceContextRestore = function() {
                            const t = J.get("WEBGL_lose_context");
                            t && t.restoreContext()
                        }, this.getPixelRatio = function() {
                            return q
                        }, this.setPixelRatio = function(t) {
                            void 0 !== t && (q = t, this.setSize(O, B, !1))
                        }, this.getSize = function(t) {
                            return t.set(O, B)
                        }, this.setSize = function(t, n, r = !0) {
                            St.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (O = t, B = n, e.width = Math.floor(t * q), e.height = Math.floor(n * q), !0 === r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                        }, this.getDrawingBufferSize = function(t) {
                            return t.set(O * q, B * q).floor()
                        }, this.setDrawingBufferSize = function(t, n, r) {
                            O = t, B = n, q = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
                        }, this.getCurrentViewport = function(t) {
                            return t.copy(R)
                        }, this.getViewport = function(t) {
                            return t.copy(k)
                        }, this.setViewport = function(t, e, n, r) {
                            t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, n, r), $.viewport(R.copy(k).multiplyScalar(q).round())
                        }, this.getScissor = function(t) {
                            return t.copy(F)
                        }, this.setScissor = function(t, e, n, r) {
                            t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, r), $.scissor(P.copy(F).multiplyScalar(q).round())
                        }, this.getScissorTest = function() {
                            return z
                        }, this.setScissorTest = function(t) {
                            $.setScissorTest(z = t)
                        }, this.setOpaqueSort = function(t) {
                            U = t
                        }, this.setTransparentSort = function(t) {
                            N = t
                        }, this.getClearColor = function(t) {
                            return t.copy(pt.getClearColor())
                        }, this.setClearColor = function() {
                            pt.setClearColor.apply(pt, arguments)
                        }, this.getClearAlpha = function() {
                            return pt.getClearAlpha()
                        }, this.setClearAlpha = function() {
                            pt.setClearAlpha.apply(pt, arguments)
                        }, this.clear = function(t = !0, e = !0, n = !0) {
                            let r = 0;
                            if (t) {
                                let t = !1;
                                if (null !== E) {
                                    const e = E.texture.format;
                                    t = e === Zt || e === Qt || e === Xt
                                }
                                if (t) {
                                    const t = E.texture.type,
                                        e = t === Rt || t === Ot || t === Dt || t === kt || t === Ut || t === Nt,
                                        n = pt.getClearColor(),
                                        r = pt.getClearAlpha(),
                                        i = n.r,
                                        a = n.g,
                                        o = n.b;
                                    e ? (d[0] = i, d[1] = a, d[2] = o, d[3] = r, bt.clearBufferuiv(bt.COLOR, 0, d)) : (g[0] = i, g[1] = a, g[2] = o, g[3] = r, bt.clearBufferiv(bt.COLOR, 0, g))
                                } else r |= bt.COLOR_BUFFER_BIT
                            }
                            e && (r |= bt.DEPTH_BUFFER_BIT), n && (r |= bt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), bt.clear(r)
                        }, this.clearColor = function() {
                            this.clear(!0, !1, !1)
                        }, this.clearDepth = function() {
                            this.clear(!1, !0, !1)
                        }, this.clearStencil = function() {
                            this.clear(!1, !1, !0)
                        }, this.dispose = function() {
                            e.removeEventListener("webglcontextlost", Et, !1), e.removeEventListener("webglcontextrestored", Ct, !1), e.removeEventListener("webglcontextcreationerror", Pt, !1), ut.dispose(), ht.dispose(), nt.dispose(), it.dispose(), at.dispose(), lt.dispose(), yt.dispose(), xt.dispose(), At.dispose(), St.dispose(), St.removeEventListener("sessionstart", Gt), St.removeEventListener("sessionend", jt), H && (H.dispose(), H = null), Vt.stop()
                        }, this.renderBufferDirect = function(t, e, n, r, i, a) {
                            null === e && (e = Q);
                            const o = i.isMesh && i.matrixWorld.determinant() < 0,
                                s = function(t, e, n, r, i) {
                                    !0 !== e.isScene && (e = Q), rt.resetTextureUnits();
                                    const a = e.fog,
                                        o = r.isMeshStandardMaterial ? e.environment : null,
                                        s = null === E ? b.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : Qe,
                                        l = (r.isMeshStandardMaterial ? at : it).get(r.envMap || o),
                                        A = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                        c = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0),
                                        u = !!n.morphAttributes.position,
                                        h = !!n.morphAttributes.normal,
                                        d = !!n.morphAttributes.color;
                                    let f = tt;
                                    r.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (f = b.toneMapping));
                                    const p = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                        m = void 0 !== p ? p.length : 0,
                                        g = nt.get(r),
                                        v = _.state.lights;
                                    if (!0 === j && (!0 === V || t !== C)) {
                                        const e = t === C && r.id === T;
                                        dt.setState(r, t, e)
                                    }
                                    let y = !1;
                                    r.version === g.__version ? g.needsLights && g.lightsStateVersion !== v.state.version || g.outputColorSpace !== s || i.isBatchedMesh && !1 === g.batching ? y = !0 : i.isBatchedMesh || !0 !== g.batching ? i.isInstancedMesh && !1 === g.instancing ? y = !0 : i.isInstancedMesh || !0 !== g.instancing ? i.isSkinnedMesh && !1 === g.skinning ? y = !0 : i.isSkinnedMesh || !0 !== g.skinning ? i.isInstancedMesh && !0 === g.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === g.instancingColor && null !== i.instanceColor || i.isInstancedMesh && !0 === g.instancingMorph && null === i.morphTexture || i.isInstancedMesh && !1 === g.instancingMorph && null !== i.morphTexture || g.envMap !== l || !0 === r.fog && g.fog !== a ? y = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === dt.numPlanes && g.numIntersection === dt.numIntersection ? (g.vertexAlphas !== A || g.vertexTangents !== c || g.morphTargets !== u || g.morphNormals !== h || g.morphColors !== d || g.toneMapping !== f || !0 === K.isWebGL2 && g.morphTargetsCount !== m) && (y = !0) : y = !0 : y = !0 : y = !0 : y = !0 : (y = !0, g.__version = r.version);
                                    let x = g.currentProgram;
                                    !0 === y && (x = Kt(r, e, i));
                                    let M = !1,
                                        w = !1,
                                        S = !1;
                                    const R = x.getUniforms(),
                                        P = g.uniforms;
                                    if ($.useProgram(x.program) && (M = !0, w = !0, S = !0), r.id !== T && (T = r.id, w = !0), M || C !== t) {
                                        R.setValue(bt, "projectionMatrix", t.projectionMatrix), R.setValue(bt, "viewMatrix", t.matrixWorldInverse);
                                        const e = R.map.cameraPosition;
                                        void 0 !== e && e.setValue(bt, Y.setFromMatrixPosition(t.matrixWorld)), K.logarithmicDepthBuffer && R.setValue(bt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && R.setValue(bt, "isOrthographic", !0 === t.isOrthographicCamera), C !== t && (C = t, w = !0, S = !0)
                                    }
                                    if (i.isSkinnedMesh) {
                                        R.setOptional(bt, i, "bindMatrix"), R.setOptional(bt, i, "bindMatrixInverse");
                                        const t = i.skeleton;
                                        t && (K.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), R.setValue(bt, "boneTexture", t.boneTexture, rt)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                                    }
                                    i.isBatchedMesh && (R.setOptional(bt, i, "batchingTexture"), R.setValue(bt, "batchingTexture", i._matricesTexture, rt));
                                    const L = n.morphAttributes;
                                    var D, I;
                                    if ((void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === K.isWebGL2) && mt.update(i, n, x), (w || g.receiveShadow !== i.receiveShadow) && (g.receiveShadow = i.receiveShadow, R.setValue(bt, "receiveShadow", i.receiveShadow)), r.isMeshGouraudMaterial && null !== r.envMap && (P.envMap.value = l, P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), w && (R.setValue(bt, "toneMappingExposure", b.toneMappingExposure), g.needsLights && (I = S, (D = P).ambientLightColor.needsUpdate = I, D.lightProbe.needsUpdate = I, D.directionalLights.needsUpdate = I, D.directionalLightShadows.needsUpdate = I, D.pointLights.needsUpdate = I, D.pointLightShadows.needsUpdate = I, D.spotLights.needsUpdate = I, D.spotLightShadows.needsUpdate = I, D.rectAreaLights.needsUpdate = I, D.hemisphereLights.needsUpdate = I), a && !0 === r.fog && ct.refreshFogUniforms(P, a), ct.refreshMaterialUniforms(P, r, q, B, H), ol.upload(bt, $t(g), P, rt)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (ol.upload(bt, $t(g), P, rt), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && R.setValue(bt, "center", i.center), R.setValue(bt, "modelViewMatrix", i.modelViewMatrix), R.setValue(bt, "normalMatrix", i.normalMatrix), R.setValue(bt, "modelMatrix", i.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial) {
                                        const t = r.uniformsGroups;
                                        for (let e = 0, n = t.length; e < n; e++)
                                            if (K.isWebGL2) {
                                                const n = t[e];
                                                xt.update(n, x), xt.bind(n, x)
                                            } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                                    }
                                    return x
                                }(t, e, n, r, i);
                            $.setMaterial(r, o);
                            let l = n.index,
                                A = 1;
                            if (!0 === r.wireframe) {
                                if (l = st.getWireframeAttribute(n), void 0 === l) return;
                                A = 2
                            }
                            const c = n.drawRange,
                                u = n.attributes.position;
                            let h = c.start * A,
                                d = (c.start + c.count) * A;
                            null !== a && (h = Math.max(h, a.start * A), d = Math.min(d, (a.start + a.count) * A)), null !== l ? (h = Math.max(h, 0), d = Math.min(d, l.count)) : null != u && (h = Math.max(h, 0), d = Math.min(d, u.count));
                            const f = d - h;
                            if (f < 0 || f === 1 / 0) return;
                            let p;
                            yt.setup(i, r, s, n, l);
                            let m = gt;
                            if (null !== l && (p = ot.get(l), m = vt, m.setIndex(p)), i.isMesh) !0 === r.wireframe ? ($.setLineWidth(r.wireframeLinewidth * Z()), m.setMode(bt.LINES)) : m.setMode(bt.TRIANGLES);
                            else if (i.isLine) {
                                let t = r.linewidth;
                                void 0 === t && (t = 1), $.setLineWidth(t * Z()), i.isLineSegments ? m.setMode(bt.LINES) : i.isLineLoop ? m.setMode(bt.LINE_LOOP) : m.setMode(bt.LINE_STRIP)
                            } else i.isPoints ? m.setMode(bt.POINTS) : i.isSprite && m.setMode(bt.TRIANGLES);
                            if (i.isBatchedMesh) m.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount);
                            else if (i.isInstancedMesh) m.renderInstances(h, f, i.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                                    e = Math.min(n.instanceCount, t);
                                m.renderInstances(h, f, e)
                            } else m.render(h, f)
                        }, this.compile = function(t, e, n = null) {
                            null === n && (n = t), _ = ht.get(n), _.init(), x.push(_), n.traverseVisible((function(t) {
                                t.isLight && t.layers.test(e.layers) && (_.pushLight(t), t.castShadow && _.pushShadow(t))
                            })), t !== n && t.traverseVisible((function(t) {
                                t.isLight && t.layers.test(e.layers) && (_.pushLight(t), t.castShadow && _.pushShadow(t))
                            })), _.setupLights(b._useLegacyLights);
                            const r = new Set;
                            return t.traverse((function(t) {
                                const e = t.material;
                                if (e)
                                    if (Array.isArray(e))
                                        for (let i = 0; i < e.length; i++) {
                                            const a = e[i];
                                            It(a, n, t), r.add(a)
                                        } else It(e, n, t), r.add(e)
                            })), x.pop(), _ = null, r
                        }, this.compileAsync = function(t, e, n = null) {
                            const r = this.compile(t, e, n);
                            return new Promise((e => {
                                function n() {
                                    r.forEach((function(t) {
                                        nt.get(t).currentProgram.isReady() && r.delete(t)
                                    })), 0 !== r.size ? setTimeout(n, 10) : e(t)
                                }
                                null !== J.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                            }))
                        };
                        let Ft = null;

                        function Gt() {
                            Vt.stop()
                        }

                        function jt() {
                            Vt.start()
                        }
                        const Vt = new mo;

                        function Ht(t, e, n, r) {
                            if (!1 === t.visible) return;
                            if (t.layers.test(e.layers))
                                if (t.isGroup) n = t.renderOrder;
                                else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                            else if (t.isLight) _.pushLight(t), t.castShadow && _.pushShadow(t);
                            else if (t.isSprite) {
                                if (!t.frustumCulled || G.intersectsSprite(t)) {
                                    r && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);
                                    const e = lt.update(t),
                                        i = t.material;
                                    i.visible && v.push(t, e, i, n, Y.z, null)
                                }
                            } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || G.intersectsObject(t))) {
                                const e = lt.update(t),
                                    i = t.material;
                                if (r && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), Y.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), Y.copy(e.boundingSphere.center)), Y.applyMatrix4(t.matrixWorld).applyMatrix4(W)), Array.isArray(i)) {
                                    const r = e.groups;
                                    for (let a = 0, o = r.length; a < o; a++) {
                                        const o = r[a],
                                            s = i[o.materialIndex];
                                        s && s.visible && v.push(t, e, s, n, Y.z, o)
                                    }
                                } else i.visible && v.push(t, e, i, n, Y.z, null)
                            }
                            const i = t.children;
                            for (let t = 0, a = i.length; t < a; t++) Ht(i[t], e, n, r)
                        }

                        function Wt(t, e, n, r) {
                            const i = t.opaque,
                                a = t.transmissive,
                                o = t.transparent;
                            _.setupLightsView(n), !0 === j && dt.setGlobalState(b.clippingPlanes, n), a.length > 0 && function(t, e, n, r) {
                                if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
                                const i = K.isWebGL2;
                                null === H && (H = new Tr(1, 1, {
                                    generateMipmaps: !0,
                                    type: J.has("EXT_color_buffer_half_float") ? qt : Rt,
                                    minFilter: Tt,
                                    samples: i ? 4 : 0
                                })), b.getDrawingBufferSize(X), i ? H.setSize(X.x, X.y) : H.setSize(Jn(X.x), Jn(X.y));
                                const a = b.getRenderTarget();
                                b.setRenderTarget(H), b.getClearColor(D), I = b.getClearAlpha(), I < 1 && b.setClearColor(16777215, .5), b.clear();
                                const o = b.toneMapping;
                                b.toneMapping = tt, Yt(t, n, r), rt.updateMultisampleRenderTarget(H), rt.updateRenderTargetMipmap(H);
                                let s = !1;
                                for (let t = 0, i = e.length; t < i; t++) {
                                    const i = e[t],
                                        a = i.object,
                                        o = i.geometry,
                                        l = i.material,
                                        A = i.group;
                                    if (l.side === m && a.layers.test(r.layers)) {
                                        const t = l.side;
                                        l.side = p, l.needsUpdate = !0, Jt(a, n, r, o, l, A), l.side = t, l.needsUpdate = !0, s = !0
                                    }
                                }!0 === s && (rt.updateMultisampleRenderTarget(H), rt.updateRenderTargetMipmap(H)), b.setRenderTarget(a), b.setClearColor(D, I), b.toneMapping = o
                            }(i, a, e, n), r && $.viewport(R.copy(r)), i.length > 0 && Yt(i, e, n), a.length > 0 && Yt(a, e, n), o.length > 0 && Yt(o, e, n), $.buffers.depth.setTest(!0), $.buffers.depth.setMask(!0), $.buffers.color.setMask(!0), $.setPolygonOffset(!1)
                        }

                        function Yt(t, e, n) {
                            const r = !0 === e.isScene ? e.overrideMaterial : null;
                            for (let i = 0, a = t.length; i < a; i++) {
                                const a = t[i],
                                    o = a.object,
                                    s = a.geometry,
                                    l = null === r ? a.material : r,
                                    A = a.group;
                                o.layers.test(n.layers) && Jt(o, e, n, s, l, A)
                            }
                        }

                        function Jt(t, e, n, r, i, a) {
                            t.onBeforeRender(b, e, n, r, i, a), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), i.onBeforeRender(b, e, n, r, t, a), !0 === i.transparent && i.side === m && !1 === i.forceSinglePass ? (i.side = p, i.needsUpdate = !0, b.renderBufferDirect(n, e, r, i, t, a), i.side = f, i.needsUpdate = !0, b.renderBufferDirect(n, e, r, i, t, a), i.side = m) : b.renderBufferDirect(n, e, r, i, t, a), t.onAfterRender(b, e, n, r, i, a)
                        }

                        function Kt(t, e, n) {
                            !0 !== e.isScene && (e = Q);
                            const r = nt.get(t),
                                i = _.state.lights,
                                a = _.state.shadowsArray,
                                o = i.state.version,
                                s = At.getParameters(t, i.state, a, e, n),
                                l = At.getProgramCacheKey(s);
                            let A = r.programs;
                            r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = (t.isMeshStandardMaterial ? at : it).get(t.envMap || r.environment), r.envMapRotation = null !== r.environment && null === t.envMap ? e.environmentRotation : t.envMapRotation, void 0 === A && (t.addEventListener("dispose", Lt), A = new Map, r.programs = A);
                            let c = A.get(l);
                            if (void 0 !== c) {
                                if (r.currentProgram === c && r.lightsStateVersion === o) return te(t, s), c
                            } else s.uniforms = At.getUniforms(t), t.onBuild(n, s, b), t.onBeforeCompile(s, b), c = At.acquireProgram(s, l), A.set(l, c), r.uniforms = s.uniforms;
                            const u = r.uniforms;
                            return (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = dt.uniform), te(t, s), r.needsLights = function(t) {
                                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                            }(t), r.lightsStateVersion = o, r.needsLights && (u.ambientLightColor.value = i.state.ambient, u.lightProbe.value = i.state.probe, u.directionalLights.value = i.state.directional, u.directionalLightShadows.value = i.state.directionalShadow, u.spotLights.value = i.state.spot, u.spotLightShadows.value = i.state.spotShadow, u.rectAreaLights.value = i.state.rectArea, u.ltc_1.value = i.state.rectAreaLTC1, u.ltc_2.value = i.state.rectAreaLTC2, u.pointLights.value = i.state.point, u.pointLightShadows.value = i.state.pointShadow, u.hemisphereLights.value = i.state.hemi, u.directionalShadowMap.value = i.state.directionalShadowMap, u.directionalShadowMatrix.value = i.state.directionalShadowMatrix, u.spotShadowMap.value = i.state.spotShadowMap, u.spotLightMatrix.value = i.state.spotLightMatrix, u.spotLightMap.value = i.state.spotLightMap, u.pointShadowMap.value = i.state.pointShadowMap, u.pointShadowMatrix.value = i.state.pointShadowMatrix), r.currentProgram = c, r.uniformsList = null, c
                        }

                        function $t(t) {
                            if (null === t.uniformsList) {
                                const e = t.currentProgram.getUniforms();
                                t.uniformsList = ol.seqWithValue(e.seq, t.uniforms)
                            }
                            return t.uniformsList
                        }

                        function te(t, e) {
                            const n = nt.get(t);
                            n.outputColorSpace = e.outputColorSpace, n.batching = e.batching, n.instancing = e.instancing, n.instancingColor = e.instancingColor, n.instancingMorph = e.instancingMorph, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
                        }
                        Vt.setAnimationLoop((function(t) {
                            Ft && Ft(t)
                        })), "undefined" != typeof self && Vt.setContext(self), this.setAnimationLoop = function(t) {
                            Ft = t, St.setAnimationLoop(t), null === t ? Vt.stop() : Vt.start()
                        }, St.addEventListener("sessionstart", Gt), St.addEventListener("sessionend", jt), this.render = function(t, e) {
                            if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                            if (!0 === M) return;
                            !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === St.enabled && !0 === St.isPresenting && (!0 === St.cameraAutoUpdate && St.updateCamera(e), e = St.getCamera()), !0 === t.isScene && t.onBeforeRender(b, t, e, E), _ = ht.get(t, x.length), _.init(), x.push(_), W.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), G.setFromProjectionMatrix(W), V = this.localClippingEnabled, j = dt.init(this.clippingPlanes, V), v = ut.get(t, y.length), v.init(), y.push(v), Ht(t, e, 0, b.sortObjects), v.finish(), !0 === b.sortObjects && v.sort(U, N), this.info.render.frame++, !0 === j && dt.beginShadows();
                            const n = _.state.shadowsArray;
                            if (ft.render(n, t, e), !0 === j && dt.endShadows(), !0 === this.info.autoReset && this.info.reset(), !1 !== St.enabled && !1 !== St.isPresenting && !1 !== St.hasDepthSensing() || pt.render(v, t), _.setupLights(b._useLegacyLights), e.isArrayCamera) {
                                const n = e.cameras;
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    Wt(v, t, r, r.viewport)
                                }
                            } else Wt(v, t, e);
                            null !== E && (rt.updateMultisampleRenderTarget(E), rt.updateRenderTargetMipmap(E)), !0 === t.isScene && t.onAfterRender(b, t, e), yt.resetDefaultState(), T = -1, C = null, x.pop(), _ = x.length > 0 ? x[x.length - 1] : null, y.pop(), v = y.length > 0 ? y[y.length - 1] : null
                        }, this.getActiveCubeFace = function() {
                            return w
                        }, this.getActiveMipmapLevel = function() {
                            return S
                        }, this.getRenderTarget = function() {
                            return E
                        }, this.setRenderTargetTextures = function(t, e, n) {
                            nt.get(t.texture).__webglTexture = e, nt.get(t.depthTexture).__webglTexture = n;
                            const r = nt.get(t);
                            r.__hasExternalTextures = !0, r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === J.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1)
                        }, this.setRenderTargetFramebuffer = function(t, e) {
                            const n = nt.get(t);
                            n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
                        }, this.setRenderTarget = function(t, e = 0, n = 0) {
                            E = t, w = e, S = n;
                            let r = !0,
                                i = null,
                                a = !1,
                                o = !1;
                            if (t) {
                                const s = nt.get(t);
                                void 0 !== s.__useDefaultFramebuffer ? ($.bindFramebuffer(bt.FRAMEBUFFER, null), r = !1) : void 0 === s.__webglFramebuffer ? rt.setupRenderTarget(t) : s.__hasExternalTextures && rt.rebindTextures(t, nt.get(t.texture).__webglTexture, nt.get(t.depthTexture).__webglTexture);
                                const l = t.texture;
                                (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0);
                                const A = nt.get(t).__webglFramebuffer;
                                t.isWebGLCubeRenderTarget ? (i = Array.isArray(A[e]) ? A[e][n] : A[e], a = !0) : i = K.isWebGL2 && t.samples > 0 && !1 === rt.useMultisampledRTT(t) ? nt.get(t).__webglMultisampledFramebuffer : Array.isArray(A) ? A[n] : A, R.copy(t.viewport), P.copy(t.scissor), L = t.scissorTest
                            } else R.copy(k).multiplyScalar(q).floor(), P.copy(F).multiplyScalar(q).floor(), L = z;
                            if ($.bindFramebuffer(bt.FRAMEBUFFER, i) && K.drawBuffers && r && $.drawBuffers(t, i), $.viewport(R), $.scissor(P), $.setScissorTest(L), a) {
                                const r = nt.get(t.texture);
                                bt.framebufferTexture2D(bt.FRAMEBUFFER, bt.COLOR_ATTACHMENT0, bt.TEXTURE_CUBE_MAP_POSITIVE_X + e, r.__webglTexture, n)
                            } else if (o) {
                                const r = nt.get(t.texture),
                                    i = e || 0;
                                bt.framebufferTextureLayer(bt.FRAMEBUFFER, bt.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i)
                            }
                            T = -1
                        }, this.readRenderTargetPixels = function(t, e, n, r, i, a, o) {
                            if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                            let s = nt.get(t).__webglFramebuffer;
                            if (t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                                $.bindFramebuffer(bt.FRAMEBUFFER, s);
                                try {
                                    const o = t.texture,
                                        s = o.format,
                                        l = o.type;
                                    if (s !== zt && _t.convert(s) !== bt.getParameter(bt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                    const A = l === qt && (J.has("EXT_color_buffer_half_float") || K.isWebGL2 && J.has("EXT_color_buffer_float"));
                                    if (!(l === Rt || _t.convert(l) === bt.getParameter(bt.IMPLEMENTATION_COLOR_READ_TYPE) || l === Bt && (K.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float")) || A)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                    e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && bt.readPixels(e, n, r, i, _t.convert(s), _t.convert(l), a)
                                } finally {
                                    const t = null !== E ? nt.get(E).__webglFramebuffer : null;
                                    $.bindFramebuffer(bt.FRAMEBUFFER, t)
                                }
                            }
                        }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                            const r = Math.pow(2, -n),
                                i = Math.floor(e.image.width * r),
                                a = Math.floor(e.image.height * r);
                            rt.setTexture2D(e, 0), bt.copyTexSubImage2D(bt.TEXTURE_2D, n, 0, 0, t.x, t.y, i, a), $.unbindTexture()
                        }, this.copyTextureToTexture = function(t, e, n, r = 0) {
                            const i = e.image.width,
                                a = e.image.height,
                                o = _t.convert(n.format),
                                s = _t.convert(n.type);
                            rt.setTexture2D(n, 0), bt.pixelStorei(bt.UNPACK_FLIP_Y_WEBGL, n.flipY), bt.pixelStorei(bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), bt.pixelStorei(bt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? bt.texSubImage2D(bt.TEXTURE_2D, r, t.x, t.y, i, a, o, s, e.image.data) : e.isCompressedTexture ? bt.compressedTexSubImage2D(bt.TEXTURE_2D, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : bt.texSubImage2D(bt.TEXTURE_2D, r, t.x, t.y, o, s, e.image), 0 === r && n.generateMipmaps && bt.generateMipmap(bt.TEXTURE_2D), $.unbindTexture()
                        }, this.copyTextureToTexture3D = function(t, e, n, r, i = 0) {
                            if (b.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                            const a = Math.round(t.max.x - t.min.x),
                                o = Math.round(t.max.y - t.min.y),
                                s = t.max.z - t.min.z + 1,
                                l = _t.convert(r.format),
                                A = _t.convert(r.type);
                            let c;
                            if (r.isData3DTexture) rt.setTexture3D(r, 0), c = bt.TEXTURE_3D;
                            else {
                                if (!r.isDataArrayTexture && !r.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                                rt.setTexture2DArray(r, 0), c = bt.TEXTURE_2D_ARRAY
                            }
                            bt.pixelStorei(bt.UNPACK_FLIP_Y_WEBGL, r.flipY), bt.pixelStorei(bt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), bt.pixelStorei(bt.UNPACK_ALIGNMENT, r.unpackAlignment);
                            const u = bt.getParameter(bt.UNPACK_ROW_LENGTH),
                                h = bt.getParameter(bt.UNPACK_IMAGE_HEIGHT),
                                d = bt.getParameter(bt.UNPACK_SKIP_PIXELS),
                                f = bt.getParameter(bt.UNPACK_SKIP_ROWS),
                                p = bt.getParameter(bt.UNPACK_SKIP_IMAGES),
                                m = n.isCompressedTexture ? n.mipmaps[i] : n.image;
                            bt.pixelStorei(bt.UNPACK_ROW_LENGTH, m.width), bt.pixelStorei(bt.UNPACK_IMAGE_HEIGHT, m.height), bt.pixelStorei(bt.UNPACK_SKIP_PIXELS, t.min.x), bt.pixelStorei(bt.UNPACK_SKIP_ROWS, t.min.y), bt.pixelStorei(bt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? bt.texSubImage3D(c, i, e.x, e.y, e.z, a, o, s, l, A, m.data) : r.isCompressedArrayTexture ? bt.compressedTexSubImage3D(c, i, e.x, e.y, e.z, a, o, s, l, m.data) : bt.texSubImage3D(c, i, e.x, e.y, e.z, a, o, s, l, A, m), bt.pixelStorei(bt.UNPACK_ROW_LENGTH, u), bt.pixelStorei(bt.UNPACK_IMAGE_HEIGHT, h), bt.pixelStorei(bt.UNPACK_SKIP_PIXELS, d), bt.pixelStorei(bt.UNPACK_SKIP_ROWS, f), bt.pixelStorei(bt.UNPACK_SKIP_IMAGES, p), 0 === i && r.generateMipmaps && bt.generateMipmap(c), $.unbindTexture()
                        }, this.initTexture = function(t) {
                            t.isCubeTexture ? rt.setTextureCube(t, 0) : t.isData3DTexture ? rt.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? rt.setTexture2DArray(t, 0) : rt.setTexture2D(t, 0), $.unbindTexture()
                        }, this.resetState = function() {
                            w = 0, S = 0, E = null, $.reset(), yt.reset()
                        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: this
                        }))
                    }
                    get coordinateSystem() {
                        return kn
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(t) {
                        this._outputColorSpace = t;
                        const e = this.getContext();
                        e.drawingBufferColorSpace = t === Ze ? "display-p3" : "srgb", e.unpackColorSpace = pr.workingColorSpace === Je ? "display-p3" : "srgb"
                    }
                    get useLegacyLights() {
                        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
                    }
                    set useLegacyLights(t) {
                        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t
                    }
                }
                class rA extends nA {}
                rA.prototype.isWebGL1Renderer = !0;
                class iA {
                    constructor(t, e = 25e-5) {
                        this.isFogExp2 = !0, this.name = "", this.color = new Ki(t), this.density = e
                    }
                    clone() {
                        return new iA(this.color, this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            name: this.name,
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                class aA {
                    constructor(t, e = 1, n = 1e3) {
                        this.isFog = !0, this.name = "", this.color = new Ki(t), this.near = e, this.far = n
                    }
                    clone() {
                        return new aA(this.color, this.near, this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            name: this.name,
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                class oA extends qi {
                    constructor() {
                        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new _i, this.environmentRotation = new _i, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: this
                        }))
                    }
                    copy(t, e) {
                        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentRotation.copy(t.environmentRotation), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), e.object.environmentRotation = this.environmentRotation.toArray(), e
                    }
                }
                class sA {
                    constructor(t, e) {
                        this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Tn, this._updateRange = {
                            offset: 0,
                            count: -1
                        }, this.updateRanges = [], this.version = 0, this.uuid = Wn()
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    get updateRange() {
                        return cr("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    addUpdateRange(t, e) {
                        this.updateRanges.push({
                            start: t,
                            count: e
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(t) {
                        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                    }
                    copyAt(t, e, n) {
                        t *= this.stride, n *= e.stride;
                        for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
                        return this
                    }
                    set(t, e = 0) {
                        return this.array.set(t, e), this
                    }
                    clone(t) {
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Wn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(e, this.stride);
                        return n.setUsage(this.usage), n
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t, this
                    }
                    toJSON(t) {
                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Wn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                const lA = new Ir;
                class AA {
                    constructor(t, e, n, r = !1) {
                        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(t) {
                        this.data.needsUpdate = t
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.data.count; e < n; e++) lA.fromBufferAttribute(this, e), lA.applyMatrix4(t), this.setXYZ(e, lA.x, lA.y, lA.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++) lA.fromBufferAttribute(this, e), lA.applyNormalMatrix(t), this.setXYZ(e, lA.x, lA.y, lA.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++) lA.fromBufferAttribute(this, e), lA.transformDirection(t), this.setXYZ(e, lA.x, lA.y, lA.z);
                        return this
                    }
                    getComponent(t, e) {
                        let n = this.array[t * this.data.stride + this.offset + e];
                        return this.normalized && (n = Kn(n, this.array)), n
                    }
                    setComponent(t, e, n) {
                        return this.normalized && (n = $n(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this
                    }
                    setX(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
                    }
                    setY(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
                    }
                    setZ(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
                    }
                    setW(t, e) {
                        return this.normalized && (e = $n(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
                    }
                    getX(t) {
                        let e = this.data.array[t * this.data.stride + this.offset];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    getY(t) {
                        let e = this.data.array[t * this.data.stride + this.offset + 1];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    getZ(t) {
                        let e = this.data.array[t * this.data.stride + this.offset + 2];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    getW(t) {
                        let e = this.data.array[t * this.data.stride + this.offset + 3];
                        return this.normalized && (e = Kn(e, this.array)), e
                    }
                    setXY(t, e, n) {
                        return t = t * this.data.stride + this.offset, this.normalized && (e = $n(e, this.array), n = $n(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                    }
                    setXYZ(t, e, n, r) {
                        return t = t * this.data.stride + this.offset, this.normalized && (e = $n(e, this.array), n = $n(n, this.array), r = $n(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
                    }
                    setXYZW(t, e, n, r, i) {
                        return t = t * this.data.stride + this.offset, this.normalized && (e = $n(e, this.array), n = $n(n, this.array), r = $n(r, this.array), i = $n(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
                    }
                    clone(t) {
                        if (void 0 === t) {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                            const t = [];
                            for (let e = 0; e < this.count; e++) {
                                const n = e * this.data.stride + this.offset;
                                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                            }
                            return new ca(new this.array.constructor(t), this.itemSize, this.normalized)
                        }
                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new AA(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                    }
                    toJSON(t) {
                        if (void 0 === t) {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                            const t = [];
                            for (let e = 0; e < this.count; e++) {
                                const n = e * this.data.stride + this.offset;
                                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: t,
                                normalized: this.normalized
                            }
                        }
                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized
                        }
                    }
                }
                class cA extends ea {
                    constructor(t) {
                        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Ki(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
                    }
                }
                let uA;
                const hA = new Ir,
                    dA = new Ir,
                    fA = new Ir,
                    pA = new er,
                    mA = new er,
                    gA = new Ai,
                    vA = new Ir,
                    _A = new Ir,
                    yA = new Ir,
                    xA = new er,
                    bA = new er,
                    MA = new er;
                class wA extends qi {
                    constructor(t = new cA) {
                        if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === uA) {
                            uA = new Ta;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                e = new sA(t, 5);
                            uA.setIndex([0, 1, 2, 0, 2, 3]), uA.setAttribute("position", new AA(e, 3, 0, !1)), uA.setAttribute("uv", new AA(e, 2, 3, !1))
                        }
                        this.geometry = uA, this.material = t, this.center = new er(.5, .5)
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), dA.setFromMatrixScale(this.matrixWorld), gA.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), fA.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && dA.multiplyScalar(-fA.z);
                        const n = this.material.rotation;
                        let r, i;
                        0 !== n && (i = Math.cos(n), r = Math.sin(n));
                        const a = this.center;
                        SA(vA.set(-.5, -.5, 0), fA, a, dA, r, i), SA(_A.set(.5, -.5, 0), fA, a, dA, r, i), SA(yA.set(.5, .5, 0), fA, a, dA, r, i), xA.set(0, 0), bA.set(1, 0), MA.set(1, 1);
                        let o = t.ray.intersectTriangle(vA, _A, yA, !1, hA);
                        if (null === o && (SA(_A.set(-.5, .5, 0), fA, a, dA, r, i), bA.set(0, 1), o = t.ray.intersectTriangle(vA, yA, _A, !1, hA), null === o)) return;
                        const s = t.ray.origin.distanceTo(hA);
                        s < t.near || s > t.far || e.push({
                            distance: s,
                            point: hA.clone(),
                            uv: Xi.getInterpolation(hA, vA, _A, yA, xA, bA, MA, new er),
                            face: null,
                            object: this
                        })
                    }
                    copy(t, e) {
                        return super.copy(t, e), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                    }
                }

                function SA(t, e, n, r, i, a) {
                    pA.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (mA.x = a * pA.x - i * pA.y, mA.y = i * pA.x + a * pA.y) : mA.copy(pA), t.copy(e), t.x += mA.x, t.y += mA.y, t.applyMatrix4(gA)
                }
                const EA = new Ir,
                    TA = new Ir;
                class CA extends qi {
                    constructor() {
                        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            },
                            isLOD: {
                                value: !0
                            }
                        }), this.autoUpdate = !0
                    }
                    copy(t) {
                        super.copy(t, !1);
                        const e = t.levels;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            this.addLevel(n.object.clone(), n.distance, n.hysteresis)
                        }
                        return this.autoUpdate = t.autoUpdate, this
                    }
                    addLevel(t, e = 0, n = 0) {
                        e = Math.abs(e);
                        const r = this.levels;
                        let i;
                        for (i = 0; i < r.length && !(e < r[i].distance); i++);
                        return r.splice(i, 0, {
                            distance: e,
                            hysteresis: n,
                            object: t
                        }), this.add(t), this
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(t) {
                        const e = this.levels;
                        if (e.length > 0) {
                            let n, r;
                            for (n = 1, r = e.length; n < r; n++) {
                                let r = e[n].distance;
                                if (e[n].object.visible && (r -= r * e[n].hysteresis), t < r) break
                            }
                            return e[n - 1].object
                        }
                        return null
                    }
                    raycast(t, e) {
                        if (this.levels.length > 0) {
                            EA.setFromMatrixPosition(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(EA);
                            this.getObjectForDistance(n).raycast(t, e)
                        }
                    }
                    update(t) {
                        const e = this.levels;
                        if (e.length > 1) {
                            EA.setFromMatrixPosition(t.matrixWorld), TA.setFromMatrixPosition(this.matrixWorld);
                            const n = EA.distanceTo(TA) / t.zoom;
                            let r, i;
                            for (e[0].object.visible = !0, r = 1, i = e.length; r < i; r++) {
                                let t = e[r].distance;
                                if (e[r].object.visible && (t -= t * e[r].hysteresis), !(n >= t)) break;
                                e[r - 1].object.visible = !1, e[r].object.visible = !0
                            }
                            for (this._currentLevel = r - 1; r < i; r++) e[r].object.visible = !1
                        }
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                        const n = this.levels;
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            e.object.levels.push({
                                object: r.object.uuid,
                                distance: r.distance,
                                hysteresis: r.hysteresis
                            })
                        }
                        return e
                    }
                }
                const RA = new Ir,
                    PA = new Sr,
                    LA = new Sr,
                    DA = new Ir,
                    IA = new Ai,
                    OA = new Ir,
                    BA = new ti,
                    qA = new Ai,
                    UA = new li;
                class NA extends Ha {
                    constructor(t, e) {
                        super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = lt, this.bindMatrix = new Ai, this.bindMatrixInverse = new Ai, this.boundingBox = null, this.boundingSphere = null
                    }
                    computeBoundingBox() {
                        const t = this.geometry;
                        null === this.boundingBox && (this.boundingBox = new qr), this.boundingBox.makeEmpty();
                        const e = t.getAttribute("position");
                        for (let t = 0; t < e.count; t++) this.getVertexPosition(t, OA), this.boundingBox.expandByPoint(OA)
                    }
                    computeBoundingSphere() {
                        const t = this.geometry;
                        null === this.boundingSphere && (this.boundingSphere = new ti), this.boundingSphere.makeEmpty();
                        const e = t.getAttribute("position");
                        for (let t = 0; t < e.count; t++) this.getVertexPosition(t, OA), this.boundingSphere.expandByPoint(OA)
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                    }
                    raycast(t, e) {
                        const n = this.material,
                            r = this.matrixWorld;
                        void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), BA.copy(this.boundingSphere), BA.applyMatrix4(r), !1 !== t.ray.intersectsSphere(BA) && (qA.copy(r).invert(), UA.copy(t.ray).applyMatrix4(qA), null !== this.boundingBox && !1 === UA.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, UA)))
                    }
                    getVertexPosition(t, e) {
                        return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
                    }
                    bind(t, e) {
                        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const t = new Sr,
                            e = this.geometry.attributes.skinWeight;
                        for (let n = 0, r = e.count; n < r; n++) {
                            t.fromBufferAttribute(e, n);
                            const r = 1 / t.manhattanLength();
                            r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), this.bindMode === lt ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === At ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    applyBoneTransform(t, e) {
                        const n = this.skeleton,
                            r = this.geometry;
                        PA.fromBufferAttribute(r.attributes.skinIndex, t), LA.fromBufferAttribute(r.attributes.skinWeight, t), RA.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                        for (let t = 0; t < 4; t++) {
                            const r = LA.getComponent(t);
                            if (0 !== r) {
                                const i = PA.getComponent(t);
                                IA.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), e.addScaledVector(DA.copy(RA).applyMatrix4(IA), r)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                class kA extends qi {
                    constructor() {
                        super(), this.isBone = !0, this.type = "Bone"
                    }
                }
                class FA extends wr {
                    constructor(t = null, e = 1, n = 1, r, i, a, o, s, l = _t, A = _t, c, u) {
                        super(null, a, o, s, l, A, r, i, c, u), this.isDataTexture = !0, this.image = {
                            data: t,
                            width: e,
                            height: n
                        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                }
                const zA = new Ai,
                    GA = new Ai;
                class jA {
                    constructor(t = [], e = []) {
                        this.uuid = Wn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init()
                    }
                    init() {
                        const t = this.bones,
                            e = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                        else if (t.length !== e.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ai)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = new Ai;
                            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                        }
                    }
                    pose() {
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                        }
                    }
                    update() {
                        const t = this.bones,
                            e = this.boneInverses,
                            n = this.boneMatrices,
                            r = this.boneTexture;
                        for (let r = 0, i = t.length; r < i; r++) {
                            const i = t[r] ? t[r].matrixWorld : GA;
                            zA.multiplyMatrices(i, e[r]), zA.toArray(n, 16 * r)
                        }
                        null !== r && (r.needsUpdate = !0)
                    }
                    clone() {
                        return new jA(this.bones, this.boneInverses)
                    }
                    computeBoneTexture() {
                        let t = Math.sqrt(4 * this.bones.length);
                        t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                        const e = new Float32Array(t * t * 4);
                        e.set(this.boneMatrices);
                        const n = new FA(e, t, t, zt, Bt);
                        return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this
                    }
                    getBoneByName(t) {
                        for (let e = 0, n = this.bones.length; e < n; e++) {
                            const n = this.bones[e];
                            if (n.name === t) return n
                        }
                    }
                    dispose() {
                        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                    }
                    fromJSON(t, e) {
                        this.uuid = t.uuid;
                        for (let n = 0, r = t.bones.length; n < r; n++) {
                            const r = t.bones[n];
                            let i = e[r];
                            void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new kA), this.bones.push(i), this.boneInverses.push((new Ai).fromArray(t.boneInverses[n]))
                        }
                        return this.init(), this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.6,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        t.uuid = this.uuid;
                        const e = this.bones,
                            n = this.boneInverses;
                        for (let r = 0, i = e.length; r < i; r++) {
                            const i = e[r];
                            t.bones.push(i.uuid);
                            const a = n[r];
                            t.boneInverses.push(a.toArray())
                        }
                        return t
                    }
                }
                class VA extends ca {
                    constructor(t, e, n, r = 1) {
                        super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
                    }
                    copy(t) {
                        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                    }
                }
                const HA = new Ai,
                    WA = new Ai,
                    XA = [],
                    YA = new qr,
                    QA = new Ai,
                    ZA = new Ha,
                    JA = new ti;
                class KA extends Ha {
                    constructor(t, e, n) {
                        super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new VA(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                        for (let t = 0; t < n; t++) this.setMatrixAt(t, QA)
                    }
                    computeBoundingBox() {
                        const t = this.geometry,
                            e = this.count;
                        null === this.boundingBox && (this.boundingBox = new qr), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
                        for (let n = 0; n < e; n++) this.getMatrixAt(n, HA), YA.copy(t.boundingBox).applyMatrix4(HA), this.boundingBox.union(YA)
                    }
                    computeBoundingSphere() {
                        const t = this.geometry,
                            e = this.count;
                        null === this.boundingSphere && (this.boundingSphere = new ti), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                        for (let n = 0; n < e; n++) this.getMatrixAt(n, HA), JA.copy(t.boundingSphere).applyMatrix4(HA), this.boundingSphere.union(JA)
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                    }
                    getColorAt(t, e) {
                        e.fromArray(this.instanceColor.array, 3 * t)
                    }
                    getMatrixAt(t, e) {
                        e.fromArray(this.instanceMatrix.array, 16 * t)
                    }
                    getMorphAt(t, e) {
                        const n = e.morphTargetInfluences,
                            r = this.morphTexture.source.data.data,
                            i = t * (n.length + 1) + 1;
                        for (let t = 0; t < n.length; t++) n[t] = r[i + t]
                    }
                    raycast(t, e) {
                        const n = this.matrixWorld,
                            r = this.count;
                        if (ZA.geometry = this.geometry, ZA.material = this.material, void 0 !== ZA.material && (null === this.boundingSphere && this.computeBoundingSphere(), JA.copy(this.boundingSphere), JA.applyMatrix4(n), !1 !== t.ray.intersectsSphere(JA)))
                            for (let i = 0; i < r; i++) {
                                this.getMatrixAt(i, HA), WA.multiplyMatrices(n, HA), ZA.matrixWorld = WA, ZA.raycast(t, XA);
                                for (let t = 0, n = XA.length; t < n; t++) {
                                    const n = XA[t];
                                    n.instanceId = i, n.object = this, e.push(n)
                                }
                                XA.length = 0
                            }
                    }
                    setColorAt(t, e) {
                        null === this.instanceColor && (this.instanceColor = new VA(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                    }
                    setMatrixAt(t, e) {
                        e.toArray(this.instanceMatrix.array, 16 * t)
                    }
                    setMorphAt(t, e) {
                        const n = e.morphTargetInfluences,
                            r = n.length + 1;
                        null === this.morphTexture && (this.morphTexture = new FA(new Float32Array(r * this.count), r, this.count, Wt, Bt));
                        const i = this.morphTexture.source.data.data;
                        let a = 0;
                        for (let t = 0; t < n.length; t++) a += n[t];
                        const o = this.geometry.morphTargetsRelative ? 1 : 1 - a,
                            s = r * t;
                        i[s] = o, i.set(n, s + 1)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }

                function $A(t, e) {
                    return t.z - e.z
                }

                function tc(t, e) {
                    return e.z - t.z
                }
                class ec {
                    constructor() {
                        this.index = 0, this.pool = [], this.list = []
                    }
                    push(t, e) {
                        const n = this.pool,
                            r = this.list;
                        this.index >= n.length && n.push({
                            start: -1,
                            count: -1,
                            z: -1
                        });
                        const i = n[this.index];
                        r.push(i), this.index++, i.start = t.start, i.count = t.count, i.z = e
                    }
                    reset() {
                        this.list.length = 0, this.index = 0
                    }
                }
                const nc = "batchId",
                    rc = new Ai,
                    ic = new Ai,
                    ac = new Ai,
                    oc = new Ai,
                    sc = new po,
                    lc = new qr,
                    Ac = new ti,
                    cc = new Ir,
                    uc = new ec,
                    hc = new Ha,
                    dc = [];

                function fc(t, e, n = 0) {
                    const r = e.itemSize;
                    if (t.isInterleavedBufferAttribute || t.array.constructor !== e.array.constructor) {
                        const i = t.count;
                        for (let a = 0; a < i; a++)
                            for (let i = 0; i < r; i++) e.setComponent(a + n, i, t.getComponent(a, i))
                    } else e.array.set(t.array, n * r);
                    e.needsUpdate = !0
                }
                class pc extends Ha {
                    get maxGeometryCount() {
                        return this._maxGeometryCount
                    }
                    constructor(t, e, n = 2 * e, r) {
                        super(new Ta, r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = t, this._maxVertexCount = e, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(t), this._multiDrawStarts = new Int32Array(t), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture()
                    }
                    _initMatricesTexture() {
                        let t = Math.sqrt(4 * this._maxGeometryCount);
                        t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                        const e = new Float32Array(t * t * 4),
                            n = new FA(e, t, t, zt, Bt);
                        this._matricesTexture = n
                    }
                    _initializeGeometry(t) {
                        const e = this.geometry,
                            n = this._maxVertexCount,
                            r = this._maxGeometryCount,
                            i = this._maxIndexCount;
                        if (!1 === this._geometryInitialized) {
                            for (const r in t.attributes) {
                                const i = t.getAttribute(r),
                                    {
                                        array: a,
                                        itemSize: o,
                                        normalized: s
                                    } = i,
                                    l = new a.constructor(n * o),
                                    A = new i.constructor(l, o, s);
                                A.setUsage(i.usage), e.setAttribute(r, A)
                            }
                            if (null !== t.getIndex()) {
                                const t = n > 65536 ? new Uint32Array(i) : new Uint16Array(i);
                                e.setIndex(new ca(t, 1))
                            }
                            const a = r > 65536 ? new Uint32Array(n) : new Uint16Array(n);
                            e.setAttribute(nc, new ca(a, 1)), this._geometryInitialized = !0
                        }
                    }
                    _validateGeometry(t) {
                        if (t.getAttribute(nc)) throw new Error(`BatchedMesh: Geometry cannot use attribute "${nc}"`);
                        const e = this.geometry;
                        if (Boolean(t.getIndex()) !== Boolean(e.getIndex())) throw new Error('BatchedMesh: All geometries must consistently have "index".');
                        for (const n in e.attributes) {
                            if (n === nc) continue;
                            if (!t.hasAttribute(n)) throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                            const r = t.getAttribute(n),
                                i = e.getAttribute(n);
                            if (r.itemSize !== i.itemSize || r.normalized !== i.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                        }
                    }
                    setCustomSort(t) {
                        return this.customSort = t, this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new qr);
                        const t = this._geometryCount,
                            e = this.boundingBox,
                            n = this._active;
                        e.makeEmpty();
                        for (let r = 0; r < t; r++) !1 !== n[r] && (this.getMatrixAt(r, rc), this.getBoundingBoxAt(r, lc).applyMatrix4(rc), e.union(lc))
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new ti);
                        const t = this._geometryCount,
                            e = this.boundingSphere,
                            n = this._active;
                        e.makeEmpty();
                        for (let r = 0; r < t; r++) !1 !== n[r] && (this.getMatrixAt(r, rc), this.getBoundingSphereAt(r, Ac).applyMatrix4(rc), e.union(Ac))
                    }
                    addGeometry(t, e = -1, n = -1) {
                        if (this._initializeGeometry(t), this._validateGeometry(t), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                        const r = {
                            vertexStart: -1,
                            vertexCount: -1,
                            indexStart: -1,
                            indexCount: -1
                        };
                        let i = null;
                        const a = this._reservedRanges,
                            o = this._drawRanges,
                            s = this._bounds;
                        0 !== this._geometryCount && (i = a[a.length - 1]), r.vertexCount = -1 === e ? t.getAttribute("position").count : e, r.vertexStart = null === i ? 0 : i.vertexStart + i.vertexCount;
                        const l = t.getIndex(),
                            A = null !== l;
                        if (A && (r.indexCount = -1 === n ? l.count : n, r.indexStart = null === i ? 0 : i.indexStart + i.indexCount), -1 !== r.indexStart && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                        const c = this._visibility,
                            u = this._active,
                            h = this._matricesTexture,
                            d = this._matricesTexture.image.data;
                        c.push(!0), u.push(!0);
                        const f = this._geometryCount;
                        this._geometryCount++, ac.toArray(d, 16 * f), h.needsUpdate = !0, a.push(r), o.push({
                            start: A ? r.indexStart : r.vertexStart,
                            count: -1
                        }), s.push({
                            boxInitialized: !1,
                            box: new qr,
                            sphereInitialized: !1,
                            sphere: new ti
                        });
                        const p = this.geometry.getAttribute(nc);
                        for (let t = 0; t < r.vertexCount; t++) p.setX(r.vertexStart + t, f);
                        return p.needsUpdate = !0, this.setGeometryAt(f, t), f
                    }
                    setGeometryAt(t, e) {
                        if (t >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                        this._validateGeometry(e);
                        const n = this.geometry,
                            r = null !== n.getIndex(),
                            i = n.getIndex(),
                            a = e.getIndex(),
                            o = this._reservedRanges[t];
                        if (r && a.count > o.indexCount || e.attributes.position.count > o.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                        const s = o.vertexStart,
                            l = o.vertexCount;
                        for (const t in n.attributes) {
                            if (t === nc) continue;
                            const r = e.getAttribute(t),
                                i = n.getAttribute(t);
                            fc(r, i, s);
                            const a = r.itemSize;
                            for (let t = r.count, e = l; t < e; t++) {
                                const e = s + t;
                                for (let t = 0; t < a; t++) i.setComponent(e, t, 0)
                            }
                            i.needsUpdate = !0
                        }
                        if (r) {
                            const t = o.indexStart;
                            for (let e = 0; e < a.count; e++) i.setX(t + e, s + a.getX(e));
                            for (let e = a.count, n = o.indexCount; e < n; e++) i.setX(t + e, s);
                            i.needsUpdate = !0
                        }
                        const A = this._bounds[t];
                        null !== e.boundingBox ? (A.box.copy(e.boundingBox), A.boxInitialized = !0) : A.boxInitialized = !1, null !== e.boundingSphere ? (A.sphere.copy(e.boundingSphere), A.sphereInitialized = !0) : A.sphereInitialized = !1;
                        const c = this._drawRanges[t],
                            u = e.getAttribute("position");
                        return c.count = r ? a.count : u.count, this._visibilityChanged = !0, t
                    }
                    deleteGeometry(t) {
                        const e = this._active;
                        return t >= e.length || !1 === e[t] || (e[t] = !1, this._visibilityChanged = !0), this
                    }
                    getBoundingBoxAt(t, e) {
                        if (!1 === this._active[t]) return null;
                        const n = this._bounds[t],
                            r = n.box,
                            i = this.geometry;
                        if (!1 === n.boxInitialized) {
                            r.makeEmpty();
                            const e = i.index,
                                a = i.attributes.position,
                                o = this._drawRanges[t];
                            for (let t = o.start, n = o.start + o.count; t < n; t++) {
                                let n = t;
                                e && (n = e.getX(n)), r.expandByPoint(cc.fromBufferAttribute(a, n))
                            }
                            n.boxInitialized = !0
                        }
                        return e.copy(r), e
                    }
                    getBoundingSphereAt(t, e) {
                        if (!1 === this._active[t]) return null;
                        const n = this._bounds[t],
                            r = n.sphere,
                            i = this.geometry;
                        if (!1 === n.sphereInitialized) {
                            r.makeEmpty(), this.getBoundingBoxAt(t, lc), lc.getCenter(r.center);
                            const e = i.index,
                                a = i.attributes.position,
                                o = this._drawRanges[t];
                            let s = 0;
                            for (let t = o.start, n = o.start + o.count; t < n; t++) {
                                let n = t;
                                e && (n = e.getX(n)), cc.fromBufferAttribute(a, n), s = Math.max(s, r.center.distanceToSquared(cc))
                            }
                            r.radius = Math.sqrt(s), n.sphereInitialized = !0
                        }
                        return e.copy(r), e
                    }
                    setMatrixAt(t, e) {
                        const n = this._active,
                            r = this._matricesTexture,
                            i = this._matricesTexture.image.data;
                        return t >= this._geometryCount || !1 === n[t] || (e.toArray(i, 16 * t), r.needsUpdate = !0), this
                    }
                    getMatrixAt(t, e) {
                        const n = this._active,
                            r = this._matricesTexture.image.data;
                        return t >= this._geometryCount || !1 === n[t] ? null : e.fromArray(r, 16 * t)
                    }
                    setVisibleAt(t, e) {
                        const n = this._visibility,
                            r = this._active;
                        return t >= this._geometryCount || !1 === r[t] || n[t] === e || (n[t] = e, this._visibilityChanged = !0), this
                    }
                    getVisibleAt(t) {
                        const e = this._visibility,
                            n = this._active;
                        return !(t >= this._geometryCount || !1 === n[t]) && e[t]
                    }
                    raycast(t, e) {
                        const n = this._visibility,
                            r = this._active,
                            i = this._drawRanges,
                            a = this._geometryCount,
                            o = this.matrixWorld,
                            s = this.geometry;
                        hc.material = this.material, hc.geometry.index = s.index, hc.geometry.attributes = s.attributes, null === hc.geometry.boundingBox && (hc.geometry.boundingBox = new qr), null === hc.geometry.boundingSphere && (hc.geometry.boundingSphere = new ti);
                        for (let s = 0; s < a; s++) {
                            if (!n[s] || !r[s]) continue;
                            const a = i[s];
                            hc.geometry.setDrawRange(a.start, a.count), this.getMatrixAt(s, hc.matrixWorld).premultiply(o), this.getBoundingBoxAt(s, hc.geometry.boundingBox), this.getBoundingSphereAt(s, hc.geometry.boundingSphere), hc.raycast(t, dc);
                            for (let t = 0, n = dc.length; t < n; t++) {
                                const n = dc[t];
                                n.object = this, n.batchId = s, e.push(n)
                            }
                            dc.length = 0
                        }
                        hc.material = null, hc.geometry.index = null, hc.geometry.attributes = {}, hc.geometry.setDrawRange(0, 1 / 0)
                    }
                    copy(t) {
                        return super.copy(t), this.geometry = t.geometry.clone(), this.perObjectFrustumCulled = t.perObjectFrustumCulled, this.sortObjects = t.sortObjects, this.boundingBox = null !== t.boundingBox ? t.boundingBox.clone() : null, this.boundingSphere = null !== t.boundingSphere ? t.boundingSphere.clone() : null, this._drawRanges = t._drawRanges.map((t => ({
                            ...t
                        }))), this._reservedRanges = t._reservedRanges.map((t => ({
                            ...t
                        }))), this._visibility = t._visibility.slice(), this._active = t._active.slice(), this._bounds = t._bounds.map((t => ({
                            boxInitialized: t.boxInitialized,
                            box: t.box.clone(),
                            sphereInitialized: t.sphereInitialized,
                            sphere: t.sphere.clone()
                        }))), this._maxGeometryCount = t._maxGeometryCount, this._maxVertexCount = t._maxVertexCount, this._maxIndexCount = t._maxIndexCount, this._geometryInitialized = t._geometryInitialized, this._geometryCount = t._geometryCount, this._multiDrawCounts = t._multiDrawCounts.slice(), this._multiDrawStarts = t._multiDrawStarts.slice(), this._matricesTexture = t._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this
                    }
                    dispose() {
                        return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this
                    }
                    onBeforeRender(t, e, n, r, i) {
                        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
                        const a = r.getIndex(),
                            o = null === a ? 1 : a.array.BYTES_PER_ELEMENT,
                            s = this._active,
                            l = this._visibility,
                            A = this._multiDrawStarts,
                            c = this._multiDrawCounts,
                            u = this._drawRanges,
                            h = this.perObjectFrustumCulled;
                        h && (oc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), sc.setFromProjectionMatrix(oc, t.coordinateSystem));
                        let d = 0;
                        if (this.sortObjects) {
                            ic.copy(this.matrixWorld).invert(), cc.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ic);
                            for (let t = 0, e = l.length; t < e; t++)
                                if (l[t] && s[t]) {
                                    this.getMatrixAt(t, rc), this.getBoundingSphereAt(t, Ac).applyMatrix4(rc);
                                    let e = !1;
                                    if (h && (e = !sc.intersectsSphere(Ac)), !e) {
                                        const e = cc.distanceTo(Ac.center);
                                        uc.push(u[t], e)
                                    }
                                } const t = uc.list,
                                e = this.customSort;
                            null === e ? t.sort(i.transparent ? tc : $A) : e.call(this, t, n);
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                A[d] = n.start * o, c[d] = n.count, d++
                            }
                            uc.reset()
                        } else
                            for (let t = 0, e = l.length; t < e; t++)
                                if (l[t] && s[t]) {
                                    let e = !1;
                                    if (h && (this.getMatrixAt(t, rc), this.getBoundingSphereAt(t, Ac).applyMatrix4(rc), e = !sc.intersectsSphere(Ac)), !e) {
                                        const e = u[t];
                                        A[d] = e.start * o, c[d] = e.count, d++
                                    }
                                } this._multiDrawCount = d, this._visibilityChanged = !1
                    }
                    onBeforeShadow(t, e, n, r, i, a) {
                        this.onBeforeRender(t, null, r, i, a)
                    }
                }
                class mc extends ea {
                    constructor(t) {
                        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Ki(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
                    }
                }
                const gc = new Ir,
                    vc = new Ir,
                    _c = new Ai,
                    yc = new li,
                    xc = new ti;
                class bc extends qi {
                    constructor(t = new Ta, e = new mc) {
                        super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [0];
                            for (let t = 1, r = e.count; t < r; t++) gc.fromBufferAttribute(e, t - 1), vc.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += gc.distanceTo(vc);
                            t.setAttribute("lineDistance", new _a(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            r = this.matrixWorld,
                            i = t.params.Line.threshold,
                            a = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), xc.copy(n.boundingSphere), xc.applyMatrix4(r), xc.radius += i, !1 === t.ray.intersectsSphere(xc)) return;
                        _c.copy(r).invert(), yc.copy(t.ray).applyMatrix4(_c);
                        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            s = o * o,
                            l = new Ir,
                            A = new Ir,
                            c = new Ir,
                            u = new Ir,
                            h = this.isLineSegments ? 2 : 1,
                            d = n.index,
                            f = n.attributes.position;
                        if (null !== d)
                            for (let n = Math.max(0, a.start), r = Math.min(d.count, a.start + a.count) - 1; n < r; n += h) {
                                const r = d.getX(n),
                                    i = d.getX(n + 1);
                                if (l.fromBufferAttribute(f, r), A.fromBufferAttribute(f, i), yc.distanceSqToSegment(l, A, u, c) > s) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const a = t.ray.origin.distanceTo(u);
                                a < t.near || a > t.far || e.push({
                                    distance: a,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            } else
                                for (let n = Math.max(0, a.start), r = Math.min(f.count, a.start + a.count) - 1; n < r; n += h) {
                                    if (l.fromBufferAttribute(f, n), A.fromBufferAttribute(f, n + 1), yc.distanceSqToSegment(l, A, u, c) > s) continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const r = t.ray.origin.distanceTo(u);
                                    r < t.near || r > t.far || e.push({
                                        distance: r,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                }
                            }
                        }
                    }
                }
                const Mc = new Ir,
                    wc = new Ir;
                class Sc extends bc {
                    constructor(t, e) {
                        super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [];
                            for (let t = 0, r = e.count; t < r; t += 2) Mc.fromBufferAttribute(e, t), wc.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Mc.distanceTo(wc);
                            t.setAttribute("lineDistance", new _a(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                }
                class Ec extends bc {
                    constructor(t, e) {
                        super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
                    }
                }
                class Tc extends ea {
                    constructor(t) {
                        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Ki(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
                    }
                }
                const Cc = new Ai,
                    Rc = new li,
                    Pc = new ti,
                    Lc = new Ir;
                class Dc extends qi {
                    constructor(t = new Ta, e = new Tc) {
                        super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            r = this.matrixWorld,
                            i = t.params.Points.threshold,
                            a = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), Pc.copy(n.boundingSphere), Pc.applyMatrix4(r), Pc.radius += i, !1 === t.ray.intersectsSphere(Pc)) return;
                        Cc.copy(r).invert(), Rc.copy(t.ray).applyMatrix4(Cc);
                        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            s = o * o,
                            l = n.index,
                            A = n.attributes.position;
                        if (null !== l)
                            for (let n = Math.max(0, a.start), i = Math.min(l.count, a.start + a.count); n < i; n++) {
                                const i = l.getX(n);
                                Lc.fromBufferAttribute(A, i), Ic(Lc, i, s, r, t, e, this)
                            } else
                                for (let n = Math.max(0, a.start), i = Math.min(A.count, a.start + a.count); n < i; n++) Lc.fromBufferAttribute(A, n), Ic(Lc, n, s, r, t, e, this)
                    }
                    updateMorphTargets() {
                        const t = this.geometry.morphAttributes,
                            e = Object.keys(t);
                        if (e.length > 0) {
                            const n = t[e[0]];
                            if (void 0 !== n) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, e = n.length; t < e; t++) {
                                    const e = n[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                }
                            }
                        }
                    }
                }

                function Ic(t, e, n, r, i, a, o) {
                    const s = Rc.distanceSqToPoint(t);
                    if (s < n) {
                        const n = new Ir;
                        Rc.closestPointToPoint(t, n), n.applyMatrix4(r);
                        const l = i.ray.origin.distanceTo(n);
                        if (l < i.near || l > i.far) return;
                        a.push({
                            distance: l,
                            distanceToRay: Math.sqrt(s),
                            point: n,
                            index: e,
                            face: null,
                            object: o
                        })
                    }
                }
                class Oc extends wr {
                    constructor(t, e, n, r, i, a, o, s, l) {
                        super(t, e, n, r, i, a, o, s, l), this.isVideoTexture = !0, this.minFilter = void 0 !== a ? a : wt, this.magFilter = void 0 !== i ? i : wt, this.generateMipmaps = !1;
                        const A = this;
                        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                            A.needsUpdate = !0, t.requestVideoFrameCallback(e)
                        }))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const t = this.image;
                        !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                }
                class Bc extends wr {
                    constructor(t, e) {
                        super({
                            width: t,
                            height: e
                        }), this.isFramebufferTexture = !0, this.magFilter = _t, this.minFilter = _t, this.generateMipmaps = !1, this.needsUpdate = !0
                    }
                }
                class qc extends wr {
                    constructor(t, e, n, r, i, a, o, s, l, A, c, u) {
                        super(null, a, o, s, l, A, r, i, c, u), this.isCompressedTexture = !0, this.image = {
                            width: e,
                            height: n
                        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                    }
                }
                class Uc extends qc {
                    constructor(t, e, n, r, i, a) {
                        super(t, e, n, i, a), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = gt
                    }
                }
                class Nc extends qc {
                    constructor(t, e, n) {
                        super(void 0, t[0].width, t[0].height, e, n, ut), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = t
                    }
                }
                class kc extends wr {
                    constructor(t, e, n, r, i, a, o, s, l) {
                        super(t, e, n, r, i, a, o, s, l), this.isCanvasTexture = !0, this.needsUpdate = !0
                    }
                }
                class Fc {
                    constructor() {
                        this.type = "Curve", this.arcLengthDivisions = 200
                    }
                    getPoint() {
                        return console.warn("THREE.Curve: .getPoint() not implemented."), null
                    }
                    getPointAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getPoint(n, e)
                    }
                    getPoints(t = 5) {
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                        return e
                    }
                    getSpacedPoints(t = 5) {
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                        return e
                    }
                    getLength() {
                        const t = this.getLengths();
                        return t[t.length - 1]
                    }
                    getLengths(t = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, r = this.getPoint(0),
                            i = 0;
                        e.push(0);
                        for (let a = 1; a <= t; a++) n = this.getPoint(a / t), i += n.distanceTo(r), e.push(i), r = n;
                        return this.cacheArcLengths = e, e
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.getLengths()
                    }
                    getUtoTmapping(t, e) {
                        const n = this.getLengths();
                        let r = 0;
                        const i = n.length;
                        let a;
                        a = e || t * n[i - 1];
                        let o, s = 0,
                            l = i - 1;
                        for (; s <= l;)
                            if (r = Math.floor(s + (l - s) / 2), o = n[r] - a, o < 0) s = r + 1;
                            else {
                                if (!(o > 0)) {
                                    l = r;
                                    break
                                }
                                l = r - 1
                            } if (r = l, n[r] === a) return r / (i - 1);
                        const A = n[r];
                        return (r + (a - A) / (n[r + 1] - A)) / (i - 1)
                    }
                    getTangent(t, e) {
                        const n = 1e-4;
                        let r = t - n,
                            i = t + n;
                        r < 0 && (r = 0), i > 1 && (i = 1);
                        const a = this.getPoint(r),
                            o = this.getPoint(i),
                            s = e || (a.isVector2 ? new er : new Ir);
                        return s.copy(o).sub(a).normalize(), s
                    }
                    getTangentAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getTangent(n, e)
                    }
                    computeFrenetFrames(t, e) {
                        const n = new Ir,
                            r = [],
                            i = [],
                            a = [],
                            o = new Ir,
                            s = new Ai;
                        for (let e = 0; e <= t; e++) {
                            const n = e / t;
                            r[e] = this.getTangentAt(n, new Ir)
                        }
                        i[0] = new Ir, a[0] = new Ir;
                        let l = Number.MAX_VALUE;
                        const A = Math.abs(r[0].x),
                            c = Math.abs(r[0].y),
                            u = Math.abs(r[0].z);
                        A <= l && (l = A, n.set(1, 0, 0)), c <= l && (l = c, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]);
                        for (let e = 1; e <= t; e++) {
                            if (i[e] = i[e - 1].clone(), a[e] = a[e - 1].clone(), o.crossVectors(r[e - 1], r[e]), o.length() > Number.EPSILON) {
                                o.normalize();
                                const t = Math.acos(Xn(r[e - 1].dot(r[e]), -1, 1));
                                i[e].applyMatrix4(s.makeRotationAxis(o, t))
                            }
                            a[e].crossVectors(r[e], i[e])
                        }
                        if (!0 === e) {
                            let e = Math.acos(Xn(i[0].dot(i[t]), -1, 1));
                            e /= t, r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e);
                            for (let n = 1; n <= t; n++) i[n].applyMatrix4(s.makeRotationAxis(r[n], e * n)), a[n].crossVectors(r[n], i[n])
                        }
                        return {
                            tangents: r,
                            normals: i,
                            binormals: a
                        }
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions, this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.6,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                    }
                    fromJSON(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions, this
                    }
                }
                class zc extends Fc {
                    constructor(t = 0, e = 0, n = 1, r = 1, i = 0, a = 2 * Math.PI, o = !1, s = 0) {
                        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s
                    }
                    getPoint(t, e = new er) {
                        const n = e,
                            r = 2 * Math.PI;
                        let i = this.aEndAngle - this.aStartAngle;
                        const a = Math.abs(i) < Number.EPSILON;
                        for (; i < 0;) i += r;
                        for (; i > r;) i -= r;
                        i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
                        const o = this.aStartAngle + t * i;
                        let s = this.aX + this.xRadius * Math.cos(o),
                            l = this.aY + this.yRadius * Math.sin(o);
                        if (0 !== this.aRotation) {
                            const t = Math.cos(this.aRotation),
                                e = Math.sin(this.aRotation),
                                n = s - this.aX,
                                r = l - this.aY;
                            s = n * t - r * e + this.aX, l = n * e + r * t + this.aY
                        }
                        return n.set(s, l)
                    }
                    copy(t) {
                        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                    }
                }
                class Gc extends zc {
                    constructor(t, e, n, r, i, a) {
                        super(t, e, n, n, r, i, a), this.isArcCurve = !0, this.type = "ArcCurve"
                    }
                }

                function jc() {
                    let t = 0,
                        e = 0,
                        n = 0,
                        r = 0;

                    function i(i, a, o, s) {
                        t = i, e = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s
                    }
                    return {
                        initCatmullRom: function(t, e, n, r, a) {
                            i(e, n, a * (n - t), a * (r - e))
                        },
                        initNonuniformCatmullRom: function(t, e, n, r, a, o, s) {
                            let l = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
                                A = (n - e) / o - (r - e) / (o + s) + (r - n) / s;
                            l *= o, A *= o, i(e, n, l, A)
                        },
                        calc: function(i) {
                            const a = i * i;
                            return t + e * i + n * a + r * (a * i)
                        }
                    }
                }
                const Vc = new Ir,
                    Hc = new jc,
                    Wc = new jc,
                    Xc = new jc;
                class Yc extends Fc {
                    constructor(t = [], e = !1, n = "centripetal", r = .5) {
                        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
                    }
                    getPoint(t, e = new Ir) {
                        const n = e,
                            r = this.points,
                            i = r.length,
                            a = (i - (this.closed ? 0 : 1)) * t;
                        let o, s, l = Math.floor(a),
                            A = a - l;
                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === A && l === i - 1 && (l = i - 2, A = 1), this.closed || l > 0 ? o = r[(l - 1) % i] : (Vc.subVectors(r[0], r[1]).add(r[0]), o = Vc);
                        const c = r[l % i],
                            u = r[(l + 1) % i];
                        if (this.closed || l + 2 < i ? s = r[(l + 2) % i] : (Vc.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), s = Vc), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const t = "chordal" === this.curveType ? .5 : .25;
                            let e = Math.pow(o.distanceToSquared(c), t),
                                n = Math.pow(c.distanceToSquared(u), t),
                                r = Math.pow(u.distanceToSquared(s), t);
                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), Hc.initNonuniformCatmullRom(o.x, c.x, u.x, s.x, e, n, r), Wc.initNonuniformCatmullRom(o.y, c.y, u.y, s.y, e, n, r), Xc.initNonuniformCatmullRom(o.z, c.z, u.z, s.z, e, n, r)
                        } else "catmullrom" === this.curveType && (Hc.initCatmullRom(o.x, c.x, u.x, s.x, this.tension), Wc.initCatmullRom(o.y, c.y, u.y, s.y, this.tension), Xc.initCatmullRom(o.z, c.z, u.z, s.z, this.tension));
                        return n.set(Hc.calc(A), Wc.calc(A), Xc.calc(A)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new Ir).fromArray(n))
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                }

                function Qc(t, e, n, r, i) {
                    const a = .5 * (r - e),
                        o = .5 * (i - n),
                        s = t * t;
                    return (2 * n - 2 * r + a + o) * (t * s) + (-3 * n + 3 * r - 2 * a - o) * s + a * t + n
                }

                function Zc(t, e, n, r) {
                    return function(t, e) {
                        const n = 1 - t;
                        return n * n * e
                    }(t, e) + function(t, e) {
                        return 2 * (1 - t) * t * e
                    }(t, n) + function(t, e) {
                        return t * t * e
                    }(t, r)
                }

                function Jc(t, e, n, r, i) {
                    return function(t, e) {
                        const n = 1 - t;
                        return n * n * n * e
                    }(t, e) + function(t, e) {
                        const n = 1 - t;
                        return 3 * n * n * t * e
                    }(t, n) + function(t, e) {
                        return 3 * (1 - t) * t * t * e
                    }(t, r) + function(t, e) {
                        return t * t * t * e
                    }(t, i)
                }
                class Kc extends Fc {
                    constructor(t = new er, e = new er, n = new er, r = new er) {
                        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
                    }
                    getPoint(t, e = new er) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            a = this.v2,
                            o = this.v3;
                        return n.set(Jc(t, r.x, i.x, a.x, o.x), Jc(t, r.y, i.y, a.y, o.y)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                    }
                }
                class $c extends Fc {
                    constructor(t = new Ir, e = new Ir, n = new Ir, r = new Ir) {
                        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
                    }
                    getPoint(t, e = new Ir) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            a = this.v2,
                            o = this.v3;
                        return n.set(Jc(t, r.x, i.x, a.x, o.x), Jc(t, r.y, i.y, a.y, o.y), Jc(t, r.z, i.z, a.z, o.z)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                    }
                }
                class tu extends Fc {
                    constructor(t = new er, e = new er) {
                        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
                    }
                    getPoint(t, e = new er) {
                        const n = e;
                        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    getTangent(t, e = new er) {
                        return e.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(t, e) {
                        return this.getTangent(t, e)
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                class eu extends Fc {
                    constructor(t = new Ir, e = new Ir) {
                        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
                    }
                    getPoint(t, e = new Ir) {
                        const n = e;
                        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    getTangent(t, e = new Ir) {
                        return e.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(t, e) {
                        return this.getTangent(t, e)
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                class nu extends Fc {
                    constructor(t = new er, e = new er, n = new er) {
                        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                    }
                    getPoint(t, e = new er) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            a = this.v2;
                        return n.set(Zc(t, r.x, i.x, a.x), Zc(t, r.y, i.y, a.y)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                class ru extends Fc {
                    constructor(t = new Ir, e = new Ir, n = new Ir) {
                        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                    }
                    getPoint(t, e = new Ir) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            a = this.v2;
                        return n.set(Zc(t, r.x, i.x, a.x), Zc(t, r.y, i.y, a.y), Zc(t, r.z, i.z, a.z)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                class iu extends Fc {
                    constructor(t = []) {
                        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
                    }
                    getPoint(t, e = new er) {
                        const n = e,
                            r = this.points,
                            i = (r.length - 1) * t,
                            a = Math.floor(i),
                            o = i - a,
                            s = r[0 === a ? a : a - 1],
                            l = r[a],
                            A = r[a > r.length - 2 ? r.length - 1 : a + 1],
                            c = r[a > r.length - 3 ? r.length - 1 : a + 2];
                        return n.set(Qc(o, s.x, l.x, A.x, c.x), Qc(o, s.y, l.y, A.y, c.y)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new er).fromArray(n))
                        }
                        return this
                    }
                }
                var au = Object.freeze({
                    __proto__: null,
                    ArcCurve: Gc,
                    CatmullRomCurve3: Yc,
                    CubicBezierCurve: Kc,
                    CubicBezierCurve3: $c,
                    EllipseCurve: zc,
                    LineCurve: tu,
                    LineCurve3: eu,
                    QuadraticBezierCurve: nu,
                    QuadraticBezierCurve3: ru,
                    SplineCurve: iu
                });
                class ou extends Fc {
                    constructor() {
                        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                    }
                    add(t) {
                        this.curves.push(t)
                    }
                    closePath() {
                        const t = this.curves[0].getPoint(0),
                            e = this.curves[this.curves.length - 1].getPoint(1);
                        if (!t.equals(e)) {
                            const n = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
                            this.curves.push(new au[n](e, t))
                        }
                        return this
                    }
                    getPoint(t, e) {
                        const n = t * this.getLength(),
                            r = this.getCurveLengths();
                        let i = 0;
                        for (; i < r.length;) {
                            if (r[i] >= n) {
                                const t = r[i] - n,
                                    a = this.curves[i],
                                    o = a.getLength(),
                                    s = 0 === o ? 0 : 1 - t / o;
                                return a.getPointAt(s, e)
                            }
                            i++
                        }
                        return null
                    }
                    getLength() {
                        const t = this.getCurveLengths();
                        return t[t.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                        const t = [];
                        let e = 0;
                        for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
                        return this.cacheLengths = t, t
                    }
                    getSpacedPoints(t = 40) {
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                        return this.autoClose && e.push(e[0]), e
                    }
                    getPoints(t = 12) {
                        const e = [];
                        let n;
                        for (let r = 0, i = this.curves; r < i.length; r++) {
                            const a = i[r],
                                o = a.isEllipseCurve ? 2 * t : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? t * a.points.length : t,
                                s = a.getPoints(o);
                            for (let t = 0; t < s.length; t++) {
                                const r = s[t];
                                n && n.equals(r) || (e.push(r), n = r)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                    }
                    copy(t) {
                        super.copy(t), this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = t.autoClose, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose, t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const n = this.curves[e];
                            t.curves.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push((new au[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }
                class su extends ou {
                    constructor(t) {
                        super(), this.type = "Path", this.currentPoint = new er, t && this.setFromPoints(t)
                    }
                    setFromPoints(t) {
                        this.moveTo(t[0].x, t[0].y);
                        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                        return this
                    }
                    moveTo(t, e) {
                        return this.currentPoint.set(t, e), this
                    }
                    lineTo(t, e) {
                        const n = new tu(this.currentPoint.clone(), new er(t, e));
                        return this.curves.push(n), this.currentPoint.set(t, e), this
                    }
                    quadraticCurveTo(t, e, n, r) {
                        const i = new nu(this.currentPoint.clone(), new er(t, e), new er(n, r));
                        return this.curves.push(i), this.currentPoint.set(n, r), this
                    }
                    bezierCurveTo(t, e, n, r, i, a) {
                        const o = new Kc(this.currentPoint.clone(), new er(t, e), new er(n, r), new er(i, a));
                        return this.curves.push(o), this.currentPoint.set(i, a), this
                    }
                    splineThru(t) {
                        const e = [this.currentPoint.clone()].concat(t),
                            n = new iu(e);
                        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                    }
                    arc(t, e, n, r, i, a) {
                        const o = this.currentPoint.x,
                            s = this.currentPoint.y;
                        return this.absarc(t + o, e + s, n, r, i, a), this
                    }
                    absarc(t, e, n, r, i, a) {
                        return this.absellipse(t, e, n, n, r, i, a), this
                    }
                    ellipse(t, e, n, r, i, a, o, s) {
                        const l = this.currentPoint.x,
                            A = this.currentPoint.y;
                        return this.absellipse(t + l, e + A, n, r, i, a, o, s), this
                    }
                    absellipse(t, e, n, r, i, a, o, s) {
                        const l = new zc(t, e, n, r, i, a, o, s);
                        if (this.curves.length > 0) {
                            const t = l.getPoint(0);
                            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                        }
                        this.curves.push(l);
                        const A = l.getPoint(1);
                        return this.currentPoint.copy(A), this
                    }
                    copy(t) {
                        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.currentPoint = this.currentPoint.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                    }
                }
                class lu extends Ta {
                    constructor(t = [new er(0, -.5), new er(.5, 0), new er(0, .5)], e = 12, n = 0, r = 2 * Math.PI) {
                        super(), this.type = "LatheGeometry", this.parameters = {
                            points: t,
                            segments: e,
                            phiStart: n,
                            phiLength: r
                        }, e = Math.floor(e), r = Xn(r, 0, 2 * Math.PI);
                        const i = [],
                            a = [],
                            o = [],
                            s = [],
                            l = [],
                            A = 1 / e,
                            c = new Ir,
                            u = new er,
                            h = new Ir,
                            d = new Ir,
                            f = new Ir;
                        let p = 0,
                            m = 0;
                        for (let e = 0; e <= t.length - 1; e++) switch (e) {
                            case 0:
                                p = t[e + 1].x - t[e].x, m = t[e + 1].y - t[e].y, h.x = 1 * m, h.y = -p, h.z = 0 * m, f.copy(h), h.normalize(), s.push(h.x, h.y, h.z);
                                break;
                            case t.length - 1:
                                s.push(f.x, f.y, f.z);
                                break;
                            default:
                                p = t[e + 1].x - t[e].x, m = t[e + 1].y - t[e].y, h.x = 1 * m, h.y = -p, h.z = 0 * m, d.copy(h), h.x += f.x, h.y += f.y, h.z += f.z, h.normalize(), s.push(h.x, h.y, h.z), f.copy(d)
                        }
                        for (let i = 0; i <= e; i++) {
                            const h = n + i * A * r,
                                d = Math.sin(h),
                                f = Math.cos(h);
                            for (let n = 0; n <= t.length - 1; n++) {
                                c.x = t[n].x * d, c.y = t[n].y, c.z = t[n].x * f, a.push(c.x, c.y, c.z), u.x = i / e, u.y = n / (t.length - 1), o.push(u.x, u.y);
                                const r = s[3 * n + 0] * d,
                                    A = s[3 * n + 1],
                                    h = s[3 * n + 0] * f;
                                l.push(r, A, h)
                            }
                        }
                        for (let n = 0; n < e; n++)
                            for (let e = 0; e < t.length - 1; e++) {
                                const r = e + n * t.length,
                                    a = r,
                                    o = r + t.length,
                                    s = r + t.length + 1,
                                    l = r + 1;
                                i.push(a, o, l), i.push(s, l, o)
                            }
                        this.setIndex(i), this.setAttribute("position", new _a(a, 3)), this.setAttribute("uv", new _a(o, 2)), this.setAttribute("normal", new _a(l, 3))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new lu(t.points, t.segments, t.phiStart, t.phiLength)
                    }
                }
                class Au extends lu {
                    constructor(t = 1, e = 1, n = 4, r = 8) {
                        const i = new su;
                        i.absarc(0, -e / 2, t, 1.5 * Math.PI, 0), i.absarc(0, e / 2, t, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
                            radius: t,
                            length: e,
                            capSegments: n,
                            radialSegments: r
                        }
                    }
                    static fromJSON(t) {
                        return new Au(t.radius, t.length, t.capSegments, t.radialSegments)
                    }
                }
                class cu extends Ta {
                    constructor(t = 1, e = 32, n = 0, r = 2 * Math.PI) {
                        super(), this.type = "CircleGeometry", this.parameters = {
                            radius: t,
                            segments: e,
                            thetaStart: n,
                            thetaLength: r
                        }, e = Math.max(3, e);
                        const i = [],
                            a = [],
                            o = [],
                            s = [],
                            l = new Ir,
                            A = new er;
                        a.push(0, 0, 0), o.push(0, 0, 1), s.push(.5, .5);
                        for (let i = 0, c = 3; i <= e; i++, c += 3) {
                            const u = n + i / e * r;
                            l.x = t * Math.cos(u), l.y = t * Math.sin(u), a.push(l.x, l.y, l.z), o.push(0, 0, 1), A.x = (a[c] / t + 1) / 2, A.y = (a[c + 1] / t + 1) / 2, s.push(A.x, A.y)
                        }
                        for (let t = 1; t <= e; t++) i.push(t, t + 1, 0);
                        this.setIndex(i), this.setAttribute("position", new _a(a, 3)), this.setAttribute("normal", new _a(o, 3)), this.setAttribute("uv", new _a(s, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new cu(t.radius, t.segments, t.thetaStart, t.thetaLength)
                    }
                }
                class uu extends Ta {
                    constructor(t = 1, e = 1, n = 1, r = 32, i = 1, a = !1, o = 0, s = 2 * Math.PI) {
                        super(), this.type = "CylinderGeometry", this.parameters = {
                            radiusTop: t,
                            radiusBottom: e,
                            height: n,
                            radialSegments: r,
                            heightSegments: i,
                            openEnded: a,
                            thetaStart: o,
                            thetaLength: s
                        };
                        const l = this;
                        r = Math.floor(r), i = Math.floor(i);
                        const A = [],
                            c = [],
                            u = [],
                            h = [];
                        let d = 0;
                        const f = [],
                            p = n / 2;
                        let m = 0;

                        function g(n) {
                            const i = d,
                                a = new er,
                                f = new Ir;
                            let g = 0;
                            const v = !0 === n ? t : e,
                                _ = !0 === n ? 1 : -1;
                            for (let t = 1; t <= r; t++) c.push(0, p * _, 0), u.push(0, _, 0), h.push(.5, .5), d++;
                            const y = d;
                            for (let t = 0; t <= r; t++) {
                                const e = t / r * s + o,
                                    n = Math.cos(e),
                                    i = Math.sin(e);
                                f.x = v * i, f.y = p * _, f.z = v * n, c.push(f.x, f.y, f.z), u.push(0, _, 0), a.x = .5 * n + .5, a.y = .5 * i * _ + .5, h.push(a.x, a.y), d++
                            }
                            for (let t = 0; t < r; t++) {
                                const e = i + t,
                                    r = y + t;
                                !0 === n ? A.push(r, r + 1, e) : A.push(r + 1, r, e), g += 3
                            }
                            l.addGroup(m, g, !0 === n ? 1 : 2), m += g
                        }! function() {
                            const a = new Ir,
                                g = new Ir;
                            let v = 0;
                            const _ = (e - t) / n;
                            for (let l = 0; l <= i; l++) {
                                const A = [],
                                    m = l / i,
                                    v = m * (e - t) + t;
                                for (let t = 0; t <= r; t++) {
                                    const e = t / r,
                                        i = e * s + o,
                                        l = Math.sin(i),
                                        f = Math.cos(i);
                                    g.x = v * l, g.y = -m * n + p, g.z = v * f, c.push(g.x, g.y, g.z), a.set(l, _, f).normalize(), u.push(a.x, a.y, a.z), h.push(e, 1 - m), A.push(d++)
                                }
                                f.push(A)
                            }
                            for (let t = 0; t < r; t++)
                                for (let e = 0; e < i; e++) {
                                    const n = f[e][t],
                                        r = f[e + 1][t],
                                        i = f[e + 1][t + 1],
                                        a = f[e][t + 1];
                                    A.push(n, r, a), A.push(r, i, a), v += 6
                                }
                            l.addGroup(m, v, 0), m += v
                        }(), !1 === a && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(A), this.setAttribute("position", new _a(c, 3)), this.setAttribute("normal", new _a(u, 3)), this.setAttribute("uv", new _a(h, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new uu(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                    }
                }
                class hu extends uu {
                    constructor(t = 1, e = 1, n = 32, r = 1, i = !1, a = 0, o = 2 * Math.PI) {
                        super(0, t, e, n, r, i, a, o), this.type = "ConeGeometry", this.parameters = {
                            radius: t,
                            height: e,
                            radialSegments: n,
                            heightSegments: r,
                            openEnded: i,
                            thetaStart: a,
                            thetaLength: o
                        }
                    }
                    static fromJSON(t) {
                        return new hu(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                    }
                }
                class du extends Ta {
                    constructor(t = [], e = [], n = 1, r = 0) {
                        super(), this.type = "PolyhedronGeometry", this.parameters = {
                            vertices: t,
                            indices: e,
                            radius: n,
                            detail: r
                        };
                        const i = [],
                            a = [];

                        function o(t, e, n, r) {
                            const i = r + 1,
                                a = [];
                            for (let r = 0; r <= i; r++) {
                                a[r] = [];
                                const o = t.clone().lerp(n, r / i),
                                    s = e.clone().lerp(n, r / i),
                                    l = i - r;
                                for (let t = 0; t <= l; t++) a[r][t] = 0 === t && r === i ? o : o.clone().lerp(s, t / l)
                            }
                            for (let t = 0; t < i; t++)
                                for (let e = 0; e < 2 * (i - t) - 1; e++) {
                                    const n = Math.floor(e / 2);
                                    e % 2 == 0 ? (s(a[t][n + 1]), s(a[t + 1][n]), s(a[t][n])) : (s(a[t][n + 1]), s(a[t + 1][n + 1]), s(a[t + 1][n]))
                                }
                        }

                        function s(t) {
                            i.push(t.x, t.y, t.z)
                        }

                        function l(e, n) {
                            const r = 3 * e;
                            n.x = t[r + 0], n.y = t[r + 1], n.z = t[r + 2]
                        }

                        function A(t, e, n, r) {
                            r < 0 && 1 === t.x && (a[e] = t.x - 1), 0 === n.x && 0 === n.z && (a[e] = r / 2 / Math.PI + .5)
                        }

                        function c(t) {
                            return Math.atan2(t.z, -t.x)
                        }! function(t) {
                            const n = new Ir,
                                r = new Ir,
                                i = new Ir;
                            for (let a = 0; a < e.length; a += 3) l(e[a + 0], n), l(e[a + 1], r), l(e[a + 2], i), o(n, r, i, t)
                        }(r),
                        function(t) {
                            const e = new Ir;
                            for (let n = 0; n < i.length; n += 3) e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2], e.normalize().multiplyScalar(t), i[n + 0] = e.x, i[n + 1] = e.y, i[n + 2] = e.z
                        }(n),
                        function() {
                            const t = new Ir;
                            for (let n = 0; n < i.length; n += 3) {
                                t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2];
                                const r = c(t) / 2 / Math.PI + .5,
                                    o = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                a.push(r, 1 - o)
                            }
                            var e;
                            (function() {
                                const t = new Ir,
                                    e = new Ir,
                                    n = new Ir,
                                    r = new Ir,
                                    o = new er,
                                    s = new er,
                                    l = new er;
                                for (let u = 0, h = 0; u < i.length; u += 9, h += 6) {
                                    t.set(i[u + 0], i[u + 1], i[u + 2]), e.set(i[u + 3], i[u + 4], i[u + 5]), n.set(i[u + 6], i[u + 7], i[u + 8]), o.set(a[h + 0], a[h + 1]), s.set(a[h + 2], a[h + 3]), l.set(a[h + 4], a[h + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                                    const d = c(r);
                                    A(o, h + 0, t, d), A(s, h + 2, e, d), A(l, h + 4, n, d)
                                }
                            })(),
                            function() {
                                for (let t = 0; t < a.length; t += 6) {
                                    const e = a[t + 0],
                                        n = a[t + 2],
                                        r = a[t + 4],
                                        i = Math.max(e, n, r),
                                        o = Math.min(e, n, r);
                                    i > .9 && o < .1 && (e < .2 && (a[t + 0] += 1), n < .2 && (a[t + 2] += 1), r < .2 && (a[t + 4] += 1))
                                }
                            }()
                        }(), this.setAttribute("position", new _a(i, 3)), this.setAttribute("normal", new _a(i.slice(), 3)), this.setAttribute("uv", new _a(a, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new du(t.vertices, t.indices, t.radius, t.details)
                    }
                }
                class fu extends du {
                    constructor(t = 1, e = 0) {
                        const n = (1 + Math.sqrt(5)) / 2,
                            r = 1 / n;
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                    static fromJSON(t) {
                        return new fu(t.radius, t.detail)
                    }
                }
                const pu = new Ir,
                    mu = new Ir,
                    gu = new Ir,
                    vu = new Xi;
                class _u extends Ta {
                    constructor(t = null, e = 1) {
                        if (super(), this.type = "EdgesGeometry", this.parameters = {
                                geometry: t,
                                thresholdAngle: e
                            }, null !== t) {
                            const n = 4,
                                r = Math.pow(10, n),
                                i = Math.cos(Vn * e),
                                a = t.getIndex(),
                                o = t.getAttribute("position"),
                                s = a ? a.count : o.count,
                                l = [0, 0, 0],
                                A = ["a", "b", "c"],
                                c = new Array(3),
                                u = {},
                                h = [];
                            for (let t = 0; t < s; t += 3) {
                                a ? (l[0] = a.getX(t), l[1] = a.getX(t + 1), l[2] = a.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2);
                                const {
                                    a: e,
                                    b: n,
                                    c: s
                                } = vu;
                                if (e.fromBufferAttribute(o, l[0]), n.fromBufferAttribute(o, l[1]), s.fromBufferAttribute(o, l[2]), vu.getNormal(gu), c[0] = `${Math.round(e.x*r)},${Math.round(e.y*r)},${Math.round(e.z*r)}`, c[1] = `${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`, c[2] = `${Math.round(s.x*r)},${Math.round(s.y*r)},${Math.round(s.z*r)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                                    for (let t = 0; t < 3; t++) {
                                        const e = (t + 1) % 3,
                                            n = c[t],
                                            r = c[e],
                                            a = vu[A[t]],
                                            o = vu[A[e]],
                                            s = `${n}_${r}`,
                                            d = `${r}_${n}`;
                                        d in u && u[d] ? (gu.dot(u[d].normal) <= i && (h.push(a.x, a.y, a.z), h.push(o.x, o.y, o.z)), u[d] = null) : s in u || (u[s] = {
                                            index0: l[t],
                                            index1: l[e],
                                            normal: gu.clone()
                                        })
                                    }
                            }
                            for (const t in u)
                                if (u[t]) {
                                    const {
                                        index0: e,
                                        index1: n
                                    } = u[t];
                                    pu.fromBufferAttribute(o, e), mu.fromBufferAttribute(o, n), h.push(pu.x, pu.y, pu.z), h.push(mu.x, mu.y, mu.z)
                                } this.setAttribute("position", new _a(h, 3))
                        }
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                }
                class yu extends su {
                    constructor(t) {
                        super(t), this.uuid = Wn(), this.type = "Shape", this.holes = []
                    }
                    getPointsHoles(t) {
                        const e = [];
                        for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
                        return e
                    }
                    extractPoints(t) {
                        return {
                            shape: this.getPoints(t),
                            holes: this.getPointsHoles(t)
                        }
                    }
                    copy(t) {
                        super.copy(t), this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid, t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const n = this.holes[e];
                            t.holes.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push((new su).fromJSON(n))
                        }
                        return this
                    }
                }

                function xu(t, e, n, r, i) {
                    let a, o;
                    if (i === function(t, e, n, r) {
                            let i = 0;
                            for (let a = e, o = n - r; a < n; a += r) i += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
                            return i
                        }(t, e, n, r) > 0)
                        for (a = e; a < n; a += r) o = Gu(a, t[a], t[a + 1], o);
                    else
                        for (a = n - r; a >= e; a -= r) o = Gu(a, t[a], t[a + 1], o);
                    return o && qu(o, o.next) && (ju(o), o = o.next), o
                }

                function bu(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    let n, r = t;
                    do {
                        if (n = !1, r.steiner || !qu(r, r.next) && 0 !== Bu(r.prev, r, r.next)) r = r.next;
                        else {
                            if (ju(r), r = e = r.prev, r === r.next) break;
                            n = !0
                        }
                    } while (n || r !== e);
                    return e
                }

                function Mu(t, e, n, r, i, a, o) {
                    if (!t) return;
                    !o && a && function(t, e, n, r) {
                        let i = t;
                        do {
                            0 === i.z && (i.z = Lu(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                        } while (i !== t);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function(t) {
                                let e, n, r, i, a, o, s, l, A = 1;
                                do {
                                    for (n = t, t = null, a = null, o = 0; n;) {
                                        for (o++, r = n, s = 0, e = 0; e < A && (s++, r = r.nextZ, r); e++);
                                        for (l = A; s > 0 || l > 0 && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;
                                        n = r
                                    }
                                    a.nextZ = null, A *= 2
                                } while (o > 1)
                            }(i)
                    }(t, r, i, a);
                    let s, l, A = t;
                    for (; t.prev !== t.next;)
                        if (s = t.prev, l = t.next, a ? Su(t, r, i, a) : wu(t)) e.push(s.i / n | 0), e.push(t.i / n | 0), e.push(l.i / n | 0), ju(t), t = l.next, A = l.next;
                        else if ((t = l) === A) {
                        o ? 1 === o ? Mu(t = Eu(bu(t), e, n), e, n, r, i, a, 2) : 2 === o && Tu(t, e, n, r, i, a) : Mu(bu(t), e, n, r, i, a, 1);
                        break
                    }
                }

                function wu(t) {
                    const e = t.prev,
                        n = t,
                        r = t.next;
                    if (Bu(e, n, r) >= 0) return !1;
                    const i = e.x,
                        a = n.x,
                        o = r.x,
                        s = e.y,
                        l = n.y,
                        A = r.y,
                        c = i < a ? i < o ? i : o : a < o ? a : o,
                        u = s < l ? s < A ? s : A : l < A ? l : A,
                        h = i > a ? i > o ? i : o : a > o ? a : o,
                        d = s > l ? s > A ? s : A : l > A ? l : A;
                    let f = r.next;
                    for (; f !== e;) {
                        if (f.x >= c && f.x <= h && f.y >= u && f.y <= d && Iu(i, s, a, l, o, A, f.x, f.y) && Bu(f.prev, f, f.next) >= 0) return !1;
                        f = f.next
                    }
                    return !0
                }

                function Su(t, e, n, r) {
                    const i = t.prev,
                        a = t,
                        o = t.next;
                    if (Bu(i, a, o) >= 0) return !1;
                    const s = i.x,
                        l = a.x,
                        A = o.x,
                        c = i.y,
                        u = a.y,
                        h = o.y,
                        d = s < l ? s < A ? s : A : l < A ? l : A,
                        f = c < u ? c < h ? c : h : u < h ? u : h,
                        p = s > l ? s > A ? s : A : l > A ? l : A,
                        m = c > u ? c > h ? c : h : u > h ? u : h,
                        g = Lu(d, f, e, n, r),
                        v = Lu(p, m, e, n, r);
                    let _ = t.prevZ,
                        y = t.nextZ;
                    for (; _ && _.z >= g && y && y.z <= v;) {
                        if (_.x >= d && _.x <= p && _.y >= f && _.y <= m && _ !== i && _ !== o && Iu(s, c, l, u, A, h, _.x, _.y) && Bu(_.prev, _, _.next) >= 0) return !1;
                        if (_ = _.prevZ, y.x >= d && y.x <= p && y.y >= f && y.y <= m && y !== i && y !== o && Iu(s, c, l, u, A, h, y.x, y.y) && Bu(y.prev, y, y.next) >= 0) return !1;
                        y = y.nextZ
                    }
                    for (; _ && _.z >= g;) {
                        if (_.x >= d && _.x <= p && _.y >= f && _.y <= m && _ !== i && _ !== o && Iu(s, c, l, u, A, h, _.x, _.y) && Bu(_.prev, _, _.next) >= 0) return !1;
                        _ = _.prevZ
                    }
                    for (; y && y.z <= v;) {
                        if (y.x >= d && y.x <= p && y.y >= f && y.y <= m && y !== i && y !== o && Iu(s, c, l, u, A, h, y.x, y.y) && Bu(y.prev, y, y.next) >= 0) return !1;
                        y = y.nextZ
                    }
                    return !0
                }

                function Eu(t, e, n) {
                    let r = t;
                    do {
                        const i = r.prev,
                            a = r.next.next;
                        !qu(i, a) && Uu(i, r, r.next, a) && Fu(i, a) && Fu(a, i) && (e.push(i.i / n | 0), e.push(r.i / n | 0), e.push(a.i / n | 0), ju(r), ju(r.next), r = t = a), r = r.next
                    } while (r !== t);
                    return bu(r)
                }

                function Tu(t, e, n, r, i, a) {
                    let o = t;
                    do {
                        let t = o.next.next;
                        for (; t !== o.prev;) {
                            if (o.i !== t.i && Ou(o, t)) {
                                let s = zu(o, t);
                                return o = bu(o, o.next), s = bu(s, s.next), Mu(o, e, n, r, i, a, 0), void Mu(s, e, n, r, i, a, 0)
                            }
                            t = t.next
                        }
                        o = o.next
                    } while (o !== t)
                }

                function Cu(t, e) {
                    return t.x - e.x
                }

                function Ru(t, e) {
                    const n = function(t, e) {
                        let n, r = e,
                            i = -1 / 0;
                        const a = t.x,
                            o = t.y;
                        do {
                            if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                                const t = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                if (t <= a && t > i && (i = t, n = r.x < r.next.x ? r : r.next, t === a)) return n
                            }
                            r = r.next
                        } while (r !== e);
                        if (!n) return null;
                        const s = n,
                            l = n.x,
                            A = n.y;
                        let c, u = 1 / 0;
                        r = n;
                        do {
                            a >= r.x && r.x >= l && a !== r.x && Iu(o < A ? a : i, o, l, A, o < A ? i : a, o, r.x, r.y) && (c = Math.abs(o - r.y) / (a - r.x), Fu(r, t) && (c < u || c === u && (r.x > n.x || r.x === n.x && Pu(n, r))) && (n = r, u = c)), r = r.next
                        } while (r !== s);
                        return n
                    }(t, e);
                    if (!n) return e;
                    const r = zu(n, t);
                    return bu(r, r.next), bu(n, n.next)
                }

                function Pu(t, e) {
                    return Bu(t.prev, t, e.prev) < 0 && Bu(e.next, t, t.next) < 0
                }

                function Lu(t, e, n, r, i) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }

                function Du(t) {
                    let e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function Iu(t, e, n, r, i, a, o, s) {
                    return (i - o) * (e - s) >= (t - o) * (a - s) && (t - o) * (r - s) >= (n - o) * (e - s) && (n - o) * (a - s) >= (i - o) * (r - s)
                }

                function Ou(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        let n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Uu(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (Fu(t, e) && Fu(e, t) && function(t, e) {
                        let n = t,
                            r = !1;
                        const i = (t.x + e.x) / 2,
                            a = (t.y + e.y) / 2;
                        do {
                            n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                        } while (n !== t);
                        return r
                    }(t, e) && (Bu(t.prev, t, e.prev) || Bu(t, e.prev, e)) || qu(t, e) && Bu(t.prev, t, t.next) > 0 && Bu(e.prev, e, e.next) > 0)
                }

                function Bu(t, e, n) {
                    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                }

                function qu(t, e) {
                    return t.x === e.x && t.y === e.y
                }

                function Uu(t, e, n, r) {
                    const i = ku(Bu(t, e, n)),
                        a = ku(Bu(t, e, r)),
                        o = ku(Bu(n, r, t)),
                        s = ku(Bu(n, r, e));
                    return i !== a && o !== s || !(0 !== i || !Nu(t, n, e)) || !(0 !== a || !Nu(t, r, e)) || !(0 !== o || !Nu(n, t, r)) || !(0 !== s || !Nu(n, e, r))
                }

                function Nu(t, e, n) {
                    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                }

                function ku(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }

                function Fu(t, e) {
                    return Bu(t.prev, t, t.next) < 0 ? Bu(t, e, t.next) >= 0 && Bu(t, t.prev, e) >= 0 : Bu(t, e, t.prev) < 0 || Bu(t, t.next, e) < 0
                }

                function zu(t, e) {
                    const n = new Vu(t.i, t.x, t.y),
                        r = new Vu(e.i, e.x, e.y),
                        i = t.next,
                        a = e.prev;
                    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r
                }

                function Gu(t, e, n, r) {
                    const i = new Vu(t, e, n);
                    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
                }

                function ju(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }

                function Vu(t, e, n) {
                    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }
                class Hu {
                    static area(t) {
                        const e = t.length;
                        let n = 0;
                        for (let r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
                        return .5 * n
                    }
                    static isClockWise(t) {
                        return Hu.area(t) < 0
                    }
                    static triangulateShape(t, e) {
                        const n = [],
                            r = [],
                            i = [];
                        Wu(t), Xu(n, t);
                        let a = t.length;
                        e.forEach(Wu);
                        for (let t = 0; t < e.length; t++) r.push(a), a += e[t].length, Xu(n, e[t]);
                        const o = function(t, e, n = 2) {
                            const r = e && e.length,
                                i = r ? e[0] * n : t.length;
                            let a = xu(t, 0, i, n, !0);
                            const o = [];
                            if (!a || a.next === a.prev) return o;
                            let s, l, A, c, u, h, d;
                            if (r && (a = function(t, e, n, r) {
                                    const i = [];
                                    let a, o, s, l, A;
                                    for (a = 0, o = e.length; a < o; a++) s = e[a] * r, l = a < o - 1 ? e[a + 1] * r : t.length, A = xu(t, s, l, r, !1), A === A.next && (A.steiner = !0), i.push(Du(A));
                                    for (i.sort(Cu), a = 0; a < i.length; a++) n = Ru(i[a], n);
                                    return n
                                }(t, e, a, n)), t.length > 80 * n) {
                                s = A = t[0], l = c = t[1];
                                for (let e = n; e < i; e += n) u = t[e], h = t[e + 1], u < s && (s = u), h < l && (l = h), u > A && (A = u), h > c && (c = h);
                                d = Math.max(A - s, c - l), d = 0 !== d ? 32767 / d : 0
                            }
                            return Mu(a, o, n, s, l, d, 0), o
                        }(n, r);
                        for (let t = 0; t < o.length; t += 3) i.push(o.slice(t, t + 3));
                        return i
                    }
                }

                function Wu(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function Xu(t, e) {
                    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                }
                class Yu extends Ta {
                    constructor(t = new yu([new er(.5, .5), new er(-.5, .5), new er(-.5, -.5), new er(.5, -.5)]), e = {}) {
                        super(), this.type = "ExtrudeGeometry", this.parameters = {
                            shapes: t,
                            options: e
                        }, t = Array.isArray(t) ? t : [t];
                        const n = this,
                            r = [],
                            i = [];
                        for (let e = 0, n = t.length; e < n; e++) a(t[e]);

                        function a(t) {
                            const a = [],
                                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                s = void 0 !== e.steps ? e.steps : 1,
                                l = void 0 !== e.depth ? e.depth : 1;
                            let A = void 0 === e.bevelEnabled || e.bevelEnabled,
                                c = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                u = void 0 !== e.bevelSize ? e.bevelSize : c - .1,
                                h = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                d = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                            const f = e.extrudePath,
                                p = void 0 !== e.UVGenerator ? e.UVGenerator : Qu;
                            let m, g, v, _, y, x = !1;
                            f && (m = f.getSpacedPoints(s), x = !0, A = !1, g = f.computeFrenetFrames(s, !1), v = new Ir, _ = new Ir, y = new Ir), A || (d = 0, c = 0, u = 0, h = 0);
                            const b = t.extractPoints(o);
                            let M = b.shape;
                            const w = b.holes;
                            if (!Hu.isClockWise(M)) {
                                M = M.reverse();
                                for (let t = 0, e = w.length; t < e; t++) {
                                    const e = w[t];
                                    Hu.isClockWise(e) && (w[t] = e.reverse())
                                }
                            }
                            const S = Hu.triangulateShape(M, w),
                                E = M;
                            for (let t = 0, e = w.length; t < e; t++) {
                                const e = w[t];
                                M = M.concat(e)
                            }

                            function T(t, e, n) {
                                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().addScaledVector(e, n)
                            }
                            const C = M.length,
                                R = S.length;

                            function P(t, e, n) {
                                let r, i, a;
                                const o = t.x - e.x,
                                    s = t.y - e.y,
                                    l = n.x - t.x,
                                    A = n.y - t.y,
                                    c = o * o + s * s,
                                    u = o * A - s * l;
                                if (Math.abs(u) > Number.EPSILON) {
                                    const u = Math.sqrt(c),
                                        h = Math.sqrt(l * l + A * A),
                                        d = e.x - s / u,
                                        f = e.y + o / u,
                                        p = ((n.x - A / h - d) * A - (n.y + l / h - f) * l) / (o * A - s * l);
                                    r = d + o * p - t.x, i = f + s * p - t.y;
                                    const m = r * r + i * i;
                                    if (m <= 2) return new er(r, i);
                                    a = Math.sqrt(m / 2)
                                } else {
                                    let t = !1;
                                    o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(s) === Math.sign(A) && (t = !0), t ? (r = -s, i = o, a = Math.sqrt(c)) : (r = o, i = s, a = Math.sqrt(c / 2))
                                }
                                return new er(r / a, i / a)
                            }
                            const L = [];
                            for (let t = 0, e = E.length, n = e - 1, r = t + 1; t < e; t++, n++, r++) n === e && (n = 0), r === e && (r = 0), L[t] = P(E[t], E[n], E[r]);
                            const D = [];
                            let I, O = L.concat();
                            for (let t = 0, e = w.length; t < e; t++) {
                                const e = w[t];
                                I = [];
                                for (let t = 0, n = e.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), I[t] = P(e[t], e[r], e[i]);
                                D.push(I), O = O.concat(I)
                            }
                            for (let t = 0; t < d; t++) {
                                const e = t / d,
                                    n = c * Math.cos(e * Math.PI / 2),
                                    r = u * Math.sin(e * Math.PI / 2) + h;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = T(E[t], L[t], r);
                                    U(e.x, e.y, -n)
                                }
                                for (let t = 0, e = w.length; t < e; t++) {
                                    const e = w[t];
                                    I = D[t];
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = T(e[t], I[t], r);
                                        U(i.x, i.y, -n)
                                    }
                                }
                            }
                            const B = u + h;
                            for (let t = 0; t < C; t++) {
                                const e = A ? T(M[t], O[t], B) : M[t];
                                x ? (_.copy(g.normals[0]).multiplyScalar(e.x), v.copy(g.binormals[0]).multiplyScalar(e.y), y.copy(m[0]).add(_).add(v), U(y.x, y.y, y.z)) : U(e.x, e.y, 0)
                            }
                            for (let t = 1; t <= s; t++)
                                for (let e = 0; e < C; e++) {
                                    const n = A ? T(M[e], O[e], B) : M[e];
                                    x ? (_.copy(g.normals[t]).multiplyScalar(n.x), v.copy(g.binormals[t]).multiplyScalar(n.y), y.copy(m[t]).add(_).add(v), U(y.x, y.y, y.z)) : U(n.x, n.y, l / s * t)
                                }
                            for (let t = d - 1; t >= 0; t--) {
                                const e = t / d,
                                    n = c * Math.cos(e * Math.PI / 2),
                                    r = u * Math.sin(e * Math.PI / 2) + h;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = T(E[t], L[t], r);
                                    U(e.x, e.y, l + n)
                                }
                                for (let t = 0, e = w.length; t < e; t++) {
                                    const e = w[t];
                                    I = D[t];
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = T(e[t], I[t], r);
                                        x ? U(i.x, i.y + m[s - 1].y, m[s - 1].x + n) : U(i.x, i.y, l + n)
                                    }
                                }
                            }

                            function q(t, e) {
                                let n = t.length;
                                for (; --n >= 0;) {
                                    const r = n;
                                    let i = n - 1;
                                    i < 0 && (i = t.length - 1);
                                    for (let t = 0, n = s + 2 * d; t < n; t++) {
                                        const n = C * t,
                                            a = C * (t + 1);
                                        k(e + r + n, e + i + n, e + i + a, e + r + a)
                                    }
                                }
                            }

                            function U(t, e, n) {
                                a.push(t), a.push(e), a.push(n)
                            }

                            function N(t, e, i) {
                                F(t), F(e), F(i);
                                const a = r.length / 3,
                                    o = p.generateTopUV(n, r, a - 3, a - 2, a - 1);
                                z(o[0]), z(o[1]), z(o[2])
                            }

                            function k(t, e, i, a) {
                                F(t), F(e), F(a), F(e), F(i), F(a);
                                const o = r.length / 3,
                                    s = p.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
                                z(s[0]), z(s[1]), z(s[3]), z(s[1]), z(s[2]), z(s[3])
                            }

                            function F(t) {
                                r.push(a[3 * t + 0]), r.push(a[3 * t + 1]), r.push(a[3 * t + 2])
                            }

                            function z(t) {
                                i.push(t.x), i.push(t.y)
                            }! function() {
                                const t = r.length / 3;
                                if (A) {
                                    let t = 0,
                                        e = C * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = S[t];
                                        N(n[2] + e, n[1] + e, n[0] + e)
                                    }
                                    t = s + 2 * d, e = C * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = S[t];
                                        N(n[0] + e, n[1] + e, n[2] + e)
                                    }
                                } else {
                                    for (let t = 0; t < R; t++) {
                                        const e = S[t];
                                        N(e[2], e[1], e[0])
                                    }
                                    for (let t = 0; t < R; t++) {
                                        const e = S[t];
                                        N(e[0] + C * s, e[1] + C * s, e[2] + C * s)
                                    }
                                }
                                n.addGroup(t, r.length / 3 - t, 0)
                            }(),
                            function() {
                                const t = r.length / 3;
                                let e = 0;
                                q(E, e), e += E.length;
                                for (let t = 0, n = w.length; t < n; t++) {
                                    const n = w[t];
                                    q(n, e), e += n.length
                                }
                                n.addGroup(t, r.length / 3 - t, 1)
                            }()
                        }
                        this.setAttribute("position", new _a(r, 3)), this.setAttribute("uv", new _a(i, 2)), this.computeVertexNormals()
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e, n) {
                            if (n.shapes = [], Array.isArray(t))
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = t[e];
                                    n.shapes.push(r.uuid)
                                } else n.shapes.push(t.uuid);
                            return n.options = Object.assign({}, e), void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                        }(this.parameters.shapes, this.parameters.options, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let r = 0, i = t.shapes.length; r < i; r++) {
                            const i = e[t.shapes[r]];
                            n.push(i)
                        }
                        const r = t.options.extrudePath;
                        return void 0 !== r && (t.options.extrudePath = (new au[r.type]).fromJSON(r)), new Yu(n, t.options)
                    }
                }
                const Qu = {
                    generateTopUV: function(t, e, n, r, i) {
                        const a = e[3 * n],
                            o = e[3 * n + 1],
                            s = e[3 * r],
                            l = e[3 * r + 1],
                            A = e[3 * i],
                            c = e[3 * i + 1];
                        return [new er(a, o), new er(s, l), new er(A, c)]
                    },
                    generateSideWallUV: function(t, e, n, r, i, a) {
                        const o = e[3 * n],
                            s = e[3 * n + 1],
                            l = e[3 * n + 2],
                            A = e[3 * r],
                            c = e[3 * r + 1],
                            u = e[3 * r + 2],
                            h = e[3 * i],
                            d = e[3 * i + 1],
                            f = e[3 * i + 2],
                            p = e[3 * a],
                            m = e[3 * a + 1],
                            g = e[3 * a + 2];
                        return Math.abs(s - c) < Math.abs(o - A) ? [new er(o, 1 - l), new er(A, 1 - u), new er(h, 1 - f), new er(p, 1 - g)] : [new er(s, 1 - l), new er(c, 1 - u), new er(d, 1 - f), new er(m, 1 - g)]
                    }
                };
                class Zu extends du {
                    constructor(t = 1, e = 0) {
                        const n = (1 + Math.sqrt(5)) / 2;
                        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                    static fromJSON(t) {
                        return new Zu(t.radius, t.detail)
                    }
                }
                class Ju extends du {
                    constructor(t = 1, e = 0) {
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                    static fromJSON(t) {
                        return new Ju(t.radius, t.detail)
                    }
                }
                class Ku extends Ta {
                    constructor(t = .5, e = 1, n = 32, r = 1, i = 0, a = 2 * Math.PI) {
                        super(), this.type = "RingGeometry", this.parameters = {
                            innerRadius: t,
                            outerRadius: e,
                            thetaSegments: n,
                            phiSegments: r,
                            thetaStart: i,
                            thetaLength: a
                        }, n = Math.max(3, n);
                        const o = [],
                            s = [],
                            l = [],
                            A = [];
                        let c = t;
                        const u = (e - t) / (r = Math.max(1, r)),
                            h = new Ir,
                            d = new er;
                        for (let t = 0; t <= r; t++) {
                            for (let t = 0; t <= n; t++) {
                                const r = i + t / n * a;
                                h.x = c * Math.cos(r), h.y = c * Math.sin(r), s.push(h.x, h.y, h.z), l.push(0, 0, 1), d.x = (h.x / e + 1) / 2, d.y = (h.y / e + 1) / 2, A.push(d.x, d.y)
                            }
                            c += u
                        }
                        for (let t = 0; t < r; t++) {
                            const e = t * (n + 1);
                            for (let t = 0; t < n; t++) {
                                const r = t + e,
                                    i = r,
                                    a = r + n + 1,
                                    s = r + n + 2,
                                    l = r + 1;
                                o.push(i, a, l), o.push(a, s, l)
                            }
                        }
                        this.setIndex(o), this.setAttribute("position", new _a(s, 3)), this.setAttribute("normal", new _a(l, 3)), this.setAttribute("uv", new _a(A, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new Ku(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
                    }
                }
                class $u extends Ta {
                    constructor(t = new yu([new er(0, .5), new er(-.5, -.5), new er(.5, -.5)]), e = 12) {
                        super(), this.type = "ShapeGeometry", this.parameters = {
                            shapes: t,
                            curveSegments: e
                        };
                        const n = [],
                            r = [],
                            i = [],
                            a = [];
                        let o = 0,
                            s = 0;
                        if (!1 === Array.isArray(t)) l(t);
                        else
                            for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, s, e), o += s, s = 0;

                        function l(t) {
                            const o = r.length / 3,
                                l = t.extractPoints(e);
                            let A = l.shape;
                            const c = l.holes;
                            !1 === Hu.isClockWise(A) && (A = A.reverse());
                            for (let t = 0, e = c.length; t < e; t++) {
                                const e = c[t];
                                !0 === Hu.isClockWise(e) && (c[t] = e.reverse())
                            }
                            const u = Hu.triangulateShape(A, c);
                            for (let t = 0, e = c.length; t < e; t++) {
                                const e = c[t];
                                A = A.concat(e)
                            }
                            for (let t = 0, e = A.length; t < e; t++) {
                                const e = A[t];
                                r.push(e.x, e.y, 0), i.push(0, 0, 1), a.push(e.x, e.y)
                            }
                            for (let t = 0, e = u.length; t < e; t++) {
                                const e = u[t],
                                    r = e[0] + o,
                                    i = e[1] + o,
                                    a = e[2] + o;
                                n.push(r, i, a), s += 3
                            }
                        }
                        this.setIndex(n), this.setAttribute("position", new _a(r, 3)), this.setAttribute("normal", new _a(i, 3)), this.setAttribute("uv", new _a(a, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e) {
                            if (e.shapes = [], Array.isArray(t))
                                for (let n = 0, r = t.length; n < r; n++) {
                                    const r = t[n];
                                    e.shapes.push(r.uuid)
                                } else e.shapes.push(t.uuid);
                            return e
                        }(this.parameters.shapes, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let r = 0, i = t.shapes.length; r < i; r++) {
                            const i = e[t.shapes[r]];
                            n.push(i)
                        }
                        return new $u(n, t.curveSegments)
                    }
                }
                class th extends Ta {
                    constructor(t = 1, e = 32, n = 16, r = 0, i = 2 * Math.PI, a = 0, o = Math.PI) {
                        super(), this.type = "SphereGeometry", this.parameters = {
                            radius: t,
                            widthSegments: e,
                            heightSegments: n,
                            phiStart: r,
                            phiLength: i,
                            thetaStart: a,
                            thetaLength: o
                        }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                        const s = Math.min(a + o, Math.PI);
                        let l = 0;
                        const A = [],
                            c = new Ir,
                            u = new Ir,
                            h = [],
                            d = [],
                            f = [],
                            p = [];
                        for (let h = 0; h <= n; h++) {
                            const m = [],
                                g = h / n;
                            let v = 0;
                            0 === h && 0 === a ? v = .5 / e : h === n && s === Math.PI && (v = -.5 / e);
                            for (let n = 0; n <= e; n++) {
                                const s = n / e;
                                c.x = -t * Math.cos(r + s * i) * Math.sin(a + g * o), c.y = t * Math.cos(a + g * o), c.z = t * Math.sin(r + s * i) * Math.sin(a + g * o), d.push(c.x, c.y, c.z), u.copy(c).normalize(), f.push(u.x, u.y, u.z), p.push(s + v, 1 - g), m.push(l++)
                            }
                            A.push(m)
                        }
                        for (let t = 0; t < n; t++)
                            for (let r = 0; r < e; r++) {
                                const e = A[t][r + 1],
                                    i = A[t][r],
                                    o = A[t + 1][r],
                                    l = A[t + 1][r + 1];
                                (0 !== t || a > 0) && h.push(e, i, l), (t !== n - 1 || s < Math.PI) && h.push(i, o, l)
                            }
                        this.setIndex(h), this.setAttribute("position", new _a(d, 3)), this.setAttribute("normal", new _a(f, 3)), this.setAttribute("uv", new _a(p, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new th(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
                    }
                }
                class eh extends du {
                    constructor(t = 1, e = 0) {
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
                            radius: t,
                            detail: e
                        }
                    }
                    static fromJSON(t) {
                        return new eh(t.radius, t.detail)
                    }
                }
                class nh extends Ta {
                    constructor(t = 1, e = .4, n = 12, r = 48, i = 2 * Math.PI) {
                        super(), this.type = "TorusGeometry", this.parameters = {
                            radius: t,
                            tube: e,
                            radialSegments: n,
                            tubularSegments: r,
                            arc: i
                        }, n = Math.floor(n), r = Math.floor(r);
                        const a = [],
                            o = [],
                            s = [],
                            l = [],
                            A = new Ir,
                            c = new Ir,
                            u = new Ir;
                        for (let a = 0; a <= n; a++)
                            for (let h = 0; h <= r; h++) {
                                const d = h / r * i,
                                    f = a / n * Math.PI * 2;
                                c.x = (t + e * Math.cos(f)) * Math.cos(d), c.y = (t + e * Math.cos(f)) * Math.sin(d), c.z = e * Math.sin(f), o.push(c.x, c.y, c.z), A.x = t * Math.cos(d), A.y = t * Math.sin(d), u.subVectors(c, A).normalize(), s.push(u.x, u.y, u.z), l.push(h / r), l.push(a / n)
                            }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= r; e++) {
                                const n = (r + 1) * t + e - 1,
                                    i = (r + 1) * (t - 1) + e - 1,
                                    o = (r + 1) * (t - 1) + e,
                                    s = (r + 1) * t + e;
                                a.push(n, i, s), a.push(i, o, s)
                            }
                        this.setIndex(a), this.setAttribute("position", new _a(o, 3)), this.setAttribute("normal", new _a(s, 3)), this.setAttribute("uv", new _a(l, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new nh(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
                    }
                }
                class rh extends Ta {
                    constructor(t = 1, e = .4, n = 64, r = 8, i = 2, a = 3) {
                        super(), this.type = "TorusKnotGeometry", this.parameters = {
                            radius: t,
                            tube: e,
                            tubularSegments: n,
                            radialSegments: r,
                            p: i,
                            q: a
                        }, n = Math.floor(n), r = Math.floor(r);
                        const o = [],
                            s = [],
                            l = [],
                            A = [],
                            c = new Ir,
                            u = new Ir,
                            h = new Ir,
                            d = new Ir,
                            f = new Ir,
                            p = new Ir,
                            m = new Ir;
                        for (let o = 0; o <= n; ++o) {
                            const v = o / n * i * Math.PI * 2;
                            g(v, i, a, t, h), g(v + .01, i, a, t, d), p.subVectors(d, h), m.addVectors(d, h), f.crossVectors(p, m), m.crossVectors(f, p), f.normalize(), m.normalize();
                            for (let t = 0; t <= r; ++t) {
                                const i = t / r * Math.PI * 2,
                                    a = -e * Math.cos(i),
                                    d = e * Math.sin(i);
                                c.x = h.x + (a * m.x + d * f.x), c.y = h.y + (a * m.y + d * f.y), c.z = h.z + (a * m.z + d * f.z), s.push(c.x, c.y, c.z), u.subVectors(c, h).normalize(), l.push(u.x, u.y, u.z), A.push(o / n), A.push(t / r)
                            }
                        }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= r; e++) {
                                const n = (r + 1) * (t - 1) + (e - 1),
                                    i = (r + 1) * t + (e - 1),
                                    a = (r + 1) * t + e,
                                    s = (r + 1) * (t - 1) + e;
                                o.push(n, i, s), o.push(i, a, s)
                            }

                        function g(t, e, n, r, i) {
                            const a = Math.cos(t),
                                o = Math.sin(t),
                                s = n / e * t,
                                l = Math.cos(s);
                            i.x = r * (2 + l) * .5 * a, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(s) * .5
                        }
                        this.setIndex(o), this.setAttribute("position", new _a(s, 3)), this.setAttribute("normal", new _a(l, 3)), this.setAttribute("uv", new _a(A, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    static fromJSON(t) {
                        return new rh(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
                    }
                }
                class ih extends Ta {
                    constructor(t = new ru(new Ir(-1, -1, 0), new Ir(-1, 1, 0), new Ir(1, 1, 0)), e = 64, n = 1, r = 8, i = !1) {
                        super(), this.type = "TubeGeometry", this.parameters = {
                            path: t,
                            tubularSegments: e,
                            radius: n,
                            radialSegments: r,
                            closed: i
                        };
                        const a = t.computeFrenetFrames(e, i);
                        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                        const o = new Ir,
                            s = new Ir,
                            l = new er;
                        let A = new Ir;
                        const c = [],
                            u = [],
                            h = [],
                            d = [];

                        function f(i) {
                            A = t.getPointAt(i / e, A);
                            const l = a.normals[i],
                                h = a.binormals[i];
                            for (let t = 0; t <= r; t++) {
                                const e = t / r * Math.PI * 2,
                                    i = Math.sin(e),
                                    a = -Math.cos(e);
                                s.x = a * l.x + i * h.x, s.y = a * l.y + i * h.y, s.z = a * l.z + i * h.z, s.normalize(), u.push(s.x, s.y, s.z), o.x = A.x + n * s.x, o.y = A.y + n * s.y, o.z = A.z + n * s.z, c.push(o.x, o.y, o.z)
                            }
                        }! function() {
                            for (let t = 0; t < e; t++) f(t);
                            f(!1 === i ? e : 0),
                                function() {
                                    for (let t = 0; t <= e; t++)
                                        for (let n = 0; n <= r; n++) l.x = t / e, l.y = n / r, h.push(l.x, l.y)
                                }(),
                                function() {
                                    for (let t = 1; t <= e; t++)
                                        for (let e = 1; e <= r; e++) {
                                            const n = (r + 1) * (t - 1) + (e - 1),
                                                i = (r + 1) * t + (e - 1),
                                                a = (r + 1) * t + e,
                                                o = (r + 1) * (t - 1) + e;
                                            d.push(n, i, o), d.push(i, a, o)
                                        }
                                }()
                        }(), this.setIndex(d), this.setAttribute("position", new _a(c, 3)), this.setAttribute("normal", new _a(u, 3)), this.setAttribute("uv", new _a(h, 2))
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.path = this.parameters.path.toJSON(), t
                    }
                    static fromJSON(t) {
                        return new ih((new au[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
                    }
                }
                class ah extends Ta {
                    constructor(t = null) {
                        if (super(), this.type = "WireframeGeometry", this.parameters = {
                                geometry: t
                            }, null !== t) {
                            const e = [],
                                n = new Set,
                                r = new Ir,
                                i = new Ir;
                            if (null !== t.index) {
                                const a = t.attributes.position,
                                    o = t.index;
                                let s = t.groups;
                                0 === s.length && (s = [{
                                    start: 0,
                                    count: o.count,
                                    materialIndex: 0
                                }]);
                                for (let t = 0, l = s.length; t < l; ++t) {
                                    const l = s[t],
                                        A = l.start;
                                    for (let t = A, s = A + l.count; t < s; t += 3)
                                        for (let s = 0; s < 3; s++) {
                                            const l = o.getX(t + s),
                                                A = o.getX(t + (s + 1) % 3);
                                            r.fromBufferAttribute(a, l), i.fromBufferAttribute(a, A), !0 === oh(r, i, n) && (e.push(r.x, r.y, r.z), e.push(i.x, i.y, i.z))
                                        }
                                }
                            } else {
                                const a = t.attributes.position;
                                for (let t = 0, o = a.count / 3; t < o; t++)
                                    for (let o = 0; o < 3; o++) {
                                        const s = 3 * t + o,
                                            l = 3 * t + (o + 1) % 3;
                                        r.fromBufferAttribute(a, s), i.fromBufferAttribute(a, l), !0 === oh(r, i, n) && (e.push(r.x, r.y, r.z), e.push(i.x, i.y, i.z))
                                    }
                            }
                            this.setAttribute("position", new _a(e, 3))
                        }
                    }
                    copy(t) {
                        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                    }
                }

                function oh(t, e, n) {
                    const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
                        i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                    return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0)
                }
                var sh = Object.freeze({
                    __proto__: null,
                    BoxGeometry: Xa,
                    CapsuleGeometry: Au,
                    CircleGeometry: cu,
                    ConeGeometry: hu,
                    CylinderGeometry: uu,
                    DodecahedronGeometry: fu,
                    EdgesGeometry: _u,
                    ExtrudeGeometry: Yu,
                    IcosahedronGeometry: Zu,
                    LatheGeometry: lu,
                    OctahedronGeometry: Ju,
                    PlaneGeometry: vo,
                    PolyhedronGeometry: du,
                    RingGeometry: Ku,
                    ShapeGeometry: $u,
                    SphereGeometry: th,
                    TetrahedronGeometry: eh,
                    TorusGeometry: nh,
                    TorusKnotGeometry: rh,
                    TubeGeometry: ih,
                    WireframeGeometry: ah
                });
                class lh extends ea {
                    constructor(t) {
                        super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Ki(0), this.transparent = !0, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.fog = t.fog, this
                    }
                }
                class Ah extends Ka {
                    constructor(t) {
                        super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                    }
                }
                class ch extends ea {
                    constructor(t) {
                        super(), this.isMeshStandardMaterial = !0, this.defines = {
                            STANDARD: ""
                        }, this.type = "MeshStandardMaterial", this.color = new Ki(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = He, this.normalScale = new er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new _i, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            STANDARD: ""
                        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                    }
                }
                class uh extends ch {
                    constructor(t) {
                        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new er(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                            get: function() {
                                return Xn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function(t) {
                                this.ior = (1 + .4 * t) / (1 - .4 * t)
                            }
                        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ki(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ki(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ki(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t)
                    }
                    get anisotropy() {
                        return this._anisotropy
                    }
                    set anisotropy(t) {
                        this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(t) {
                        this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
                    }
                    get iridescence() {
                        return this._iridescence
                    }
                    set iridescence(t) {
                        this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(t) {
                        this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(t) {
                        this._transmission > 0 != t > 0 && this.version++, this._transmission = t
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                    }
                }
                class hh extends ea {
                    constructor(t) {
                        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Ki(16777215), this.specular = new Ki(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = He, this.normalScale = new er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new _i, this.combine = J, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                    }
                }
                class dh extends ea {
                    constructor(t) {
                        super(), this.isMeshToonMaterial = !0, this.defines = {
                            TOON: ""
                        }, this.type = "MeshToonMaterial", this.color = new Ki(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = He, this.normalScale = new er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
                    }
                }
                class fh extends ea {
                    constructor(t) {
                        super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = He, this.normalScale = new er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                    }
                }
                class ph extends ea {
                    constructor(t) {
                        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Ki(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = He, this.normalScale = new er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new _i, this.combine = J, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                    }
                }
                class mh extends ea {
                    constructor(t) {
                        super(), this.isMeshMatcapMaterial = !0, this.defines = {
                            MATCAP: ""
                        }, this.type = "MeshMatcapMaterial", this.color = new Ki(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = He, this.normalScale = new er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            MATCAP: ""
                        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this
                    }
                }
                class gh extends mc {
                    constructor(t) {
                        super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                    }
                }

                function vh(t, e, n) {
                    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                }

                function _h(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                }

                function yh(t) {
                    const e = t.length,
                        n = new Array(e);
                    for (let t = 0; t !== e; ++t) n[t] = t;
                    return n.sort((function(e, n) {
                        return t[e] - t[n]
                    })), n
                }

                function xh(t, e, n) {
                    const r = t.length,
                        i = new t.constructor(r);
                    for (let a = 0, o = 0; o !== r; ++a) {
                        const r = n[a] * e;
                        for (let n = 0; n !== e; ++n) i[o++] = t[r + n]
                    }
                    return i
                }

                function bh(t, e, n, r) {
                    let i = 1,
                        a = t[0];
                    for (; void 0 !== a && void 0 === a[r];) a = t[i++];
                    if (void 0 === a) return;
                    let o = a[r];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            do {
                                o = a[r], void 0 !== o && (e.push(a.time), n.push.apply(n, o)), a = t[i++]
                            } while (void 0 !== a);
                        else if (void 0 !== o.toArray)
                        do {
                            o = a[r], void 0 !== o && (e.push(a.time), o.toArray(n, n.length)), a = t[i++]
                        } while (void 0 !== a);
                    else
                        do {
                            o = a[r], void 0 !== o && (e.push(a.time), n.push(o)), a = t[i++]
                        } while (void 0 !== a)
                }
                const Mh = {
                    convertArray: vh,
                    isTypedArray: _h,
                    getKeyframeOrder: yh,
                    sortedArray: xh,
                    flattenJSON: bh,
                    subclip: function(t, e, n, r, i = 30) {
                        const a = t.clone();
                        a.name = e;
                        const o = [];
                        for (let t = 0; t < a.tracks.length; ++t) {
                            const e = a.tracks[t],
                                s = e.getValueSize(),
                                l = [],
                                A = [];
                            for (let t = 0; t < e.times.length; ++t) {
                                const a = e.times[t] * i;
                                if (!(a < n || a >= r)) {
                                    l.push(e.times[t]);
                                    for (let n = 0; n < s; ++n) A.push(e.values[t * s + n])
                                }
                            }
                            0 !== l.length && (e.times = vh(l, e.times.constructor), e.values = vh(A, e.values.constructor), o.push(e))
                        }
                        a.tracks = o;
                        let s = 1 / 0;
                        for (let t = 0; t < a.tracks.length; ++t) s > a.tracks[t].times[0] && (s = a.tracks[t].times[0]);
                        for (let t = 0; t < a.tracks.length; ++t) a.tracks[t].shift(-1 * s);
                        return a.resetDuration(), a
                    },
                    makeClipAdditive: function(t, e = 0, n = t, r = 30) {
                        r <= 0 && (r = 30);
                        const i = n.tracks.length,
                            a = e / r;
                        for (let e = 0; e < i; ++e) {
                            const r = n.tracks[e],
                                i = r.ValueTypeName;
                            if ("bool" === i || "string" === i) continue;
                            const o = t.tracks.find((function(t) {
                                return t.name === r.name && t.ValueTypeName === i
                            }));
                            if (void 0 === o) continue;
                            let s = 0;
                            const l = r.getValueSize();
                            r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
                            let A = 0;
                            const c = o.getValueSize();
                            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (A = c / 3);
                            const u = r.times.length - 1;
                            let h;
                            if (a <= r.times[0]) {
                                const t = s,
                                    e = l - s;
                                h = r.values.slice(t, e)
                            } else if (a >= r.times[u]) {
                                const t = u * l + s,
                                    e = t + l - s;
                                h = r.values.slice(t, e)
                            } else {
                                const t = r.createInterpolant(),
                                    e = s,
                                    n = l - s;
                                t.evaluate(a), h = t.resultBuffer.slice(e, n)
                            }
                            "quaternion" === i && (new Dr).fromArray(h).normalize().conjugate().toArray(h);
                            const d = o.times.length;
                            for (let t = 0; t < d; ++t) {
                                const e = t * c + A;
                                if ("quaternion" === i) Dr.multiplyQuaternionsFlat(o.values, e, h, 0, o.values, e);
                                else {
                                    const t = c - 2 * A;
                                    for (let n = 0; n < t; ++n) o.values[e + n] -= h[n]
                                }
                            }
                        }
                        return t.blendMode = ke, t
                    }
                };
                class wh {
                    constructor(t, e, n, r) {
                        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                    }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            r = e[n],
                            i = e[n - 1];
                        t: {
                            e: {
                                let a;n: {
                                    r: if (!(t < r)) {
                                        for (let a = n + 2;;) {
                                            if (void 0 === r) {
                                                if (t < i) break r;
                                                return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                            }
                                            if (n === a) break;
                                            if (i = r, r = e[++n], t < r) break e
                                        }
                                        a = e.length;
                                        break n
                                    }if (t >= i) break t;
                                    {
                                        const o = e[1];
                                        t < o && (n = 2, i = o);
                                        for (let a = n - 2;;) {
                                            if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                            if (n === a) break;
                                            if (r = i, i = e[--n - 1], t >= i) break e
                                        }
                                        a = n, n = 0
                                    }
                                }
                                for (; n < a;) {
                                    const r = n + a >>> 1;
                                    t < e[r] ? a = r : n = r + 1
                                }
                                if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                                if (void 0 === r) return n = e.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, i, r)
                        }
                        return this.interpolate_(n, i, t, r)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            r = this.valueSize,
                            i = t * r;
                        for (let t = 0; t !== r; ++t) e[t] = n[i + t];
                        return e
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                class Sh extends wh {
                    constructor(t, e, n, r) {
                        super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                            endingStart: Be,
                            endingEnd: Be
                        }
                    }
                    intervalChanged_(t, e, n) {
                        const r = this.parameterPositions;
                        let i = t - 2,
                            a = t + 1,
                            o = r[i],
                            s = r[a];
                        if (void 0 === o) switch (this.getSettings_().endingStart) {
                            case qe:
                                i = t, o = 2 * e - n;
                                break;
                            case Ue:
                                i = r.length - 2, o = e + r[i] - r[i + 1];
                                break;
                            default:
                                i = t, o = n
                        }
                        if (void 0 === s) switch (this.getSettings_().endingEnd) {
                            case qe:
                                a = t, s = 2 * n - e;
                                break;
                            case Ue:
                                a = 1, s = n + r[1] - r[0];
                                break;
                            default:
                                a = t - 1, s = e
                        }
                        const l = .5 * (n - e),
                            A = this.valueSize;
                        this._weightPrev = l / (e - o), this._weightNext = l / (s - n), this._offsetPrev = i * A, this._offsetNext = a * A
                    }
                    interpolate_(t, e, n, r) {
                        const i = this.resultBuffer,
                            a = this.sampleValues,
                            o = this.valueSize,
                            s = t * o,
                            l = s - o,
                            A = this._offsetPrev,
                            c = this._offsetNext,
                            u = this._weightPrev,
                            h = this._weightNext,
                            d = (n - e) / (r - e),
                            f = d * d,
                            p = f * d,
                            m = -u * p + 2 * u * f - u * d,
                            g = (1 + u) * p + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1,
                            v = (-1 - h) * p + (1.5 + h) * f + .5 * d,
                            _ = h * p - h * f;
                        for (let t = 0; t !== o; ++t) i[t] = m * a[A + t] + g * a[l + t] + v * a[s + t] + _ * a[c + t];
                        return i
                    }
                }
                class Eh extends wh {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    interpolate_(t, e, n, r) {
                        const i = this.resultBuffer,
                            a = this.sampleValues,
                            o = this.valueSize,
                            s = t * o,
                            l = s - o,
                            A = (n - e) / (r - e),
                            c = 1 - A;
                        for (let t = 0; t !== o; ++t) i[t] = a[l + t] * c + a[s + t] * A;
                        return i
                    }
                }
                class Th extends wh {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    interpolate_(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }
                class Ch {
                    constructor(t, e, n, r) {
                        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = vh(e, this.TimeBufferType), this.values = vh(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = {
                                name: t.name,
                                times: vh(t.times, Array),
                                values: vh(t.values, Array)
                            };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation && (n.interpolation = e)
                        }
                        return n.type = t.ValueTypeName, n
                    }
                    InterpolantFactoryMethodDiscrete(t) {
                        return new Th(this.times, this.values, this.getValueSize(), t)
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new Eh(this.times, this.values, this.getValueSize(), t)
                    }
                    InterpolantFactoryMethodSmooth(t) {
                        return new Sh(this.times, this.values, this.getValueSize(), t)
                    }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case De:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case Ie:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case Oe:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(e);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", e), this
                        }
                        return this.createInterpolant = e, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return De;
                            case this.InterpolantFactoryMethodLinear:
                                return Ie;
                            case this.InterpolantFactoryMethodSmooth:
                                return Oe
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(t) {
                        if (0 !== t) {
                            const e = this.times;
                            for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
                        }
                        return this
                    }
                    scale(t) {
                        if (1 !== t) {
                            const e = this.times;
                            for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
                        }
                        return this
                    }
                    trim(t, e) {
                        const n = this.times,
                            r = n.length;
                        let i = 0,
                            a = r - 1;
                        for (; i !== r && n[i] < t;) ++i;
                        for (; - 1 !== a && n[a] > e;) --a;
                        if (++a, 0 !== i || a !== r) {
                            i >= a && (a = Math.max(a, 1), i = a - 1);
                            const t = this.getValueSize();
                            this.times = n.slice(i, a), this.values = this.values.slice(i * t, a * t)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        const n = this.times,
                            r = this.values,
                            i = n.length;
                        0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        let a = null;
                        for (let e = 0; e !== i; e++) {
                            const r = n[e];
                            if ("number" == typeof r && isNaN(r)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, r), t = !1;
                                break
                            }
                            if (null !== a && a > r) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, e, r, a), t = !1;
                                break
                            }
                            a = r
                        }
                        if (void 0 !== r && _h(r))
                            for (let e = 0, n = r.length; e !== n; ++e) {
                                const n = r[e];
                                if (isNaN(n)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                    break
                                }
                            }
                        return t
                    }
                    optimize() {
                        const t = this.times.slice(),
                            e = this.values.slice(),
                            n = this.getValueSize(),
                            r = this.getInterpolation() === Oe,
                            i = t.length - 1;
                        let a = 1;
                        for (let o = 1; o < i; ++o) {
                            let i = !1;
                            const s = t[o];
                            if (s !== t[o + 1] && (1 !== o || s !== t[0]))
                                if (r) i = !0;
                                else {
                                    const t = o * n,
                                        r = t - n,
                                        a = t + n;
                                    for (let o = 0; o !== n; ++o) {
                                        const n = e[t + o];
                                        if (n !== e[r + o] || n !== e[a + o]) {
                                            i = !0;
                                            break
                                        }
                                    }
                                } if (i) {
                                if (o !== a) {
                                    t[a] = t[o];
                                    const r = o * n,
                                        i = a * n;
                                    for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
                                }++a
                            }
                        }
                        if (i > 0) {
                            t[a] = t[i];
                            for (let t = i * n, r = a * n, o = 0; o !== n; ++o) e[r + o] = e[t + o];
                            ++a
                        }
                        return a !== t.length ? (this.times = t.slice(0, a), this.values = e.slice(0, a * n)) : (this.times = t, this.values = e), this
                    }
                    clone() {
                        const t = this.times.slice(),
                            e = this.values.slice(),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }
                Ch.prototype.TimeBufferType = Float32Array, Ch.prototype.ValueBufferType = Float32Array, Ch.prototype.DefaultInterpolation = Ie;
                class Rh extends Ch {}
                Rh.prototype.ValueTypeName = "bool", Rh.prototype.ValueBufferType = Array, Rh.prototype.DefaultInterpolation = De, Rh.prototype.InterpolantFactoryMethodLinear = void 0, Rh.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Ph extends Ch {}
                Ph.prototype.ValueTypeName = "color";
                class Lh extends Ch {}
                Lh.prototype.ValueTypeName = "number";
                class Dh extends wh {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    interpolate_(t, e, n, r) {
                        const i = this.resultBuffer,
                            a = this.sampleValues,
                            o = this.valueSize,
                            s = (n - e) / (r - e);
                        let l = t * o;
                        for (let t = l + o; l !== t; l += 4) Dr.slerpFlat(i, 0, a, l - o, a, l, s);
                        return i
                    }
                }
                class Ih extends Ch {
                    InterpolantFactoryMethodLinear(t) {
                        return new Dh(this.times, this.values, this.getValueSize(), t)
                    }
                }
                Ih.prototype.ValueTypeName = "quaternion", Ih.prototype.DefaultInterpolation = Ie, Ih.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Oh extends Ch {}
                Oh.prototype.ValueTypeName = "string", Oh.prototype.ValueBufferType = Array, Oh.prototype.DefaultInterpolation = De, Oh.prototype.InterpolantFactoryMethodLinear = void 0, Oh.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Bh extends Ch {}
                Bh.prototype.ValueTypeName = "vector";
                class qh {
                    constructor(t, e = -1, n, r = Ne) {
                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = Wn(), this.duration < 0 && this.resetDuration()
                    }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            r = 1 / (t.fps || 1);
                        for (let t = 0, i = n.length; t !== i; ++t) e.push(Uh(n[t]).scale(r));
                        const i = new this(t.name, t.duration, e, t.blendMode);
                        return i.uuid = t.uuid, i
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            r = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid,
                                blendMode: t.blendMode
                            };
                        for (let t = 0, r = n.length; t !== r; ++t) e.push(Ch.toJSON(n[t]));
                        return r
                    }
                    static CreateFromMorphTargetSequence(t, e, n, r) {
                        const i = e.length,
                            a = [];
                        for (let t = 0; t < i; t++) {
                            let o = [],
                                s = [];
                            o.push((t + i - 1) % i, t, (t + 1) % i), s.push(0, 1, 0);
                            const l = yh(o);
                            o = xh(o, 1, l), s = xh(s, 1, l), r || 0 !== o[0] || (o.push(i), s.push(s[0])), a.push(new Lh(".morphTargetInfluences[" + e[t].name + "]", o, s).scale(1 / n))
                        }
                        return new this(t, -1, a)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n = e.geometry && e.geometry.animations || e.animations
                        }
                        for (let t = 0; t < n.length; t++)
                            if (n[t].name === e) return n[t];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const r = {},
                            i = /^([\w-]*?)([\d]+)$/;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e],
                                a = n.name.match(i);
                            if (a && a.length > 1) {
                                const t = a[1];
                                let e = r[t];
                                e || (r[t] = e = []), e.push(n)
                            }
                        }
                        const a = [];
                        for (const t in r) a.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
                        return a
                    }
                    static parseAnimation(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        const n = function(t, e, n, r, i) {
                                if (0 !== n.length) {
                                    const a = [],
                                        o = [];
                                    bh(n, a, o, r), 0 !== a.length && i.push(new t(e, a, o))
                                }
                            },
                            r = [],
                            i = t.name || "default",
                            a = t.fps || 30,
                            o = t.blendMode;
                        let s = t.length || -1;
                        const l = t.hierarchy || [];
                        for (let t = 0; t < l.length; t++) {
                            const i = l[t].keys;
                            if (i && 0 !== i.length)
                                if (i[0].morphTargets) {
                                    const t = {};
                                    let e;
                                    for (e = 0; e < i.length; e++)
                                        if (i[e].morphTargets)
                                            for (let n = 0; n < i[e].morphTargets.length; n++) t[i[e].morphTargets[n]] = -1;
                                    for (const n in t) {
                                        const t = [],
                                            a = [];
                                        for (let r = 0; r !== i[e].morphTargets.length; ++r) {
                                            const r = i[e];
                                            t.push(r.time), a.push(r.morphTarget === n ? 1 : 0)
                                        }
                                        r.push(new Lh(".morphTargetInfluence[" + n + "]", t, a))
                                    }
                                    s = t.length * a
                                } else {
                                    const a = ".bones[" + e[t].name + "]";
                                    n(Bh, a + ".position", i, "pos", r), n(Ih, a + ".quaternion", i, "rot", r), n(Bh, a + ".scale", i, "scl", r)
                                }
                        }
                        return 0 === r.length ? null : new this(i, s, r, o)
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    }
                    trim() {
                        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let t = !0;
                        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    }
                    optimize() {
                        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    }
                    clone() {
                        const t = [];
                        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                        return new this.constructor(this.name, this.duration, t, this.blendMode)
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }

                function Uh(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = function(t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return Lh;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return Bh;
                            case "color":
                                return Ph;
                            case "quaternion":
                                return Ih;
                            case "bool":
                            case "boolean":
                                return Rh;
                            case "string":
                                return Oh
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                    }(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        bh(t.keys, e, n, "value"), t.times = e, t.values = n
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                }
                const Nh = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        !1 !== this.enabled && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (!1 !== this.enabled) return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                class kh {
                    constructor(t, e, n) {
                        const r = this;
                        let i, a = !1,
                            o = 0,
                            s = 0;
                        const l = [];
                        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                            s++, !1 === a && void 0 !== r.onStart && r.onStart(t, o, s), a = !0
                        }, this.itemEnd = function(t) {
                            o++, void 0 !== r.onProgress && r.onProgress(t, o, s), o === s && (a = !1, void 0 !== r.onLoad && r.onLoad())
                        }, this.itemError = function(t) {
                            void 0 !== r.onError && r.onError(t)
                        }, this.resolveURL = function(t) {
                            return i ? i(t) : t
                        }, this.setURLModifier = function(t) {
                            return i = t, this
                        }, this.addHandler = function(t, e) {
                            return l.push(t, e), this
                        }, this.removeHandler = function(t) {
                            const e = l.indexOf(t);
                            return -1 !== e && l.splice(e, 2), this
                        }, this.getHandler = function(t) {
                            for (let e = 0, n = l.length; e < n; e += 2) {
                                const n = l[e],
                                    r = l[e + 1];
                                if (n.global && (n.lastIndex = 0), n.test(t)) return r
                            }
                            return null
                        }
                    }
                }
                const Fh = new kh;
                class zh {
                    constructor(t) {
                        this.manager = void 0 !== t ? t : Fh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(t, e) {
                        const n = this;
                        return new Promise((function(r, i) {
                            n.load(t, r, e, i)
                        }))
                    }
                    parse() {}
                    setCrossOrigin(t) {
                        return this.crossOrigin = t, this
                    }
                    setWithCredentials(t) {
                        return this.withCredentials = t, this
                    }
                    setPath(t) {
                        return this.path = t, this
                    }
                    setResourcePath(t) {
                        return this.resourcePath = t, this
                    }
                    setRequestHeader(t) {
                        return this.requestHeader = t, this
                    }
                }
                zh.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                const Gh = {};
                class jh extends Error {
                    constructor(t, e) {
                        super(t), this.response = e
                    }
                }
                class Vh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const i = Nh.get(t);
                        if (void 0 !== i) return this.manager.itemStart(t), setTimeout((() => {
                            e && e(i), this.manager.itemEnd(t)
                        }), 0), i;
                        if (void 0 !== Gh[t]) return void Gh[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: r
                        });
                        Gh[t] = [], Gh[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: r
                        });
                        const a = new Request(t, {
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials ? "include" : "same-origin"
                            }),
                            o = this.mimeType,
                            s = this.responseType;
                        fetch(a).then((e => {
                            if (200 === e.status || 0 === e.status) {
                                if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                                const n = Gh[t],
                                    r = e.body.getReader(),
                                    i = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
                                    a = i ? parseInt(i) : 0,
                                    o = 0 !== a;
                                let s = 0;
                                const l = new ReadableStream({
                                    start(t) {
                                        ! function e() {
                                            r.read().then((({
                                                done: r,
                                                value: i
                                            }) => {
                                                if (r) t.close();
                                                else {
                                                    s += i.byteLength;
                                                    const r = new ProgressEvent("progress", {
                                                        lengthComputable: o,
                                                        loaded: s,
                                                        total: a
                                                    });
                                                    for (let t = 0, e = n.length; t < e; t++) {
                                                        const e = n[t];
                                                        e.onProgress && e.onProgress(r)
                                                    }
                                                    t.enqueue(i), e()
                                                }
                                            }))
                                        }()
                                    }
                                });
                                return new Response(l)
                            }
                            throw new jh(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                        })).then((t => {
                            switch (s) {
                                case "arraybuffer":
                                    return t.arrayBuffer();
                                case "blob":
                                    return t.blob();
                                case "document":
                                    return t.text().then((t => (new DOMParser).parseFromString(t, o)));
                                case "json":
                                    return t.json();
                                default:
                                    if (void 0 === o) return t.text();
                                    {
                                        const e = /charset="?([^;"\s]*)"?/i.exec(o),
                                            n = e && e[1] ? e[1].toLowerCase() : void 0,
                                            r = new TextDecoder(n);
                                        return t.arrayBuffer().then((t => r.decode(t)))
                                    }
                            }
                        })).then((e => {
                            Nh.add(t, e);
                            const n = Gh[t];
                            delete Gh[t];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                r.onLoad && r.onLoad(e)
                            }
                        })).catch((e => {
                            const n = Gh[t];
                            if (void 0 === n) throw this.manager.itemError(t), e;
                            delete Gh[t];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                r.onError && r.onError(e)
                            }
                            this.manager.itemError(t)
                        })).finally((() => {
                            this.manager.itemEnd(t)
                        })), this.manager.itemStart(t)
                    }
                    setResponseType(t) {
                        return this.responseType = t, this
                    }
                    setMimeType(t) {
                        return this.mimeType = t, this
                    }
                }
                class Hh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = new Vh(this.manager);
                        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(n) {
                            try {
                                e(i.parse(JSON.parse(n)))
                            } catch (e) {
                                r ? r(e) : console.error(e), i.manager.itemError(t)
                            }
                        }), n, r)
                    }
                    parse(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const r = qh.parse(t[n]);
                            e.push(r)
                        }
                        return e
                    }
                }
                class Wh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = [],
                            o = new qc,
                            s = new Vh(this.manager);
                        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials);
                        let l = 0;

                        function A(A) {
                            s.load(t[A], (function(t) {
                                const n = i.parse(t, !0);
                                a[A] = {
                                    width: n.width,
                                    height: n.height,
                                    format: n.format,
                                    mipmaps: n.mipmaps
                                }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = wt), o.image = a, o.format = n.format, o.needsUpdate = !0, e && e(o))
                            }), n, r)
                        }
                        if (Array.isArray(t))
                            for (let e = 0, n = t.length; e < n; ++e) A(e);
                        else s.load(t, (function(t) {
                            const n = i.parse(t, !0);
                            if (n.isCubemap) {
                                const t = n.mipmaps.length / n.mipmapCount;
                                for (let e = 0; e < t; e++) {
                                    a[e] = {
                                        mipmaps: []
                                    };
                                    for (let t = 0; t < n.mipmapCount; t++) a[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), a[e].format = n.format, a[e].width = n.width, a[e].height = n.height
                                }
                                o.image = a
                            } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                            1 === n.mipmapCount && (o.minFilter = wt), o.format = n.format, o.needsUpdate = !0, e && e(o)
                        }), n, r);
                        return o
                    }
                }
                class Xh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const i = this,
                            a = Nh.get(t);
                        if (void 0 !== a) return i.manager.itemStart(t), setTimeout((function() {
                            e && e(a), i.manager.itemEnd(t)
                        }), 0), a;
                        const o = sr("img");

                        function s() {
                            A(), Nh.add(t, this), e && e(this), i.manager.itemEnd(t)
                        }

                        function l(e) {
                            A(), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                        }

                        function A() {
                            o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1)
                        }
                        return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o
                    }
                }
                class Yh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = new oo;
                        i.colorSpace = Ye;
                        const a = new Xh(this.manager);
                        a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                        let o = 0;

                        function s(n) {
                            a.load(t[n], (function(t) {
                                i.images[n] = t, o++, 6 === o && (i.needsUpdate = !0, e && e(i))
                            }), void 0, r)
                        }
                        for (let e = 0; e < t.length; ++e) s(e);
                        return i
                    }
                }
                class Qh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = new FA,
                            o = new Vh(this.manager);
                        return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(t, (function(t) {
                            let n;
                            try {
                                n = i.parse(t)
                            } catch (t) {
                                if (void 0 === r) return void console.error(t);
                                r(t)
                            }
                            void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : gt, a.wrapT = void 0 !== n.wrapT ? n.wrapT : gt, a.magFilter = void 0 !== n.magFilter ? n.magFilter : wt, a.minFilter = void 0 !== n.minFilter ? n.minFilter : wt, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace && (a.colorSpace = n.colorSpace), void 0 !== n.flipY && (a.flipY = n.flipY), void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = Tt), 1 === n.mipmapCount && (a.minFilter = wt), void 0 !== n.generateMipmaps && (a.generateMipmaps = n.generateMipmaps), a.needsUpdate = !0, e && e(a, n)
                        }), n, r), a
                    }
                }
                class Zh extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = new wr,
                            a = new Xh(this.manager);
                        return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, (function(t) {
                            i.image = t, i.needsUpdate = !0, void 0 !== e && e(i)
                        }), n, r), i
                    }
                }
                class Jh extends qi {
                    constructor(t, e = 1) {
                        super(), this.isLight = !0, this.type = "Light", this.color = new Ki(t), this.intensity = e
                    }
                    dispose() {}
                    copy(t, e) {
                        return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                    }
                }
                class Kh extends Jh {
                    constructor(t, e, n) {
                        super(t, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(qi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Ki(e)
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.groundColor.copy(t.groundColor), this
                    }
                }
                const $h = new Ai,
                    td = new Ir,
                    ed = new Ir;
                class nd {
                    constructor(t) {
                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new er(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ai, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new po, this._frameExtents = new er(1, 1), this._viewportCount = 1, this._viewports = [new Sr(0, 0, 1, 1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        td.setFromMatrixPosition(t.matrixWorld), e.position.copy(td), ed.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(ed), e.updateMatrixWorld(), $h.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix($h), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply($h)
                    }
                    getViewport(t) {
                        return this._viewports[t]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                    }
                    copy(t) {
                        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    toJSON() {
                        const t = {};
                        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                    }
                }
                class rd extends nd {
                    constructor() {
                        super(new ro(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = 2 * Hn * t.angle * this.focus,
                            r = this.mapSize.width / this.mapSize.height,
                            i = t.distance || e.far;
                        n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t)
                    }
                    copy(t) {
                        return super.copy(t), this.focus = t.focus, this
                    }
                }
                class id extends Jh {
                    constructor(t, e, n = 0, r = Math.PI / 3, i = 0, a = 2) {
                        super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(qi.DEFAULT_UP), this.updateMatrix(), this.target = new qi, this.distance = n, this.angle = r, this.penumbra = i, this.decay = a, this.map = null, this.shadow = new rd
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                    }
                }
                const ad = new Ai,
                    od = new Ir,
                    sd = new Ir;
                class ld extends nd {
                    constructor() {
                        super(new ro(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new er(4, 2), this._viewportCount = 6, this._viewports = [new Sr(2, 1, 1, 1), new Sr(0, 1, 1, 1), new Sr(3, 1, 1, 1), new Sr(1, 1, 1, 1), new Sr(3, 0, 1, 1), new Sr(1, 0, 1, 1)], this._cubeDirections = [new Ir(1, 0, 0), new Ir(-1, 0, 0), new Ir(0, 0, 1), new Ir(0, 0, -1), new Ir(0, 1, 0), new Ir(0, -1, 0)], this._cubeUps = [new Ir(0, 1, 0), new Ir(0, 1, 0), new Ir(0, 1, 0), new Ir(0, 1, 0), new Ir(0, 0, 1), new Ir(0, 0, -1)]
                    }
                    updateMatrices(t, e = 0) {
                        const n = this.camera,
                            r = this.matrix,
                            i = t.distance || n.far;
                        i !== n.far && (n.far = i, n.updateProjectionMatrix()), od.setFromMatrixPosition(t.matrixWorld), n.position.copy(od), sd.copy(n.position), sd.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(sd), n.updateMatrixWorld(), r.makeTranslation(-od.x, -od.y, -od.z), ad.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ad)
                    }
                }
                class Ad extends Jh {
                    constructor(t, e, n = 0, r = 2) {
                        super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new ld
                    }
                    get power() {
                        return 4 * this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                    }
                }
                class cd extends nd {
                    constructor() {
                        super(new Lo(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                    }
                }
                class ud extends Jh {
                    constructor(t, e) {
                        super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(qi.DEFAULT_UP), this.updateMatrix(), this.target = new qi, this.shadow = new cd
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                    }
                }
                class hd extends Jh {
                    constructor(t, e) {
                        super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
                    }
                }
                class dd extends Jh {
                    constructor(t, e, n = 10, r = 10) {
                        super(t, e), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (this.width * this.height * Math.PI)
                    }
                    copy(t) {
                        return super.copy(t), this.width = t.width, this.height = t.height, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.width = this.width, e.object.height = this.height, e
                    }
                }
                class fd {
                    constructor() {
                        this.isSphericalHarmonics3 = !0, this.coefficients = [];
                        for (let t = 0; t < 9; t++) this.coefficients.push(new Ir)
                    }
                    set(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                        return this
                    }
                    zero() {
                        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                        return this
                    }
                    getAt(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z,
                            a = this.coefficients;
                        return e.copy(a[0]).multiplyScalar(.282095), e.addScaledVector(a[1], .488603 * r), e.addScaledVector(a[2], .488603 * i), e.addScaledVector(a[3], .488603 * n), e.addScaledVector(a[4], n * r * 1.092548), e.addScaledVector(a[5], r * i * 1.092548), e.addScaledVector(a[6], .315392 * (3 * i * i - 1)), e.addScaledVector(a[7], n * i * 1.092548), e.addScaledVector(a[8], .546274 * (n * n - r * r)), e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z,
                            a = this.coefficients;
                        return e.copy(a[0]).multiplyScalar(.886227), e.addScaledVector(a[1], 1.023328 * r), e.addScaledVector(a[2], 1.023328 * i), e.addScaledVector(a[3], 1.023328 * n), e.addScaledVector(a[4], .858086 * n * r), e.addScaledVector(a[5], .858086 * r * i), e.addScaledVector(a[6], .743125 * i * i - .247708), e.addScaledVector(a[7], .858086 * n * i), e.addScaledVector(a[8], .429043 * (n * n - r * r)), e
                    }
                    add(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                        return this
                    }
                    addScaledSH(t, e) {
                        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                        return this
                    }
                    scale(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                        return this
                    }
                    lerp(t, e) {
                        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                        return this
                    }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                        return !0
                    }
                    copy(t) {
                        return this.set(t.coefficients)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    fromArray(t, e = 0) {
                        const n = this.coefficients;
                        for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
                        return this
                    }
                    toArray(t = [], e = 0) {
                        const n = this.coefficients;
                        for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
                        return t
                    }
                    static getBasisAt(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z;
                        e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
                    }
                }
                class pd extends Jh {
                    constructor(t = new fd, e = 1) {
                        super(void 0, e), this.isLightProbe = !0, this.sh = t
                    }
                    copy(t) {
                        return super.copy(t), this.sh.copy(t.sh), this
                    }
                    fromJSON(t) {
                        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.sh = this.sh.toArray(), e
                    }
                }
                class md extends zh {
                    constructor(t) {
                        super(t), this.textures = {}
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = new Vh(i.manager);
                        a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, (function(n) {
                            try {
                                e(i.parse(JSON.parse(n)))
                            } catch (e) {
                                r ? r(e) : console.error(e), i.manager.itemError(t)
                            }
                        }), n, r)
                    }
                    parse(t) {
                        const e = this.textures;

                        function n(t) {
                            return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                        }
                        const r = md.createMaterialFromType(t.type);
                        if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && void 0 !== r.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = t.sheen), void 0 !== t.sheenColor && (r.sheenColor = (new Ki).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (r.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== r.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== r.specular && r.specular.setHex(t.specular), void 0 !== t.specularIntensity && (r.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.iridescence && (r.iridescence = t.iridescence), void 0 !== t.iridescenceIOR && (r.iridescenceIOR = t.iridescenceIOR), void 0 !== t.iridescenceThicknessRange && (r.iridescenceThicknessRange = t.iridescenceThicknessRange), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.thickness && (r.thickness = t.thickness), void 0 !== t.attenuationDistance && (r.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(t.attenuationColor), void 0 !== t.anisotropy && (r.anisotropy = t.anisotropy), void 0 !== t.anisotropyRotation && (r.anisotropyRotation = t.anisotropyRotation), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.shadowSide && (r.shadowSide = t.shadowSide), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.alphaHash && (r.alphaHash = t.alphaHash), void 0 !== t.depthFunc && (r.depthFunc = t.depthFunc), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.blendSrc && (r.blendSrc = t.blendSrc), void 0 !== t.blendDst && (r.blendDst = t.blendDst), void 0 !== t.blendEquation && (r.blendEquation = t.blendEquation), void 0 !== t.blendSrcAlpha && (r.blendSrcAlpha = t.blendSrcAlpha), void 0 !== t.blendDstAlpha && (r.blendDstAlpha = t.blendDstAlpha), void 0 !== t.blendEquationAlpha && (r.blendEquationAlpha = t.blendEquationAlpha), void 0 !== t.blendColor && void 0 !== r.blendColor && r.blendColor.setHex(t.blendColor), void 0 !== t.blendAlpha && (r.blendAlpha = t.blendAlpha), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), void 0 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.alphaToCoverage && (r.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (r.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.forceSinglePass && (r.forceSinglePass = t.forceSinglePass), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                            for (const e in t.uniforms) {
                                const i = t.uniforms[e];
                                switch (r.uniforms[e] = {}, i.type) {
                                    case "t":
                                        r.uniforms[e].value = n(i.value);
                                        break;
                                    case "c":
                                        r.uniforms[e].value = (new Ki).setHex(i.value);
                                        break;
                                    case "v2":
                                        r.uniforms[e].value = (new er).fromArray(i.value);
                                        break;
                                    case "v3":
                                        r.uniforms[e].value = (new Ir).fromArray(i.value);
                                        break;
                                    case "v4":
                                        r.uniforms[e].value = (new Sr).fromArray(i.value);
                                        break;
                                    case "m3":
                                        r.uniforms[e].value = (new nr).fromArray(i.value);
                                        break;
                                    case "m4":
                                        r.uniforms[e].value = (new Ai).fromArray(i.value);
                                        break;
                                    default:
                                        r.uniforms[e].value = i.value
                                }
                            }
                        if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.glslVersion && (r.glslVersion = t.glslVersion), void 0 !== t.extensions)
                            for (const e in t.extensions) r.extensions[e] = t.extensions[e];
                        if (void 0 !== t.lights && (r.lights = t.lights), void 0 !== t.clipping && (r.clipping = t.clipping), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.matcap && (r.matcap = n(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                            let e = t.normalScale;
                            !1 === Array.isArray(e) && (e = [e, e]), r.normalScale = (new er).fromArray(e)
                        }
                        return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (r.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (r.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapRotation && r.envMapRotation.fromArray(t.envMapRotation), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new er).fromArray(t.clearcoatNormalScale)), void 0 !== t.iridescenceMap && (r.iridescenceMap = n(t.iridescenceMap)), void 0 !== t.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(t.iridescenceThicknessMap)), void 0 !== t.transmissionMap && (r.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (r.thicknessMap = n(t.thicknessMap)), void 0 !== t.anisotropyMap && (r.anisotropyMap = n(t.anisotropyMap)), void 0 !== t.sheenColorMap && (r.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (r.sheenRoughnessMap = n(t.sheenRoughnessMap)), r
                    }
                    setTextures(t) {
                        return this.textures = t, this
                    }
                    static createMaterialFromType(t) {
                        return new {
                            ShadowMaterial: lh,
                            SpriteMaterial: cA,
                            RawShaderMaterial: Ah,
                            ShaderMaterial: Ka,
                            PointsMaterial: Tc,
                            MeshPhysicalMaterial: uh,
                            MeshStandardMaterial: ch,
                            MeshPhongMaterial: hh,
                            MeshToonMaterial: dh,
                            MeshNormalMaterial: fh,
                            MeshLambertMaterial: ph,
                            MeshDepthMaterial: Fl,
                            MeshDistanceMaterial: zl,
                            MeshBasicMaterial: na,
                            MeshMatcapMaterial: mh,
                            LineDashedMaterial: gh,
                            LineBasicMaterial: mc,
                            Material: ea
                        } [t]
                    }
                }
                class gd {
                    static decodeText(t) {
                        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                        let e = "";
                        for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                        try {
                            return decodeURIComponent(escape(e))
                        } catch (t) {
                            return e
                        }
                    }
                    static extractUrlBase(t) {
                        const e = t.lastIndexOf("/");
                        return -1 === e ? "./" : t.slice(0, e + 1)
                    }
                    static resolveURL(t, e) {
                        return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                    }
                }
                class vd extends Ta {
                    constructor() {
                        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                    }
                    copy(t) {
                        return super.copy(t), this.instanceCount = t.instanceCount, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                    }
                }
                class _d extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = new Vh(i.manager);
                        a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, (function(n) {
                            try {
                                e(i.parse(JSON.parse(n)))
                            } catch (e) {
                                r ? r(e) : console.error(e), i.manager.itemError(t)
                            }
                        }), n, r)
                    }
                    parse(t) {
                        const e = {},
                            n = {};

                        function r(t, r) {
                            if (void 0 !== e[r]) return e[r];
                            const i = t.interleavedBuffers[r],
                                a = function(t, e) {
                                    if (void 0 !== n[e]) return n[e];
                                    const r = t.arrayBuffers[e],
                                        i = new Uint32Array(r).buffer;
                                    return n[e] = i, i
                                }(t, i.buffer),
                                o = or(i.type, a),
                                s = new sA(o, i.stride);
                            return s.uuid = i.uuid, e[r] = s, s
                        }
                        const i = t.isInstancedBufferGeometry ? new vd : new Ta,
                            a = t.data.index;
                        if (void 0 !== a) {
                            const t = or(a.type, a.array);
                            i.setIndex(new ca(t, 1))
                        }
                        const o = t.data.attributes;
                        for (const e in o) {
                            const n = o[e];
                            let a;
                            if (n.isInterleavedBufferAttribute) {
                                const e = r(t.data, n.data);
                                a = new AA(e, n.itemSize, n.offset, n.normalized)
                            } else {
                                const t = or(n.type, n.array);
                                a = new(n.isInstancedBufferAttribute ? VA : ca)(t, n.itemSize, n.normalized)
                            }
                            void 0 !== n.name && (a.name = n.name), void 0 !== n.usage && a.setUsage(n.usage), i.setAttribute(e, a)
                        }
                        const s = t.data.morphAttributes;
                        if (s)
                            for (const e in s) {
                                const n = s[e],
                                    a = [];
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    let o;
                                    if (i.isInterleavedBufferAttribute) {
                                        const e = r(t.data, i.data);
                                        o = new AA(e, i.itemSize, i.offset, i.normalized)
                                    } else {
                                        const t = or(i.type, i.array);
                                        o = new ca(t, i.itemSize, i.normalized)
                                    }
                                    void 0 !== i.name && (o.name = i.name), a.push(o)
                                }
                                i.morphAttributes[e] = a
                            }
                        t.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                        const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (void 0 !== l)
                            for (let t = 0, e = l.length; t !== e; ++t) {
                                const e = l[t];
                                i.addGroup(e.start, e.count, e.materialIndex)
                            }
                        const A = t.data.boundingSphere;
                        if (void 0 !== A) {
                            const t = new Ir;
                            void 0 !== A.center && t.fromArray(A.center), i.boundingSphere = new ti(t, A.radius)
                        }
                        return t.name && (i.name = t.name), t.userData && (i.userData = t.userData), i
                    }
                }
                class yd extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = "" === this.path ? gd.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || a;
                        const o = new Vh(this.manager);
                        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(n) {
                            let a = null;
                            try {
                                a = JSON.parse(n)
                            } catch (e) {
                                return void 0 !== r && r(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                            }
                            const o = a.metadata;
                            if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) return void 0 !== r && r(new Error("THREE.ObjectLoader: Can't load " + t)), void console.error("THREE.ObjectLoader: Can't load " + t);
                            i.parse(a, e)
                        }), n, r)
                    }
                    async loadAsync(t, e) {
                        const n = "" === this.path ? gd.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || n;
                        const r = new Vh(this.manager);
                        r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
                        const i = await r.loadAsync(t, e),
                            a = JSON.parse(i),
                            o = a.metadata;
                        if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t);
                        return await this.parseAsync(a)
                    }
                    parse(t, e) {
                        const n = this.parseAnimations(t.animations),
                            r = this.parseShapes(t.shapes),
                            i = this.parseGeometries(t.geometries, r),
                            a = this.parseImages(t.images, (function() {
                                void 0 !== e && e(l)
                            })),
                            o = this.parseTextures(t.textures, a),
                            s = this.parseMaterials(t.materials, o),
                            l = this.parseObject(t.object, i, s, o, n),
                            A = this.parseSkeletons(t.skeletons, l);
                        if (this.bindSkeletons(l, A), void 0 !== e) {
                            let t = !1;
                            for (const e in a)
                                if (a[e].data instanceof HTMLImageElement) {
                                    t = !0;
                                    break
                                }! 1 === t && e(l)
                        }
                        return l
                    }
                    async parseAsync(t) {
                        const e = this.parseAnimations(t.animations),
                            n = this.parseShapes(t.shapes),
                            r = this.parseGeometries(t.geometries, n),
                            i = await this.parseImagesAsync(t.images),
                            a = this.parseTextures(t.textures, i),
                            o = this.parseMaterials(t.materials, a),
                            s = this.parseObject(t.object, r, o, a, e),
                            l = this.parseSkeletons(t.skeletons, s);
                        return this.bindSkeletons(s, l), s
                    }
                    parseShapes(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = (new yu).fromJSON(t[n]);
                                e[r.uuid] = r
                            }
                        return e
                    }
                    parseSkeletons(t, e) {
                        const n = {},
                            r = {};
                        if (e.traverse((function(t) {
                                t.isBone && (r[t.uuid] = t)
                            })), void 0 !== t)
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = (new jA).fromJSON(t[e], r);
                                n[i.uuid] = i
                            }
                        return n
                    }
                    parseGeometries(t, e) {
                        const n = {};
                        if (void 0 !== t) {
                            const r = new _d;
                            for (let i = 0, a = t.length; i < a; i++) {
                                let a;
                                const o = t[i];
                                switch (o.type) {
                                    case "BufferGeometry":
                                    case "InstancedBufferGeometry":
                                        a = r.parse(o);
                                        break;
                                    default:
                                        o.type in sh ? a = sh[o.type].fromJSON(o, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)
                                }
                                a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), void 0 !== o.userData && (a.userData = o.userData), n[o.uuid] = a
                            }
                        }
                        return n
                    }
                    parseMaterials(t, e) {
                        const n = {},
                            r = {};
                        if (void 0 !== t) {
                            const i = new md;
                            i.setTextures(e);
                            for (let e = 0, a = t.length; e < a; e++) {
                                const a = t[e];
                                void 0 === n[a.uuid] && (n[a.uuid] = i.parse(a)), r[a.uuid] = n[a.uuid]
                            }
                        }
                        return r
                    }
                    parseAnimations(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0; n < t.length; n++) {
                                const r = t[n],
                                    i = qh.parse(r);
                                e[i.uuid] = i
                            }
                        return e
                    }
                    parseImages(t, e) {
                        const n = this,
                            r = {};
                        let i;

                        function a(t) {
                            if ("string" == typeof t) {
                                const e = t;
                                return function(t) {
                                    return n.manager.itemStart(t), i.load(t, (function() {
                                        n.manager.itemEnd(t)
                                    }), void 0, (function() {
                                        n.manager.itemError(t), n.manager.itemEnd(t)
                                    }))
                                }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e)
                            }
                            return t.data ? {
                                data: or(t.type, t.data),
                                width: t.width,
                                height: t.height
                            } : null
                        }
                        if (void 0 !== t && t.length > 0) {
                            const n = new kh(e);
                            i = new Xh(n), i.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e],
                                    i = n.url;
                                if (Array.isArray(i)) {
                                    const t = [];
                                    for (let e = 0, n = i.length; e < n; e++) {
                                        const n = a(i[e]);
                                        null !== n && (n instanceof HTMLImageElement ? t.push(n) : t.push(new FA(n.data, n.width, n.height)))
                                    }
                                    r[n.uuid] = new xr(t)
                                } else {
                                    const t = a(n.url);
                                    r[n.uuid] = new xr(t)
                                }
                            }
                        }
                        return r
                    }
                    async parseImagesAsync(t) {
                        const e = this,
                            n = {};
                        let r;
                        async function i(t) {
                            if ("string" == typeof t) {
                                const n = t,
                                    i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : e.resourcePath + n;
                                return await r.loadAsync(i)
                            }
                            return t.data ? {
                                data: or(t.type, t.data),
                                width: t.width,
                                height: t.height
                            } : null
                        }
                        if (void 0 !== t && t.length > 0) {
                            r = new Xh(this.manager), r.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = t[e],
                                    a = r.url;
                                if (Array.isArray(a)) {
                                    const t = [];
                                    for (let e = 0, n = a.length; e < n; e++) {
                                        const n = a[e],
                                            r = await i(n);
                                        null !== r && (r instanceof HTMLImageElement ? t.push(r) : t.push(new FA(r.data, r.width, r.height)))
                                    }
                                    n[r.uuid] = new xr(t)
                                } else {
                                    const t = await i(r.url);
                                    n[r.uuid] = new xr(t)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(t, e) {
                        function n(t, e) {
                            return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                        }
                        const r = {};
                        if (void 0 !== t)
                            for (let i = 0, a = t.length; i < a; i++) {
                                const a = t[i];
                                void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                                const o = e[a.image],
                                    s = o.data;
                                let l;
                                Array.isArray(s) ? (l = new oo, 6 === s.length && (l.needsUpdate = !0)) : (l = s && s.data ? new FA : new wr, s && (l.needsUpdate = !0)), l.source = o, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = n(a.mapping, xd)), void 0 !== a.channel && (l.channel = a.channel), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = n(a.wrap[0], bd), l.wrapT = n(a.wrap[1], bd)), void 0 !== a.format && (l.format = a.format), void 0 !== a.internalFormat && (l.internalFormat = a.internalFormat), void 0 !== a.type && (l.type = a.type), void 0 !== a.colorSpace && (l.colorSpace = a.colorSpace), void 0 !== a.minFilter && (l.minFilter = n(a.minFilter, Md)), void 0 !== a.magFilter && (l.magFilter = n(a.magFilter, Md)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), void 0 !== a.generateMipmaps && (l.generateMipmaps = a.generateMipmaps), void 0 !== a.premultiplyAlpha && (l.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (l.unpackAlignment = a.unpackAlignment), void 0 !== a.compareFunction && (l.compareFunction = a.compareFunction), void 0 !== a.userData && (l.userData = a.userData), r[a.uuid] = l
                            }
                        return r
                    }
                    parseObject(t, e, n, r, i) {
                        let a, o, s;

                        function l(t) {
                            return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                        }

                        function A(t) {
                            if (void 0 !== t) {
                                if (Array.isArray(t)) {
                                    const e = [];
                                    for (let r = 0, i = t.length; r < i; r++) {
                                        const i = t[r];
                                        void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), e.push(n[i])
                                    }
                                    return e
                                }
                                return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                            }
                        }

                        function c(t) {
                            return void 0 === r[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), r[t]
                        }
                        switch (t.type) {
                            case "Scene":
                                a = new oA, void 0 !== t.background && (Number.isInteger(t.background) ? a.background = new Ki(t.background) : a.background = c(t.background)), void 0 !== t.environment && (a.environment = c(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? a.fog = new aA(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (a.fog = new iA(t.fog.color, t.fog.density)), "" !== t.fog.name && (a.fog.name = t.fog.name)), void 0 !== t.backgroundBlurriness && (a.backgroundBlurriness = t.backgroundBlurriness), void 0 !== t.backgroundIntensity && (a.backgroundIntensity = t.backgroundIntensity), void 0 !== t.backgroundRotation && a.backgroundRotation.fromArray(t.backgroundRotation), void 0 !== t.environmentRotation && a.environmentRotation.fromArray(t.environmentRotation);
                                break;
                            case "PerspectiveCamera":
                                a = new ro(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (a.focus = t.focus), void 0 !== t.zoom && (a.zoom = t.zoom), void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset), void 0 !== t.view && (a.view = Object.assign({}, t.view));
                                break;
                            case "OrthographicCamera":
                                a = new Lo(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (a.zoom = t.zoom), void 0 !== t.view && (a.view = Object.assign({}, t.view));
                                break;
                            case "AmbientLight":
                                a = new hd(t.color, t.intensity);
                                break;
                            case "DirectionalLight":
                                a = new ud(t.color, t.intensity);
                                break;
                            case "PointLight":
                                a = new Ad(t.color, t.intensity, t.distance, t.decay);
                                break;
                            case "RectAreaLight":
                                a = new dd(t.color, t.intensity, t.width, t.height);
                                break;
                            case "SpotLight":
                                a = new id(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                break;
                            case "HemisphereLight":
                                a = new Kh(t.color, t.groundColor, t.intensity);
                                break;
                            case "LightProbe":
                                a = (new pd).fromJSON(t);
                                break;
                            case "SkinnedMesh":
                                o = l(t.geometry), s = A(t.material), a = new NA(o, s), void 0 !== t.bindMode && (a.bindMode = t.bindMode), void 0 !== t.bindMatrix && a.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (a.skeleton = t.skeleton);
                                break;
                            case "Mesh":
                                o = l(t.geometry), s = A(t.material), a = new Ha(o, s);
                                break;
                            case "InstancedMesh":
                                o = l(t.geometry), s = A(t.material);
                                const e = t.count,
                                    n = t.instanceMatrix,
                                    r = t.instanceColor;
                                a = new KA(o, s, e), a.instanceMatrix = new VA(new Float32Array(n.array), 16), void 0 !== r && (a.instanceColor = new VA(new Float32Array(r.array), r.itemSize));
                                break;
                            case "BatchedMesh":
                                o = l(t.geometry), s = A(t.material), a = new pc(t.maxGeometryCount, t.maxVertexCount, t.maxIndexCount, s), a.geometry = o, a.perObjectFrustumCulled = t.perObjectFrustumCulled, a.sortObjects = t.sortObjects, a._drawRanges = t.drawRanges, a._reservedRanges = t.reservedRanges, a._visibility = t.visibility, a._active = t.active, a._bounds = t.bounds.map((t => {
                                    const e = new qr;
                                    e.min.fromArray(t.boxMin), e.max.fromArray(t.boxMax);
                                    const n = new ti;
                                    return n.radius = t.sphereRadius, n.center.fromArray(t.sphereCenter), {
                                        boxInitialized: t.boxInitialized,
                                        box: e,
                                        sphereInitialized: t.sphereInitialized,
                                        sphere: n
                                    }
                                })), a._maxGeometryCount = t.maxGeometryCount, a._maxVertexCount = t.maxVertexCount, a._maxIndexCount = t.maxIndexCount, a._geometryInitialized = t.geometryInitialized, a._geometryCount = t.geometryCount, a._matricesTexture = c(t.matricesTexture.uuid);
                                break;
                            case "LOD":
                                a = new CA;
                                break;
                            case "Line":
                                a = new bc(l(t.geometry), A(t.material));
                                break;
                            case "LineLoop":
                                a = new Ec(l(t.geometry), A(t.material));
                                break;
                            case "LineSegments":
                                a = new Sc(l(t.geometry), A(t.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                a = new Dc(l(t.geometry), A(t.material));
                                break;
                            case "Sprite":
                                a = new wA(A(t.material));
                                break;
                            case "Group":
                                a = new Xl;
                                break;
                            case "Bone":
                                a = new kA;
                                break;
                            default:
                                a = new qi
                        }
                        if (a.uuid = t.uuid, void 0 !== t.name && (a.name = t.name), void 0 !== t.matrix ? (a.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (a.matrixAutoUpdate = t.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== t.position && a.position.fromArray(t.position), void 0 !== t.rotation && a.rotation.fromArray(t.rotation), void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion), void 0 !== t.scale && a.scale.fromArray(t.scale)), void 0 !== t.up && a.up.fromArray(t.up), void 0 !== t.castShadow && (a.castShadow = t.castShadow), void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (a.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && a.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (a.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (a.visible = t.visible), void 0 !== t.frustumCulled && (a.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (a.renderOrder = t.renderOrder), void 0 !== t.userData && (a.userData = t.userData), void 0 !== t.layers && (a.layers.mask = t.layers), void 0 !== t.children) {
                            const o = t.children;
                            for (let t = 0; t < o.length; t++) a.add(this.parseObject(o[t], e, n, r, i))
                        }
                        if (void 0 !== t.animations) {
                            const e = t.animations;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t];
                                a.animations.push(i[n])
                            }
                        }
                        if ("LOD" === t.type) {
                            void 0 !== t.autoUpdate && (a.autoUpdate = t.autoUpdate);
                            const e = t.levels;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t],
                                    r = a.getObjectByProperty("uuid", n.object);
                                void 0 !== r && a.addLevel(r, n.distance, n.hysteresis)
                            }
                        }
                        return a
                    }
                    bindSkeletons(t, e) {
                        0 !== Object.keys(e).length && t.traverse((function(t) {
                            if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                                const n = e[t.skeleton];
                                void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
                            }
                        }))
                    }
                }
                const xd = {
                        UVMapping: ct,
                        CubeReflectionMapping: ut,
                        CubeRefractionMapping: ht,
                        EquirectangularReflectionMapping: dt,
                        EquirectangularRefractionMapping: ft,
                        CubeUVReflectionMapping: pt
                    },
                    bd = {
                        RepeatWrapping: mt,
                        ClampToEdgeWrapping: gt,
                        MirroredRepeatWrapping: vt
                    },
                    Md = {
                        NearestFilter: _t,
                        NearestMipmapNearestFilter: yt,
                        NearestMipmapLinearFilter: bt,
                        LinearFilter: wt,
                        LinearMipmapNearestFilter: St,
                        LinearMipmapLinearFilter: Tt
                    };
                class wd extends zh {
                    constructor(t) {
                        super(t), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                            premultiplyAlpha: "none"
                        }
                    }
                    setOptions(t) {
                        return this.options = t, this
                    }
                    load(t, e, n, r) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const i = this,
                            a = Nh.get(t);
                        if (void 0 !== a) return i.manager.itemStart(t), a.then ? void a.then((n => {
                            e && e(n), i.manager.itemEnd(t)
                        })).catch((t => {
                            r && r(t)
                        })) : (setTimeout((function() {
                            e && e(a), i.manager.itemEnd(t)
                        }), 0), a);
                        const o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader;
                        const s = fetch(t, o).then((function(t) {
                            return t.blob()
                        })).then((function(t) {
                            return createImageBitmap(t, Object.assign(i.options, {
                                colorSpaceConversion: "none"
                            }))
                        })).then((function(n) {
                            return Nh.add(t, n), e && e(n), i.manager.itemEnd(t), n
                        })).catch((function(e) {
                            r && r(e), Nh.remove(t), i.manager.itemError(t), i.manager.itemEnd(t)
                        }));
                        Nh.add(t, s), i.manager.itemStart(t)
                    }
                }
                let Sd;
                class Ed {
                    static getContext() {
                        return void 0 === Sd && (Sd = new(window.AudioContext || window.webkitAudioContext)), Sd
                    }
                    static setContext(t) {
                        Sd = t
                    }
                }
                class Td extends zh {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            a = new Vh(this.manager);

                        function o(e) {
                            r ? r(e) : console.error(e), i.manager.itemError(t)
                        }
                        a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(t) {
                            try {
                                const n = t.slice(0);
                                Ed.getContext().decodeAudioData(n, (function(t) {
                                    e(t)
                                })).catch(o)
                            } catch (t) {
                                o(t)
                            }
                        }), n, r)
                    }
                }
                const Cd = new Ai,
                    Rd = new Ai,
                    Pd = new Ai;
                class Ld {
                    constructor() {
                        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ro, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ro, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(t) {
                        const e = this._cache;
                        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, Pd.copy(t.projectionMatrix);
                            const n = e.eyeSep / 2,
                                r = n * e.near / e.focus,
                                i = e.near * Math.tan(Vn * e.fov * .5) / e.zoom;
                            let a, o;
                            Rd.elements[12] = -n, Cd.elements[12] = n, a = -i * e.aspect + r, o = i * e.aspect + r, Pd.elements[0] = 2 * e.near / (o - a), Pd.elements[8] = (o + a) / (o - a), this.cameraL.projectionMatrix.copy(Pd), a = -i * e.aspect - r, o = i * e.aspect - r, Pd.elements[0] = 2 * e.near / (o - a), Pd.elements[8] = (o + a) / (o - a), this.cameraR.projectionMatrix.copy(Pd)
                        }
                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Rd), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Cd)
                    }
                }
                class Dd {
                    constructor(t = !0) {
                        this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                    }
                    start() {
                        this.startTime = Id(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(), this.running = !1, this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(), this.elapsedTime
                    }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            const e = Id();
                            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                        }
                        return t
                    }
                }

                function Id() {
                    return ("undefined" == typeof performance ? Date : performance).now()
                }
                const Od = new Ir,
                    Bd = new Dr,
                    qd = new Ir,
                    Ud = new Ir;
                class Nd extends qi {
                    constructor() {
                        super(), this.type = "AudioListener", this.context = Ed.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Dd
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(t) {
                        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t);
                        const e = this.context.listener,
                            n = this.up;
                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Od, Bd, qd), Ud.set(0, 0, -1).applyQuaternion(Bd), e.positionX) {
                            const t = this.context.currentTime + this.timeDelta;
                            e.positionX.linearRampToValueAtTime(Od.x, t), e.positionY.linearRampToValueAtTime(Od.y, t), e.positionZ.linearRampToValueAtTime(Od.z, t), e.forwardX.linearRampToValueAtTime(Ud.x, t), e.forwardY.linearRampToValueAtTime(Ud.y, t), e.forwardZ.linearRampToValueAtTime(Ud.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
                        } else e.setPosition(Od.x, Od.y, Od.z), e.setOrientation(Ud.x, Ud.y, Ud.z, n.x, n.y, n.z)
                    }
                }
                class kd extends qi {
                    constructor(t) {
                        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                    }
                    setMediaElementSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                    }
                    setMediaStreamSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                    }
                    setBuffer(t) {
                        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                    }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return this._progress = 0, null !== this.source && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this._connected = !0, this
                    }
                    disconnect() {
                        if (!1 !== this._connected) {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                                this.filters[this.filters.length - 1].disconnect(this.getOutput())
                            } else this.source.disconnect(this.getOutput());
                            return this._connected = !1, this
                        }
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(t) {
                        return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                    }
                    setDetune(t) {
                        return this.detune = t, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(t) {
                        return this.setFilters(t ? [t] : [])
                    }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1
                    }
                    getLoop() {
                        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                    }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(t) {
                        return this.loopStart = t, this
                    }
                    setLoopEnd(t) {
                        return this.loopEnd = t, this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                }
                const Fd = new Ir,
                    zd = new Dr,
                    Gd = new Ir,
                    jd = new Ir;
                class Vd extends kd {
                    constructor(t) {
                        super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                    }
                    connect() {
                        super.connect(), this.panner.connect(this.gain)
                    }
                    disconnect() {
                        super.disconnect(), this.panner.disconnect(this.gain)
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(t) {
                        return this.panner.refDistance = t, this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(t) {
                        return this.panner.rolloffFactor = t, this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(t) {
                        return this.panner.distanceModel = t, this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(t) {
                        return this.panner.maxDistance = t, this
                    }
                    setDirectionalCone(t, e, n) {
                        return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                    }
                    updateMatrixWorld(t) {
                        if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                        this.matrixWorld.decompose(Fd, zd, Gd), jd.set(0, 0, 1).applyQuaternion(zd);
                        const e = this.panner;
                        if (e.positionX) {
                            const t = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(Fd.x, t), e.positionY.linearRampToValueAtTime(Fd.y, t), e.positionZ.linearRampToValueAtTime(Fd.z, t), e.orientationX.linearRampToValueAtTime(jd.x, t), e.orientationY.linearRampToValueAtTime(jd.y, t), e.orientationZ.linearRampToValueAtTime(jd.z, t)
                        } else e.setPosition(Fd.x, Fd.y, Fd.z), e.setOrientation(jd.x, jd.y, jd.z)
                    }
                }
                class Hd {
                    constructor(t, e = 2048) {
                        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data), this.data
                    }
                    getAverageFrequency() {
                        let t = 0;
                        const e = this.getFrequencyData();
                        for (let n = 0; n < e.length; n++) t += e[n];
                        return t / e.length
                    }
                }
                class Wd {
                    constructor(t, e, n) {
                        let r, i, a;
                        switch (this.binding = t, this.valueSize = n, e) {
                            case "quaternion":
                                r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                                break;
                            default:
                                r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                        }
                        this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            r = this.valueSize,
                            i = t * r + r;
                        let a = this.cumulativeWeight;
                        if (0 === a) {
                            for (let t = 0; t !== r; ++t) n[i + t] = n[t];
                            a = e
                        } else {
                            a += e;
                            const t = e / a;
                            this._mixBufferRegion(n, i, 0, t, r)
                        }
                        this.cumulativeWeight = a
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            r = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            r = t * e + e,
                            i = this.cumulativeWeight,
                            a = this.cumulativeWeightAdditive,
                            o = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, r, t, 1 - i, e)
                        }
                        a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
                        for (let t = e, i = e + e; t !== i; ++t)
                            if (n[t] !== n[t + e]) {
                                o.setValue(n, r);
                                break
                            }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            r = n * this._origIndex;
                        t.getValue(e, r);
                        for (let t = n, i = r; t !== i; ++t) e[t] = e[r + t % n];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, r, i) {
                        if (r >= .5)
                            for (let r = 0; r !== i; ++r) t[e + r] = t[n + r]
                    }
                    _slerp(t, e, n, r) {
                        Dr.slerpFlat(t, e, t, e, t, n, r)
                    }
                    _slerpAdditive(t, e, n, r, i) {
                        const a = this._workIndex * i;
                        Dr.multiplyQuaternionsFlat(t, a, t, e, t, n), Dr.slerpFlat(t, e, t, e, t, a, r)
                    }
                    _lerp(t, e, n, r, i) {
                        const a = 1 - r;
                        for (let o = 0; o !== i; ++o) {
                            const i = e + o;
                            t[i] = t[i] * a + t[n + o] * r
                        }
                    }
                    _lerpAdditive(t, e, n, r, i) {
                        for (let a = 0; a !== i; ++a) {
                            const i = e + a;
                            t[i] = t[i] + t[n + a] * r
                        }
                    }
                }
                const Xd = "\\[\\]\\.:\\/",
                    Yd = new RegExp("[" + Xd + "]", "g"),
                    Qd = "[^" + Xd + "]",
                    Zd = "[^" + Xd.replace("\\.", "") + "]",
                    Jd = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Qd) + /(WCOD+)?/.source.replace("WCOD", Zd) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Qd) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Qd) + "$"),
                    Kd = ["material", "materials", "bones", "map"];
                class $d {
                    constructor(t, e, n) {
                        this.path = e, this.parsedPath = n || $d.parseTrackName(e), this.node = $d.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                    static create(t, e, n) {
                        return t && t.isAnimationObjectGroup ? new $d.Composite(t, e, n) : new $d(t, e, n)
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(Yd, "")
                    }
                    static parseTrackName(t) {
                        const e = Jd.exec(t);
                        if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6]
                            },
                            r = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== r && -1 !== r) {
                            const t = n.nodeName.substring(r + 1); - 1 !== Kd.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                    static findNode(t, e) {
                        if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            const n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n
                        }
                        if (t.children) {
                            const n = function(t) {
                                    for (let r = 0; r < t.length; r++) {
                                        const i = t[r];
                                        if (i.name === e || i.uuid === e) return i;
                                        const a = n(i.children);
                                        if (a) return a
                                    }
                                    return null
                                },
                                r = n(t.children);
                            if (r) return r
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) {
                        t[e] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
                    }
                    _getValue_arrayElement(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }
                    _setValue_direct(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }
                    _setValue_direct_setNeedsUpdate(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
                    }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }
                    _setValue_fromArray_setNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(t, e) {
                        this.bind(), this.getValue(t, e)
                    }
                    _setValue_unbound(t, e) {
                        this.bind(), this.setValue(t, e)
                    }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            r = e.propertyName;
                        let i = e.propertyIndex;
                        if (t || (t = $d.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                        if (n) {
                            let r = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === r) {
                                            r = e;
                                            break
                                        } break;
                                case "map":
                                    if ("map" in t) {
                                        t = t.map;
                                        break
                                    }
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    t = t.material.map;
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== r) {
                                if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[r]
                            }
                        }
                        const a = t[r];
                        if (void 0 === a) {
                            const n = e.nodeName;
                            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                        }
                        let o = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let s = this.BindingType.Direct;
                        if (void 0 !== i) {
                            if ("morphTargetInfluences" === r) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                            }
                            s = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = i
                        } else void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][o]
                    }
                    unbind() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }
                $d.Composite = class {
                    constructor(t, e, n) {
                        const r = n || $d.parseTrackName(e);
                        this._targetGroup = t, this._bindings = t.subscribe_(e, r)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            r = this._bindings[n];
                        void 0 !== r && r.getValue(t, e)
                    }
                    setValue(t, e) {
                        const n = this._bindings;
                        for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
                    }
                    bind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                    }
                    unbind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                    }
                }, $d.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                }, $d.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                }, $d.prototype.GetterByBindingType = [$d.prototype._getValue_direct, $d.prototype._getValue_array, $d.prototype._getValue_arrayElement, $d.prototype._getValue_toArray], $d.prototype.SetterByBindingTypeAndVersioning = [
                    [$d.prototype._setValue_direct, $d.prototype._setValue_direct_setNeedsUpdate, $d.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [$d.prototype._setValue_array, $d.prototype._setValue_array_setNeedsUpdate, $d.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [$d.prototype._setValue_arrayElement, $d.prototype._setValue_arrayElement_setNeedsUpdate, $d.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [$d.prototype._setValue_fromArray, $d.prototype._setValue_fromArray_setNeedsUpdate, $d.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                ];
                class tf {
                    constructor() {
                        this.isAnimationObjectGroup = !0, this.uuid = Wn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                        const t = {};
                        this._indicesByUUID = t;
                        for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                        const e = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return e._objects.length
                                },
                                get inUse() {
                                    return this.total - e.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return e._bindings.length
                            }
                        }
                    }
                    add() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._paths,
                            r = this._parsedPaths,
                            i = this._bindings,
                            a = i.length;
                        let o, s = t.length,
                            l = this.nCachedObjects_;
                        for (let A = 0, c = arguments.length; A !== c; ++A) {
                            const c = arguments[A],
                                u = c.uuid;
                            let h = e[u];
                            if (void 0 === h) {
                                h = s++, e[u] = h, t.push(c);
                                for (let t = 0, e = a; t !== e; ++t) i[t].push(new $d(c, n[t], r[t]))
                            } else if (h < l) {
                                o = t[h];
                                const s = --l,
                                    A = t[s];
                                e[A.uuid] = h, t[h] = A, e[u] = s, t[s] = c;
                                for (let t = 0, e = a; t !== e; ++t) {
                                    const e = i[t],
                                        a = e[s];
                                    let o = e[h];
                                    e[h] = a, void 0 === o && (o = new $d(c, n[t], r[t])), e[s] = o
                                }
                            } else t[h] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = l
                    }
                    remove() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            r = n.length;
                        let i = this.nCachedObjects_;
                        for (let a = 0, o = arguments.length; a !== o; ++a) {
                            const o = arguments[a],
                                s = o.uuid,
                                l = e[s];
                            if (void 0 !== l && l >= i) {
                                const a = i++,
                                    A = t[a];
                                e[A.uuid] = l, t[l] = A, e[s] = a, t[a] = o;
                                for (let t = 0, e = r; t !== e; ++t) {
                                    const e = n[t],
                                        r = e[a],
                                        i = e[l];
                                    e[l] = r, e[a] = i
                                }
                            }
                        }
                        this.nCachedObjects_ = i
                    }
                    uncache() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            r = n.length;
                        let i = this.nCachedObjects_,
                            a = t.length;
                        for (let o = 0, s = arguments.length; o !== s; ++o) {
                            const s = arguments[o].uuid,
                                l = e[s];
                            if (void 0 !== l)
                                if (delete e[s], l < i) {
                                    const o = --i,
                                        s = t[o],
                                        A = --a,
                                        c = t[A];
                                    e[s.uuid] = l, t[l] = s, e[c.uuid] = o, t[o] = c, t.pop();
                                    for (let t = 0, e = r; t !== e; ++t) {
                                        const e = n[t],
                                            r = e[o],
                                            i = e[A];
                                        e[l] = r, e[o] = i, e.pop()
                                    }
                                } else {
                                    const i = --a,
                                        o = t[i];
                                    i > 0 && (e[o.uuid] = l), t[l] = o, t.pop();
                                    for (let t = 0, e = r; t !== e; ++t) {
                                        const e = n[t];
                                        e[l] = e[i], e.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = i
                    }
                    subscribe_(t, e) {
                        const n = this._bindingsIndicesByPath;
                        let r = n[t];
                        const i = this._bindings;
                        if (void 0 !== r) return i[r];
                        const a = this._paths,
                            o = this._parsedPaths,
                            s = this._objects,
                            l = s.length,
                            A = this.nCachedObjects_,
                            c = new Array(l);
                        r = i.length, n[t] = r, a.push(t), o.push(e), i.push(c);
                        for (let n = A, r = s.length; n !== r; ++n) {
                            const r = s[n];
                            c[n] = new $d(r, t, e)
                        }
                        return c
                    }
                    unsubscribe_(t) {
                        const e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            const r = this._paths,
                                i = this._parsedPaths,
                                a = this._bindings,
                                o = a.length - 1,
                                s = a[o];
                            e[t[o]] = n, a[n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop()
                        }
                    }
                }
                class ef {
                    constructor(t, e, n = null, r = e.blendMode) {
                        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
                        const i = e.tracks,
                            a = i.length,
                            o = new Array(a),
                            s = {
                                endingStart: Be,
                                endingEnd: Be
                            };
                        for (let t = 0; t !== a; ++t) {
                            const e = i[t].createInterpolant(null);
                            o[t] = e, e.settings = s
                        }
                        this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Pe, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this), this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this), this.reset()
                    }
                    reset() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(t) {
                        return this._startTime = t, this
                    }
                    setLoop(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    }
                    setEffectiveWeight(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(t) {
                        return this._scheduleFading(t, 0, 1)
                    }
                    fadeOut(t) {
                        return this._scheduleFading(t, 1, 0)
                    }
                    crossFadeFrom(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            const n = this._clip.duration,
                                r = t._clip.duration,
                                i = r / n,
                                a = n / r;
                            t.warp(1, i, e), this.warp(a, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n) {
                        return t.crossFadeFrom(this, e, n)
                    }
                    stopFading() {
                        const t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    }
                    setEffectiveTimeScale(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    }
                    syncWith(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    }
                    halt(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    }
                    warp(t, e, n) {
                        const r = this._mixer,
                            i = r.time,
                            a = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        const s = o.parameterPositions,
                            l = o.sampleValues;
                        return s[0] = i, s[1] = i + n, l[0] = t / a, l[1] = e / a, this
                    }
                    stopWarping() {
                        const t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(t, e, n, r) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const i = this._startTime;
                        if (null !== i) {
                            const r = (t - i) * n;
                            r < 0 || 0 === n ? e = 0 : (this._startTime = null, e = n * r)
                        }
                        e *= this._updateTimeScale(t);
                        const a = this._updateTime(e),
                            o = this._updateWeight(t);
                        if (o > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            if (this.blendMode === ke)
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(a), e[n].accumulateAdditive(o);
                            else
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(a), e[n].accumulate(r, o)
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const r = n.evaluate(t)[0];
                                e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                        }
                        return this._effectiveTimeScale = e, e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let r = this.time + t,
                            i = this._loopCount;
                        const a = n === Le;
                        if (0 === t) return -1 === i ? r : a && 1 == (1 & i) ? e - r : r;
                        if (n === Re) {
                            -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (r >= e) r = e;
                                else {
                                    if (!(r < 0)) {
                                        this.time = r;
                                        break t
                                    }
                                    r = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = r,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= e || r < 0) {
                                const n = Math.floor(r / e);
                                r -= e * n, i += Math.abs(n);
                                const o = this.repetitions - i;
                                if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === o) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, a)
                                    } else this._setEndings(!1, !1, a);
                                    this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: n
                                    })
                                }
                            } else this.time = r;
                            if (a && 1 == (1 & i)) return e - r
                        }
                        return r
                    }
                    _setEndings(t, e, n) {
                        const r = this._interpolantSettings;
                        n ? (r.endingStart = qe, r.endingEnd = qe) : (r.endingStart = t ? this.zeroSlopeAtStart ? qe : Be : Ue, r.endingEnd = e ? this.zeroSlopeAtEnd ? qe : Be : Ue)
                    }
                    _scheduleFading(t, e, n) {
                        const r = this._mixer,
                            i = r.time;
                        let a = this._weightInterpolant;
                        null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
                        const o = a.parameterPositions,
                            s = a.sampleValues;
                        return o[0] = i, s[0] = e, o[1] = i + t, s[1] = n, this
                    }
                }
                const nf = new Float32Array(1);
                class rf extends zn {
                    constructor(t) {
                        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                    }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            r = t._clip.tracks,
                            i = r.length,
                            a = t._propertyBindings,
                            o = t._interpolants,
                            s = n.uuid,
                            l = this._bindingsByRootAndName;
                        let A = l[s];
                        void 0 === A && (A = {}, l[s] = A);
                        for (let t = 0; t !== i; ++t) {
                            const i = r[t],
                                l = i.name;
                            let c = A[l];
                            if (void 0 !== c) ++c.referenceCount, a[t] = c;
                            else {
                                if (c = a[t], void 0 !== c) {
                                    null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, s, l));
                                    continue
                                }
                                const r = e && e._propertyBindings[t].binding.parsedPath;
                                c = new Wd($d.create(n, l, r), i.ValueTypeName, i.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, s, l), a[t] = c
                            }
                            o[t].resultBuffer = c.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    r = this._actionsByClip[n];
                                this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(t) {
                        const e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    }
                    _addInactiveAction(t, e, n) {
                        const r = this._actions,
                            i = this._actionsByClip;
                        let a = i[e];
                        if (void 0 === a) a = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, i[e] = a;
                        else {
                            const e = a.knownActions;
                            t._byClipCacheIndex = e.length, e.push(t)
                        }
                        t._cacheIndex = r.length, r.push(t), a.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            r = t._cacheIndex;
                        n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                        const i = t._clip.uuid,
                            a = this._actionsByClip,
                            o = a[i],
                            s = o.knownActions,
                            l = s[s.length - 1],
                            A = t._byClipCacheIndex;
                        l._byClipCacheIndex = A, s[A] = l, s.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.referenceCount && this._removeInactiveBinding(n)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            r = this._nActiveActions++,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            r = --this._nActiveActions,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _addInactiveBinding(t, e, n) {
                        const r = this._bindingsByRootAndName,
                            i = this._bindings;
                        let a = r[e];
                        void 0 === a && (a = {}, r[e] = a), a[n] = t, t._cacheIndex = i.length, i.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            r = n.rootNode.uuid,
                            i = n.path,
                            a = this._bindingsByRootAndName,
                            o = a[r],
                            s = e[e.length - 1],
                            l = t._cacheIndex;
                        s._cacheIndex = l, e[l] = s, e.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r]
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            r = this._nActiveBindings++,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            r = --this._nActiveBindings,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return void 0 === n && (n = new Eh(new Float32Array(2), new Float32Array(2), 1, nf), n.__cacheIndex = e, t[e] = n), n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            r = --this._nActiveControlInterpolants,
                            i = e[r];
                        t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
                    }
                    clipAction(t, e, n) {
                        const r = e || this._root,
                            i = r.uuid;
                        let a = "string" == typeof t ? qh.findByName(r, t) : t;
                        const o = null !== a ? a.uuid : t,
                            s = this._actionsByClip[o];
                        let l = null;
                        if (void 0 === n && (n = null !== a ? a.blendMode : Ne), void 0 !== s) {
                            const t = s.actionByRoot[i];
                            if (void 0 !== t && t.blendMode === n) return t;
                            l = s.knownActions[0], null === a && (a = l._clip)
                        }
                        if (null === a) return null;
                        const A = new ef(this, a, e, n);
                        return this._bindAction(A, l), this._addInactiveAction(A, o, i), A
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            r = n.uuid,
                            i = "string" == typeof t ? qh.findByName(n, t) : t,
                            a = i ? i.uuid : t,
                            o = this._actionsByClip[a];
                        return void 0 !== o && o.actionByRoot[r] || null
                    }
                    stopAllAction() {
                        const t = this._actions;
                        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                        return this
                    }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            r = this.time += t,
                            i = Math.sign(t),
                            a = this._accuIndex ^= 1;
                        for (let o = 0; o !== n; ++o) e[o]._update(r, t, i, a);
                        const o = this._bindings,
                            s = this._nActiveBindings;
                        for (let t = 0; t !== s; ++t) o[t].apply(a);
                        return this
                    }
                    setTime(t) {
                        this.time = 0;
                        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                        return this.update(t)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            r = this._actionsByClip,
                            i = r[n];
                        if (void 0 !== i) {
                            const t = i.knownActions;
                            for (let n = 0, r = t.length; n !== r; ++n) {
                                const r = t[n];
                                this._deactivateAction(r);
                                const i = r._cacheIndex,
                                    a = e[e.length - 1];
                                r._cacheIndex = null, r._byClipCacheIndex = null, a._cacheIndex = i, e[i] = a, e.pop(), this._removeInactiveBindingsForAction(r)
                            }
                            delete r[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const t in n) {
                            const r = n[t].actionByRoot[e];
                            void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                        }
                        const r = this._bindingsByRootAndName[e];
                        if (void 0 !== r)
                            for (const t in r) {
                                const e = r[t];
                                e.restoreOriginalState(), this._removeInactiveBinding(e)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }
                class af {
                    constructor(t) {
                        this.value = t
                    }
                    clone() {
                        return new af(void 0 === this.value.clone ? this.value : this.value.clone())
                    }
                }
                let of = 0;
                class sf extends zn {
                    constructor() {
                        super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                            value: of ++
                        }), this.name = "", this.usage = Tn, this.uniforms = []
                    }
                    add(t) {
                        return this.uniforms.push(t), this
                    }
                    remove(t) {
                        const e = this.uniforms.indexOf(t);
                        return -1 !== e && this.uniforms.splice(e, 1), this
                    }
                    setName(t) {
                        return this.name = t, this
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    dispose() {
                        return this.dispatchEvent({
                            type: "dispose"
                        }), this
                    }
                    copy(t) {
                        this.name = t.name, this.usage = t.usage;
                        const e = t.uniforms;
                        this.uniforms.length = 0;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = Array.isArray(e[t]) ? e[t] : [e[t]];
                            for (let t = 0; t < n.length; t++) this.uniforms.push(n[t].clone())
                        }
                        return this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class lf extends sA {
                    constructor(t, e, n = 1) {
                        super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
                    }
                    copy(t) {
                        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                    clone(t) {
                        const e = super.clone(t);
                        return e.meshPerAttribute = this.meshPerAttribute, e
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                    }
                }
                class Af {
                    constructor(t, e, n, r, i) {
                        this.isGLBufferAttribute = !0, this.name = "", this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setBuffer(t) {
                        return this.buffer = t, this
                    }
                    setType(t, e) {
                        return this.type = t, this.elementSize = e, this
                    }
                    setItemSize(t) {
                        return this.itemSize = t, this
                    }
                    setCount(t) {
                        return this.count = t, this
                    }
                }
                const cf = new Ai;
                class uf {
                    constructor(t, e, n = 0, r = 1 / 0) {
                        this.ray = new li(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new yi, this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(t, e) {
                        this.ray.set(t, e)
                    }
                    setFromCamera(t, e) {
                        e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                    }
                    setFromXRController(t) {
                        return cf.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(cf), this
                    }
                    intersectObject(t, e = !0, n = []) {
                        return df(t, this, n, e), n.sort(hf), n
                    }
                    intersectObjects(t, e = !0, n = []) {
                        for (let r = 0, i = t.length; r < i; r++) df(t[r], this, n, e);
                        return n.sort(hf), n
                    }
                }

                function hf(t, e) {
                    return t.distance - e.distance
                }

                function df(t, e, n, r) {
                    if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) {
                        const r = t.children;
                        for (let t = 0, i = r.length; t < i; t++) df(r[t], e, n, !0)
                    }
                }
                class ff {
                    constructor(t = 1, e = 0, n = 0) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    }
                    set(t, e, n) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    }
                    copy(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    }
                    makeSafe() {
                        const t = 1e-6;
                        return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Xn(e / this.radius, -1, 1))), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class pf {
                    constructor(t = 1, e = 0, n = 0) {
                        return this.radius = t, this.theta = e, this.y = n, this
                    }
                    set(t, e, n) {
                        return this.radius = t, this.theta = e, this.y = n, this
                    }
                    copy(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const mf = new er;
                class gf {
                    constructor(t = new er(1 / 0, 1 / 0), e = new er(-1 / 0, -1 / 0)) {
                        this.isBox2 = !0, this.min = t, this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = mf.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(t) {
                        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                    containsPoint(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    }
                    getParameter(t, e) {
                        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return this.clampPoint(t, mf).distanceTo(t)
                    }
                    intersect(t) {
                        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                const vf = new Ir,
                    _f = new Ir;
                class yf {
                    constructor(t = new Ir, e = new Ir) {
                        this.start = t, this.end = e
                    }
                    set(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    }
                    copy(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    }
                    getCenter(t) {
                        return t.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(t) {
                        return t.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(t, e) {
                        return this.delta(e).multiplyScalar(t).add(this.start)
                    }
                    closestPointToPointParameter(t, e) {
                        vf.subVectors(t, this.start), _f.subVectors(this.end, this.start);
                        const n = _f.dot(_f);
                        let r = _f.dot(vf) / n;
                        return e && (r = Xn(r, 0, 1)), r
                    }
                    closestPointToPoint(t, e, n) {
                        const r = this.closestPointToPointParameter(t, e);
                        return this.delta(n).multiplyScalar(r).add(this.start)
                    }
                    applyMatrix4(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    }
                    equals(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const xf = new Ir;
                class bf extends qi {
                    constructor(t, e) {
                        super(), this.light = t, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
                        const n = new Ta,
                            r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                            const i = t / n * Math.PI * 2,
                                a = e / n * Math.PI * 2;
                            r.push(Math.cos(i), Math.sin(i), 1, Math.cos(a), Math.sin(a), 1)
                        }
                        n.setAttribute("position", new _a(r, 3));
                        const i = new mc({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new Sc(n, i), this.add(this.cone), this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(), this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
                        const t = this.light.distance ? this.light.distance : 1e3,
                            e = t * Math.tan(this.light.angle);
                        this.cone.scale.set(e, e, t), xf.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(xf), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                const Mf = new Ir,
                    wf = new Ai,
                    Sf = new Ai;
                class Ef extends Sc {
                    constructor(t) {
                        const e = Tf(t),
                            n = new Ta,
                            r = [],
                            i = [],
                            a = new Ki(0, 0, 1),
                            o = new Ki(0, 1, 0);
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(o.r, o.g, o.b))
                        }
                        n.setAttribute("position", new _a(r, 3)), n.setAttribute("color", new _a(i, 3)), super(n, new mc({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            r = n.getAttribute("position");
                        Sf.copy(this.root.matrixWorld).invert();
                        for (let t = 0, n = 0; t < e.length; t++) {
                            const i = e[t];
                            i.parent && i.parent.isBone && (wf.multiplyMatrices(Sf, i.matrixWorld), Mf.setFromMatrixPosition(wf), r.setXYZ(n, Mf.x, Mf.y, Mf.z), wf.multiplyMatrices(Sf, i.parent.matrixWorld), Mf.setFromMatrixPosition(wf), r.setXYZ(n + 1, Mf.x, Mf.y, Mf.z), n += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }

                function Tf(t) {
                    const e = [];
                    !0 === t.isBone && e.push(t);
                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, Tf(t.children[n]));
                    return e
                }
                class Cf extends Ha {
                    constructor(t, e, n) {
                        super(new th(e, 4, 2), new na({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        })), this.light = t, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                const Rf = new Ir,
                    Pf = new Ki,
                    Lf = new Ki;
                class Df extends qi {
                    constructor(t, e, n) {
                        super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
                        const r = new Ju(e);
                        r.rotateY(.5 * Math.PI), this.material = new na({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }), void 0 === this.color && (this.material.vertexColors = !0);
                        const i = r.getAttribute("position"),
                            a = new Float32Array(3 * i.count);
                        r.setAttribute("color", new ca(a, 3)), this.add(new Ha(r, this.material)), this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(), this.children[0].material.dispose()
                    }
                    update() {
                        const t = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            const e = t.geometry.getAttribute("color");
                            Pf.copy(this.light.color), Lf.copy(this.light.groundColor);
                            for (let t = 0, n = e.count; t < n; t++) {
                                const r = t < n / 2 ? Pf : Lf;
                                e.setXYZ(t, r.r, r.g, r.b)
                            }
                            e.needsUpdate = !0
                        }
                        this.light.updateWorldMatrix(!0, !1), t.lookAt(Rf.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                class If extends Sc {
                    constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
                        n = new Ki(n), r = new Ki(r);
                        const i = e / 2,
                            a = t / e,
                            o = t / 2,
                            s = [],
                            l = [];
                        for (let t = 0, A = 0, c = -o; t <= e; t++, c += a) {
                            s.push(-o, 0, c, o, 0, c), s.push(c, 0, -o, c, 0, o);
                            const e = t === i ? n : r;
                            e.toArray(l, A), A += 3, e.toArray(l, A), A += 3, e.toArray(l, A), A += 3, e.toArray(l, A), A += 3
                        }
                        const A = new Ta;
                        A.setAttribute("position", new _a(s, 3)), A.setAttribute("color", new _a(l, 3)), super(A, new mc({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "GridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }
                class Of extends Sc {
                    constructor(t = 10, e = 16, n = 8, r = 64, i = 4473924, a = 8947848) {
                        i = new Ki(i), a = new Ki(a);
                        const o = [],
                            s = [];
                        if (e > 1)
                            for (let n = 0; n < e; n++) {
                                const r = n / e * (2 * Math.PI),
                                    l = Math.sin(r) * t,
                                    A = Math.cos(r) * t;
                                o.push(0, 0, 0), o.push(l, 0, A);
                                const c = 1 & n ? i : a;
                                s.push(c.r, c.g, c.b), s.push(c.r, c.g, c.b)
                            }
                        for (let e = 0; e < n; e++) {
                            const l = 1 & e ? i : a,
                                A = t - t / n * e;
                            for (let t = 0; t < r; t++) {
                                let e = t / r * (2 * Math.PI),
                                    n = Math.sin(e) * A,
                                    i = Math.cos(e) * A;
                                o.push(n, 0, i), s.push(l.r, l.g, l.b), e = (t + 1) / r * (2 * Math.PI), n = Math.sin(e) * A, i = Math.cos(e) * A, o.push(n, 0, i), s.push(l.r, l.g, l.b)
                            }
                        }
                        const l = new Ta;
                        l.setAttribute("position", new _a(o, 3)), l.setAttribute("color", new _a(s, 3)), super(l, new mc({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "PolarGridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }
                const Bf = new Ir,
                    qf = new Ir,
                    Uf = new Ir;
                class Nf extends qi {
                    constructor(t, e, n) {
                        super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", void 0 === e && (e = 1);
                        let r = new Ta;
                        r.setAttribute("position", new _a([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                        const i = new mc({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new bc(r, i), this.add(this.lightPlane), r = new Ta, r.setAttribute("position", new _a([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new bc(r, i), this.add(this.targetLine), this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Bf.setFromMatrixPosition(this.light.matrixWorld), qf.setFromMatrixPosition(this.light.target.matrixWorld), Uf.subVectors(qf, Bf), this.lightPlane.lookAt(qf), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(qf), this.targetLine.scale.z = Uf.length()
                    }
                }
                const kf = new Ir,
                    Ff = new $a;
                class zf extends Sc {
                    constructor(t) {
                        const e = new Ta,
                            n = new mc({
                                color: 16777215,
                                vertexColors: !0,
                                toneMapped: !1
                            }),
                            r = [],
                            i = [],
                            a = {};

                        function o(t, e) {
                            s(t), s(e)
                        }

                        function s(t) {
                            r.push(0, 0, 0), i.push(0, 0, 0), void 0 === a[t] && (a[t] = []), a[t].push(r.length / 3 - 1)
                        }
                        o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), e.setAttribute("position", new _a(r, 3)), e.setAttribute("color", new _a(i, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
                        const l = new Ki(16755200),
                            A = new Ki(16711680),
                            c = new Ki(43775),
                            u = new Ki(16777215),
                            h = new Ki(3355443);
                        this.setColors(l, A, c, u, h)
                    }
                    setColors(t, e, n, r, i) {
                        const a = this.geometry.getAttribute("color");
                        a.setXYZ(0, t.r, t.g, t.b), a.setXYZ(1, t.r, t.g, t.b), a.setXYZ(2, t.r, t.g, t.b), a.setXYZ(3, t.r, t.g, t.b), a.setXYZ(4, t.r, t.g, t.b), a.setXYZ(5, t.r, t.g, t.b), a.setXYZ(6, t.r, t.g, t.b), a.setXYZ(7, t.r, t.g, t.b), a.setXYZ(8, t.r, t.g, t.b), a.setXYZ(9, t.r, t.g, t.b), a.setXYZ(10, t.r, t.g, t.b), a.setXYZ(11, t.r, t.g, t.b), a.setXYZ(12, t.r, t.g, t.b), a.setXYZ(13, t.r, t.g, t.b), a.setXYZ(14, t.r, t.g, t.b), a.setXYZ(15, t.r, t.g, t.b), a.setXYZ(16, t.r, t.g, t.b), a.setXYZ(17, t.r, t.g, t.b), a.setXYZ(18, t.r, t.g, t.b), a.setXYZ(19, t.r, t.g, t.b), a.setXYZ(20, t.r, t.g, t.b), a.setXYZ(21, t.r, t.g, t.b), a.setXYZ(22, t.r, t.g, t.b), a.setXYZ(23, t.r, t.g, t.b), a.setXYZ(24, e.r, e.g, e.b), a.setXYZ(25, e.r, e.g, e.b), a.setXYZ(26, e.r, e.g, e.b), a.setXYZ(27, e.r, e.g, e.b), a.setXYZ(28, e.r, e.g, e.b), a.setXYZ(29, e.r, e.g, e.b), a.setXYZ(30, e.r, e.g, e.b), a.setXYZ(31, e.r, e.g, e.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, i.r, i.g, i.b), a.setXYZ(41, i.r, i.g, i.b), a.setXYZ(42, i.r, i.g, i.b), a.setXYZ(43, i.r, i.g, i.b), a.setXYZ(44, i.r, i.g, i.b), a.setXYZ(45, i.r, i.g, i.b), a.setXYZ(46, i.r, i.g, i.b), a.setXYZ(47, i.r, i.g, i.b), a.setXYZ(48, i.r, i.g, i.b), a.setXYZ(49, i.r, i.g, i.b), a.needsUpdate = !0
                    }
                    update() {
                        const t = this.geometry,
                            e = this.pointMap;
                        Ff.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Gf("c", e, t, Ff, 0, 0, -1), Gf("t", e, t, Ff, 0, 0, 1), Gf("n1", e, t, Ff, -1, -1, -1), Gf("n2", e, t, Ff, 1, -1, -1), Gf("n3", e, t, Ff, -1, 1, -1), Gf("n4", e, t, Ff, 1, 1, -1), Gf("f1", e, t, Ff, -1, -1, 1), Gf("f2", e, t, Ff, 1, -1, 1), Gf("f3", e, t, Ff, -1, 1, 1), Gf("f4", e, t, Ff, 1, 1, 1), Gf("u1", e, t, Ff, .7, 1.1, -1), Gf("u2", e, t, Ff, -.7, 1.1, -1), Gf("u3", e, t, Ff, 0, 2, -1), Gf("cf1", e, t, Ff, -1, 0, 1), Gf("cf2", e, t, Ff, 1, 0, 1), Gf("cf3", e, t, Ff, 0, -1, 1), Gf("cf4", e, t, Ff, 0, 1, 1), Gf("cn1", e, t, Ff, -1, 0, -1), Gf("cn2", e, t, Ff, 1, 0, -1), Gf("cn3", e, t, Ff, 0, -1, -1), Gf("cn4", e, t, Ff, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }

                function Gf(t, e, n, r, i, a, o) {
                    kf.set(i, a, o).unproject(r);
                    const s = e[t];
                    if (void 0 !== s) {
                        const t = n.getAttribute("position");
                        for (let e = 0, n = s.length; e < n; e++) t.setXYZ(s[e], kf.x, kf.y, kf.z)
                    }
                }
                const jf = new qr;
                class Vf extends Sc {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            r = new Float32Array(24),
                            i = new Ta;
                        i.setIndex(new ca(n, 1)), i.setAttribute("position", new ca(r, 3)), super(i, new mc({
                            color: e,
                            toneMapped: !1
                        })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                    }
                    update(t) {
                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && jf.setFromObject(this.object), jf.isEmpty()) return;
                        const e = jf.min,
                            n = jf.max,
                            r = this.geometry.attributes.position,
                            i = r.array;
                        i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = e.x, i[4] = n.y, i[5] = n.z, i[6] = e.x, i[7] = e.y, i[8] = n.z, i[9] = n.x, i[10] = e.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = e.z, i[15] = e.x, i[16] = n.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = n.x, i[22] = e.y, i[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                    setFromObject(t) {
                        return this.object = t, this.update(), this
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.object = t.object, this
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }
                class Hf extends Sc {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            r = new Ta;
                        r.setIndex(new ca(n, 1)), r.setAttribute("position", new _a([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new mc({
                            color: e,
                            toneMapped: !1
                        })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(t) {
                        const e = this.box;
                        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }
                class Wf extends bc {
                    constructor(t, e = 1, n = 16776960) {
                        const r = n,
                            i = new Ta;
                        i.setAttribute("position", new _a([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere(), super(i, new mc({
                            color: r,
                            toneMapped: !1
                        })), this.type = "PlaneHelper", this.plane = t, this.size = e;
                        const a = new Ta;
                        a.setAttribute("position", new _a([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), a.computeBoundingSphere(), this.add(new Ha(a, new na({
                            color: r,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(t) {
                        this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(t)
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
                    }
                }
                const Xf = new Ir;
                let Yf, Qf;
                class Zf extends qi {
                    constructor(t = new Ir(0, 0, 1), e = new Ir(0, 0, 0), n = 1, r = 16776960, i = .2 * n, a = .2 * i) {
                        super(), this.type = "ArrowHelper", void 0 === Yf && (Yf = new Ta, Yf.setAttribute("position", new _a([0, 0, 0, 0, 1, 0], 3)), Qf = new uu(0, .5, 1, 5, 1), Qf.translate(0, -.5, 0)), this.position.copy(e), this.line = new bc(Yf, new mc({
                            color: r,
                            toneMapped: !1
                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ha(Qf, new na({
                            color: r,
                            toneMapped: !1
                        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, i, a)
                    }
                    setDirection(t) {
                        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                        else {
                            Xf.set(t.z, 0, -t.x).normalize();
                            const e = Math.acos(t.y);
                            this.quaternion.setFromAxisAngle(Xf, e)
                        }
                    }
                    setLength(t, e = .2 * t, n = .2 * e) {
                        this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
                    }
                    setColor(t) {
                        this.line.material.color.set(t), this.cone.material.color.set(t)
                    }
                    copy(t) {
                        return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                    }
                    dispose() {
                        this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
                    }
                }
                class Jf extends Sc {
                    constructor(t = 1) {
                        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                            n = new Ta;
                        n.setAttribute("position", new _a(e, 3)), n.setAttribute("color", new _a([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new mc({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "AxesHelper"
                    }
                    setColors(t, e, n) {
                        const r = new Ki,
                            i = this.geometry.attributes.color.array;
                        return r.set(t), r.toArray(i, 0), r.toArray(i, 3), r.set(e), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this
                    }
                    dispose() {
                        this.geometry.dispose(), this.material.dispose()
                    }
                }
                class Kf {
                    constructor() {
                        this.type = "ShapePath", this.color = new Ki, this.subPaths = [], this.currentPath = null
                    }
                    moveTo(t, e) {
                        return this.currentPath = new su, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                    }
                    lineTo(t, e) {
                        return this.currentPath.lineTo(t, e), this
                    }
                    quadraticCurveTo(t, e, n, r) {
                        return this.currentPath.quadraticCurveTo(t, e, n, r), this
                    }
                    bezierCurveTo(t, e, n, r, i, a) {
                        return this.currentPath.bezierCurveTo(t, e, n, r, i, a), this
                    }
                    splineThru(t) {
                        return this.currentPath.splineThru(t), this
                    }
                    toShapes(t) {
                        function e(t, e) {
                            const n = e.length;
                            let r = !1;
                            for (let i = n - 1, a = 0; a < n; i = a++) {
                                let n = e[i],
                                    o = e[a],
                                    s = o.x - n.x,
                                    l = o.y - n.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (n = e[a], s = -s, o = e[i], l = -l), t.y < n.y || t.y > o.y) continue;
                                    if (t.y === n.y) {
                                        if (t.x === n.x) return !0
                                    } else {
                                        const e = l * (t.x - n.x) - s * (t.y - n.y);
                                        if (0 === e) return !0;
                                        if (e < 0) continue;
                                        r = !r
                                    }
                                } else {
                                    if (t.y !== n.y) continue;
                                    if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
                                }
                            }
                            return r
                        }
                        const n = Hu.isClockWise,
                            r = this.subPaths;
                        if (0 === r.length) return [];
                        let i, a, o;
                        const s = [];
                        if (1 === r.length) return a = r[0], o = new yu, o.curves = a.curves, s.push(o), s;
                        let l = !n(r[0].getPoints());
                        l = t ? !l : l;
                        const A = [],
                            c = [];
                        let u, h, d = [],
                            f = 0;
                        c[f] = void 0, d[f] = [];
                        for (let e = 0, o = r.length; e < o; e++) a = r[e], u = a.getPoints(), i = n(u), i = t ? !i : i, i ? (!l && c[f] && f++, c[f] = {
                            s: new yu,
                            p: u
                        }, c[f].s.curves = a.curves, l && f++, d[f] = []) : d[f].push({
                            h: a,
                            p: u[0]
                        });
                        if (!c[0]) return function(t) {
                            const e = [];
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = t[n],
                                    i = new yu;
                                i.curves = r.curves, e.push(i)
                            }
                            return e
                        }(r);
                        if (c.length > 1) {
                            let t = !1,
                                n = 0;
                            for (let t = 0, e = c.length; t < e; t++) A[t] = [];
                            for (let r = 0, i = c.length; r < i; r++) {
                                const i = d[r];
                                for (let a = 0; a < i.length; a++) {
                                    const o = i[a];
                                    let s = !0;
                                    for (let i = 0; i < c.length; i++) e(o.p, c[i].p) && (r !== i && n++, s ? (s = !1, A[i].push(o)) : t = !0);
                                    s && A[r].push(o)
                                }
                            }
                            n > 0 && !1 === t && (d = A)
                        }
                        for (let t = 0, e = c.length; t < e; t++) {
                            o = c[t].s, s.push(o), h = d[t];
                            for (let t = 0, e = h.length; t < e; t++) o.holes.push(h[t].h)
                        }
                        return s
                    }
                }
                class $f extends Tr {
                    constructor(t = 1, e = 1, n = 1, r = {}) {
                        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(t, e, {
                            ...r,
                            count: n
                        }), this.isWebGLMultipleRenderTargets = !0
                    }
                    get texture() {
                        return this.textures
                    }
                }
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                    detail: {
                        revision: r
                    }
                })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r)
            },
            "./node_modules/three/examples/jsm/controls/OrbitControls.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    OrbitControls: () => c
                });
                var r = n("./node_modules/three/build/three.module.js");
                const i = {
                        type: "change"
                    },
                    a = {
                        type: "start"
                    },
                    o = {
                        type: "end"
                    },
                    s = new r.Ray,
                    l = new r.Plane,
                    A = Math.cos(70 * r.MathUtils.DEG2RAD);
                class c extends r.EventDispatcher {
                    constructor(t, e) {
                        super(), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new r.Vector3, this.cursor = new r.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                            LEFT: "ArrowLeft",
                            UP: "ArrowUp",
                            RIGHT: "ArrowRight",
                            BOTTOM: "ArrowDown"
                        }, this.mouseButtons = {
                            LEFT: r.MOUSE.ROTATE,
                            MIDDLE: r.MOUSE.DOLLY,
                            RIGHT: r.MOUSE.PAN
                        }, this.touches = {
                            ONE: r.TOUCH.ROTATE,
                            TWO: r.TOUCH.DOLLY_PAN
                        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
                            return d.phi
                        }, this.getAzimuthalAngle = function() {
                            return d.theta
                        }, this.getDistance = function() {
                            return this.object.position.distanceTo(this.target)
                        }, this.listenToKeyEvents = function(t) {
                            t.addEventListener("keydown", nt), this._domElementKeyEvents = t
                        }, this.stopListenToKeyEvents = function() {
                            this._domElementKeyEvents.removeEventListener("keydown", nt), this._domElementKeyEvents = null
                        }, this.saveState = function() {
                            n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                        }, this.reset = function() {
                            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(i), n.update(), u = c.NONE
                        }, this.update = function() {
                            const e = new r.Vector3,
                                a = (new r.Quaternion).setFromUnitVectors(t.up, new r.Vector3(0, 1, 0)),
                                o = a.clone().invert(),
                                g = new r.Vector3,
                                v = new r.Quaternion,
                                _ = new r.Vector3,
                                y = 2 * Math.PI;
                            return function(x = null) {
                                const b = n.object.position;
                                e.copy(b).sub(n.target), e.applyQuaternion(a), d.setFromVector3(e), n.autoRotate && u === c.NONE && I(function(t) {
                                    return null !== t ? 2 * Math.PI / 60 * n.autoRotateSpeed * t : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
                                }(x)), n.enableDamping ? (d.theta += f.theta * n.dampingFactor, d.phi += f.phi * n.dampingFactor) : (d.theta += f.theta, d.phi += f.phi);
                                let M = n.minAzimuthAngle,
                                    w = n.maxAzimuthAngle;
                                isFinite(M) && isFinite(w) && (M < -Math.PI ? M += y : M > Math.PI && (M -= y), w < -Math.PI ? w += y : w > Math.PI && (w -= y), d.theta = M <= w ? Math.max(M, Math.min(w, d.theta)) : d.theta > (M + w) / 2 ? Math.max(M, d.theta) : Math.min(w, d.theta)), d.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, d.phi)), d.makeSafe(), !0 === n.enableDamping ? n.target.addScaledVector(m, n.dampingFactor) : n.target.add(m), n.target.sub(n.cursor), n.target.clampLength(n.minTargetRadius, n.maxTargetRadius), n.target.add(n.cursor);
                                let S = !1;
                                if (n.zoomToCursor && C || n.object.isOrthographicCamera) d.radius = z(d.radius);
                                else {
                                    const t = d.radius;
                                    d.radius = z(d.radius * p), S = t != d.radius
                                }
                                if (e.setFromSpherical(d), e.applyQuaternion(o), b.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (f.theta *= 1 - n.dampingFactor, f.phi *= 1 - n.dampingFactor, m.multiplyScalar(1 - n.dampingFactor)) : (f.set(0, 0, 0), m.set(0, 0, 0)), n.zoomToCursor && C) {
                                    let i = null;
                                    if (n.object.isPerspectiveCamera) {
                                        const t = e.length();
                                        i = z(t * p);
                                        const r = t - i;
                                        n.object.position.addScaledVector(E, r), n.object.updateMatrixWorld(), S = !!r
                                    } else if (n.object.isOrthographicCamera) {
                                        const t = new r.Vector3(T.x, T.y, 0);
                                        t.unproject(n.object);
                                        const a = n.object.zoom;
                                        n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / p)), n.object.updateProjectionMatrix(), S = a !== n.object.zoom;
                                        const o = new r.Vector3(T.x, T.y, 0);
                                        o.unproject(n.object), n.object.position.sub(o).add(t), n.object.updateMatrixWorld(), i = e.length()
                                    } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
                                    null !== i && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(i).add(n.object.position) : (s.origin.copy(n.object.position), s.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(s.direction)) < A ? t.lookAt(n.target) : (l.setFromNormalAndCoplanarPoint(n.object.up, n.target), s.intersectPlane(l, n.target))))
                                } else if (n.object.isOrthographicCamera) {
                                    const t = n.object.zoom;
                                    n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / p)), t !== n.object.zoom && (n.object.updateProjectionMatrix(), S = !0)
                                }
                                return p = 1, C = !1, !!(S || g.distanceToSquared(n.object.position) > h || 8 * (1 - v.dot(n.object.quaternion)) > h || _.distanceToSquared(n.target) > h) && (n.dispatchEvent(i), g.copy(n.object.position), v.copy(n.object.quaternion), _.copy(n.target), !0)
                            }
                        }(), this.dispose = function() {
                            n.domElement.removeEventListener("contextmenu", it), n.domElement.removeEventListener("pointerdown", Z), n.domElement.removeEventListener("pointercancel", K), n.domElement.removeEventListener("wheel", $), n.domElement.removeEventListener("pointermove", J), n.domElement.removeEventListener("pointerup", K), n.domElement.getRootNode().removeEventListener("keydown", tt, {
                                capture: !0
                            }), null !== n._domElementKeyEvents && (n._domElementKeyEvents.removeEventListener("keydown", nt), n._domElementKeyEvents = null)
                        };
                        const n = this,
                            c = {
                                NONE: -1,
                                ROTATE: 0,
                                DOLLY: 1,
                                PAN: 2,
                                TOUCH_ROTATE: 3,
                                TOUCH_PAN: 4,
                                TOUCH_DOLLY_PAN: 5,
                                TOUCH_DOLLY_ROTATE: 6
                            };
                        let u = c.NONE;
                        const h = 1e-6,
                            d = new r.Spherical,
                            f = new r.Spherical;
                        let p = 1;
                        const m = new r.Vector3,
                            g = new r.Vector2,
                            v = new r.Vector2,
                            _ = new r.Vector2,
                            y = new r.Vector2,
                            x = new r.Vector2,
                            b = new r.Vector2,
                            M = new r.Vector2,
                            w = new r.Vector2,
                            S = new r.Vector2,
                            E = new r.Vector3,
                            T = new r.Vector2;
                        let C = !1;
                        const R = [],
                            P = {};
                        let L = !1;

                        function D(t) {
                            const e = Math.abs(.01 * t);
                            return Math.pow(.95, n.zoomSpeed * e)
                        }

                        function I(t) {
                            f.theta -= t
                        }

                        function O(t) {
                            f.phi -= t
                        }
                        const B = function() {
                                const t = new r.Vector3;
                                return function(e, n) {
                                    t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), m.add(t)
                                }
                            }(),
                            q = function() {
                                const t = new r.Vector3;
                                return function(e, r) {
                                    !0 === n.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), m.add(t)
                                }
                            }(),
                            U = function() {
                                const t = new r.Vector3;
                                return function(e, r) {
                                    const i = n.domElement;
                                    if (n.object.isPerspectiveCamera) {
                                        const a = n.object.position;
                                        t.copy(a).sub(n.target);
                                        let o = t.length();
                                        o *= Math.tan(n.object.fov / 2 * Math.PI / 180), B(2 * e * o / i.clientHeight, n.object.matrix), q(2 * r * o / i.clientHeight, n.object.matrix)
                                    } else n.object.isOrthographicCamera ? (B(e * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), q(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                                }
                            }();

                        function N(t) {
                            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? p /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                        }

                        function k(t) {
                            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? p *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                        }

                        function F(t, e) {
                            if (!n.zoomToCursor) return;
                            C = !0;
                            const r = n.domElement.getBoundingClientRect(),
                                i = t - r.left,
                                a = e - r.top,
                                o = r.width,
                                s = r.height;
                            T.x = i / o * 2 - 1, T.y = -a / s * 2 + 1, E.set(T.x, T.y, 1).unproject(n.object).sub(n.object.position).normalize()
                        }

                        function z(t) {
                            return Math.max(n.minDistance, Math.min(n.maxDistance, t))
                        }

                        function G(t) {
                            g.set(t.clientX, t.clientY)
                        }

                        function j(t) {
                            y.set(t.clientX, t.clientY)
                        }

                        function V(t) {
                            if (1 === R.length) g.set(t.pageX, t.pageY);
                            else {
                                const e = ot(t),
                                    n = .5 * (t.pageX + e.x),
                                    r = .5 * (t.pageY + e.y);
                                g.set(n, r)
                            }
                        }

                        function H(t) {
                            if (1 === R.length) y.set(t.pageX, t.pageY);
                            else {
                                const e = ot(t),
                                    n = .5 * (t.pageX + e.x),
                                    r = .5 * (t.pageY + e.y);
                                y.set(n, r)
                            }
                        }

                        function W(t) {
                            const e = ot(t),
                                n = t.pageX - e.x,
                                r = t.pageY - e.y,
                                i = Math.sqrt(n * n + r * r);
                            M.set(0, i)
                        }

                        function X(t) {
                            if (1 == R.length) v.set(t.pageX, t.pageY);
                            else {
                                const e = ot(t),
                                    n = .5 * (t.pageX + e.x),
                                    r = .5 * (t.pageY + e.y);
                                v.set(n, r)
                            }
                            _.subVectors(v, g).multiplyScalar(n.rotateSpeed);
                            const e = n.domElement;
                            I(2 * Math.PI * _.x / e.clientHeight), O(2 * Math.PI * _.y / e.clientHeight), g.copy(v)
                        }

                        function Y(t) {
                            if (1 === R.length) x.set(t.pageX, t.pageY);
                            else {
                                const e = ot(t),
                                    n = .5 * (t.pageX + e.x),
                                    r = .5 * (t.pageY + e.y);
                                x.set(n, r)
                            }
                            b.subVectors(x, y).multiplyScalar(n.panSpeed), U(b.x, b.y), y.copy(x)
                        }

                        function Q(t) {
                            const e = ot(t),
                                r = t.pageX - e.x,
                                i = t.pageY - e.y,
                                a = Math.sqrt(r * r + i * i);
                            w.set(0, a), S.set(0, Math.pow(w.y / M.y, n.zoomSpeed)), N(S.y), M.copy(w), F(.5 * (t.pageX + e.x), .5 * (t.pageY + e.y))
                        }

                        function Z(t) {
                            !1 !== n.enabled && (0 === R.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", J), n.domElement.addEventListener("pointerup", K)), function(t) {
                                for (let e = 0; e < R.length; e++)
                                    if (R[e] == t.pointerId) return !0;
                                return !1
                            }(t) || (function(t) {
                                R.push(t.pointerId)
                            }(t), "touch" === t.pointerType ? rt(t) : function(t) {
                                let e;
                                switch (t.button) {
                                    case 0:
                                        e = n.mouseButtons.LEFT;
                                        break;
                                    case 1:
                                        e = n.mouseButtons.MIDDLE;
                                        break;
                                    case 2:
                                        e = n.mouseButtons.RIGHT;
                                        break;
                                    default:
                                        e = -1
                                }
                                switch (e) {
                                    case r.MOUSE.DOLLY:
                                        if (!1 === n.enableZoom) return;
                                        ! function(t) {
                                            F(t.clientX, t.clientX), M.set(t.clientX, t.clientY)
                                        }(t), u = c.DOLLY;
                                        break;
                                    case r.MOUSE.ROTATE:
                                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                            if (!1 === n.enablePan) return;
                                            j(t), u = c.PAN
                                        } else {
                                            if (!1 === n.enableRotate) return;
                                            G(t), u = c.ROTATE
                                        }
                                        break;
                                    case r.MOUSE.PAN:
                                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                            if (!1 === n.enableRotate) return;
                                            G(t), u = c.ROTATE
                                        } else {
                                            if (!1 === n.enablePan) return;
                                            j(t), u = c.PAN
                                        }
                                        break;
                                    default:
                                        u = c.NONE
                                }
                                u !== c.NONE && n.dispatchEvent(a)
                            }(t)))
                        }

                        function J(t) {
                            !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                                switch (at(t), u) {
                                    case c.TOUCH_ROTATE:
                                        if (!1 === n.enableRotate) return;
                                        X(t), n.update();
                                        break;
                                    case c.TOUCH_PAN:
                                        if (!1 === n.enablePan) return;
                                        Y(t), n.update();
                                        break;
                                    case c.TOUCH_DOLLY_PAN:
                                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                        ! function(t) {
                                            n.enableZoom && Q(t), n.enablePan && Y(t)
                                        }(t), n.update();
                                        break;
                                    case c.TOUCH_DOLLY_ROTATE:
                                        if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                        ! function(t) {
                                            n.enableZoom && Q(t), n.enableRotate && X(t)
                                        }(t), n.update();
                                        break;
                                    default:
                                        u = c.NONE
                                }
                            }(t) : function(t) {
                                switch (u) {
                                    case c.ROTATE:
                                        if (!1 === n.enableRotate) return;
                                        ! function(t) {
                                            v.set(t.clientX, t.clientY), _.subVectors(v, g).multiplyScalar(n.rotateSpeed);
                                            const e = n.domElement;
                                            I(2 * Math.PI * _.x / e.clientHeight), O(2 * Math.PI * _.y / e.clientHeight), g.copy(v), n.update()
                                        }(t);
                                        break;
                                    case c.DOLLY:
                                        if (!1 === n.enableZoom) return;
                                        ! function(t) {
                                            w.set(t.clientX, t.clientY), S.subVectors(w, M), S.y > 0 ? N(D(S.y)) : S.y < 0 && k(D(S.y)), M.copy(w), n.update()
                                        }(t);
                                        break;
                                    case c.PAN:
                                        if (!1 === n.enablePan) return;
                                        ! function(t) {
                                            x.set(t.clientX, t.clientY), b.subVectors(x, y).multiplyScalar(n.panSpeed), U(b.x, b.y), y.copy(x), n.update()
                                        }(t)
                                }
                            }(t))
                        }

                        function K(t) {
                            switch (function(t) {
                                    delete P[t.pointerId];
                                    for (let e = 0; e < R.length; e++)
                                        if (R[e] == t.pointerId) return void R.splice(e, 1)
                                }(t), R.length) {
                                case 0:
                                    n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", J), n.domElement.removeEventListener("pointerup", K), n.dispatchEvent(o), u = c.NONE;
                                    break;
                                case 1:
                                    const e = R[0],
                                        r = P[e];
                                    rt({
                                        pointerId: e,
                                        pageX: r.x,
                                        pageY: r.y
                                    })
                            }
                        }

                        function $(t) {
                            !1 !== n.enabled && !1 !== n.enableZoom && u === c.NONE && (t.preventDefault(), n.dispatchEvent(a), function(t) {
                                F(t.clientX, t.clientY), t.deltaY < 0 ? k(D(t.deltaY)) : t.deltaY > 0 && N(D(t.deltaY)), n.update()
                            }(function(t) {
                                const e = t.deltaMode,
                                    n = {
                                        clientX: t.clientX,
                                        clientY: t.clientY,
                                        deltaY: t.deltaY
                                    };
                                switch (e) {
                                    case 1:
                                        n.deltaY *= 16;
                                        break;
                                    case 2:
                                        n.deltaY *= 100
                                }
                                return t.ctrlKey && !L && (n.deltaY *= 10), n
                            }(t)), n.dispatchEvent(o))
                        }

                        function tt(t) {
                            "Control" === t.key && (L = !0, n.domElement.getRootNode().addEventListener("keyup", et, {
                                passive: !0,
                                capture: !0
                            }))
                        }

                        function et(t) {
                            "Control" === t.key && (L = !1, n.domElement.getRootNode().removeEventListener("keyup", et, {
                                passive: !0,
                                capture: !0
                            }))
                        }

                        function nt(t) {
                            !1 !== n.enabled && !1 !== n.enablePan && function(t) {
                                let e = !1;
                                switch (t.code) {
                                    case n.keys.UP:
                                        t.ctrlKey || t.metaKey || t.shiftKey ? O(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(0, n.keyPanSpeed), e = !0;
                                        break;
                                    case n.keys.BOTTOM:
                                        t.ctrlKey || t.metaKey || t.shiftKey ? O(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(0, -n.keyPanSpeed), e = !0;
                                        break;
                                    case n.keys.LEFT:
                                        t.ctrlKey || t.metaKey || t.shiftKey ? I(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(n.keyPanSpeed, 0), e = !0;
                                        break;
                                    case n.keys.RIGHT:
                                        t.ctrlKey || t.metaKey || t.shiftKey ? I(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(-n.keyPanSpeed, 0), e = !0
                                }
                                e && (t.preventDefault(), n.update())
                            }(t)
                        }

                        function rt(t) {
                            switch (at(t), R.length) {
                                case 1:
                                    switch (n.touches.ONE) {
                                        case r.TOUCH.ROTATE:
                                            if (!1 === n.enableRotate) return;
                                            V(t), u = c.TOUCH_ROTATE;
                                            break;
                                        case r.TOUCH.PAN:
                                            if (!1 === n.enablePan) return;
                                            H(t), u = c.TOUCH_PAN;
                                            break;
                                        default:
                                            u = c.NONE
                                    }
                                    break;
                                case 2:
                                    switch (n.touches.TWO) {
                                        case r.TOUCH.DOLLY_PAN:
                                            if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                            ! function(t) {
                                                n.enableZoom && W(t), n.enablePan && H(t)
                                            }(t), u = c.TOUCH_DOLLY_PAN;
                                            break;
                                        case r.TOUCH.DOLLY_ROTATE:
                                            if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                            ! function(t) {
                                                n.enableZoom && W(t), n.enableRotate && V(t)
                                            }(t), u = c.TOUCH_DOLLY_ROTATE;
                                            break;
                                        default:
                                            u = c.NONE
                                    }
                                    break;
                                default:
                                    u = c.NONE
                            }
                            u !== c.NONE && n.dispatchEvent(a)
                        }

                        function it(t) {
                            !1 !== n.enabled && t.preventDefault()
                        }

                        function at(t) {
                            let e = P[t.pointerId];
                            void 0 === e && (e = new r.Vector2, P[t.pointerId] = e), e.set(t.pageX, t.pageY)
                        }

                        function ot(t) {
                            const e = t.pointerId === R[0] ? R[1] : R[0];
                            return P[e]
                        }
                        n.domElement.addEventListener("contextmenu", it), n.domElement.addEventListener("pointerdown", Z), n.domElement.addEventListener("pointercancel", K), n.domElement.addEventListener("wheel", $, {
                            passive: !1
                        }), n.domElement.getRootNode().addEventListener("keydown", tt, {
                            passive: !0,
                            capture: !0
                        }), this.update()
                    }
                }
            },
            "./node_modules/three/examples/jsm/controls/TrackballControls.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    TrackballControls: () => s
                });
                var r = n("./node_modules/three/build/three.module.js");
                const i = {
                        type: "change"
                    },
                    a = {
                        type: "start"
                    },
                    o = {
                        type: "end"
                    };
                class s extends r.EventDispatcher {
                    constructor(t, e) {
                        super();
                        const n = this,
                            s = -1;
                        this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.screen = {
                            left: 0,
                            top: 0,
                            width: 0,
                            height: 0
                        }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = .3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = .2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = ["KeyA", "KeyS", "KeyD"], this.mouseButtons = {
                            LEFT: r.MOUSE.ROTATE,
                            MIDDLE: r.MOUSE.DOLLY,
                            RIGHT: r.MOUSE.PAN
                        }, this.target = new r.Vector3;
                        const l = 1e-6,
                            A = new r.Vector3;
                        let c = 1,
                            u = s,
                            h = s,
                            d = 0,
                            f = 0,
                            p = 0;
                        const m = new r.Vector3,
                            g = new r.Vector2,
                            v = new r.Vector2,
                            _ = new r.Vector3,
                            y = new r.Vector2,
                            x = new r.Vector2,
                            b = new r.Vector2,
                            M = new r.Vector2,
                            w = [],
                            S = {};
                        this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.up0 = this.object.up.clone(), this.zoom0 = this.object.zoom, this.handleResize = function() {
                            const t = n.domElement.getBoundingClientRect(),
                                e = n.domElement.ownerDocument.documentElement;
                            n.screen.left = t.left + window.pageXOffset - e.clientLeft, n.screen.top = t.top + window.pageYOffset - e.clientTop, n.screen.width = t.width, n.screen.height = t.height
                        };
                        const E = function() {
                                const t = new r.Vector2;
                                return function(e, r) {
                                    return t.set((e - n.screen.left) / n.screen.width, (r - n.screen.top) / n.screen.height), t
                                }
                            }(),
                            T = function() {
                                const t = new r.Vector2;
                                return function(e, r) {
                                    return t.set((e - .5 * n.screen.width - n.screen.left) / (.5 * n.screen.width), (n.screen.height + 2 * (n.screen.top - r)) / n.screen.width), t
                                }
                            }();

                        function C(t) {
                            !1 !== n.enabled && (0 === w.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", R), n.domElement.addEventListener("pointerup", P)), function(t) {
                                w.push(t)
                            }(t), "touch" === t.pointerType ? function(t) {
                                if (1 === (U(t), w.length)) u = 3, v.copy(T(w[0].pageX, w[0].pageY)), g.copy(v);
                                else {
                                    u = 4;
                                    const t = w[0].pageX - w[1].pageX,
                                        e = w[0].pageY - w[1].pageY;
                                    f = d = Math.sqrt(t * t + e * e);
                                    const n = (w[0].pageX + w[1].pageX) / 2,
                                        r = (w[0].pageY + w[1].pageY) / 2;
                                    b.copy(E(n, r)), M.copy(b)
                                }
                                n.dispatchEvent(a)
                            }(t) : function(t) {
                                if (u === s) switch (t.button) {
                                    case n.mouseButtons.LEFT:
                                        u = 0;
                                        break;
                                    case n.mouseButtons.MIDDLE:
                                        u = 1;
                                        break;
                                    case n.mouseButtons.RIGHT:
                                        u = 2
                                }
                                const e = h !== s ? h : u;
                                0 !== e || n.noRotate ? 1 !== e || n.noZoom ? 2 !== e || n.noPan || (b.copy(E(t.pageX, t.pageY)), M.copy(b)) : (y.copy(E(t.pageX, t.pageY)), x.copy(y)) : (v.copy(T(t.pageX, t.pageY)), g.copy(v)), n.dispatchEvent(a)
                            }(t))
                        }

                        function R(t) {
                            !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                                if (1 === (U(t), w.length)) g.copy(v), v.copy(T(t.pageX, t.pageY));
                                else {
                                    const e = function(t) {
                                            const e = t.pointerId === w[0].pointerId ? w[1] : w[0];
                                            return S[e.pointerId]
                                        }(t),
                                        n = t.pageX - e.x,
                                        r = t.pageY - e.y;
                                    f = Math.sqrt(n * n + r * r);
                                    const i = (t.pageX + e.x) / 2,
                                        a = (t.pageY + e.y) / 2;
                                    M.copy(E(i, a))
                                }
                            }(t) : function(t) {
                                const e = h !== s ? h : u;
                                0 !== e || n.noRotate ? 1 !== e || n.noZoom ? 2 !== e || n.noPan || M.copy(E(t.pageX, t.pageY)) : x.copy(E(t.pageX, t.pageY)) : (g.copy(v), v.copy(T(t.pageX, t.pageY)))
                            }(t))
                        }

                        function P(t) {
                            !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                                switch (w.length) {
                                    case 0:
                                        u = s;
                                        break;
                                    case 1:
                                        u = 3, v.copy(T(t.pageX, t.pageY)), g.copy(v);
                                        break;
                                    case 2:
                                        u = 4;
                                        for (let e = 0; e < w.length; e++)
                                            if (w[e].pointerId !== t.pointerId) {
                                                const t = S[w[e].pointerId];
                                                v.copy(T(t.x, t.y)), g.copy(v);
                                                break
                                            }
                                }
                                n.dispatchEvent(o)
                            }(t) : (u = s, n.dispatchEvent(o)), q(t), 0 === w.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", R), n.domElement.removeEventListener("pointerup", P)))
                        }

                        function L(t) {
                            q(t)
                        }

                        function D(t) {
                            !1 !== n.enabled && (window.removeEventListener("keydown", D), h === s && (t.code !== n.keys[0] || n.noRotate ? t.code !== n.keys[1] || n.noZoom ? t.code !== n.keys[2] || n.noPan || (h = 2) : h = 1 : h = 0))
                        }

                        function I() {
                            !1 !== n.enabled && (h = s, window.addEventListener("keydown", D))
                        }

                        function O(t) {
                            if (!1 !== n.enabled && !0 !== n.noZoom) {
                                switch (t.preventDefault(), t.deltaMode) {
                                    case 2:
                                        y.y -= .025 * t.deltaY;
                                        break;
                                    case 1:
                                        y.y -= .01 * t.deltaY;
                                        break;
                                    default:
                                        y.y -= 25e-5 * t.deltaY
                                }
                                n.dispatchEvent(a), n.dispatchEvent(o)
                            }
                        }

                        function B(t) {
                            !1 !== n.enabled && t.preventDefault()
                        }

                        function q(t) {
                            delete S[t.pointerId];
                            for (let e = 0; e < w.length; e++)
                                if (w[e].pointerId == t.pointerId) return void w.splice(e, 1)
                        }

                        function U(t) {
                            let e = S[t.pointerId];
                            void 0 === e && (e = new r.Vector2, S[t.pointerId] = e), e.set(t.pageX, t.pageY)
                        }
                        this.rotateCamera = function() {
                            const t = new r.Vector3,
                                e = new r.Quaternion,
                                i = new r.Vector3,
                                a = new r.Vector3,
                                o = new r.Vector3,
                                s = new r.Vector3;
                            return function() {
                                s.set(v.x - g.x, v.y - g.y, 0);
                                let r = s.length();
                                r ? (m.copy(n.object.position).sub(n.target), i.copy(m).normalize(), a.copy(n.object.up).normalize(), o.crossVectors(a, i).normalize(), a.setLength(v.y - g.y), o.setLength(v.x - g.x), s.copy(a.add(o)), t.crossVectors(s, m).normalize(), r *= n.rotateSpeed, e.setFromAxisAngle(t, r), m.applyQuaternion(e), n.object.up.applyQuaternion(e), _.copy(t), p = r) : !n.staticMoving && p && (p *= Math.sqrt(1 - n.dynamicDampingFactor), m.copy(n.object.position).sub(n.target), e.setFromAxisAngle(_, p), m.applyQuaternion(e), n.object.up.applyQuaternion(e)), g.copy(v)
                            }
                        }(), this.zoomCamera = function() {
                            let t;
                            4 === u ? (t = d / f, d = f, n.object.isPerspectiveCamera ? m.multiplyScalar(t) : n.object.isOrthographicCamera ? (n.object.zoom = r.MathUtils.clamp(n.object.zoom / t, n.minZoom, n.maxZoom), c !== n.object.zoom && n.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (t = 1 + (x.y - y.y) * n.zoomSpeed, 1 !== t && t > 0 && (n.object.isPerspectiveCamera ? m.multiplyScalar(t) : n.object.isOrthographicCamera ? (n.object.zoom = r.MathUtils.clamp(n.object.zoom / t, n.minZoom, n.maxZoom), c !== n.object.zoom && n.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), n.staticMoving ? y.copy(x) : y.y += (x.y - y.y) * this.dynamicDampingFactor)
                        }, this.panCamera = function() {
                            const t = new r.Vector2,
                                e = new r.Vector3,
                                i = new r.Vector3;
                            return function() {
                                if (t.copy(M).sub(b), t.lengthSq()) {
                                    if (n.object.isOrthographicCamera) {
                                        const e = (n.object.right - n.object.left) / n.object.zoom / n.domElement.clientWidth,
                                            r = (n.object.top - n.object.bottom) / n.object.zoom / n.domElement.clientWidth;
                                        t.x *= e, t.y *= r
                                    }
                                    t.multiplyScalar(m.length() * n.panSpeed), i.copy(m).cross(n.object.up).setLength(t.x), i.add(e.copy(n.object.up).setLength(t.y)), n.object.position.add(i), n.target.add(i), n.staticMoving ? b.copy(M) : b.add(t.subVectors(M, b).multiplyScalar(n.dynamicDampingFactor))
                                }
                            }
                        }(), this.checkDistances = function() {
                            n.noZoom && n.noPan || (m.lengthSq() > n.maxDistance * n.maxDistance && (n.object.position.addVectors(n.target, m.setLength(n.maxDistance)), y.copy(x)), m.lengthSq() < n.minDistance * n.minDistance && (n.object.position.addVectors(n.target, m.setLength(n.minDistance)), y.copy(x)))
                        }, this.update = function() {
                            m.subVectors(n.object.position, n.target), n.noRotate || n.rotateCamera(), n.noZoom || n.zoomCamera(), n.noPan || n.panCamera(), n.object.position.addVectors(n.target, m), n.object.isPerspectiveCamera ? (n.checkDistances(), n.object.lookAt(n.target), A.distanceToSquared(n.object.position) > l && (n.dispatchEvent(i), A.copy(n.object.position))) : n.object.isOrthographicCamera ? (n.object.lookAt(n.target), (A.distanceToSquared(n.object.position) > l || c !== n.object.zoom) && (n.dispatchEvent(i), A.copy(n.object.position), c = n.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type")
                        }, this.reset = function() {
                            u = s, h = s, n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.up.copy(n.up0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), m.subVectors(n.object.position, n.target), n.object.lookAt(n.target), n.dispatchEvent(i), A.copy(n.object.position), c = n.object.zoom
                        }, this.dispose = function() {
                            n.domElement.removeEventListener("contextmenu", B), n.domElement.removeEventListener("pointerdown", C), n.domElement.removeEventListener("pointercancel", L), n.domElement.removeEventListener("wheel", O), n.domElement.removeEventListener("pointermove", R), n.domElement.removeEventListener("pointerup", P), window.removeEventListener("keydown", D), window.removeEventListener("keyup", I)
                        }, this.domElement.addEventListener("contextmenu", B), this.domElement.addEventListener("pointerdown", C), this.domElement.addEventListener("pointercancel", L), this.domElement.addEventListener("wheel", O, {
                            passive: !1
                        }), window.addEventListener("keydown", D), window.addEventListener("keyup", I), this.handleResize(), this.update()
                    }
                }
            },
            "./node_modules/three/examples/jsm/geometries/TextGeometry.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    TextGeometry: () => i
                });
                var r = n("./node_modules/three/build/three.module.js");
                class i extends r.ExtrudeGeometry {
                    constructor(t, e = {}) {
                        const n = e.font;
                        if (void 0 === n) super();
                        else {
                            const r = n.generateShapes(t, e.size);
                            e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), super(r, e)
                        }
                        this.type = "TextGeometry"
                    }
                }
            },
            "./node_modules/three/examples/jsm/loaders/FontLoader.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    Font: () => a,
                    FontLoader: () => i
                });
                var r = n("./node_modules/three/build/three.module.js");
                class i extends r.Loader {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, i) {
                        const a = this,
                            o = new r.FileLoader(this.manager);
                        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(t) {
                            const n = a.parse(JSON.parse(t));
                            e && e(n)
                        }), n, i)
                    }
                    parse(t) {
                        return new a(t)
                    }
                }
                class a {
                    constructor(t) {
                        this.isFont = !0, this.type = "Font", this.data = t
                    }
                    generateShapes(t, e = 100) {
                        const n = [],
                            r = function(t, e, n) {
                                const r = Array.from(t),
                                    i = e / n.resolution,
                                    a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i,
                                    s = [];
                                let l = 0,
                                    A = 0;
                                for (let t = 0; t < r.length; t++) {
                                    const e = r[t];
                                    if ("\n" === e) l = 0, A -= a;
                                    else {
                                        const t = o(e, i, l, A, n);
                                        l += t.offsetX, s.push(t.path)
                                    }
                                }
                                return s
                            }(t, e, this.data);
                        for (let t = 0, e = r.length; t < e; t++) n.push(...r[t].toShapes());
                        return n
                    }
                }

                function o(t, e, n, i, a) {
                    const o = a.glyphs[t] || a.glyphs["?"];
                    if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + a.familyName + ".");
                    const s = new r.ShapePath;
                    let l, A, c, u, h, d, f, p;
                    if (o.o) {
                        const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
                        for (let r = 0, a = t.length; r < a;) switch (t[r++]) {
                            case "m":
                                l = t[r++] * e + n, A = t[r++] * e + i, s.moveTo(l, A);
                                break;
                            case "l":
                                l = t[r++] * e + n, A = t[r++] * e + i, s.lineTo(l, A);
                                break;
                            case "q":
                                c = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, s.quadraticCurveTo(h, d, c, u);
                                break;
                            case "b":
                                c = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, f = t[r++] * e + n, p = t[r++] * e + i, s.bezierCurveTo(h, d, f, p, c, u)
                        }
                    }
                    return {
                        offsetX: o.ha * e,
                        path: s
                    }
                }
            },
            "./node_modules/three/examples/jsm/renderers/CSS2DRenderer.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    CSS2DObject: () => i,
                    CSS2DRenderer: () => c
                });
                var r = n("./node_modules/three/build/three.module.js");
                class i extends r.Object3D {
                    constructor(t = document.createElement("div")) {
                        super(), this.isCSS2DObject = !0, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new r.Vector2(.5, .5), this.addEventListener("removed", (function() {
                            this.traverse((function(t) {
                                t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element)
                            }))
                        }))
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.element = t.element.cloneNode(!0), this.center = t.center, this
                    }
                }
                const a = new r.Vector3,
                    o = new r.Matrix4,
                    s = new r.Matrix4,
                    l = new r.Vector3,
                    A = new r.Vector3;
                class c {
                    constructor(t = {}) {
                        const e = this;
                        let n, r, i, c;
                        const u = {
                                objects: new WeakMap
                            },
                            h = void 0 !== t.element ? t.element : document.createElement("div");

                        function d(t, n, r) {
                            if (t.isCSS2DObject) {
                                a.setFromMatrixPosition(t.matrixWorld), a.applyMatrix4(s);
                                const d = !0 === t.visible && a.z >= -1 && a.z <= 1 && !0 === t.layers.test(r.layers);
                                if (t.element.style.display = !0 === d ? "" : "none", !0 === d) {
                                    t.onBeforeRender(e, n, r);
                                    const o = t.element;
                                    o.style.transform = "translate(" + -100 * t.center.x + "%," + -100 * t.center.y + "%)translate(" + (a.x * i + i) + "px," + (-a.y * c + c) + "px)", o.parentNode !== h && h.appendChild(o), t.onAfterRender(e, n, r)
                                }
                                const p = {
                                    distanceToCameraSquared: (o = r, f = t, l.setFromMatrixPosition(o.matrixWorld), A.setFromMatrixPosition(f.matrixWorld), l.distanceToSquared(A))
                                };
                                u.objects.set(t, p)
                            }
                            var o, f;
                            for (let e = 0, i = t.children.length; e < i; e++) d(t.children[e], n, r)
                        }
                        h.style.overflow = "hidden", this.domElement = h, this.getSize = function() {
                            return {
                                width: n,
                                height: r
                            }
                        }, this.render = function(t, e) {
                            !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), o.copy(e.matrixWorldInverse), s.multiplyMatrices(e.projectionMatrix, o), d(t, t, e),
                                function(t) {
                                    const e = function(t) {
                                            const e = [];
                                            return t.traverse((function(t) {
                                                t.isCSS2DObject && e.push(t)
                                            })), e
                                        }(t).sort((function(t, e) {
                                            return t.renderOrder !== e.renderOrder ? e.renderOrder - t.renderOrder : u.objects.get(t).distanceToCameraSquared - u.objects.get(e).distanceToCameraSquared
                                        })),
                                        n = e.length;
                                    for (let t = 0, r = e.length; t < r; t++) e[t].element.style.zIndex = n - t
                                }(t)
                        }, this.setSize = function(t, e) {
                            n = t, r = e, i = n / 2, c = r / 2, h.style.width = t + "px", h.style.height = e + "px"
                        }
                    }
                }
            },
            "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js": (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, {
                    computeMikkTSpaceTangents: () => i,
                    computeMorphedAttributes: () => f,
                    deepCloneAttribute: () => s,
                    deinterleaveAttribute: () => A,
                    deinterleaveGeometry: () => c,
                    estimateBytesUsed: () => u,
                    interleaveAttributes: () => l,
                    mergeAttributes: () => o,
                    mergeGeometries: () => a,
                    mergeGroups: () => p,
                    mergeVertices: () => h,
                    toCreasedNormals: () => m,
                    toTrianglesDrawMode: () => d
                });
                var r = n("./node_modules/three/build/three.module.js");

                function i(t, e, n = !0) {
                    if (!e || !e.isReady) throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
                    if (!t.hasAttribute("position") || !t.hasAttribute("normal") || !t.hasAttribute("uv")) throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');

                    function i(t) {
                        if (t.normalized || t.isInterleavedBufferAttribute) {
                            const e = new Float32Array(t.count * t.itemSize);
                            for (let n = 0, r = 0; n < t.count; n++) e[r++] = t.getX(n), e[r++] = t.getY(n), t.itemSize > 2 && (e[r++] = t.getZ(n));
                            return e
                        }
                        return t.array instanceof Float32Array ? t.array : new Float32Array(t.array)
                    }
                    const a = t.index ? t.toNonIndexed() : t,
                        o = e.generateTangents(i(a.attributes.position), i(a.attributes.normal), i(a.attributes.uv));
                    if (n)
                        for (let t = 3; t < o.length; t += 4) o[t] *= -1;
                    return a.setAttribute("tangent", new r.BufferAttribute(o, 4)), t !== a && t.copy(a), t
                }

                function a(t, e = !1) {
                    const n = null !== t[0].index,
                        i = new Set(Object.keys(t[0].attributes)),
                        a = new Set(Object.keys(t[0].morphAttributes)),
                        s = {},
                        l = {},
                        A = t[0].morphTargetsRelative,
                        c = new r.BufferGeometry;
                    let u = 0;
                    for (let r = 0; r < t.length; ++r) {
                        const o = t[r];
                        let h = 0;
                        if (n !== (null !== o.index)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
                        for (const t in o.attributes) {
                            if (!i.has(t)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + '. All geometries must have compatible attributes; make sure "' + t + '" attribute exists among all geometries, or in none of them.'), null;
                            void 0 === s[t] && (s[t] = []), s[t].push(o.attributes[t]), h++
                        }
                        if (h !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". Make sure all geometries have the same number of attributes."), null;
                        if (A !== o.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
                        for (const t in o.morphAttributes) {
                            if (!a.has(t)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ".  .morphAttributes must be consistent throughout all geometries."), null;
                            void 0 === l[t] && (l[t] = []), l[t].push(o.morphAttributes[t])
                        }
                        if (e) {
                            let t;
                            if (n) t = o.index.count;
                            else {
                                if (void 0 === o.attributes.position) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + r + ". The geometry must have either an index or a position attribute"), null;
                                t = o.attributes.position.count
                            }
                            c.addGroup(u, t, r), u += t
                        }
                    }
                    if (n) {
                        let e = 0;
                        const n = [];
                        for (let r = 0; r < t.length; ++r) {
                            const i = t[r].index;
                            for (let t = 0; t < i.count; ++t) n.push(i.getX(t) + e);
                            e += t[r].attributes.position.count
                        }
                        c.setIndex(n)
                    }
                    for (const t in s) {
                        const e = o(s[t]);
                        if (!e) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + t + " attribute."), null;
                        c.setAttribute(t, e)
                    }
                    for (const t in l) {
                        const e = l[t][0].length;
                        if (0 === e) break;
                        c.morphAttributes = c.morphAttributes || {}, c.morphAttributes[t] = [];
                        for (let n = 0; n < e; ++n) {
                            const e = [];
                            for (let r = 0; r < l[t].length; ++r) e.push(l[t][r][n]);
                            const r = o(e);
                            if (!r) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + t + " morphAttribute."), null;
                            c.morphAttributes[t].push(r)
                        }
                    }
                    return c
                }

                function o(t) {
                    let e, n, i, a = -1,
                        o = 0;
                    for (let r = 0; r < t.length; ++r) {
                        const s = t[r];
                        if (void 0 === e && (e = s.array.constructor), e !== s.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
                        if (void 0 === n && (n = s.itemSize), n !== s.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
                        if (void 0 === i && (i = s.normalized), i !== s.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
                        if (-1 === a && (a = s.gpuType), a !== s.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
                        o += s.count * n
                    }
                    const s = new e(o),
                        l = new r.BufferAttribute(s, n, i);
                    let A = 0;
                    for (let e = 0; e < t.length; ++e) {
                        const r = t[e];
                        if (r.isInterleavedBufferAttribute) {
                            const t = A / n;
                            for (let e = 0, i = r.count; e < i; e++)
                                for (let i = 0; i < n; i++) {
                                    const n = r.getComponent(e, i);
                                    l.setComponent(e + t, i, n)
                                }
                        } else s.set(r.array, A);
                        A += r.count * n
                    }
                    return void 0 !== a && (l.gpuType = a), l
                }

                function s(t) {
                    return t.isInstancedInterleavedBufferAttribute || t.isInterleavedBufferAttribute ? A(t) : t.isInstancedBufferAttribute ? (new r.InstancedBufferAttribute).copy(t) : (new r.BufferAttribute).copy(t)
                }

                function l(t) {
                    let e, n = 0,
                        i = 0;
                    for (let r = 0, a = t.length; r < a; ++r) {
                        const a = t[r];
                        if (void 0 === e && (e = a.array.constructor), e !== a.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null;
                        n += a.array.length, i += a.itemSize
                    }
                    const a = new r.InterleavedBuffer(new e(n), i);
                    let o = 0;
                    const s = [],
                        l = ["getX", "getY", "getZ", "getW"],
                        A = ["setX", "setY", "setZ", "setW"];
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e],
                            i = n.itemSize,
                            c = n.count,
                            u = new r.InterleavedBufferAttribute(a, i, o, n.normalized);
                        s.push(u), o += i;
                        for (let t = 0; t < c; t++)
                            for (let e = 0; e < i; e++) u[A[e]](t, n[l[e]](t))
                    }
                    return s
                }

                function A(t) {
                    const e = t.data.array.constructor,
                        n = t.count,
                        i = t.itemSize,
                        a = t.normalized,
                        o = new e(n * i);
                    let s;
                    s = t.isInstancedInterleavedBufferAttribute ? new r.InstancedBufferAttribute(o, i, a, t.meshPerAttribute) : new r.BufferAttribute(o, i, a);
                    for (let e = 0; e < n; e++) s.setX(e, t.getX(e)), i >= 2 && s.setY(e, t.getY(e)), i >= 3 && s.setZ(e, t.getZ(e)), i >= 4 && s.setW(e, t.getW(e));
                    return s
                }

                function c(t) {
                    const e = t.attributes,
                        n = t.morphTargets,
                        r = new Map;
                    for (const t in e) {
                        const n = e[t];
                        n.isInterleavedBufferAttribute && (r.has(n) || r.set(n, A(n)), e[t] = r.get(n))
                    }
                    for (const t in n) {
                        const e = n[t];
                        e.isInterleavedBufferAttribute && (r.has(e) || r.set(e, A(e)), n[t] = r.get(e))
                    }
                }

                function u(t) {
                    let e = 0;
                    for (const n in t.attributes) {
                        const r = t.getAttribute(n);
                        e += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT
                    }
                    const n = t.getIndex();
                    return e += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, e
                }

                function h(t, e = 1e-4) {
                    e = Math.max(e, Number.EPSILON);
                    const n = {},
                        i = t.getIndex(),
                        a = t.getAttribute("position"),
                        o = i ? i.count : a.count;
                    let s = 0;
                    const l = Object.keys(t.attributes),
                        A = {},
                        c = {},
                        u = [],
                        h = ["getX", "getY", "getZ", "getW"],
                        d = ["setX", "setY", "setZ", "setW"];
                    for (let e = 0, n = l.length; e < n; e++) {
                        const n = l[e],
                            i = t.attributes[n];
                        A[n] = new r.BufferAttribute(new i.array.constructor(i.count * i.itemSize), i.itemSize, i.normalized);
                        const a = t.morphAttributes[n];
                        a && (c[n] = new r.BufferAttribute(new a.array.constructor(a.count * a.itemSize), a.itemSize, a.normalized))
                    }
                    const f = .5 * e,
                        p = Math.log10(1 / e),
                        m = Math.pow(10, p),
                        g = f * m;
                    for (let e = 0; e < o; e++) {
                        const r = i ? i.getX(e) : e;
                        let a = "";
                        for (let e = 0, n = l.length; e < n; e++) {
                            const n = l[e],
                                i = t.getAttribute(n),
                                o = i.itemSize;
                            for (let t = 0; t < o; t++) a += ~~(i[h[t]](r) * m + g) + ","
                        }
                        if (a in n) u.push(n[a]);
                        else {
                            for (let e = 0, n = l.length; e < n; e++) {
                                const n = l[e],
                                    i = t.getAttribute(n),
                                    a = t.morphAttributes[n],
                                    o = i.itemSize,
                                    u = A[n],
                                    f = c[n];
                                for (let t = 0; t < o; t++) {
                                    const e = h[t],
                                        n = d[t];
                                    if (u[n](s, i[e](r)), a)
                                        for (let t = 0, i = a.length; t < i; t++) f[t][n](s, a[t][e](r))
                                }
                            }
                            n[a] = s, u.push(s), s++
                        }
                    }
                    const v = t.clone();
                    for (const e in t.attributes) {
                        const t = A[e];
                        if (v.setAttribute(e, new r.BufferAttribute(t.array.slice(0, s * t.itemSize), t.itemSize, t.normalized)), e in c)
                            for (let t = 0; t < c[e].length; t++) {
                                const n = c[e][t];
                                v.morphAttributes[e][t] = new r.BufferAttribute(n.array.slice(0, s * n.itemSize), n.itemSize, n.normalized)
                            }
                    }
                    return v.setIndex(u), v
                }

                function d(t, e) {
                    if (e === r.TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), t;
                    if (e === r.TriangleFanDrawMode || e === r.TriangleStripDrawMode) {
                        let n = t.getIndex();
                        if (null === n) {
                            const e = [],
                                r = t.getAttribute("position");
                            if (void 0 === r) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                            for (let t = 0; t < r.count; t++) e.push(t);
                            t.setIndex(e), n = t.getIndex()
                        }
                        const i = n.count - 2,
                            a = [];
                        if (e === r.TriangleFanDrawMode)
                            for (let t = 1; t <= i; t++) a.push(n.getX(0)), a.push(n.getX(t)), a.push(n.getX(t + 1));
                        else
                            for (let t = 0; t < i; t++) t % 2 == 0 ? (a.push(n.getX(t)), a.push(n.getX(t + 1)), a.push(n.getX(t + 2))) : (a.push(n.getX(t + 2)), a.push(n.getX(t + 1)), a.push(n.getX(t)));
                        a.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                        const o = t.clone();
                        return o.setIndex(a), o.clearGroups(), o
                    }
                    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), t
                }

                function f(t) {
                    const e = new r.Vector3,
                        n = new r.Vector3,
                        i = new r.Vector3,
                        a = new r.Vector3,
                        o = new r.Vector3,
                        s = new r.Vector3,
                        l = new r.Vector3,
                        A = new r.Vector3,
                        c = new r.Vector3;

                    function u(t, r, u, h, d, f, p, m) {
                        e.fromBufferAttribute(r, d), n.fromBufferAttribute(r, f), i.fromBufferAttribute(r, p);
                        const g = t.morphTargetInfluences;
                        if (u && g) {
                            l.set(0, 0, 0), A.set(0, 0, 0), c.set(0, 0, 0);
                            for (let t = 0, r = u.length; t < r; t++) {
                                const r = g[t],
                                    m = u[t];
                                0 !== r && (a.fromBufferAttribute(m, d), o.fromBufferAttribute(m, f), s.fromBufferAttribute(m, p), h ? (l.addScaledVector(a, r), A.addScaledVector(o, r), c.addScaledVector(s, r)) : (l.addScaledVector(a.sub(e), r), A.addScaledVector(o.sub(n), r), c.addScaledVector(s.sub(i), r)))
                            }
                            e.add(l), n.add(A), i.add(c)
                        }
                        t.isSkinnedMesh && (t.applyBoneTransform(d, e), t.applyBoneTransform(f, n), t.applyBoneTransform(p, i)), m[3 * d + 0] = e.x, m[3 * d + 1] = e.y, m[3 * d + 2] = e.z, m[3 * f + 0] = n.x, m[3 * f + 1] = n.y, m[3 * f + 2] = n.z, m[3 * p + 0] = i.x, m[3 * p + 1] = i.y, m[3 * p + 2] = i.z
                    }
                    const h = t.geometry,
                        d = t.material;
                    let f, p, m;
                    const g = h.index,
                        v = h.attributes.position,
                        _ = h.morphAttributes.position,
                        y = h.morphTargetsRelative,
                        x = h.attributes.normal,
                        b = h.morphAttributes.position,
                        M = h.groups,
                        w = h.drawRange;
                    let S, E, T, C, R, P, L;
                    const D = new Float32Array(v.count * v.itemSize),
                        I = new Float32Array(x.count * x.itemSize);
                    if (null !== g)
                        if (Array.isArray(d))
                            for (S = 0, T = M.length; S < T; S++)
                                for (R = M[S], P = Math.max(R.start, w.start), L = Math.min(R.start + R.count, w.start + w.count), E = P, C = L; E < C; E += 3) f = g.getX(E), p = g.getX(E + 1), m = g.getX(E + 2), u(t, v, _, y, f, p, m, D), u(t, x, b, y, f, p, m, I);
                        else
                            for (P = Math.max(0, w.start), L = Math.min(g.count, w.start + w.count), S = P, T = L; S < T; S += 3) f = g.getX(S), p = g.getX(S + 1), m = g.getX(S + 2), u(t, v, _, y, f, p, m, D), u(t, x, b, y, f, p, m, I);
                    else if (Array.isArray(d))
                        for (S = 0, T = M.length; S < T; S++)
                            for (R = M[S], P = Math.max(R.start, w.start), L = Math.min(R.start + R.count, w.start + w.count), E = P, C = L; E < C; E += 3) f = E, p = E + 1, m = E + 2, u(t, v, _, y, f, p, m, D), u(t, x, b, y, f, p, m, I);
                    else
                        for (P = Math.max(0, w.start), L = Math.min(v.count, w.start + w.count), S = P, T = L; S < T; S += 3) f = S, p = S + 1, m = S + 2, u(t, v, _, y, f, p, m, D), u(t, x, b, y, f, p, m, I);
                    return {
                        positionAttribute: v,
                        normalAttribute: x,
                        morphedPositionAttribute: new r.Float32BufferAttribute(D, 3),
                        morphedNormalAttribute: new r.Float32BufferAttribute(I, 3)
                    }
                }

                function p(t) {
                    if (0 === t.groups.length) return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), t;
                    let e = t.groups;
                    if (e = e.sort(((t, e) => t.materialIndex !== e.materialIndex ? t.materialIndex - e.materialIndex : t.start - e.start)), null === t.getIndex()) {
                        const e = t.getAttribute("position"),
                            n = [];
                        for (let t = 0; t < e.count; t += 3) n.push(t, t + 1, t + 2);
                        t.setIndex(n)
                    }
                    const n = t.getIndex(),
                        r = [];
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t],
                            a = i.start,
                            o = a + i.count;
                        for (let t = a; t < o; t++) r.push(n.getX(t))
                    }
                    t.dispose(), t.setIndex(r);
                    let i = 0;
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        n.start = i, i += n.count
                    }
                    let a = e[0];
                    t.groups = [a];
                    for (let n = 1; n < e.length; n++) {
                        const r = e[n];
                        a.materialIndex === r.materialIndex ? a.count += r.count : (a = r, t.groups.push(a))
                    }
                    return t
                }

                function m(t, e = Math.PI / 3) {
                    const n = Math.cos(e),
                        i = 100 * (1 + 1e-10),
                        a = [new r.Vector3, new r.Vector3, new r.Vector3],
                        o = new r.Vector3,
                        s = new r.Vector3,
                        l = new r.Vector3,
                        A = new r.Vector3;

                    function c(t) {
                        return `${~~(t.x*i)},${~~(t.y*i)},${~~(t.z*i)}`
                    }
                    const u = t.index ? t.toNonIndexed() : t,
                        h = u.attributes.position,
                        d = {};
                    for (let t = 0, e = h.count / 3; t < e; t++) {
                        const e = 3 * t,
                            n = a[0].fromBufferAttribute(h, e + 0),
                            i = a[1].fromBufferAttribute(h, e + 1),
                            l = a[2].fromBufferAttribute(h, e + 2);
                        o.subVectors(l, i), s.subVectors(n, i);
                        const A = (new r.Vector3).crossVectors(o, s).normalize();
                        for (let t = 0; t < 3; t++) {
                            const e = c(a[t]);
                            e in d || (d[e] = []), d[e].push(A)
                        }
                    }
                    const f = new Float32Array(3 * h.count),
                        p = new r.BufferAttribute(f, 3, !1);
                    for (let t = 0, e = h.count / 3; t < e; t++) {
                        const e = 3 * t,
                            r = a[0].fromBufferAttribute(h, e + 0),
                            i = a[1].fromBufferAttribute(h, e + 1),
                            u = a[2].fromBufferAttribute(h, e + 2);
                        o.subVectors(u, i), s.subVectors(r, i), l.crossVectors(o, s).normalize();
                        for (let t = 0; t < 3; t++) {
                            const r = d[c(a[t])];
                            A.set(0, 0, 0);
                            for (let t = 0, e = r.length; t < e; t++) {
                                const e = r[t];
                                l.dot(e) > n && A.add(e)
                            }
                            A.normalize(), p.setXYZ(e + t, A.x, A.y, A.z)
                        }
                    }
                    return u.setAttribute("normal", p), u
                }
            },
            "./node_modules/tinycolor2/esm/tinycolor.js": (t, e, n) => {
                "use strict";

                function r(t) {
                    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    } : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }, r(t)
                }
                n.r(e), n.d(e, {
                    default: () => o
                });
                var i = /^\s+/,
                    a = /\s+$/;

                function o(t, e) {
                    if (e = e || {}, (t = t || "") instanceof o) return t;
                    if (!(this instanceof o)) return new o(t, e);
                    var n = function(t) {
                        var e, n, o, s = {
                                r: 0,
                                g: 0,
                                b: 0
                            },
                            l = 1,
                            A = null,
                            c = null,
                            u = null,
                            h = !1,
                            d = !1;
                        return "string" == typeof t && (t = function(t) {
                            t = t.replace(i, "").replace(a, "").toLowerCase();
                            var e, n = !1;
                            if (M[t]) t = M[t], n = !0;
                            else if ("transparent" == t) return {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0,
                                format: "name"
                            };
                            return (e = q.rgb.exec(t)) ? {
                                r: e[1],
                                g: e[2],
                                b: e[3]
                            } : (e = q.rgba.exec(t)) ? {
                                r: e[1],
                                g: e[2],
                                b: e[3],
                                a: e[4]
                            } : (e = q.hsl.exec(t)) ? {
                                h: e[1],
                                s: e[2],
                                l: e[3]
                            } : (e = q.hsla.exec(t)) ? {
                                h: e[1],
                                s: e[2],
                                l: e[3],
                                a: e[4]
                            } : (e = q.hsv.exec(t)) ? {
                                h: e[1],
                                s: e[2],
                                v: e[3]
                            } : (e = q.hsva.exec(t)) ? {
                                h: e[1],
                                s: e[2],
                                v: e[3],
                                a: e[4]
                            } : (e = q.hex8.exec(t)) ? {
                                r: C(e[1]),
                                g: C(e[2]),
                                b: C(e[3]),
                                a: D(e[4]),
                                format: n ? "name" : "hex8"
                            } : (e = q.hex6.exec(t)) ? {
                                r: C(e[1]),
                                g: C(e[2]),
                                b: C(e[3]),
                                format: n ? "name" : "hex"
                            } : (e = q.hex4.exec(t)) ? {
                                r: C(e[1] + "" + e[1]),
                                g: C(e[2] + "" + e[2]),
                                b: C(e[3] + "" + e[3]),
                                a: D(e[4] + "" + e[4]),
                                format: n ? "name" : "hex8"
                            } : !!(e = q.hex3.exec(t)) && {
                                r: C(e[1] + "" + e[1]),
                                g: C(e[2] + "" + e[2]),
                                b: C(e[3] + "" + e[3]),
                                format: n ? "name" : "hex"
                            }
                        }(t)), "object" == r(t) && (U(t.r) && U(t.g) && U(t.b) ? (e = t.r, n = t.g, o = t.b, s = {
                            r: 255 * E(e, 255),
                            g: 255 * E(n, 255),
                            b: 255 * E(o, 255)
                        }, h = !0, d = "%" === String(t.r).substr(-1) ? "prgb" : "rgb") : U(t.h) && U(t.s) && U(t.v) ? (A = P(t.s), c = P(t.v), s = function(t, e, n) {
                            t = 6 * E(t, 360), e = E(e, 100), n = E(n, 100);
                            var r = Math.floor(t),
                                i = t - r,
                                a = n * (1 - e),
                                o = n * (1 - i * e),
                                s = n * (1 - (1 - i) * e),
                                l = r % 6;
                            return {
                                r: 255 * [n, o, a, a, s, n][l],
                                g: 255 * [s, n, n, o, a, a][l],
                                b: 255 * [a, a, s, n, n, o][l]
                            }
                        }(t.h, A, c), h = !0, d = "hsv") : U(t.h) && U(t.s) && U(t.l) && (A = P(t.s), u = P(t.l), s = function(t, e, n) {
                            var r, i, a;

                            function o(t, e, n) {
                                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
                            }
                            if (t = E(t, 360), e = E(e, 100), n = E(n, 100), 0 === e) r = i = a = n;
                            else {
                                var s = n < .5 ? n * (1 + e) : n + e - n * e,
                                    l = 2 * n - s;
                                r = o(l, s, t + 1 / 3), i = o(l, s, t), a = o(l, s, t - 1 / 3)
                            }
                            return {
                                r: 255 * r,
                                g: 255 * i,
                                b: 255 * a
                            }
                        }(t.h, A, u), h = !0, d = "hsl"), t.hasOwnProperty("a") && (l = t.a)), l = S(l), {
                            ok: h,
                            format: t.format || d,
                            r: Math.min(255, Math.max(s.r, 0)),
                            g: Math.min(255, Math.max(s.g, 0)),
                            b: Math.min(255, Math.max(s.b, 0)),
                            a: l
                        }
                    }(t);
                    this._originalInput = t, this._r = n.r, this._g = n.g, this._b = n.b, this._a = n.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || n.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = n.ok
                }

                function s(t, e, n) {
                    t = E(t, 255), e = E(e, 255), n = E(n, 255);
                    var r, i, a = Math.max(t, e, n),
                        o = Math.min(t, e, n),
                        s = (a + o) / 2;
                    if (a == o) r = i = 0;
                    else {
                        var l = a - o;
                        switch (i = s > .5 ? l / (2 - a - o) : l / (a + o), a) {
                            case t:
                                r = (e - n) / l + (e < n ? 6 : 0);
                                break;
                            case e:
                                r = (n - t) / l + 2;
                                break;
                            case n:
                                r = (t - e) / l + 4
                        }
                        r /= 6
                    }
                    return {
                        h: r,
                        s: i,
                        l: s
                    }
                }

                function l(t, e, n) {
                    t = E(t, 255), e = E(e, 255), n = E(n, 255);
                    var r, i, a = Math.max(t, e, n),
                        o = Math.min(t, e, n),
                        s = a,
                        l = a - o;
                    if (i = 0 === a ? 0 : l / a, a == o) r = 0;
                    else {
                        switch (a) {
                            case t:
                                r = (e - n) / l + (e < n ? 6 : 0);
                                break;
                            case e:
                                r = (n - t) / l + 2;
                                break;
                            case n:
                                r = (t - e) / l + 4
                        }
                        r /= 6
                    }
                    return {
                        h: r,
                        s: i,
                        v: s
                    }
                }

                function A(t, e, n, r) {
                    var i = [R(Math.round(t).toString(16)), R(Math.round(e).toString(16)), R(Math.round(n).toString(16))];
                    return r && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
                }

                function c(t, e, n, r) {
                    return [R(L(r)), R(Math.round(t).toString(16)), R(Math.round(e).toString(16)), R(Math.round(n).toString(16))].join("")
                }

                function u(t, e) {
                    e = 0 === e ? 0 : e || 10;
                    var n = o(t).toHsl();
                    return n.s -= e / 100, n.s = T(n.s), o(n)
                }

                function h(t, e) {
                    e = 0 === e ? 0 : e || 10;
                    var n = o(t).toHsl();
                    return n.s += e / 100, n.s = T(n.s), o(n)
                }

                function d(t) {
                    return o(t).desaturate(100)
                }

                function f(t, e) {
                    e = 0 === e ? 0 : e || 10;
                    var n = o(t).toHsl();
                    return n.l += e / 100, n.l = T(n.l), o(n)
                }

                function p(t, e) {
                    e = 0 === e ? 0 : e || 10;
                    var n = o(t).toRgb();
                    return n.r = Math.max(0, Math.min(255, n.r - Math.round(-e / 100 * 255))), n.g = Math.max(0, Math.min(255, n.g - Math.round(-e / 100 * 255))), n.b = Math.max(0, Math.min(255, n.b - Math.round(-e / 100 * 255))), o(n)
                }

                function m(t, e) {
                    e = 0 === e ? 0 : e || 10;
                    var n = o(t).toHsl();
                    return n.l -= e / 100, n.l = T(n.l), o(n)
                }

                function g(t, e) {
                    var n = o(t).toHsl(),
                        r = (n.h + e) % 360;
                    return n.h = r < 0 ? 360 + r : r, o(n)
                }

                function v(t) {
                    var e = o(t).toHsl();
                    return e.h = (e.h + 180) % 360, o(e)
                }

                function _(t, e) {
                    if (isNaN(e) || e <= 0) throw new Error("Argument to polyad must be a positive number");
                    for (var n = o(t).toHsl(), r = [o(t)], i = 360 / e, a = 1; a < e; a++) r.push(o({
                        h: (n.h + a * i) % 360,
                        s: n.s,
                        l: n.l
                    }));
                    return r
                }

                function y(t) {
                    var e = o(t).toHsl(),
                        n = e.h;
                    return [o(t), o({
                        h: (n + 72) % 360,
                        s: e.s,
                        l: e.l
                    }), o({
                        h: (n + 216) % 360,
                        s: e.s,
                        l: e.l
                    })]
                }

                function x(t, e, n) {
                    e = e || 6, n = n || 30;
                    var r = o(t).toHsl(),
                        i = 360 / n,
                        a = [o(t)];
                    for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e;) r.h = (r.h + i) % 360, a.push(o(r));
                    return a
                }

                function b(t, e) {
                    e = e || 6;
                    for (var n = o(t).toHsv(), r = n.h, i = n.s, a = n.v, s = [], l = 1 / e; e--;) s.push(o({
                        h: r,
                        s: i,
                        v: a
                    })), a = (a + l) % 1;
                    return s
                }
                o.prototype = {
                    isDark: function() {
                        return this.getBrightness() < 128
                    },
                    isLight: function() {
                        return !this.isDark()
                    },
                    isValid: function() {
                        return this._ok
                    },
                    getOriginalInput: function() {
                        return this._originalInput
                    },
                    getFormat: function() {
                        return this._format
                    },
                    getAlpha: function() {
                        return this._a
                    },
                    getBrightness: function() {
                        var t = this.toRgb();
                        return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3
                    },
                    getLuminance: function() {
                        var t, e, n, r = this.toRgb();
                        return t = r.r / 255, e = r.g / 255, n = r.b / 255, .2126 * (t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)) + .7152 * (e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)) + .0722 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4))
                    },
                    setAlpha: function(t) {
                        return this._a = S(t), this._roundA = Math.round(100 * this._a) / 100, this
                    },
                    toHsv: function() {
                        var t = l(this._r, this._g, this._b);
                        return {
                            h: 360 * t.h,
                            s: t.s,
                            v: t.v,
                            a: this._a
                        }
                    },
                    toHsvString: function() {
                        var t = l(this._r, this._g, this._b),
                            e = Math.round(360 * t.h),
                            n = Math.round(100 * t.s),
                            r = Math.round(100 * t.v);
                        return 1 == this._a ? "hsv(" + e + ", " + n + "%, " + r + "%)" : "hsva(" + e + ", " + n + "%, " + r + "%, " + this._roundA + ")"
                    },
                    toHsl: function() {
                        var t = s(this._r, this._g, this._b);
                        return {
                            h: 360 * t.h,
                            s: t.s,
                            l: t.l,
                            a: this._a
                        }
                    },
                    toHslString: function() {
                        var t = s(this._r, this._g, this._b),
                            e = Math.round(360 * t.h),
                            n = Math.round(100 * t.s),
                            r = Math.round(100 * t.l);
                        return 1 == this._a ? "hsl(" + e + ", " + n + "%, " + r + "%)" : "hsla(" + e + ", " + n + "%, " + r + "%, " + this._roundA + ")"
                    },
                    toHex: function(t) {
                        return A(this._r, this._g, this._b, t)
                    },
                    toHexString: function(t) {
                        return "#" + this.toHex(t)
                    },
                    toHex8: function(t) {
                        return function(t, e, n, r, i) {
                            var a = [R(Math.round(t).toString(16)), R(Math.round(e).toString(16)), R(Math.round(n).toString(16)), R(L(r))];
                            return i && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("")
                        }(this._r, this._g, this._b, this._a, t)
                    },
                    toHex8String: function(t) {
                        return "#" + this.toHex8(t)
                    },
                    toRgb: function() {
                        return {
                            r: Math.round(this._r),
                            g: Math.round(this._g),
                            b: Math.round(this._b),
                            a: this._a
                        }
                    },
                    toRgbString: function() {
                        return 1 == this._a ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")"
                    },
                    toPercentageRgb: function() {
                        return {
                            r: Math.round(100 * E(this._r, 255)) + "%",
                            g: Math.round(100 * E(this._g, 255)) + "%",
                            b: Math.round(100 * E(this._b, 255)) + "%",
                            a: this._a
                        }
                    },
                    toPercentageRgbString: function() {
                        return 1 == this._a ? "rgb(" + Math.round(100 * E(this._r, 255)) + "%, " + Math.round(100 * E(this._g, 255)) + "%, " + Math.round(100 * E(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * E(this._r, 255)) + "%, " + Math.round(100 * E(this._g, 255)) + "%, " + Math.round(100 * E(this._b, 255)) + "%, " + this._roundA + ")"
                    },
                    toName: function() {
                        return 0 === this._a ? "transparent" : !(this._a < 1) && (w[A(this._r, this._g, this._b, !0)] || !1)
                    },
                    toFilter: function(t) {
                        var e = "#" + c(this._r, this._g, this._b, this._a),
                            n = e,
                            r = this._gradientType ? "GradientType = 1, " : "";
                        if (t) {
                            var i = o(t);
                            n = "#" + c(i._r, i._g, i._b, i._a)
                        }
                        return "progid:DXImageTransform.Microsoft.gradient(" + r + "startColorstr=" + e + ",endColorstr=" + n + ")"
                    },
                    toString: function(t) {
                        var e = !!t;
                        t = t || this._format;
                        var n = !1,
                            r = this._a < 1 && this._a >= 0;
                        return e || !r || "hex" !== t && "hex6" !== t && "hex3" !== t && "hex4" !== t && "hex8" !== t && "name" !== t ? ("rgb" === t && (n = this.toRgbString()), "prgb" === t && (n = this.toPercentageRgbString()), "hex" !== t && "hex6" !== t || (n = this.toHexString()), "hex3" === t && (n = this.toHexString(!0)), "hex4" === t && (n = this.toHex8String(!0)), "hex8" === t && (n = this.toHex8String()), "name" === t && (n = this.toName()), "hsl" === t && (n = this.toHslString()), "hsv" === t && (n = this.toHsvString()), n || this.toHexString()) : "name" === t && 0 === this._a ? this.toName() : this.toRgbString()
                    },
                    clone: function() {
                        return o(this.toString())
                    },
                    _applyModification: function(t, e) {
                        var n = t.apply(null, [this].concat([].slice.call(e)));
                        return this._r = n._r, this._g = n._g, this._b = n._b, this.setAlpha(n._a), this
                    },
                    lighten: function() {
                        return this._applyModification(f, arguments)
                    },
                    brighten: function() {
                        return this._applyModification(p, arguments)
                    },
                    darken: function() {
                        return this._applyModification(m, arguments)
                    },
                    desaturate: function() {
                        return this._applyModification(u, arguments)
                    },
                    saturate: function() {
                        return this._applyModification(h, arguments)
                    },
                    greyscale: function() {
                        return this._applyModification(d, arguments)
                    },
                    spin: function() {
                        return this._applyModification(g, arguments)
                    },
                    _applyCombination: function(t, e) {
                        return t.apply(null, [this].concat([].slice.call(e)))
                    },
                    analogous: function() {
                        return this._applyCombination(x, arguments)
                    },
                    complement: function() {
                        return this._applyCombination(v, arguments)
                    },
                    monochromatic: function() {
                        return this._applyCombination(b, arguments)
                    },
                    splitcomplement: function() {
                        return this._applyCombination(y, arguments)
                    },
                    triad: function() {
                        return this._applyCombination(_, [3])
                    },
                    tetrad: function() {
                        return this._applyCombination(_, [4])
                    }
                }, o.fromRatio = function(t, e) {
                    if ("object" == r(t)) {
                        var n = {};
                        for (var i in t) t.hasOwnProperty(i) && (n[i] = "a" === i ? t[i] : P(t[i]));
                        t = n
                    }
                    return o(t, e)
                }, o.equals = function(t, e) {
                    return !(!t || !e) && o(t).toRgbString() == o(e).toRgbString()
                }, o.random = function() {
                    return o.fromRatio({
                        r: Math.random(),
                        g: Math.random(),
                        b: Math.random()
                    })
                }, o.mix = function(t, e, n) {
                    n = 0 === n ? 0 : n || 50;
                    var r = o(t).toRgb(),
                        i = o(e).toRgb(),
                        a = n / 100;
                    return o({
                        r: (i.r - r.r) * a + r.r,
                        g: (i.g - r.g) * a + r.g,
                        b: (i.b - r.b) * a + r.b,
                        a: (i.a - r.a) * a + r.a
                    })
                }, o.readability = function(t, e) {
                    var n = o(t),
                        r = o(e);
                    return (Math.max(n.getLuminance(), r.getLuminance()) + .05) / (Math.min(n.getLuminance(), r.getLuminance()) + .05)
                }, o.isReadable = function(t, e, n) {
                    var r, i, a, s, l, A = o.readability(t, e);
                    switch (i = !1, (a = n, "AA" !== (s = ((a = a || {
                            level: "AA",
                            size: "small"
                        }).level || "AA").toUpperCase()) && "AAA" !== s && (s = "AA"), "small" !== (l = (a.size || "small").toLowerCase()) && "large" !== l && (l = "small"), r = {
                            level: s,
                            size: l
                        }).level + r.size) {
                        case "AAsmall":
                        case "AAAlarge":
                            i = A >= 4.5;
                            break;
                        case "AAlarge":
                            i = A >= 3;
                            break;
                        case "AAAsmall":
                            i = A >= 7
                    }
                    return i
                }, o.mostReadable = function(t, e, n) {
                    var r, i, a, s, l = null,
                        A = 0;
                    i = (n = n || {}).includeFallbackColors, a = n.level, s = n.size;
                    for (var c = 0; c < e.length; c++)(r = o.readability(t, e[c])) > A && (A = r, l = o(e[c]));
                    return o.isReadable(t, l, {
                        level: a,
                        size: s
                    }) || !i ? l : (n.includeFallbackColors = !1, o.mostReadable(t, ["#fff", "#000"], n))
                };
                var M = o.names = {
                        aliceblue: "f0f8ff",
                        antiquewhite: "faebd7",
                        aqua: "0ff",
                        aquamarine: "7fffd4",
                        azure: "f0ffff",
                        beige: "f5f5dc",
                        bisque: "ffe4c4",
                        black: "000",
                        blanchedalmond: "ffebcd",
                        blue: "00f",
                        blueviolet: "8a2be2",
                        brown: "a52a2a",
                        burlywood: "deb887",
                        burntsienna: "ea7e5d",
                        cadetblue: "5f9ea0",
                        chartreuse: "7fff00",
                        chocolate: "d2691e",
                        coral: "ff7f50",
                        cornflowerblue: "6495ed",
                        cornsilk: "fff8dc",
                        crimson: "dc143c",
                        cyan: "0ff",
                        darkblue: "00008b",
                        darkcyan: "008b8b",
                        darkgoldenrod: "b8860b",
                        darkgray: "a9a9a9",
                        darkgreen: "006400",
                        darkgrey: "a9a9a9",
                        darkkhaki: "bdb76b",
                        darkmagenta: "8b008b",
                        darkolivegreen: "556b2f",
                        darkorange: "ff8c00",
                        darkorchid: "9932cc",
                        darkred: "8b0000",
                        darksalmon: "e9967a",
                        darkseagreen: "8fbc8f",
                        darkslateblue: "483d8b",
                        darkslategray: "2f4f4f",
                        darkslategrey: "2f4f4f",
                        darkturquoise: "00ced1",
                        darkviolet: "9400d3",
                        deeppink: "ff1493",
                        deepskyblue: "00bfff",
                        dimgray: "696969",
                        dimgrey: "696969",
                        dodgerblue: "1e90ff",
                        firebrick: "b22222",
                        floralwhite: "fffaf0",
                        forestgreen: "228b22",
                        fuchsia: "f0f",
                        gainsboro: "dcdcdc",
                        ghostwhite: "f8f8ff",
                        gold: "ffd700",
                        goldenrod: "daa520",
                        gray: "808080",
                        green: "008000",
                        greenyellow: "adff2f",
                        grey: "808080",
                        honeydew: "f0fff0",
                        hotpink: "ff69b4",
                        indianred: "cd5c5c",
                        indigo: "4b0082",
                        ivory: "fffff0",
                        khaki: "f0e68c",
                        lavender: "e6e6fa",
                        lavenderblush: "fff0f5",
                        lawngreen: "7cfc00",
                        lemonchiffon: "fffacd",
                        lightblue: "add8e6",
                        lightcoral: "f08080",
                        lightcyan: "e0ffff",
                        lightgoldenrodyellow: "fafad2",
                        lightgray: "d3d3d3",
                        lightgreen: "90ee90",
                        lightgrey: "d3d3d3",
                        lightpink: "ffb6c1",
                        lightsalmon: "ffa07a",
                        lightseagreen: "20b2aa",
                        lightskyblue: "87cefa",
                        lightslategray: "789",
                        lightslategrey: "789",
                        lightsteelblue: "b0c4de",
                        lightyellow: "ffffe0",
                        lime: "0f0",
                        limegreen: "32cd32",
                        linen: "faf0e6",
                        magenta: "f0f",
                        maroon: "800000",
                        mediumaquamarine: "66cdaa",
                        mediumblue: "0000cd",
                        mediumorchid: "ba55d3",
                        mediumpurple: "9370db",
                        mediumseagreen: "3cb371",
                        mediumslateblue: "7b68ee",
                        mediumspringgreen: "00fa9a",
                        mediumturquoise: "48d1cc",
                        mediumvioletred: "c71585",
                        midnightblue: "191970",
                        mintcream: "f5fffa",
                        mistyrose: "ffe4e1",
                        moccasin: "ffe4b5",
                        navajowhite: "ffdead",
                        navy: "000080",
                        oldlace: "fdf5e6",
                        olive: "808000",
                        olivedrab: "6b8e23",
                        orange: "ffa500",
                        orangered: "ff4500",
                        orchid: "da70d6",
                        palegoldenrod: "eee8aa",
                        palegreen: "98fb98",
                        paleturquoise: "afeeee",
                        palevioletred: "db7093",
                        papayawhip: "ffefd5",
                        peachpuff: "ffdab9",
                        peru: "cd853f",
                        pink: "ffc0cb",
                        plum: "dda0dd",
                        powderblue: "b0e0e6",
                        purple: "800080",
                        rebeccapurple: "663399",
                        red: "f00",
                        rosybrown: "bc8f8f",
                        royalblue: "4169e1",
                        saddlebrown: "8b4513",
                        salmon: "fa8072",
                        sandybrown: "f4a460",
                        seagreen: "2e8b57",
                        seashell: "fff5ee",
                        sienna: "a0522d",
                        silver: "c0c0c0",
                        skyblue: "87ceeb",
                        slateblue: "6a5acd",
                        slategray: "708090",
                        slategrey: "708090",
                        snow: "fffafa",
                        springgreen: "00ff7f",
                        steelblue: "4682b4",
                        tan: "d2b48c",
                        teal: "008080",
                        thistle: "d8bfd8",
                        tomato: "ff6347",
                        turquoise: "40e0d0",
                        violet: "ee82ee",
                        wheat: "f5deb3",
                        white: "fff",
                        whitesmoke: "f5f5f5",
                        yellow: "ff0",
                        yellowgreen: "9acd32"
                    },
                    w = o.hexNames = function(t) {
                        var e = {};
                        for (var n in t) t.hasOwnProperty(n) && (e[t[n]] = n);
                        return e
                    }(M);

                function S(t) {
                    return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
                }

                function E(t, e) {
                    (function(t) {
                        return "string" == typeof t && -1 != t.indexOf(".") && 1 === parseFloat(t)
                    })(t) && (t = "100%");
                    var n = function(t) {
                        return "string" == typeof t && -1 != t.indexOf("%")
                    }(t);
                    return t = Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(t * e, 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : t % e / parseFloat(e)
                }

                function T(t) {
                    return Math.min(1, Math.max(0, t))
                }

                function C(t) {
                    return parseInt(t, 16)
                }

                function R(t) {
                    return 1 == t.length ? "0" + t : "" + t
                }

                function P(t) {
                    return t <= 1 && (t = 100 * t + "%"), t
                }

                function L(t) {
                    return Math.round(255 * parseFloat(t)).toString(16)
                }

                function D(t) {
                    return C(t) / 255
                }
                var I, O, B, q = (O = "[\\s|\\(]+(" + (I = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)") + ")[,|\\s]+(" + I + ")[,|\\s]+(" + I + ")\\s*\\)?", B = "[\\s|\\(]+(" + I + ")[,|\\s]+(" + I + ")[,|\\s]+(" + I + ")[,|\\s]+(" + I + ")\\s*\\)?", {
                    CSS_UNIT: new RegExp(I),
                    rgb: new RegExp("rgb" + O),
                    rgba: new RegExp("rgba" + B),
                    hsl: new RegExp("hsl" + O),
                    hsla: new RegExp("hsla" + B),
                    hsv: new RegExp("hsv" + O),
                    hsva: new RegExp("hsva" + B),
                    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
                });

                function U(t) {
                    return !!q.CSS_UNIT.exec(t)
                }
            }
        },
        e = {};

    function n(r) {
        var i = e[r];
        if (void 0 !== i) return i.exports;
        var a = e[r] = {
            exports: {}
        };
        return t[r].call(a.exports, a, a.exports, n), a.exports
    }
    n.d = (t, e) => {
        for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, {
            enumerable: !0,
            get: e[r]
        })
    }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    };
    var r = {};
    (() => {
        "use strict";
        n.r(r), n("./src/js/planet.js")
    })()
})();
//# sourceMappingURL=main3d0a7a2df2b3e40babbd.js.map